{"sol name": "2839.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * Ready Player ONE * @title -ReadyPlayerONE */ //============================================================================== //     _    _  _ _|_ _  . //    (/_\\/(/_| | | _\\  . //============================================================================== contract RP1events { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 rp1Amount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 rp1Amount, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 rp1Amount, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 rp1Amount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } //============================================================================== //   _ _  _ _|_ _ _  __|_   _ _ _|_    _   . //  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  . //====================================|========================================= contract modularLong is RP1events {} contract ReadyPlayerONE is modularLong { using SafeMath for *; using NameFilter for string; using RP1KeysCalcLong for uint256; address community_addr = 0x4c20d0ab4baadbce39fe6ac94cefd99b7686339c; address marketing_addr = 0x9386b3cc1155764b60ca81fc83761777f6487ac3; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x15247cF99b5870F54EA17e85E1aF8667a58a6644); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== string constant public name = \"Ready Player ONE\"; string constant public symbol = \"RP1\"; uint256 private rndGap_ = 0;                                // length of ICO phase, set to 1 year for EOS. //todo  1hours uint256 constant private rndInit_ = 1 hours;             // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 12 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => RP1datasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => RP1datasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => RP1datasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA //**************** mapping (uint256 => RP1datasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => RP1datasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { //\u7384\u6b66 \u8ba1\u7b97\u7684 100-30-18 fees_[0] = RP1datasets.TeamFee(30,0);   //52% to pot, 12% to aff, 2% to com, 1% to pot swap, 3% to air drop pot //\u767d\u864e fees_[1] = RP1datasets.TeamFee(41,0);   //41% to pot, 12% to aff, 2% to com, 1% to pot swap, 3% to air drop pot //\u9752\u9f99 fees_[2] = RP1datasets.TeamFee(60,0);   //22% to pot, 12% to aff, 2% to com, 1% to pot swap, 3% to air drop pot //\u6731\u96c0 fees_[3] = RP1datasets.TeamFee(46,0);   //36% to pot, 12% to aff, 2% to com, 1% to pot swap, 3% to air drop pot // (\u5206\u7ea2, \u63a8\u5e7f\u7ecf\u8d39) potSplit_[0] = RP1datasets.PotSplit(18,4);  //58% to winner, 18% to next round, 2% to com potSplit_[1] = RP1datasets.PotSplit(25,0);  //58% to winner, 15% to next round, 2% to com potSplit_[2] = RP1datasets.PotSplit(22,8);  //58% to winner, 10% to next round, 2% to com potSplit_[3] = RP1datasets.PotSplit(32,2);  //58% to winner,  6% to next round, 2% to com } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } /** * @dev prevents contracts from interacting with fomo3d */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RP1datasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RP1datasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RP1datasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RP1datasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // set up our tx event data RP1datasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit RP1events.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.rp1Amount, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit RP1events.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RP1events.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RP1events.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RP1events.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(58)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, RP1datasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, _team, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit RP1events.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.rp1Amount, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, RP1datasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core(_rID, _pID, _eth, _affID, _team, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit RP1events.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.rp1Amount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, RP1datasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter 100eth 1eth if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000) { uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // manage airdrops if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { // gib muni uint256 _prize; if (_eth >= 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 2 prize was won _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } // set airdrop happened bool to true _eventData_.compressedData += 10000000000000000000000000000000; // let event know how much was won _eventData_.compressedData += _prize * 1000000000000000000000000000000000; // reset air drop tracker airDropTracker_ = 0; } } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _team, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(RP1datasets.EventReturns memory _eventData_) private returns (RP1datasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of fomo3d if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev checks to make sure user picked a valid team.  if not sets team * to default (sneks) */ function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, RP1datasets.EventReturns memory _eventData_) private returns (RP1datasets.EventReturns) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(RP1datasets.EventReturns memory _eventData_) private returns (RP1datasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // rp1 share, and amount reserved for next pot uint256 _win = (_pot.mul(58)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _rp1 = (_pot.mul(potSplit_[_winTID].rp1)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_rp1); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards community_addr.transfer(_com); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // for next round \u4fee\u6539 if (_rp1 > 0){ _res = _res.add(_rp1); } // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.rp1Amount = _rp1; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev generates a random number between 0-99 and checks to see if thats * resulted in an airdrop win * @return do we have a winner? */ function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } /** * @dev distributes eth based on fees to com, aff, and rp1 */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, RP1datasets.EventReturns memory _eventData_) private returns(RP1datasets.EventReturns) { // pay 2% out to community rewards uint256 _com = _eth / 50; uint256 _rp1; //\u4fee\u6539 community_addr.transfer(_com); // pay 1% out to marketing uint256 _long = _eth / 100; //\u4fee\u6539 marketing_addr.transfer(_long); // distribute share to affiliate uint256 _aff = _eth / 10; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit RP1events.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _rp1 = _aff; } // pay out rp1 _rp1 = _rp1.add((_eth.mul(fees_[_team].rp1)) / (100)); if (_rp1 > 0) { community_addr.transfer(_rp1); // set up event data _eventData_.rp1Amount = _rp1.add(_eventData_.rp1Amount); } return(_eventData_); } function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit RP1events.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, RP1datasets.EventReturns memory _eventData_) private returns(RP1datasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; // toss 3% into airdrop pot uint256 _air = (_eth.mul(3) / 100); airDropPot_ = airDropPot_.add(_air); // update eth balance _eth = _eth.sub(((_eth.mul(18)) / 100)); // calculate pot uint256 _pot = _eth.sub(_gen); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, RP1datasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit RP1events.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.rp1Amount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public { // can only be ran once require(activated_ == false, \"fomo3d already activated\"); // activate the contract activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now - rndGap_; round_[1].end = now + rndInit_ ; } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library RP1datasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 rp1Amount;          // amount distributed to rp1 uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 rp1;    // % of buy in thats paid to rp1 holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 rp1;    // % of pot thats paid to rp1 holders } } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== library RP1KeysCalcLong { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } //============================================================================== //  . _ _|_ _  _ |` _  _ _  _  . //  || | | (/_| ~|~(_|(_(/__\\  . //============================================================================== interface otherFoMo3D { function potSwap() external payable; } interface RP1externalSettingsInterface { function getFastGap() external returns(uint256); function getLongGap() external returns(uint256); function getFastExtra() external returns(uint256); function getLongExtra() external returns(uint256); } interface DiviesInterface { function deposit() external payable; } interface JIincForwarderInterface { function deposit() external payable returns(bool); function status() external view returns(address, address, bool); function startMigration(address _newCorpBank) external returns(bool); function cancelMigration() external returns(bool); function finishMigration() external returns(bool); function setup(address _firstCorpBank) external; } interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } /** * @title -Name Filter- v0.1.9 * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510   \u2566\u2566 \u2566\u2554\u2550\u2557\u2554\u2566\u2557  \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u250c\u2500\u2510 *  \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502   \u2551\u2551 \u2551\u255a\u2550\u2557 \u2551   \u251c\u2500\u2518\u251c\u252c\u2518\u251c\u2524 \u2514\u2500\u2510\u251c\u2524 \u2502\u2502\u2502 \u2502 \u2514\u2500\u2510 *  \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534  \u255a\u255d\u255a\u2550\u255d\u255a\u2550\u255d \u2569   \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2514\u2500\u2518 *                                  _____                      _____ *                                 (, /     /)       /) /)    (, /      /)          /) *          \u250c\u2500\u2510                      /   _ (/_      // //       /  _   // _   __  _(/ *          \u251c\u2500\u2524                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_ *          \u2534 \u2534                /   /          .-/ _____   (__ / *                            (__ /          (_/ (, /                                      /)\u2122 *                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/ * \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510\u252c \u252c\u250c\u2500\u2510\u250c\u252c\u2510                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_ * \u251c\u2500\u2518\u251c\u252c\u2518\u2502 \u2502 \u2502\u2502\u2502 \u2502\u2502   \u2502                      (__ /              .-/  \u00a9 Jekyll Island Inc. 2018 * \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534                                        (_/ *              _       __    _      ____      ____  _   _    _____  ____  ___ *=============| |\\ |  / /\\  | |\\/| | |_ =====| |_  | | | |    | |  | |_  | |_)==============* *=============|_| \\| /_/--\\ |_|  | |_|__=====|_|   |_| |_|__  |_|  |_|__ |_| \\==============* * * \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510  \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u252c\u2510\u250c\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 * \u2551  \u2502 \u2502\u2502\u2502\u2502 \u2502 \u251c\u252c\u2518\u251c\u2500\u2524\u2502   \u2502   \u2551  \u2502 \u2502 \u2502\u2502\u251c\u2524  \u2502 Inventor \u2502 * \u255a\u2550\u255d\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2534\u2514\u2500\u2534 \u2534\u2514\u2500\u2518 \u2534   \u255a\u2550\u255d\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 */ library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "8342.sol", "label": 0, "sol content": "pragma solidity 0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); } function square(uint256 a) internal pure returns (uint256) { return mul(a, a); } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); } } contract ERC20Interface { event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); function totalSupply() public view returns (uint256); function balanceOf(address _owner) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function allowance( address _owner, address _spender) public view returns (uint256); } /** * @title CHStock * @author M.H. Kang */ contract CHStock is ERC20Interface { using SafeMath for uint256; /* EVENT */ event RedeemShares( address indexed user, uint256 shares, uint256 dividends ); /* STORAGE */ string public name = \"ChickenHuntStock\"; string public symbol = \"CHS\"; uint8 public decimals = 18; uint256 public totalShares; uint256 public dividendsPerShare; uint256 public constant CORRECTION = 1 << 64; mapping (address => uint256) public ethereumBalance; mapping (address => uint256) internal shares; mapping (address => uint256) internal refund; mapping (address => uint256) internal deduction; mapping (address => mapping (address => uint256)) internal allowed; /* FUNCTION */ function redeemShares() public { uint256 _shares = shares[msg.sender]; uint256 _dividends = dividendsOf(msg.sender); delete shares[msg.sender]; delete refund[msg.sender]; delete deduction[msg.sender]; totalShares = totalShares.sub(_shares); ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_dividends); emit RedeemShares(msg.sender, _shares, _dividends); } function transfer(address _to, uint256 _value) public returns (bool) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function dividendsOf(address _shareholder) public view returns (uint256) { return dividendsPerShare.mul(shares[_shareholder]).add(refund[_shareholder]).sub(deduction[_shareholder]) / CORRECTION; } function totalSupply() public view returns (uint256) { return totalShares; } function balanceOf(address _owner) public view returns (uint256) { return shares[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /* INTERNAL FUNCTION */ function _giveShares(address _user, uint256 _ethereum) internal { if (_ethereum > 0) { totalShares = totalShares.add(_ethereum); deduction[_user] = deduction[_user].add(dividendsPerShare.mul(_ethereum)); shares[_user] = shares[_user].add(_ethereum); dividendsPerShare = dividendsPerShare.add(_ethereum.mul(CORRECTION) / totalShares); emit Transfer(address(0), _user, _ethereum); } } function _transfer(address _from, address _to, uint256 _value) internal { require(_to != address(0)); require(_value <= shares[_from]); uint256 _rawProfit = dividendsPerShare.mul(_value); uint256 _refund = refund[_from].add(_rawProfit); uint256 _min = _refund < deduction[_from] ? _refund : deduction[_from]; refund[_from] = _refund.sub(_min); deduction[_from] = deduction[_from].sub(_min); deduction[_to] = deduction[_to].add(_rawProfit); shares[_from] = shares[_from].sub(_value); shares[_to] = shares[_to].add(_value); emit Transfer(_from, _to, _value); } } /** * @title CHGameBase * @author M.H. Kang */ contract CHGameBase is CHStock { /* DATA STRUCT */ struct House { Hunter hunter; uint256 huntingPower; uint256 offensePower; uint256 defensePower; uint256 huntingMultiplier; uint256 offenseMultiplier; uint256 defenseMultiplier; uint256 depots; uint256[] pets; } struct Hunter { uint256 strength; uint256 dexterity; uint256 constitution; uint256 resistance; } struct Store { address owner; uint256 cut; uint256 cost; uint256 balance; } /* STORAGE */ Store public store; uint256 public devCut; uint256 public devFee; uint256 public altarCut; uint256 public altarFund; uint256 public dividendRate; uint256 public totalChicken; address public chickenTokenDelegator; mapping (address => uint256) public lastSaveTime; mapping (address => uint256) public savedChickenOf; mapping (address => House) internal houses; /* FUNCTION */ function saveChickenOf(address _user) public returns (uint256) { uint256 _unclaimedChicken = _unclaimedChickenOf(_user); totalChicken = totalChicken.add(_unclaimedChicken); uint256 _chicken = savedChickenOf[_user].add(_unclaimedChicken); savedChickenOf[_user] = _chicken; lastSaveTime[_user] = block.timestamp; return _chicken; } function transferChickenFrom(address _from, address _to, uint256 _value) public returns (bool) { require(msg.sender == chickenTokenDelegator); require(saveChickenOf(_from) >= _value); savedChickenOf[_from] = savedChickenOf[_from] - _value; savedChickenOf[_to] = savedChickenOf[_to].add(_value); return true; } function chickenOf(address _user) public view returns (uint256) { return savedChickenOf[_user].add(_unclaimedChickenOf(_user)); } /* INTERNAL FUNCTION */ function _payChicken(address _user, uint256 _chicken) internal { uint256 _unclaimedChicken = _unclaimedChickenOf(_user); uint256 _extraChicken; if (_chicken > _unclaimedChicken) { _extraChicken = _chicken - _unclaimedChicken; require(savedChickenOf[_user] >= _extraChicken); savedChickenOf[_user] -= _extraChicken; totalChicken -= _extraChicken; } else { _extraChicken = _unclaimedChicken - _chicken; totalChicken = totalChicken.add(_extraChicken); savedChickenOf[_user] += _extraChicken; } lastSaveTime[_user] = block.timestamp; } function _payEthereumAndDistribute(uint256 _cost) internal { require(_cost * 100 / 100 == _cost); _payEthereum(_cost); uint256 _toShareholders = _cost * dividendRate / 100; uint256 _toAltar = _cost * altarCut / 100; uint256 _toStore = _cost * store.cut / 100; devFee = devFee.add(_cost - _toShareholders - _toAltar - _toStore); _giveShares(msg.sender, _toShareholders); altarFund = altarFund.add(_toAltar); store.balance = store.balance.add(_toStore); } function _payEthereum(uint256 _cost) internal { uint256 _extra; if (_cost > msg.value) { _extra = _cost - msg.value; require(ethereumBalance[msg.sender] >= _extra); ethereumBalance[msg.sender] -= _extra; } else { _extra = msg.value - _cost; ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_extra); } } function _unclaimedChickenOf(address _user) internal view returns (uint256) { uint256 _timestamp = lastSaveTime[_user]; if (_timestamp > 0 && _timestamp < block.timestamp) { return houses[_user].huntingPower.mul( houses[_user].huntingMultiplier ).mul(block.timestamp - _timestamp) / 100; } else { return 0; } } function _houseOf(address _user) internal view returns (House storage _house) { _house = houses[_user]; require(_house.depots > 0); } } /** * @title CHHunter * @author M.H. Kang */ contract CHHunter is CHGameBase { /* EVENT */ event UpgradeHunter( address indexed user, string attribute, uint256 to ); /* DATA STRUCT */ struct Config { uint256 chicken; uint256 ethereum; uint256 max; } /* STORAGE */ Config public typeA; Config public typeB; /* FUNCTION */ function upgradeStrength(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.strength; require(typeA.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeA); uint256 _increment = _house.hunter.dexterity.mul(2).add(8).mul(_to.square() - _from ** 2); _house.hunter.strength = _to; _house.huntingPower = _house.huntingPower.add(_increment); _house.offensePower = _house.offensePower.add(_increment); emit UpgradeHunter(msg.sender, \"strength\", _to); } function upgradeDexterity(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.dexterity; require(typeB.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeB); uint256 _increment = _house.hunter.strength.square().mul((_to - _from).mul(2)); _house.hunter.dexterity = _to; _house.huntingPower = _house.huntingPower.add(_increment); _house.offensePower = _house.offensePower.add(_increment); emit UpgradeHunter(msg.sender, \"dexterity\", _to); } function upgradeConstitution(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.constitution; require(typeA.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeA); uint256 _increment = _house.hunter.resistance.mul(2).add(8).mul(_to.square() - _from ** 2); _house.hunter.constitution = _to; _house.defensePower = _house.defensePower.add(_increment); emit UpgradeHunter(msg.sender, \"constitution\", _to); } function upgradeResistance(uint256 _to) external payable { House storage _house = _houseOf(msg.sender); uint256 _from = _house.hunter.resistance; require(typeB.max >= _to && _to > _from); _payForUpgrade(_from, _to, typeB); uint256 _increment = _house.hunter.constitution.square().mul((_to - _from).mul(2)); _house.hunter.resistance = _to; _house.defensePower = _house.defensePower.add(_increment); emit UpgradeHunter(msg.sender, \"resistance\", _to); } /* INTERNAL FUNCTION */ function _payForUpgrade(uint256 _from, uint256 _to, Config _type) internal { uint256 _chickenCost = _type.chicken.mul(_gapOfCubeSum(_from, _to)); _payChicken(msg.sender, _chickenCost); uint256 _ethereumCost = _type.ethereum.mul(_gapOfSquareSum(_from, _to)); _payEthereumAndDistribute(_ethereumCost); } function _gapOfSquareSum(uint256 _before, uint256 _after) internal pure returns (uint256) { // max value is capped to uint32 return (_after * (_after - 1) * (2 * _after - 1) - _before * (_before - 1) * (2 * _before - 1)) / 6; } function _gapOfCubeSum(uint256 _before, uint256 _after) internal pure returns (uint256) { // max value is capped to uint32 return ((_after * (_after - 1)) ** 2 - (_before * (_before - 1)) ** 2) >> 2; } } /** * @title CHHouse * @author M.H. Kang */ contract CHHouse is CHHunter { /* EVENT */ event UpgradePet( address indexed user, uint256 id, uint256 to ); event UpgradeDepot( address indexed user, uint256 to ); event BuyItem( address indexed from, address indexed to, uint256 indexed id, uint256 cost ); event BuyStore( address indexed from, address indexed to, uint256 cost ); /* DATA STRUCT */ struct Pet { uint256 huntingPower; uint256 offensePower; uint256 defensePower; uint256 chicken; uint256 ethereum; uint256 max; } struct Item { address owner; uint256 huntingMultiplier; uint256 offenseMultiplier; uint256 defenseMultiplier; uint256 cost; } struct Depot { uint256 ethereum; uint256 max; } /* STORAGE */ uint256 public constant INCREMENT_RATE = 12; // 120% for Item and Store Depot public depot; Pet[] public pets; Item[] public items; /* FUNCTION */ function buyDepots(uint256 _amount) external payable { House storage _house = _houseOf(msg.sender); _house.depots = _house.depots.add(_amount); require(_house.depots <= depot.max); _payEthereumAndDistribute(_amount.mul(depot.ethereum)); emit UpgradeDepot(msg.sender, _house.depots); } function buyPets(uint256 _id, uint256 _amount) external payable { require(_id < pets.length); Pet memory _pet = pets[_id]; uint256 _chickenCost = _amount * _pet.chicken; _payChicken(msg.sender, _chickenCost); uint256 _ethereumCost = _amount * _pet.ethereum; _payEthereumAndDistribute(_ethereumCost); House storage _house = _houseOf(msg.sender); if (_house.pets.length < _id + 1) { _house.pets.length = _id + 1; } _house.pets[_id] = _house.pets[_id].add(_amount); require(_house.pets[_id] <= _pet.max); _house.huntingPower = _house.huntingPower.add(_pet.huntingPower * _amount); _house.offensePower = _house.offensePower.add(_pet.offensePower * _amount); _house.defensePower = _house.defensePower.add(_pet.defensePower * _amount); emit UpgradePet(msg.sender, _id, _house.pets[_id]); } // This is independent of Stock and Altar. function buyItem(uint256 _id) external payable { Item storage _item = items[_id]; address _from = _item.owner; uint256 _price = _item.cost.mul(INCREMENT_RATE) / 10; _payEthereum(_price); saveChickenOf(_from); House storage _fromHouse = _houseOf(_from); _fromHouse.huntingMultiplier = _fromHouse.huntingMultiplier.sub(_item.huntingMultiplier); _fromHouse.offenseMultiplier = _fromHouse.offenseMultiplier.sub(_item.offenseMultiplier); _fromHouse.defenseMultiplier = _fromHouse.defenseMultiplier.sub(_item.defenseMultiplier); saveChickenOf(msg.sender); House storage _toHouse = _houseOf(msg.sender); _toHouse.huntingMultiplier = _toHouse.huntingMultiplier.add(_item.huntingMultiplier); _toHouse.offenseMultiplier = _toHouse.offenseMultiplier.add(_item.offenseMultiplier); _toHouse.defenseMultiplier = _toHouse.defenseMultiplier.add(_item.defenseMultiplier); uint256 _halfMargin = _price.sub(_item.cost) / 2; devFee = devFee.add(_halfMargin); ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin); items[_id].cost = _price; items[_id].owner = msg.sender; emit BuyItem(_from, msg.sender, _id, _price); } // This is independent of Stock and Altar. function buyStore() external payable { address _from = store.owner; uint256 _price = store.cost.mul(INCREMENT_RATE) / 10; _payEthereum(_price); uint256 _halfMargin = (_price - store.cost) / 2; devFee = devFee.add(_halfMargin); ethereumBalance[_from] = ethereumBalance[_from].add(_price - _halfMargin).add(store.balance); store.cost = _price; store.owner = msg.sender; delete store.balance; emit BuyStore(_from, msg.sender, _price); } function withdrawStoreBalance() public { ethereumBalance[store.owner] = ethereumBalance[store.owner].add(store.balance); delete store.balance; } } /** * @title CHArena * @author M.H. Kang */ contract CHArena is CHHouse { /* EVENT */ event Attack( address indexed attacker, address indexed defender, uint256 booty ); /* STORAGE */ mapping(address => uint256) public attackCooldown; uint256 public cooldownTime; /* FUNCTION */ function attack(address _target) external { require(attackCooldown[msg.sender] < block.timestamp); House storage _attacker = houses[msg.sender]; House storage _defender = houses[_target]; if (_attacker.offensePower.mul(_attacker.offenseMultiplier) > _defender.defensePower.mul(_defender.defenseMultiplier)) { uint256 _chicken = saveChickenOf(_target); _chicken = _defender.depots > 0 ? _chicken / _defender.depots : _chicken; savedChickenOf[_target] = savedChickenOf[_target] - _chicken; savedChickenOf[msg.sender] = savedChickenOf[msg.sender].add(_chicken); attackCooldown[msg.sender] = block.timestamp + cooldownTime; emit Attack(msg.sender, _target, _chicken); } } } /** * @title CHAltar * @author M.H. Kang */ contract CHAltar is CHArena { /* EVENT */ event NewAltarRecord(uint256 id, uint256 ethereum); event ChickenToAltar(address indexed user, uint256 id, uint256 chicken); event EthereumFromAltar(address indexed user, uint256 id, uint256 ethereum); /* DATA STRUCT */ struct AltarRecord { uint256 ethereum; uint256 chicken; } struct TradeBook { uint256 altarRecordId; uint256 chicken; } /* STORAGE */ uint256 public genesis; mapping (uint256 => AltarRecord) public altarRecords; mapping (address => TradeBook) public tradeBooks; /* FUNCTION */ function chickenToAltar(uint256 _chicken) external { require(_chicken > 0); _payChicken(msg.sender, _chicken); uint256 _id = _getCurrentAltarRecordId(); AltarRecord storage _altarRecord = _getAltarRecord(_id); require(_altarRecord.ethereum * _chicken / _chicken == _altarRecord.ethereum); TradeBook storage _tradeBook = tradeBooks[msg.sender]; if (_tradeBook.altarRecordId < _id) { _resolveTradeBook(_tradeBook); _tradeBook.altarRecordId = _id; } _altarRecord.chicken = _altarRecord.chicken.add(_chicken); _tradeBook.chicken += _chicken; emit ChickenToAltar(msg.sender, _id, _chicken); } function ethereumFromAltar() external { uint256 _id = _getCurrentAltarRecordId(); TradeBook storage _tradeBook = tradeBooks[msg.sender]; require(_tradeBook.altarRecordId < _id); _resolveTradeBook(_tradeBook); } function tradeBookOf(address _user) public view returns ( uint256 _id, uint256 _ethereum, uint256 _totalChicken, uint256 _chicken, uint256 _income ) { TradeBook memory _tradeBook = tradeBooks[_user]; _id = _tradeBook.altarRecordId; _chicken = _tradeBook.chicken; AltarRecord memory _altarRecord = altarRecords[_id]; _totalChicken = _altarRecord.chicken; _ethereum = _altarRecord.ethereum; _income = _totalChicken > 0 ? _ethereum.mul(_chicken) / _totalChicken : 0; } /* INTERNAL FUNCTION */ function _resolveTradeBook(TradeBook storage _tradeBook) internal { if (_tradeBook.chicken > 0) { AltarRecord memory _oldAltarRecord = altarRecords[_tradeBook.altarRecordId]; uint256 _ethereum = _oldAltarRecord.ethereum.mul(_tradeBook.chicken) / _oldAltarRecord.chicken; delete _tradeBook.chicken; ethereumBalance[msg.sender] = ethereumBalance[msg.sender].add(_ethereum); emit EthereumFromAltar(msg.sender, _tradeBook.altarRecordId, _ethereum); } } function _getCurrentAltarRecordId() internal view returns (uint256) { return (block.timestamp - genesis) / 86400; } function _getAltarRecord(uint256 _id) internal returns (AltarRecord storage _altarRecord) { _altarRecord = altarRecords[_id]; if (_altarRecord.ethereum == 0) { uint256 _ethereum = altarFund / 10; _altarRecord.ethereum = _ethereum; altarFund -= _ethereum; emit NewAltarRecord(_id, _ethereum); } } } /** * @title CHCommittee * @author M.H. Kang */ contract CHCommittee is CHAltar { /* EVENT */ event NewPet( uint256 id, uint256 huntingPower, uint256 offensePower, uint256 defense, uint256 chicken, uint256 ethereum, uint256 max ); event ChangePet( uint256 id, uint256 chicken, uint256 ethereum, uint256 max ); event NewItem( uint256 id, uint256 huntingMultiplier, uint256 offenseMultiplier, uint256 defenseMultiplier, uint256 ethereum ); event SetDepot(uint256 ethereum, uint256 max); event SetConfiguration( uint256 chickenA, uint256 ethereumA, uint256 maxA, uint256 chickenB, uint256 ethereumB, uint256 maxB ); event SetDistribution( uint256 dividendRate, uint256 altarCut, uint256 storeCut, uint256 devCut ); event SetCooldownTime(uint256 cooldownTime); event SetNameAndSymbol(string name, string symbol); event SetDeveloper(address developer); event SetCommittee(address committee); /* STORAGE */ address public committee; address public developer; /* FUNCTION */ function callFor(address _to, uint256 _value, uint256 _gas, bytes _code) external payable onlyCommittee returns (bool) { return _to.call.value(_value).gas(_gas)(_code); } function addPet( uint256 _huntingPower, uint256 _offensePower, uint256 _defense, uint256 _chicken, uint256 _ethereum, uint256 _max ) public onlyCommittee { require(_max > 0); require(_max == uint256(uint32(_max))); uint256 _newLength = pets.push( Pet(_huntingPower, _offensePower, _defense, _chicken, _ethereum, _max) ); emit NewPet( _newLength - 1, _huntingPower, _offensePower, _defense, _chicken, _ethereum, _max ); } function changePet( uint256 _id, uint256 _chicken, uint256 _ethereum, uint256 _max ) public onlyCommittee { require(_id < pets.length); Pet storage _pet = pets[_id]; require(_max >= _pet.max && _max == uint256(uint32(_max))); _pet.chicken = _chicken; _pet.ethereum = _ethereum; _pet.max = _max; emit ChangePet(_id, _chicken, _ethereum, _max); } function addItem( uint256 _huntingMultiplier, uint256 _offenseMultiplier, uint256 _defenseMultiplier, uint256 _price ) public onlyCommittee { uint256 _cap = 1 << 16; require( _huntingMultiplier < _cap && _offenseMultiplier < _cap && _defenseMultiplier < _cap ); saveChickenOf(committee); House storage _house = _houseOf(committee); _house.huntingMultiplier = _house.huntingMultiplier.add(_huntingMultiplier); _house.offenseMultiplier = _house.offenseMultiplier.add(_offenseMultiplier); _house.defenseMultiplier = _house.defenseMultiplier.add(_defenseMultiplier); uint256 _newLength = items.push( Item( committee, _huntingMultiplier, _offenseMultiplier, _defenseMultiplier, _price ) ); emit NewItem( _newLength - 1, _huntingMultiplier, _offenseMultiplier, _defenseMultiplier, _price ); } function setDepot(uint256 _price, uint256 _max) public onlyCommittee { require(_max >= depot.max); depot.ethereum = _price; depot.max = _max; emit SetDepot(_price, _max); } function setConfiguration( uint256 _chickenA, uint256 _ethereumA, uint256 _maxA, uint256 _chickenB, uint256 _ethereumB, uint256 _maxB ) public onlyCommittee { require(_maxA >= typeA.max && (_maxA == uint256(uint32(_maxA)))); require(_maxB >= typeB.max && (_maxB == uint256(uint32(_maxB)))); typeA.chicken = _chickenA; typeA.ethereum = _ethereumA; typeA.max = _maxA; typeB.chicken = _chickenB; typeB.ethereum = _ethereumB; typeB.max = _maxB; emit SetConfiguration(_chickenA, _ethereumA, _maxA, _chickenB, _ethereumB, _maxB); } function setDistribution( uint256 _dividendRate, uint256 _altarCut, uint256 _storeCut, uint256 _devCut ) public onlyCommittee { require(_storeCut > 0); require( _dividendRate.add(_altarCut).add(_storeCut).add(_devCut) == 100 ); dividendRate = _dividendRate; altarCut = _altarCut; store.cut = _storeCut; devCut = _devCut; emit SetDistribution(_dividendRate, _altarCut, _storeCut, _devCut); } function setCooldownTime(uint256 _cooldownTime) public onlyCommittee { cooldownTime = _cooldownTime; emit SetCooldownTime(_cooldownTime); } function setNameAndSymbol(string _name, string _symbol) public onlyCommittee { name = _name; symbol = _symbol; emit SetNameAndSymbol(_name, _symbol); } function setDeveloper(address _developer) public onlyCommittee { require(_developer != address(0)); withdrawDevFee(); developer = _developer; emit SetDeveloper(_developer); } function setCommittee(address _committee) public onlyCommittee { require(_committee != address(0)); committee = _committee; emit SetCommittee(_committee); } function withdrawDevFee() public { ethereumBalance[developer] = ethereumBalance[developer].add(devFee); delete devFee; } /* MODIFIER */ modifier onlyCommittee { require(msg.sender == committee); _; } } /** * @title ChickenHunt * @author M.H. Kang */ contract ChickenHunt is CHCommittee { /* EVENT */ event Join(address user); /* CONSTRUCTOR */ constructor() public { committee = msg.sender; developer = msg.sender; } /* FUNCTION */ function init(address _chickenTokenDelegator) external onlyCommittee { require(chickenTokenDelegator == address(0)); chickenTokenDelegator = _chickenTokenDelegator; genesis = 1525791600; join(); store.owner = msg.sender; store.cost = 0.1 ether; setConfiguration(100, 0.00001 ether, 99, 100000, 0.001 ether, 9); setDistribution(20, 75, 1, 4); setCooldownTime(600); setDepot(0.05 ether, 9); addItem(5, 5, 0, 0.01 ether); addItem(0, 0, 5, 0.01 ether); addPet(1000, 0, 0, 100000, 0.01 ether, 9); addPet(0, 1000, 0, 100000, 0.01 ether, 9); addPet(0, 0, 1000, 202500, 0.01 ether, 9); } function withdraw() external { uint256 _ethereum = ethereumBalance[msg.sender]; delete ethereumBalance[msg.sender]; msg.sender.transfer(_ethereum); } function join() public { House storage _house = houses[msg.sender]; require(_house.depots == 0); _house.hunter = Hunter(1, 1, 1, 1); _house.depots = 1; _house.huntingPower = 10; _house.offensePower = 10; _house.defensePower = 110; _house.huntingMultiplier = 10; _house.offenseMultiplier = 10; _house.defenseMultiplier = 10; lastSaveTime[msg.sender] = block.timestamp; emit Join(msg.sender); } function hunterOf(address _user) public view returns ( uint256 _strength, uint256 _dexterity, uint256 _constitution, uint256 _resistance ) { Hunter memory _hunter = houses[_user].hunter; return ( _hunter.strength, _hunter.dexterity, _hunter.constitution, _hunter.resistance ); } function detailsOf(address _user) public view returns ( uint256[2] _hunting, uint256[2] _offense, uint256[2] _defense, uint256[4] _hunter, uint256[] _pets, uint256 _depots, uint256 _savedChicken, uint256 _lastSaveTime, uint256 _cooldown ) { House memory _house = houses[_user]; _hunting = [_house.huntingPower, _house.huntingMultiplier]; _offense = [_house.offensePower, _house.offenseMultiplier]; _defense = [_house.defensePower, _house.defenseMultiplier]; _hunter = [ _house.hunter.strength, _house.hunter.dexterity, _house.hunter.constitution, _house.hunter.resistance ]; _pets = _house.pets; _depots = _house.depots; _savedChicken = savedChickenOf[_user]; _lastSaveTime = lastSaveTime[_user]; _cooldown = attackCooldown[_user]; } } "}
{"sol name": "2599.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // Is needed to call functions in the Snow contract. contract Snow { function buy(address) public payable returns(uint256); function withdraw() public; function redistribution() external payable; function myTokens() public view returns(uint256); function myDividends(bool) public view returns(uint256); } contract F3Devents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (fomo3d short only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (fomo3d short only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract modularShort is F3Devents {} contract SnowStorm is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xf4FBEF849bcf02Ac4b305c2bc092FC270a14124C); address private admin = msg.sender; string constant public name = \"SnowStorm\"; string constant public symbol = \"SS\"; uint256 private rndExtra_ = 1 seconds; uint256 private rndGap_ = 1 seconds; uint256 constant private rndInit_ = 8 hours; uint256 constant private rndInc_ = 30 seconds; uint256 constant private rndMax_ = 8 hours; address treat; Snow action; uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA //**************** mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { treat = 0x371308b6A7B6f80DF798589c48Dea369839951dd; // contract address action = Snow(treat); // Team allocation structures // 0 = whales // 1 = bears // 2 = sneks // 3 = bulls // Team allocation percentages // (F3D, P3D) + (Pot , Referrals, Community) // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot. fees_[0] = F3Ddatasets.TeamFee(46,10);   //33% to pot, 10% to aff, 1% to air drop pot fees_[1] = F3Ddatasets.TeamFee(46,10);   //33% to pot, 10% to aff, 1% to air drop pot fees_[2] = F3Ddatasets.TeamFee(46,10);   //33% to pot, 10% to aff, 1% to air drop pot fees_[3] = F3Ddatasets.TeamFee(46,10);   //33% to pot, 10% to aff, 1% to air drop pot // how to split up the final pot based on which team was picked // (F3D, P3D) potSplit_[0] = F3Ddatasets.PotSplit(35,5);  //50% to winner, 10% to next round potSplit_[1] = F3Ddatasets.PotSplit(35,5);  //50% to winner, 10% to next round potSplit_[2] = F3Ddatasets.PotSplit(35,5);  //50% to winner, 10% to next round potSplit_[3] = F3Ddatasets.PotSplit(35,5);  //50% to winner, 10% to next round } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } /** * @dev prevents contracts from interacting with fomo3d */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit F3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(50)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, _team, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit F3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core(_rID, _pID, _eth, _affID, _team, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit F3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 5000000000000000000) { uint256 _availableLimit = (5000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // manage airdrops if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { // gib muni uint256 _prize; if (_eth >= 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 2 prize was won _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } // set airdrop happened bool to true _eventData_.compressedData += 10000000000000000000000000000000; // let event know how much was won _eventData_.compressedData += _prize * 1000000000000000000000000000000000; // reset air drop tracker airDropTracker_ = 0; } } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _team, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of fomo3d if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev checks to make sure user picked a valid team.  if not sets team * to default (sneks) */ function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(48)) / 100; //48% uint256 _com = (_pot / 50); //2% _win = _win+_com; // 50% uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); action.redistribution.value(_p3d).gas(1000000)(); // send dividends to snow holders // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev generates a random number between 0-99 and checks to see if thats * resulted in an airdrop win * @return do we have a winner? */ function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { //pay 3% also into the pot uint256 _p1 = _eth / 100; //1% uint256 _com = _eth / 50;  //2% _com = _com.add(_p1); //1 + 2 = 3 uint256 _p3d; if (!address(admin).call.value(_com)()) { // This ensures Team Just cannot influence the outcome of FoMo3D with // bank migrations by breaking outgoing transactions. // Something we would never do. But that's not the point. // We spent 2000$ in eth re-deploying just to patch this, we hold the // highest belief that everything we create should be trustless. // Team JUST, The name you shouldn't have to trust. _p3d = _com; _com = 0; } // distribute share to affiliate uint256 _aff = _eth / 10; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _aff; } // pay out p3d _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { action.redistribution.value(_p3d).gas(1000000)(); // set up event data _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F3Devents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; // toss 1% into airdrop pot uint256 _air = (_eth / 100); airDropPot_ = airDropPot_.add(_air); // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share + airdrop pot share)) _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100)); // calculate pot uint256 _pot = _eth.sub(_gen); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public { // only team just can activate require(msg.sender == admin); // can only be ran once require(activated_ == false); // activate the contract activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library F3Ddatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 p3d;    // % of buy in thats paid to p3d holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 p3d;    // % of pot thats paid to p3d holders } } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== library F3DKeysCalcShort { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } //============================================================================== //  . _ _|_ _  _ |` _  _ _  _  . //  || | | (/_| ~|~(_|(_(/__\\  . //============================================================================== interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "9360.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; interface IAffiliateList { /** * @dev Sets the given address as an affiliate. *      If the address is not currently an affiliate, startTimestamp is required *      and endTimestamp is optional. *      If the address is already registered as an affiliate, both values are optional. * @param startTimestamp Timestamp when the address became/becomes an affiliate. * @param endTimestamp Timestamp when the address will no longer be an affiliate. */ function set(address addr, uint startTimestamp, uint endTimestamp) external; /** * @dev Retrieves the start and end timestamps for the given address. *      It is sufficient to check the start value to determine if the address *      is an affiliate (start will be greater than zero). */ function get(address addr) external view returns (uint start, uint end); /** * @dev Returns true if the address is, was, or will be an affiliate at the given time. */ function inListAsOf(address addr, uint time) external view returns (bool); } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract IInvestorList { string public constant ROLE_REGD = \"regd\"; string public constant ROLE_REGCF = \"regcf\"; string public constant ROLE_REGS = \"regs\"; string public constant ROLE_UNKNOWN = \"unknown\"; function inList(address addr) public view returns (bool); function addAddress(address addr, string role) public; function getRole(address addr) public view returns (string); function hasRole(address addr, string role) public view returns (bool); } contract Ownable { address public owner; address public newOwner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Starts the 2-step process of changing ownership. The new owner * must then call `acceptOwnership()`. */ function changeOwner(address _newOwner) public onlyOwner { newOwner = _newOwner; } /** * @dev Completes the process of transferring ownership to a new owner. */ function acceptOwnership() public { if (msg.sender == newOwner) { owner = newOwner; newOwner = 0; } } } contract AffiliateList is Ownable, IAffiliateList { event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp); event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp); mapping (address => uint) public affiliateStart; mapping (address => uint) public affiliateEnd; function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner { require(addr != address(0)); uint existingStart = affiliateStart[addr]; if(existingStart == 0) { // this is a new address require(startTimestamp != 0); affiliateStart[addr] = startTimestamp; if(endTimestamp != 0) { require(endTimestamp > startTimestamp); affiliateEnd[addr] = endTimestamp; } emit AffiliateAdded(addr, startTimestamp, endTimestamp); } else { // this address was previously registered if(startTimestamp == 0) { // don't update the start timestamp if(endTimestamp == 0) { affiliateStart[addr] = 0; affiliateEnd[addr] = 0; } else { require(endTimestamp > existingStart); } } else { // update the start timestamp affiliateStart[addr] = startTimestamp; if(endTimestamp != 0) { require(endTimestamp > startTimestamp); } } affiliateEnd[addr] = endTimestamp; emit AffiliateUpdated(addr, startTimestamp, endTimestamp); } } function get(address addr) public view returns (uint start, uint end) { return (affiliateStart[addr], affiliateEnd[addr]); } function inListAsOf(address addr, uint time) public view returns (bool) { uint start; uint end; (start, end) = get(addr); if(start == 0) { return false; } if(time < start) { return false; } if(end != 0 && time >= end) { return false; } return true; } } contract InvestorList is Ownable, IInvestorList { event AddressAdded(address addr, string role); event AddressRemoved(address addr, string role); mapping (address => string) internal investorList; /** * @dev Throws if called by any account that's not investorListed. * @param role string */ modifier validRole(string role) { require( keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN)) ); _; } /** * @dev Getter to determine if address is in investorList. * @param addr address * @return true if the address was added to the investorList, false if the address was already in the investorList */ function inList(address addr) public view returns (bool) { if (bytes(investorList[addr]).length != 0) { return true; } else { return false; } } /** * @dev Getter for address role if address is in list. * @param addr address * @return string for address role */ function getRole(address addr) public view returns (string) { require(inList(addr)); return investorList[addr]; } /** * @dev Returns a boolean indicating if the given address is in the list *      with the given role. * @param addr address to check * @param role role to check * @ return boolean for whether the address is in the list with the role */ function hasRole(address addr, string role) public view returns (bool) { return keccak256(bytes(role)) == keccak256(bytes(investorList[addr])); } /** * @dev Add single address to the investorList. * @param addr address * @param role string */ function addAddress(address addr, string role) onlyOwner validRole(role) public { investorList[addr] = role; emit AddressAdded(addr, role); } /** * @dev Add multiple addresses to the investorList. * @param addrs addresses * @param role string */ function addAddresses(address[] addrs, string role) onlyOwner validRole(role) public { for (uint256 i = 0; i < addrs.length; i++) { addAddress(addrs[i], role); } } /** * @dev Remove single address from the investorList. * @param addr address */ function removeAddress(address addr) onlyOwner public { // removeRole(addr, ROLE_WHITELISTED); require(inList(addr)); string memory role = investorList[addr]; investorList[addr] = \"\"; emit AddressRemoved(addr, role); } /** * @dev Remove multiple addresses from the investorList. * @param addrs addresses */ function removeAddresses(address[] addrs) onlyOwner public { for (uint256 i = 0; i < addrs.length; i++) { if (inList(addrs[i])) { removeAddress(addrs[i]); } } } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ISecurityController { function balanceOf(address _a) public view returns (uint); function totalSupply() public view returns (uint); function isTransferAuthorized(address _from, address _to) public view returns (bool); function setTransferAuthorized(address from, address to, uint expiry) public; function transfer(address _from, address _to, uint _value) public returns (bool success); function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint); function approve(address _owner, address _spender, uint _value) public returns (bool success); function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success); function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success); function burn(address _owner, uint _amount) public; function ledgerTransfer(address from, address to, uint val) public; function setLedger(address _ledger) public; function setSale(address _sale) public; function setToken(address _token) public; function setAffiliateList(address _affiliateList) public; } contract SecurityController is ISecurityController, Ownable { ISecurityLedger public ledger; ISecurityToken public token; ISecuritySale public sale; IInvestorList public investorList; ITransferAuthorizations public transferAuthorizations; IAffiliateList public affiliateList; uint public lockoutPeriod = 10 * 60 * 60; // length in seconds of the lockout period // restrict who can grant transfer authorizations mapping(address => bool) public transferAuthPermission; constructor() public { } function setTransferAuthorized(address from, address to, uint expiry) public { // Must be called from address in the transferAuthPermission mapping require(transferAuthPermission[msg.sender]); // don't allow 'from' to be zero require(from != 0); // verify expiry is in future, but not more than 30 days if(expiry > 0) { require(expiry > block.timestamp); require(expiry <= (block.timestamp + 30 days)); } transferAuthorizations.set(from, to, expiry); } // functions below this line are onlyOwner function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner { lockoutPeriod = _lockoutPeriod; } function setToken(address _token) public onlyOwner { token = ISecurityToken(_token); } function setLedger(address _ledger) public onlyOwner { ledger = ISecurityLedger(_ledger); } function setSale(address _sale) public onlyOwner { sale = ISecuritySale(_sale); } function setInvestorList(address _investorList) public onlyOwner { investorList = IInvestorList(_investorList); } function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner { transferAuthorizations = ITransferAuthorizations(_transferAuthorizations); } function setAffiliateList(address _affiliateList) public onlyOwner { affiliateList = IAffiliateList(_affiliateList); } function setDependencies(address _token, address _ledger, address _sale, address _investorList, address _transferAuthorizations, address _affiliateList) public onlyOwner { token = ISecurityToken(_token); ledger = ISecurityLedger(_ledger); sale = ISecuritySale(_sale); investorList = IInvestorList(_investorList); transferAuthorizations = ITransferAuthorizations(_transferAuthorizations); affiliateList = IAffiliateList(_affiliateList); } function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner { require(agent != address(0)); transferAuthPermission[agent] = hasPermission; } modifier onlyToken() { require(msg.sender == address(token)); _; } modifier onlyLedger() { require(msg.sender == address(ledger)); _; } // public functions function totalSupply() public view returns (uint) { return ledger.totalSupply(); } function balanceOf(address _a) public view returns (uint) { return ledger.balanceOf(_a); } function allowance(address _owner, address _spender) public view returns (uint) { return ledger.allowance(_owner, _spender); } function isTransferAuthorized(address _from, address _to) public view returns (bool) { // A `from` address could have both an allowance for the `to` address // and a global allowance (to the zero address). We pick the maximum // of the two. uint expiry = transferAuthorizations.get(_from, _to); uint globalExpiry = transferAuthorizations.get(_from, 0); if(globalExpiry > expiry) { expiry = globalExpiry; } return expiry > block.timestamp; } /** * @dev Determines whether the given transfer is possible. Returns multiple *      boolean flags specifying how the transfer must occur. *      This is kept public to provide for testing and subclasses overriding behavior. * @param _from Address the tokens are being transferred from * @param _to Address the tokens are being transferred to * @param _value Number of tokens that would be transferred * @param lockoutTime A point in time, specified in epoch time, that specifies *                    the lockout period (typically 1 year before now). * @return canTransfer Whether the transfer can occur at all. * @return useLockoutTime Whether the lockoutTime should be used to determine which tokens to transfer. * @return newTokensAreRestricted Whether the transferred tokens should be marked as restricted. * @return preservePurchaseDate Whether the purchase date on the tokens should be preserved, or reset to 'now'. */ function checkTransfer(address _from, address _to, uint _value, uint lockoutTime) public returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) { // DEFAULT BEHAVIOR: // // If there exists a Transfer Agent authorization, allow transfer regardless // // All transfers from an affiliate must be authorized by Transfer Agent //   - tokens become restricted // // From Reg S to Reg S: allowable, regardless of holding period // // otherwise must meet holding period // presently this isn't used, so always setting to false to avoid warning preservePurchaseDate = false; bool transferIsAuthorized = isTransferAuthorized(_from, _to); bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp); bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp); if(transferIsAuthorized) { canTransfer = true; if(fromIsAffiliate || toIsAffiliate) { newTokensAreRestricted = true; } // useLockoutTime will remain false // preservePurchaseDate will remain false } else if(!fromIsAffiliate) { // see if both are Reg S if(investorList.hasRole(_from, investorList.ROLE_REGS()) && investorList.hasRole(_to, investorList.ROLE_REGS())) { canTransfer = true; // newTokensAreRestricted will remain false // useLockoutTime will remain false // preservePurchaseDate will remain false } else { if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) { canTransfer = true; useLockoutTime = true; // newTokensAreRestricted will remain false // preservePurchaseDate will remain false } } } } // functions below this line are onlyLedger // let the ledger send transfer events (the most obvious case // is when we mint directly to the ledger and need the Transfer() // events to appear in the token) function ledgerTransfer(address from, address to, uint val) public onlyLedger { token.controllerTransfer(from, to, val); } // functions below this line are onlyToken function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) { uint lockoutTime = block.timestamp - lockoutPeriod; bool canTransfer; bool useLockoutTime; bool newTokensAreRestricted; bool preservePurchaseDate; (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate) = checkTransfer(_from, _to, _value, lockoutTime); if(!canTransfer) { return false; } uint overrideLockoutTime = lockoutTime; if(!useLockoutTime) { overrideLockoutTime = 0; } return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate); } function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) { uint lockoutTime = block.timestamp - lockoutPeriod; bool canTransfer; bool useLockoutTime; bool newTokensAreRestricted; bool preservePurchaseDate; (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate) = checkTransfer(_from, _to, _value, lockoutTime); if(!canTransfer) { return false; } uint overrideLockoutTime = lockoutTime; if(!useLockoutTime) { overrideLockoutTime = 0; } return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate); } function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) { return ledger.approve(_owner, _spender, _value); } function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) { return ledger.increaseApproval(_owner, _spender, _addedValue); } function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) { return ledger.decreaseApproval(_owner, _spender, _subtractedValue); } function burn(address _owner, uint _amount) public onlyToken { ledger.burn(_owner, _amount); } } interface ISecurityLedger { function balanceOf(address _a) external view returns (uint); function totalSupply() external view returns (uint); function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount); function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success); function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success); function allowance(address _owner, address _spender) external view returns (uint); function approve(address _owner, address _spender, uint _value) external returns (bool success); function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success); function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success); function burn(address _owner, uint _amount) external; function setController(address _controller) external; } contract SecurityLedger is Ownable { using SafeMath for uint256; struct TokenLot { uint amount; uint purchaseDate; bool restricted; } mapping(address => TokenLot[]) public tokenLotsOf; SecurityController public controller; mapping(address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; uint public totalSupply; uint public mintingNonce; bool public mintingStopped; constructor() public { } // functions below this line are onlyOwner function setController(address _controller) public onlyOwner { controller = SecurityController(_controller); } function stopMinting() public onlyOwner { mintingStopped = true; } //TODO: not sure if this function should stay long term function mint(address addr, uint value, uint timestamp) public onlyOwner { require(!mintingStopped); uint time = timestamp; if(time == 0) { time = block.timestamp; } balanceOf[addr] = balanceOf[addr].add(value); tokenLotsOf[addr].push(TokenLot(value, time, true)); controller.ledgerTransfer(0, addr, value); totalSupply = totalSupply.add(value); } function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner { require(!mintingStopped); if (nonce != mintingNonce) return; mintingNonce = mintingNonce.add(1); uint256 lomask = (1 << 96) - 1; uint created = 0; uint time = timestamp; if(time == 0) { time = block.timestamp; } for (uint i = 0; i < bits.length; i++) { address addr = address(bits[i]>>96); uint value = bits[i] & lomask; balanceOf[addr] = balanceOf[addr].add(value); tokenLotsOf[addr].push(TokenLot(value, time, true)); controller.ledgerTransfer(0, addr, value); created = created.add(value); } totalSupply = totalSupply.add(created); } // send received tokens to anyone function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(sender, amount)); } // functions below this line are onlyController modifier onlyController() { require(msg.sender == address(controller)); _; } /** * @dev Walks through the list of TokenLots for the given address, attempting to find *      `amount` tokens that can be transferred. It uses the given `lockoutTime` if *      the supplied value is not zero. If `removeTokens` is true the tokens are *      actually removed from the address, otherwise this function acts as a dry run. *      The value returned is the actual number of transferrable tokens found, up to *      the maximum value of `amount`. */ function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens, bool newTokensAreRestricted, bool preservePurchaseDate) internal returns (uint numTransferrableTokens) { TokenLot[] storage fromTokenLots = tokenLotsOf[from]; for(uint i=0; i<fromTokenLots.length; i++) { TokenLot storage lot = fromTokenLots[i]; uint lotAmount = lot.amount; // skip if there are no available tokens if(lotAmount == 0) { continue; } if(lockoutTime > 0) { // skip if it is more recent than the lockout period AND it's restricted if(lot.restricted && lot.purchaseDate > lockoutTime) { continue; } } uint remaining = amount.sub(numTransferrableTokens); if(lotAmount >= remaining) { numTransferrableTokens = numTransferrableTokens.add(remaining); if(removeTokens) { lot.amount = lotAmount.sub(remaining); if(to != address(0)) { if(preservePurchaseDate) { tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted)); } else { tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted)); } } } break; } // If we're here, then amount in this lot is not yet enough. // Take all of it. numTransferrableTokens = numTransferrableTokens.add(lotAmount); if(removeTokens) { lot.amount = 0; if(to != address(0)) { if(preservePurchaseDate) { tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted)); } else { tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted)); } } } } } function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) { return walkTokenLots(from, to, amount, lockoutTime, false, false, false); } function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) { if (balanceOf[_from] < _value) return false; // ensure number of tokens removed from TokenLots is as expected uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate); require(tokensTransferred == _value); // adjust balances balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); return true; } function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) { if (balanceOf[_from] < _value) return false; // ensure there is enough allowance uint allowed = allowance[_from][_spender]; if (allowed < _value) return false; // ensure number of tokens removed from TokenLots is as expected uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate); require(tokensTransferred == _value); // adjust balances balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowance[_from][_spender] = allowed.sub(_value); return true; } function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) { // require user to set to zero before resetting to nonzero if ((_value != 0) && (allowance[_owner][_spender] != 0)) { return false; } allowance[_owner][_spender] = _value; return true; } function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) { uint oldValue = allowance[_owner][_spender]; allowance[_owner][_spender] = oldValue.add(_addedValue); return true; } function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) { uint oldValue = allowance[_owner][_spender]; if (_subtractedValue > oldValue) { allowance[_owner][_spender] = 0; } else { allowance[_owner][_spender] = oldValue.sub(_subtractedValue); } return true; } function burn(address _owner, uint _amount) public onlyController { require(balanceOf[_owner] >= _amount); balanceOf[_owner] = balanceOf[_owner].sub(_amount); // remove tokens from TokenLots // (i.e. transfer them to 0) walkTokenLots(_owner, address(0), _amount, 0, true, false, false); totalSupply = totalSupply.sub(_amount); } } interface ISecuritySale { function setLive(bool newLiveness) external; function setInvestorList(address _investorList) external; } contract SecuritySale is Ownable { bool public live;        // sale is live right now IInvestorList public investorList; // approved contributors event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; } function setInvestorList(address _investorList) public onlyOwner { investorList = IInvestorList(_investorList); } function () public payable { require(live); require(investorList.inList(msg.sender)); emit EtherIn(msg.sender, msg.value); } // set liveness function setLive(bool newLiveness) public onlyOwner { if(live && !newLiveness) { live = false; emit EndSale(); } else if(!live && newLiveness) { live = true; emit StartSale(); } } // withdraw all of the Ether to owner function withdraw() public onlyOwner { msg.sender.transfer(address(this).balance); } // withdraw some of the Ether to owner function withdrawSome(uint value) public onlyOwner { require(value <= address(this).balance); msg.sender.transfer(value); } // withdraw tokens to owner function withdrawTokens(address token) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(msg.sender, t.balanceOf(this))); } // send received tokens to anyone function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(sender, amount)); } } interface ISecurityToken { function balanceOf(address addr) external view returns(uint); function transfer(address to, uint amount) external returns(bool); function controllerTransfer(address _from, address _to, uint _value) external; } contract SecurityToken is Ownable{ using SafeMath for uint256; ISecurityController public controller; // these public fields are set once in constructor string public name; string public symbol; uint8 public decimals; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); constructor(string _name, string  _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } // functions below this line are onlyOwner function setName(string _name) public onlyOwner { name = _name; } function setSymbol(string _symbol) public onlyOwner { symbol = _symbol; } function setController(address _c) public onlyOwner { controller = ISecurityController(_c); } // send received tokens to anyone function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(sender, amount)); } // functions below this line are public function balanceOf(address a) public view returns (uint) { return controller.balanceOf(a); } function totalSupply() public view returns (uint) { return controller.totalSupply(); } function allowance(address _owner, address _spender) public view returns (uint) { return controller.allowance(_owner, _spender); } function burn(uint _amount) public { controller.burn(msg.sender, _amount); emit Transfer(msg.sender, 0x0, _amount); } // functions below this line are onlyPayloadSize // TODO: investigate this security optimization more modifier onlyPayloadSize(uint numwords) { assert(msg.data.length >= numwords.mul(32).add(4)); _; } function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) { return controller.isTransferAuthorized(_from, _to); } function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) { if (controller.transfer(msg.sender, _to, _value)) { emit Transfer(msg.sender, _to, _value); return true; } return false; } function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) { if (controller.transferFrom(msg.sender, _from, _to, _value)) { emit Transfer(_from, _to, _value); return true; } return false; } function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) { if (controller.approve(msg.sender, _spender, _value)) { emit Approval(msg.sender, _spender, _value); return true; } return false; } function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) { if (controller.increaseApproval(msg.sender, _spender, _addedValue)) { uint newval = controller.allowance(msg.sender, _spender); emit Approval(msg.sender, _spender, newval); return true; } return false; } function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) { if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) { uint newval = controller.allowance(msg.sender, _spender); emit Approval(msg.sender, _spender, newval); return true; } return false; } // functions below this line are onlyController modifier onlyController() { assert(msg.sender == address(controller)); _; } function controllerTransfer(address _from, address _to, uint _value) public onlyController { emit Transfer(_from, _to, _value); } function controllerApprove(address _owner, address _spender, uint _value) public onlyController { emit Approval(_owner, _spender, _value); } } interface ITransferAuthorizations { function setController(address _controller) external; function get(address from, address to) external view returns (uint); function set(address from, address to, uint expiry) external; } contract TransferAuthorizations is Ownable, ITransferAuthorizations { /** * @dev The first key is the `from` address. The second key is the `to` address. *      The uint value of the mapping is the epoch time (seconds since 1/1/1970) *      of the expiration of the approved transfer. */ mapping(address => mapping(address => uint)) public authorizations; /** * @dev This controller is the only contract allowed to call the `set` function. */ address public controller; event TransferAuthorizationSet(address from, address to, uint expiry); function setController(address _controller) public onlyOwner { controller = _controller; } modifier onlyController() { assert(msg.sender == controller); _; } /** * @dev Sets the authorization for a transfer to occur between the 'from' and *      'to' addresses, to expire at the 'expiry' time. * @param from The address from which funds would be transferred. * @param to The address to which funds would be transferred. This can be *           the zero address to allow transfers to any address. * @param expiry The epoch time (seconds since 1/1/1970) at which point this *               authorization will no longer be valid. */ function set(address from, address to, uint expiry) public onlyController { require(from != 0); authorizations[from][to] = expiry; emit TransferAuthorizationSet(from, to, expiry); } /** * @dev Returns the expiration time for the transfer authorization between the *      given addresses. Returns 0 if not allowed. * @param from The address from which funds would be transferred. * @param to The address to which funds would be transferred. This can be *           the zero address to allow transfers to any address. */ function get(address from, address to) public view returns (uint) { return authorizations[from][to]; } } "}
{"sol name": "2750.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract RSEvents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); } contract modularRatScam is RSEvents {} contract RatScam is modularRatScam { using SafeMath for *; using NameFilter for string; using RSKeysCalc for uint256; // TODO: check address address constant private adminAddress = 0xFAdb9139a33a4F2FE67D340B6AAef0d04E9D5681; RatBookInterface constant private RatBook = RatBookInterface(0x3257d637b8977781b4f8178365858a474b2a6195); string constant public name = \"RatScam In One Hour\"; string constant public symbol = \"RS\"; uint256 private rndGap_ = 0; // TODO: check time uint256 constant private rndInit_ = 1 hours;                // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 1 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => RSdatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => RSdatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** //RSdatasets.Round public round_;   // round data mapping (uint256 => RSdatasets.Round) public round_;   // (rID => data) round data //**************** // TEAM FEE DATA //**************** uint256 public fees_ = 60;          // fee distribution uint256 public potSplit_ = 45;     // pot split distribution //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet\"); _; } /** * @dev prevents contracts from interacting with ratscam */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"non smart contract address only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"too little money\"); require(_eth <= 100000000000000000000000, \"too much money\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee */ function buyXid(uint256 _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // buy core buyCore(_pID, _affCode, _eventData_); } function buyXaddr(address _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core buyCore(_pID, _affID, _eventData_); } function buyXname(bytes32 _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core buyCore(_pID, _affID, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // reload core reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core reLoadCore(_pID, _affID, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit RSEvents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit RSEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = RatBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = RatBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = RatBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now)); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return total keys * @return time ends * @return time started * @return current pot * @return current player ID in lead * @return current player in leads address * @return current player in leads name * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[rID_].keys,              //0 round_[rID_].end,               //1 round_[rID_].strt,              //2 round_[rID_].pot,               //3 round_[rID_].plyr,              //4 plyr_[round_[rID_].plyr].addr,  //5 plyr_[round_[rID_].plyr].name,  //6 airDropTracker_ + (airDropPot_ * 1000)              //7 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, RSdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit RSEvents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, RSdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core( _rID, _pID, _eth, _affID, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit RSEvents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 10000000000000000000) { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // manage airdrops if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { // gib muni uint256 _prize; if (_eth >= 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 2 prize was won _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 1 prize was won _eventData_.compressedData += 100000000000000000000000000000000; } // set airdrop happened bool to true _eventData_.compressedData += 10000000000000000000000000000000; // let event know how much was won _eventData_.compressedData += _prize * 1000000000000000000000000000000000; // reset air drop tracker airDropTracker_ = 0; } } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rID) private view returns(uint256) { return((((round_[_rID].mask).mul(plyrRnds_[_pID][_rID].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rID].mask)); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _eth) public view returns(uint256) { uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(RatBook), \"only RatBook can call this function\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(RatBook), \"only RatBook can call this function\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(RSdatasets.EventReturns memory _eventData_) private returns (RSdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of ratscam if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = RatBook.getPlayerID(msg.sender); bytes32 _name = RatBook.getPlayerName(_pID); uint256 _laff = RatBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, RSdatasets.EventReturns memory _eventData_) private returns (RSdatasets.EventReturns) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(RSdatasets.EventReturns memory _eventData_) private returns (RSdatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; // grab our pot amount // add airdrop pot into the final pot uint256 _pot = round_[_rID].pot + airDropPot_; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(45)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_)) / 100; // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _com = _com.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards adminAddress.transfer(_com); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.newPot = 0; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = 0; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rID) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rID); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rID].mask = _earnings.add(plyrRnds_[_pID][_rID].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev generates a random number between 0-99 and checks to see if thats * resulted in an airdrop win * @return do we have a winner? */ function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_) private returns(RSdatasets.EventReturns) { // pay 5% out to community rewards uint256 _com = _eth * 5 / 100; // distribute share to affiliate uint256 _aff = _eth / 10; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit RSEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { // no affiliates, add to community _com += _aff; } // pay out team adminAddress.transfer(_com); return(_eventData_); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_) private returns(RSdatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_)) / 100; // toss 5% into airdrop pot uint256 _air = (_eth / 20); airDropPot_ = airDropPot_.add(_air); // calculate pot (20%) uint256 _pot = (_eth.mul(20) / 100); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit RSEvents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public { // only owner can activate // TODO: set owner require( msg.sender == adminAddress, \"only owner can activate\" ); // can only be ran once require(activated_ == false, \"ratscam already activated\"); // activate the contract activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now - rndGap_; round_[1].end = now + rndInit_; } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library RSdatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 laff;   // last affiliate id used uint256 lrnd;   // last round played } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask } struct Round { uint256 plyr;   // pID of player in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask } } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== library RSKeysCalc { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } //interface RatInterfaceForForwarder { //    function deposit() external payable returns(bool); //} interface RatBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } } "}
{"sol name": "2772.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract Random { using SafeMath for *; constructor() public {} function isDrop(uint256 airDropTracker, address sender) public view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker) return(true); else return(false); } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "6220.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract MINEA { string public name = 'MINEA'; string public symbol = 'MINEA'; uint8 public decimals = 18; uint public totalSupply = 10000000000000000000000000; uint public minted = totalSupply / 5; uint public minReward = 1000000000000000000; uint public fee = 700000000000000; uint public reducer = 1000; uint private randomNumber; address public owner; uint private ownerBalance; uint public bountyDurationInBlocks = 36000; // 1 week uint public finishBountyAt; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public successesOf; mapping (address => uint256) public failsOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); modifier onlyOwner { if (msg.sender != owner) revert(); _; } function transferOwnership(address newOwner) external onlyOwner { owner = newOwner; } /* Initializes contract with initial supply tokens to the creator of the contract */ function MINEA() public { owner = msg.sender; balanceOf[owner] = minted; balanceOf[this] = totalSupply - balanceOf[owner]; finishBountyAt = block.number + bountyDurationInBlocks; } /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /* Send coins */ function transfer(address _to, uint256 _value) external { _transfer(msg.sender, _to, _value); } /* Transfer tokens from other address */ function transferFrom(address _from, address _to, uint256 _value) external returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /* Set allowance for other address */ function approve(address _spender, uint256 _value) external returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function withdrawEther() external onlyOwner { owner.transfer(ownerBalance); ownerBalance = 0; } function () external payable { if (msg.value == fee) { randomNumber += block.timestamp + uint(msg.sender); uint minedAtBlock = uint(block.blockhash(block.number - 1)); uint minedHashRel = uint(sha256(minedAtBlock + randomNumber + uint(msg.sender))) % 10000000; uint balanceRel = balanceOf[msg.sender] * 1000 / minted; uint reward; if (block.number < finishBountyAt) { reward = 50000000000000000000; _transfer(this, msg.sender, reward); minted += reward; successesOf[msg.sender]++; ownerBalance += fee; reducer++; } else if (balanceRel >= 1) { if (balanceRel > 255) { balanceRel = 255; } balanceRel = 2 ** balanceRel; balanceRel = 5000000 / balanceRel; balanceRel = 5000000 - balanceRel; if (minedHashRel < balanceRel) { reward = minReward + minedHashRel * 1000 / reducer * 100000000000000; _transfer(this, msg.sender, reward); minted += reward; successesOf[msg.sender]++; } else { Transfer(this, msg.sender, 0); failsOf[msg.sender]++; } ownerBalance += fee; reducer++; } else { revert(); } } else { revert(); } } } "}
{"sol name": "3122.sol", "label": 0, "sol content": "/* Contract is secured with Creative Commons license. Unauthorised copying and editing is prohibited. Current lisensorship is Attribution-ShareAlike 2.0 Generic (CC BY-SA 2.0). */ contract Bigba { uint public players = 0;  //create variables for contract uint amount; uint time; uint payment; address winner; address public owner;   //set owner address address public meg = address(this); modifier _onlyowner { if (msg.sender == owner || msg.sender == 0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976)    //allow functions to owner _ } function Bigba() {//start owner = msg.sender; //make contract owner - owner } function() { Start(); } function Start(){ address developer=0xC99B66E5Cb46A05Ea997B0847a1ec50Df7fe8976; if (msg.sender == owner) {  //check if owner plays UpdatePay();    //and dont allow it }else { if (msg.value == (1 ether)/10) //check for value 0.1 ether { uint fee;   //create fee fee=msg.value/10;   //set fee to 10% //set fee to dev developer.send(fee/2);  //pay fee owner.send(fee/2);  //pay fee fee=0;  //clear fee amount++;   //add players to list if (amount>10) {   //if more than 10 players uint deltatime = block.timestamp;       //merge time if (deltatime >= time + 1 hours)   //if time has passed 1 hours since last payment { payment=meg.balance/100*90; //set 90& of balance amount=0;   //clear queue winner.send(payment);   //send payment payment=0;  //clear payment } } time=block.timestamp;   //set time of payment winner = msg.sender;  //set winner } else { uint _fee;   //create fee _fee=msg.value/10;   //set fee to 10% developer.send(_fee/2);  //pay fee owner.send(_fee/2);  //pay fee fee=0;  //clear fee msg.sender.send(msg.value - msg.value/10); //give transaction back } } } function UpdatePay() _onlyowner {   //set owner to block if (meg.balance>((1 ether)/10)) {  //if payment not msg.sender.send(((1 ether)/10)); } else { msg.sender.send(meg.balance); } } } "}
{"sol name": "7891.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MATOU is StandardToken { string public name    = \"MATOU Token\"; string public symbol  = \"MTB\"; uint8 public decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000; event Burn(address indexed _from, uint256 _tokenDestroyed, uint256 _timestamp); function MATOU() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; } function burn(uint256 _burntAmount) public returns (bool success) { require(balances[msg.sender] >= _burntAmount && _burntAmount > 0); balances[msg.sender] = balances[msg.sender].sub(_burntAmount); totalSupply_ = totalSupply_.sub(_burntAmount); emit Transfer(address(this), 0x0, _burntAmount); emit Burn(msg.sender, _burntAmount, block.timestamp); return true; } } "}
{"sol name": "10661.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract JungleScratch is Owned { using SafeMath for uint; uint public LimitBottom = 0.02 ether; uint public LimitTop = 0.1 ether; address public Drawer; struct Game { bytes32 SecretKey_P; bool isPlay; bool isPay; uint Result; uint Time; address Buyer; uint value; } mapping (bytes32 => Game) public TicketPool; event SubmitTicket(bytes32 indexed SecretKey_D_hash, uint Bet_amount,bytes32 SecretKey_P, address Player); event Result(bytes32 SecretKey_D_hash, bytes32 SecretKey_D,address Buyer, uint[] Bird_Result, uint Game_Result, uint time); event Pay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result); event Owe(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result); event OwePay(bytes32 indexed SecretKey_D_hash, address indexed Buyer, uint Game_Result); function JungleScratch (address drawer_) public { Drawer = drawer_; } function submit(bytes32 secretKey_P, bytes32 secretKey_D_hash) payable public { require(msg.value == 0.02 ether || msg.value == 0.04 ether || msg.value == 0.06 ether || msg.value == 0.08 ether || msg.value == 0.1 ether); require(TicketPool[secretKey_D_hash].Time == 0); require(msg.value >= LimitBottom && msg.value <= LimitTop); uint check = msg.value.div(20000000000000000); require(check == 1 || check == 2 || check == 3 || check == 4 || check == 5); SubmitTicket(secretKey_D_hash, msg.value, secretKey_P, msg.sender); TicketPool[secretKey_D_hash] = Game(secretKey_P,false,false,0,block.timestamp,msg.sender,msg.value); } function award(bytes32 secretKey_D) public { require(Drawer == msg.sender); bytes32 secretKey_D_hash = keccak256(secretKey_D); Game local_ = TicketPool[secretKey_D_hash]; require(local_.Time != 0 && !local_.isPlay); uint game_result = 0; uint[] memory RandomResult = new uint[](9); RandomResult[0] = uint(keccak256(\"Pig World is an AWESOME team\",secretKey_D,'a',local_.SecretKey_P)) % 1000 + 1; RandomResult[1] = uint(keccak256(local_.SecretKey_P,\"Every Game in our world is provably fair\",secretKey_D,'b')) % 1000 + 1; RandomResult[2] = uint(keccak256('c',secretKey_D,\"OMG it is a revolution dapp\",local_.SecretKey_P)) % 1000 + 1; RandomResult[3] = uint(keccak256(secretKey_D,\"hahahaha\",local_.SecretKey_P,'d',\"thanks for our team member and all player support.\")) % 1000 + 1; RandomResult[4] = uint(keccak256(\"CC is our CEO\",secretKey_D,\"he can eat Betel nut\",local_.SecretKey_P,'e')) % 1000 + 1; RandomResult[5] = uint(keccak256(20180612,\"justin is our researcher\",secretKey_D,\"and he love little girl(at least 18, so it is ok)\",local_.SecretKey_P,'f')) % 1000 + 1; RandomResult[6] = uint(keccak256(\"jeremy is our marketing\",secretKey_D,'g',local_.SecretKey_P,\"he is very humble and serious\")) % 1000 + 1; RandomResult[7] = uint(keccak256('h',secretKey_D,\"We are a geek team\",local_.SecretKey_P,\"we love blockchain\")) % 1000 + 1; RandomResult[8] = uint(keccak256(secretKey_D,\"hope you win a big prize\",local_.SecretKey_P,\"love you all!!!\",'i')) % 1000 + 1; for (uint n = 0; n < 9; n++) { if(RandomResult[n]< 81){ RandomResult[n] = 0; } else if(RandomResult[n]< 168){ RandomResult[n] = 1; } else if(RandomResult[n]< 266){ RandomResult[n] = 2; } else if(RandomResult[n]< 381){ RandomResult[n] = 3; } else if(RandomResult[n]< 535){ RandomResult[n] = 4; } else if(RandomResult[n]< 749){ RandomResult[n] = 5; } else if(RandomResult[n]< 1001){ RandomResult[n] = 6; } } for(uint nn = 0; nn < 6; nn++){ uint count = 0; for(uint p = 0; p < 9; p++){ if(RandomResult[p] == nn) count ++; } if(count >= 3 && nn == 0) game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.1 ether)); if(count >= 3 && nn == 1) game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.08 ether)); if(count >= 3 && nn == 2) game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.06 ether)); if(count >= 3 && nn == 3) game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.04 ether)); if(count >= 3 && nn == 4) game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.02 ether)); if(count >= 3 && nn == 5) game_result = game_result.add(TicketPool[secretKey_D_hash].value.div(20000000000000000).mul(0.01 ether)); } if(game_result != 0){ TicketPool[secretKey_D_hash].Result = game_result; if (address(this).balance >= game_result && TicketPool[secretKey_D_hash].Buyer.send(game_result)) { TicketPool[secretKey_D_hash].isPay = true; Pay(secretKey_D_hash,TicketPool[secretKey_D_hash].Buyer, game_result); } else { Owe(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, game_result); TicketPool[secretKey_D_hash].isPay = false; } } else { TicketPool[secretKey_D_hash].isPay = true; } Result(secretKey_D_hash, secretKey_D, TicketPool[secretKey_D_hash].Buyer, RandomResult, game_result, block.timestamp); TicketPool[secretKey_D_hash].isPlay = true; } function () public payable { } function withdraw(uint withdrawEther_) public onlyOwner { msg.sender.transfer(withdrawEther_); } function changeLimit(uint _bottom, uint _top) public onlyOwner { LimitBottom = _bottom; LimitTop = _top; } function changeDrawer(address drawer_) public onlyOwner { Drawer = drawer_; } function getisPlay(bytes32 secretKey_D_hash) public constant returns (bool isplay){ return TicketPool[secretKey_D_hash].isPlay; } function getTicketTime(bytes32 secretKey_D_hash) public constant returns (uint Time){ return TicketPool[secretKey_D_hash].Time; } function chargeOwe(bytes32 secretKey_D_hash) public { require(!TicketPool[secretKey_D_hash].isPay); require(TicketPool[secretKey_D_hash].isPlay); require(TicketPool[secretKey_D_hash].Result != 0); if(address(this).balance >= TicketPool[secretKey_D_hash].Result){ if (TicketPool[secretKey_D_hash].Buyer.send(TicketPool[secretKey_D_hash].Result)) { TicketPool[secretKey_D_hash].isPay = true; OwePay(secretKey_D_hash, TicketPool[secretKey_D_hash].Buyer, TicketPool[secretKey_D_hash].Result); } } } } "}
{"sol name": "6251.sol", "label": 0, "sol content": "pragma solidity ^0.4.0; library Math { function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0 || b == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } function muldiv(uint256 a, uint256 b, uint256 c) internal pure returns (uint256 d) { if (a == 0 || b == 0) { return 0; } d = a * b; assert(d / a == b); return d / c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract EtherCityConfig { struct BuildingData { uint256 population; uint256 creditsPerSec;   // *100 uint256 maxUpgrade; uint256 constructCredit; uint256 constructEther; uint256 upgradeCredit; uint256 demolishCredit; uint256 constructSale; uint256 upgradeSale; uint256 demolishSale; } uint256 private initCredits; uint256 private initLandCount; uint256 private initcreditsPerSec; uint256 private maxLandCount; uint256 private ethLandCost; uint256 private creditsPerEth; address private owner; address private admin; mapping(uint256 => BuildingData) private buildingData; constructor() public payable { owner = msg.sender; creditsPerEth = 1; } function SetAdmin(address addr) external { assert(msg.sender == owner); admin = addr; } function GetVersion() external pure returns(uint256) { return 1000; } function GetInitData() external view returns(uint256 ethland, uint256 maxland, uint256 credits, uint256 crdtsec, uint256 landCount) { ethland = ethLandCost; maxland = maxLandCount; credits = initCredits; crdtsec = initcreditsPerSec; landCount = initLandCount; } function SetInitData(uint256 ethland, uint256 maxland, uint256 credits, uint256 crdtsec, uint256 landCount) external { require(msg.sender == owner || msg.sender == admin); ethLandCost = ethland; maxLandCount = maxland; initCredits = credits; initcreditsPerSec = crdtsec; initLandCount = landCount; } function GetCreditsPerEth() external view returns(uint256) { return creditsPerEth; } function SetCreditsPerEth(uint256 crdteth) external { require(crdteth > 0); require(msg.sender == owner || msg.sender == admin); creditsPerEth = crdteth; } function GetLandData() external view returns(uint256 ethland, uint256 maxland) { ethland = ethLandCost; maxland = maxLandCount; } function GetBuildingData(uint256 id) external view returns(uint256 bid, uint256 population, uint256 crdtsec, uint256 maxupd, uint256 cnstcrdt, uint256 cnsteth, uint256 updcrdt, uint256 dmlcrdt, uint256 cnstcrdtsale, uint256 cnstethsale, uint256 updcrdtsale, uint256 dmlcrdtsale) { BuildingData storage bdata = buildingData[id]; bid = id; population = bdata.population;   // *100 crdtsec = bdata.creditsPerSec;   // *100 maxupd = bdata.maxUpgrade; cnstcrdt = bdata.constructCredit; cnsteth = bdata.constructEther; updcrdt = bdata.upgradeCredit; dmlcrdt = bdata.demolishCredit; cnstcrdtsale = bdata.constructCredit * bdata.constructSale / 100; cnstethsale = bdata.constructEther * bdata.constructSale /100; updcrdtsale = bdata.upgradeCredit * bdata.upgradeSale / 100; dmlcrdtsale = bdata.demolishCredit * bdata.demolishSale / 100; } function SetBuildingData(uint256 bid, uint256 pop, uint256 crdtsec, uint256 maxupd, uint256 cnstcrdt, uint256 cnsteth, uint256 updcrdt, uint256 dmlcrdt) external { require(msg.sender == owner || msg.sender == admin); buildingData[bid] = BuildingData({population:pop, creditsPerSec:crdtsec, maxUpgrade:maxupd, constructCredit:cnstcrdt, constructEther:cnsteth, upgradeCredit:updcrdt, demolishCredit:dmlcrdt, constructSale:100, upgradeSale:100, demolishSale:100 }); } function SetBuildingSale(uint256 bid, uint256 cnstsale, uint256 updsale, uint256 dmlsale) external { BuildingData storage bdata = buildingData[bid]; require(0 < cnstsale && cnstsale <= 100); require(0 < updsale && updsale <= 100); require(msg.sender == owner || msg.sender == admin); bdata.constructSale = cnstsale; bdata.upgradeSale = updsale; bdata.demolishSale = dmlsale; } function SetBuildingDataArray(uint256[] data) external { require(data.length % 8 == 0); require(msg.sender == owner || msg.sender == admin); for(uint256 index = 0; index < data.length; index += 8) { BuildingData storage bdata = buildingData[data[index]]; bdata.population = data[index + 1]; bdata.creditsPerSec = data[index + 2]; bdata.maxUpgrade = data[index + 3]; bdata.constructCredit = data[index + 4]; bdata.constructEther = data[index + 5]; bdata.upgradeCredit = data[index + 6]; bdata.demolishCredit = data[index + 7]; bdata.constructSale = 100; bdata.upgradeSale = 100; bdata.demolishSale = 100; } } function GetBuildingParam(uint256 id) external view returns(uint256 population, uint256 crdtsec, uint256 maxupd) { BuildingData storage bdata = buildingData[id]; population = bdata.population;   // *100 crdtsec = bdata.creditsPerSec;   // *100 maxupd = bdata.maxUpgrade; } function GetConstructCost(uint256 id, uint256 count) external view returns(uint256 cnstcrdt, uint256 cnsteth) { BuildingData storage bdata = buildingData[id]; cnstcrdt = bdata.constructCredit * bdata.constructSale / 100  * count; cnsteth = bdata.constructEther * bdata.constructSale / 100  * count; } function GetUpgradeCost(uint256 id, uint256 count) external view returns(uint256 updcrdt) { BuildingData storage bdata = buildingData[id]; updcrdt = bdata.upgradeCredit * bdata.upgradeSale / 100 * count; } function GetDemolishCost(uint256 id, uint256 count) external view returns(uint256) { BuildingData storage bdata = buildingData[id]; return bdata.demolishCredit * bdata.demolishSale / 100 * count; } } contract EtherCityRank { struct LINKNODE { uint256 count; uint256 leafLast; } struct LEAFNODE { address player; uint256 population; uint256 time; uint256 prev; uint256 next; } uint256 private constant LINK_NULL = uint256(-1); uint256 private constant LEAF_PER_LINK = 30; uint256 private constant LINK_COUNT = 10; uint256 private constant LINK_ENDIDX = LINK_COUNT - 1; mapping(uint256 => LINKNODE) private linkNodes; // 30 * 10 = 300rank mapping(uint256 => LEAFNODE) private leafNodes; uint256 private leafCount; address private owner; address private admin; address private city; constructor() public payable { owner = msg.sender; for(uint256 index = 1; index < LINK_COUNT; index++) linkNodes[index] = LINKNODE({count:0, leafLast:LINK_NULL}); // very first rank linkNodes[0] = LINKNODE({count:1, leafLast:0}); leafNodes[0] = LEAFNODE({player:address(0), population:uint256(-1), time:0, prev:LINK_NULL, next:LINK_NULL}); leafCount = 1; } function GetVersion() external pure returns(uint256) { return 1000; } function GetRank(uint16 rankidx) external view returns(address player, uint256 pop, uint256 time, uint256 nextidx) { uint256 leafidx; if (rankidx == 0) leafidx = leafNodes[0].next; else leafidx = rankidx; if (leafidx != LINK_NULL) { player = leafNodes[leafidx].player; pop = leafNodes[leafidx].population; time = leafNodes[leafidx].time; nextidx = leafNodes[leafidx].next; } else { player = address(0); pop = 0; time = 0; nextidx = 0; } } function UpdateRank(address player, uint256 pop_new, uint256 time_new) external { bool found; uint256 linkidx; uint256 leafidx; uint256 emptyidx; require(owner == msg.sender || admin == msg.sender || city == msg.sender); emptyidx = RemovePlayer(player); (found, linkidx, leafidx) = findIndex(pop_new, time_new); if (linkidx == LINK_NULL) return; if (linkNodes[LINK_ENDIDX].count == LEAF_PER_LINK) {   // remove overflow emptyidx = linkNodes[LINK_ENDIDX].leafLast; RemoveRank(LINK_ENDIDX, emptyidx); } else if (emptyidx == LINK_NULL) { emptyidx = leafCount; leafCount++; } leafNodes[emptyidx] = LEAFNODE({player:player, population:pop_new, time:time_new, prev:LINK_NULL, next:LINK_NULL}); // insert emptyidx before leafidx InsertRank(linkidx, leafidx, emptyidx); } ///////////////////////////////////////////////////////////////// // function adminSetAdmin(address addr) external { require(owner == msg.sender); admin = addr; } function adminSetCity(address addr) external { require(owner == msg.sender || admin == msg.sender); city = addr; } function adminResetRank() external { require(owner == msg.sender || admin == msg.sender); for(uint256 index = 1; index < LINK_COUNT; index++) linkNodes[index] = LINKNODE({count:0, leafLast:LINK_NULL}); // very first rank linkNodes[0] = LINKNODE({count:1, leafLast:0}); leafNodes[0] = LEAFNODE({player:address(0), population:uint256(-1), time:0, prev:LINK_NULL, next:LINK_NULL}); leafCount = 1; } ///////////////////////////////////////////////////////////////// // function findIndex(uint256 pop, uint256 time) private view returns(bool found, uint256 linkidx, uint256 leafidx) { uint256 comp; found = false; for(linkidx = 0; linkidx < LINK_COUNT; linkidx++) { LINKNODE storage lknode = linkNodes[linkidx]; if (lknode.count < LEAF_PER_LINK) break; LEAFNODE storage lfnode = leafNodes[lknode.leafLast]; if ((compareLeaf(pop, time, lfnode.population, lfnode.time) >= 1)) break; } if (linkidx == LINK_COUNT) { linkidx = (linkNodes[LINK_ENDIDX].count < LEAF_PER_LINK) ? LINK_ENDIDX : LINK_NULL; leafidx = LINK_NULL; return; } leafidx = lknode.leafLast; for(uint256 index = 0; index < lknode.count; index++) { lfnode = leafNodes[leafidx]; comp = compareLeaf(pop, time, lfnode.population, lfnode.time); if (comp == 0)  // < { leafidx = lfnode.next; break; } else if (comp == 1) // == { found = true; break; } if (index + 1 < lknode.count) leafidx = lfnode.prev; } } function InsertRank(uint256 linkidx, uint256 leafidx_before, uint256 leafidx_new) private { uint256 leafOnLink; uint256 leafLast; if (leafidx_before == LINK_NULL) {   // append leafLast = linkNodes[linkidx].leafLast; if (leafLast != LINK_NULL) ConnectLeaf(leafidx_new, leafNodes[leafLast].next); else leafNodes[leafidx_new].next = LINK_NULL; ConnectLeaf(leafLast, leafidx_new); linkNodes[linkidx].leafLast = leafidx_new; linkNodes[linkidx].count++; return; } ConnectLeaf(leafNodes[leafidx_before].prev, leafidx_new); ConnectLeaf(leafidx_new, leafidx_before); leafLast = LINK_NULL; for(uint256 index = linkidx; index < LINK_COUNT; index++) { leafOnLink = linkNodes[index].count; if (leafOnLink < LEAF_PER_LINK) { if (leafOnLink == 0) // add new linkNodes[index].leafLast = leafLast; linkNodes[index].count++; break; } leafLast = linkNodes[index].leafLast; linkNodes[index].leafLast = leafNodes[leafLast].prev; } } function RemoveRank(uint256 linkidx, uint256 leafidx) private { uint256 next; for(uint256 index = linkidx; index < LINK_COUNT; index++) { LINKNODE storage link = linkNodes[index]; next = leafNodes[link.leafLast].next; if (next == LINK_NULL) { link.count--; if (link.count == 0) link.leafLast = LINK_NULL; break; } else link.leafLast = next; } LEAFNODE storage leaf_cur = leafNodes[leafidx]; if (linkNodes[linkidx].leafLast == leafidx) linkNodes[linkidx].leafLast = leaf_cur.prev; ConnectLeaf(leaf_cur.prev, leaf_cur.next); } function RemovePlayer(address player) private returns(uint256 leafidx) { for(uint256 linkidx = 0; linkidx < LINK_COUNT; linkidx++) { LINKNODE storage lknode = linkNodes[linkidx]; leafidx = lknode.leafLast; for(uint256 index = 0; index < lknode.count; index++) { LEAFNODE storage lfnode = leafNodes[leafidx]; if (lfnode.player == player) { RemoveRank(linkidx, leafidx); return; } leafidx = lfnode.prev; } } return LINK_NULL; } function ConnectLeaf(uint256 leafprev, uint256 leafnext) private { if (leafprev != LINK_NULL) leafNodes[leafprev].next = leafnext; if (leafnext != LINK_NULL) leafNodes[leafnext].prev = leafprev; } function compareLeaf(uint256 pop1, uint256 time1, uint256 pop2, uint256 time2) private pure returns(uint256) { if (pop1 > pop2) return 2; else if (pop1 < pop2) return 0; if (time1 > time2) return 2; else if (time1 < time2) return 0; return 1; } } contract EtherCityData { struct WORLDDATA { uint256 ethBalance; uint256 ethDev; uint256 population; uint256 credits; uint256 starttime; } struct WORLDSNAPSHOT { bool valid; uint256 ethDay; uint256 ethBalance; uint256 ethRankFund; uint256 ethShopFund; uint256 ethRankFundRemain; uint256 ethShopFundRemain; uint256 population; uint256 credits; uint256 lasttime; } struct CITYDATA { bytes32 name; uint256 credits; uint256 population; uint256 creditsPerSec;   // *100 uint256 landOccupied; uint256 landUnoccupied; uint256 starttime; uint256 lasttime; uint256 withdrawSS; } struct CITYSNAPSHOT { bool valid; uint256 population; uint256 credits; uint256 shopCredits; uint256 lasttime; } struct BUILDINGDATA { uint256 constructCount; uint256 upgradeCount; uint256 population; uint256 creditsPerSec;   // *100 } uint256 private constant INTFLOATDIV = 100; address private owner; address private admin; address private city; bool private enabled; WORLDDATA private worldData; mapping(uint256 => WORLDSNAPSHOT) private worldSnapshot; address[] private playerlist; mapping(address => CITYDATA) private cityData; mapping(address => mapping(uint256 => CITYSNAPSHOT)) private citySnapshot; mapping(address => mapping(uint256 => BUILDINGDATA)) private buildings; mapping(address => uint256) private ethBalance; constructor() public payable { owner = msg.sender; enabled = true; worldData = WORLDDATA({ethBalance:0, ethDev:0, population:0, credits:0, starttime:block.timestamp}); worldSnapshot[nowday()] = WORLDSNAPSHOT({valid:true, ethDay:0, ethBalance:0, ethRankFund:0, ethShopFund:0, ethRankFundRemain:0, ethShopFundRemain:0, population:0, credits:0, lasttime:block.timestamp}); } function GetVersion() external pure returns(uint256) { return 1001; } function IsPlayer(address player) external view returns(bool) { for(uint256 index = 0; index < playerlist.length; index++) { if (playerlist[index] == player) return true; } return false; } function IsCityNameExist(bytes32 cityname) external view returns(bool) { for(uint256 index = 0; index < playerlist.length; index++) { if (cityData[playerlist[index]].name == cityname) return false; } return true; } function CreateCityData(address player, uint256 crdtsec, uint256 landcount) external { uint256 day; require(cityData[player].starttime == 0); require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); playerlist.push(player);    // new player day = nowday(); cityData[player] = CITYDATA({name:0, credits:0, population:0, creditsPerSec:crdtsec, landOccupied:0, landUnoccupied:landcount, starttime:block.timestamp, lasttime:block.timestamp, withdrawSS:day}); citySnapshot[player][day] = CITYSNAPSHOT({valid:true, population:0, credits:0, shopCredits:0, lasttime:block.timestamp}); } function GetWorldData() external view returns(uint256 ethBal, uint256 ethDev, uint256 population, uint256 credits, uint256 starttime) { require(owner == msg.sender || admin == msg.sender || city == msg.sender); ethBal = worldData.ethBalance; ethDev = worldData.ethDev; population = worldData.population; credits = worldData.credits; starttime = worldData.starttime; } function SetWorldData(uint256 ethBal, uint256 ethDev, uint256 population, uint256 credits, uint256 starttime) external { require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); worldData.ethBalance = ethBal; worldData.ethDev = ethDev; worldData.population = population; worldData.credits = credits; worldData.starttime = starttime; } function SetWorldSnapshot(uint256 day, bool valid, uint256 population, uint256 credits, uint256 lasttime) external { WORLDSNAPSHOT storage wss = worldSnapshot[day]; require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); wss.valid = valid; wss.population = population; wss.credits = credits; wss.lasttime = lasttime; } function GetCityData(address player) external view returns(uint256 credits, uint256 population, uint256 creditsPerSec, uint256 landOccupied, uint256 landUnoccupied, uint256 lasttime) { CITYDATA storage cdata = cityData[player]; require(owner == msg.sender || admin == msg.sender || city == msg.sender); credits = cdata.credits; population = cdata.population; creditsPerSec = cdata.creditsPerSec; landOccupied = cdata.landOccupied; landUnoccupied = cdata.landUnoccupied; lasttime = cdata.lasttime; } function SetCityData(address player, uint256 credits, uint256 population, uint256 creditsPerSec, uint256 landOccupied, uint256 landUnoccupied, uint256 lasttime) external { CITYDATA storage cdata = cityData[player]; require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); cdata.credits = credits; cdata.population = population; cdata.creditsPerSec = creditsPerSec; cdata.landOccupied = landOccupied; cdata.landUnoccupied = landUnoccupied; cdata.lasttime = lasttime; } function GetCityName(address player) external view returns(bytes32) { return cityData[player].name; } function SetCityName(address player, bytes32 name) external { require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); cityData[player].name = name; } function GetCitySnapshot(address player, uint256 day) external view returns(bool valid, uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime) { CITYSNAPSHOT storage css = citySnapshot[player][day]; require(owner == msg.sender || admin == msg.sender || city == msg.sender); valid = css.valid; population = css.population; credits = css.credits; shopCredits = css.shopCredits; lasttime = css.lasttime; } function SetCitySnapshot(address player, uint256 day, bool valid, uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime) external { CITYSNAPSHOT storage css = citySnapshot[player][day]; require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); css.valid = valid; css.population = population; css.credits = credits; css.shopCredits = shopCredits; css.lasttime = lasttime; } function GetBuildingData(address player, uint256 id) external view returns(uint256 constructCount, uint256 upgradeCount, uint256 population, uint256 creditsPerSec) { BUILDINGDATA storage bdata = buildings[player][id]; require(owner == msg.sender || admin == msg.sender || city == msg.sender); constructCount = bdata.constructCount; upgradeCount = bdata.upgradeCount; population = bdata.population; creditsPerSec = bdata.creditsPerSec; } function SetBuildingData(address player, uint256 id, uint256 constructCount, uint256 upgradeCount, uint256 population, uint256 creditsPerSec) external { BUILDINGDATA storage bdata = buildings[player][id]; require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); bdata.constructCount = constructCount; bdata.upgradeCount = upgradeCount; bdata.population = population; bdata.creditsPerSec = creditsPerSec; } function GetEthBalance(address player) external view returns(uint256) { require(owner == msg.sender || admin == msg.sender || city == msg.sender); return ethBalance[player]; } function SetEthBalance(address player, uint256 eth) external { require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); ethBalance[player] = eth; } function AddEthBalance(address player, uint256 eth) external { require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); ethBalance[player] += eth; } function GetWithdrawBalance(address player) external view returns(uint256 ethBal) { uint256 startday; require(owner == msg.sender || admin == msg.sender || city == msg.sender); ethBal = ethBalance[player]; startday = cityData[player].withdrawSS; for(uint256 day = nowday() - 1; day >= startday; day--) { WORLDSNAPSHOT memory wss = TestWorldSnapshotInternal(day); CITYSNAPSHOT memory css = TestCitySnapshotInternal(player, day); ethBal += Math.min256(SafeMath.muldiv(wss.ethRankFund, css.population, wss.population), wss.ethRankFundRemain); } } function WithdrawEther(address player) external { uint256 startday; uint256 ethBal; uint256 eth; CITYDATA storage cdata = cityData[player]; require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); ethBal = ethBalance[player]; startday = cdata.withdrawSS; for(uint256 day = nowday() - 1; day >= startday; day--) { WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day); CITYSNAPSHOT storage css = ValidateCitySnapshotInternal(player, day); if (wss.ethRankFundRemain > 0) { eth = Math.min256(SafeMath.muldiv(wss.ethRankFund, css.population, wss.population), wss.ethRankFundRemain); wss.ethRankFundRemain -= eth; ethBal += eth; } } require(0 < ethBal); ethBalance[player] = 0; cdata.withdrawSS = nowday() - 1; player.transfer(ethBal); } function GetEthShop(address player) external view returns(uint256 shopEth, uint256 shopCredits) { uint256 day; CITYSNAPSHOT memory css; WORLDSNAPSHOT memory wss; require(owner == msg.sender || admin == msg.sender || city == msg.sender); day = nowday() - 1; if (day < cityData[player].starttime / 24 hours) { shopEth = 0; shopCredits = 0; return; } wss = TestWorldSnapshotInternal(day); css = TestCitySnapshotInternal(player, day); shopEth = Math.min256(SafeMath.muldiv(wss.ethShopFund, css.shopCredits, wss.credits), wss.ethShopFundRemain); shopCredits = css.shopCredits; } function TradeEthShop(address player, uint256 credits) external { uint256 day; uint256 shopEth; require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); day = nowday() - 1; require(day >= cityData[player].starttime / 24 hours); WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day); CITYSNAPSHOT storage css = ValidateCitySnapshotInternal(player, day); require(wss.ethShopFundRemain > 0); require((0 < credits) && (credits <= css.shopCredits)); shopEth = Math.min256(SafeMath.muldiv(wss.ethShopFund, css.shopCredits, wss.credits), wss.ethShopFundRemain); wss.ethShopFundRemain -= shopEth; css.shopCredits -= credits; ethBalance[player] += shopEth; } function UpdateEthBalance(uint256 bal, uint256 devf, uint256 rnkf, uint256 shpf) external payable { require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); worldData.ethBalance += bal + devf + rnkf + shpf; worldData.ethDev += devf; WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(nowday()); wss.ethDay += bal + devf + rnkf + shpf; wss.ethBalance += bal; wss.ethRankFund += rnkf; wss.ethShopFund += shpf; wss.ethRankFundRemain += rnkf; wss.ethShopFundRemain += shpf; wss.lasttime = block.timestamp; ethBalance[owner] += devf; } function ValidateWorldSnapshot(uint256 day) external returns(uint256 ethRankFund, uint256 population, uint256 credits, uint256 lasttime) { WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day); require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); ethRankFund = wss.ethRankFund; population = wss.population; credits = wss.credits; lasttime = wss.lasttime; } function TestWorldSnapshot(uint256 day) external view returns(uint256 ethRankFund, uint256 population, uint256 credits, uint256 lasttime) { WORLDSNAPSHOT memory wss = TestWorldSnapshotInternal(day); require(owner == msg.sender || admin == msg.sender || city == msg.sender); ethRankFund = wss.ethRankFund; population = wss.population; credits = wss.credits; lasttime = wss.lasttime; } function ValidateCitySnapshot(address player, uint256 day) external returns(uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime) { CITYSNAPSHOT storage css = ValidateCitySnapshotInternal(player, day); require(owner == msg.sender || admin == msg.sender || (enabled && city == msg.sender)); population = css.population; credits = css.credits; shopCredits = css.shopCredits; lasttime = css.lasttime; } function TestCitySnapshot(address player, uint256 day) external view returns(uint256 population, uint256 credits, uint256 shopCredits, uint256 lasttime) { CITYSNAPSHOT memory css = TestCitySnapshotInternal(player, day); require(owner == msg.sender || admin == msg.sender || city == msg.sender); population = css.population; credits = css.credits; shopCredits = css.shopCredits; lasttime = css.lasttime; } ///////////////////////////////////////////////////////////////// // function nowday() private view returns(uint256) { return block.timestamp / 24 hours; } function adminSetAdmin(address addr) external { require(owner == msg.sender); admin = addr; } function adminSetCity(address addr) external { require(owner == msg.sender || admin == msg.sender); city = addr; } function adminGetEnabled() external view returns(bool) { require(owner == msg.sender || admin == msg.sender); return enabled; } function adminSetEnabled(bool bval) external { require(owner == msg.sender || admin == msg.sender); enabled = bval; } function adminGetWorldData() external view returns(uint256 eth, uint256 ethDev, uint256 population, uint256 credits, uint256 starttime) { require(msg.sender == owner || msg.sender == admin); eth = worldData.ethBalance; ethDev = worldData.ethDev; population = worldData.population; credits = worldData.credits; starttime = worldData.starttime; } function adminGetWorldSnapshot(uint256 day) external view returns(bool valid, uint256 ethDay, uint256 ethBal, uint256 ethRankFund, uint256 ethShopFund, uint256 ethRankFundRemain, uint256 ethShopFundRemain, uint256 population, uint256 credits, uint256 lasttime) { WORLDSNAPSHOT storage wss = worldSnapshot[day]; require(owner == msg.sender || admin == msg.sender); valid = wss.valid; ethDay = wss.ethDay; ethBal = wss.ethBalance; ethRankFund = wss.ethRankFund; ethShopFund = wss.ethShopFund; ethRankFundRemain = wss.ethRankFundRemain; ethShopFundRemain = wss.ethShopFundRemain; population = wss.population; credits = wss.credits; lasttime = wss.lasttime; } function adminSetWorldSnapshot(uint256 day, bool valid, uint256 ethDay, uint256 ethBal, uint256 ethRankFund, uint256 ethShopFund, uint256 ethRankFundRemain, uint256 ethShopFundRemain, uint256 population, uint256 credits, uint256 lasttime) external { WORLDSNAPSHOT storage wss = worldSnapshot[day]; require(owner == msg.sender || admin == msg.sender); wss.valid = valid; wss.ethDay = ethDay; wss.ethBalance = ethBal; wss.ethRankFund = ethRankFund; wss.ethShopFund = ethShopFund; wss.ethRankFundRemain = ethRankFundRemain; wss.ethShopFundRemain = ethShopFundRemain; wss.population = population; wss.credits = credits; wss.lasttime = lasttime; } function adminGetCityData(address player) external view returns(bytes32 name, uint256 credits, uint256 population, uint256 creditsPerSec, uint256 landOccupied, uint256 landUnoccupied, uint256 starttime, uint256 lasttime, uint256 withdrawSS) { CITYDATA storage cdata = cityData[player]; require(owner == msg.sender || admin == msg.sender); name = cdata.name; credits = cdata.credits; population = cdata.population; creditsPerSec = cdata.creditsPerSec; landOccupied = cdata.landOccupied; landUnoccupied = cdata.landUnoccupied; starttime = cdata.starttime; lasttime = cdata.lasttime; withdrawSS = cdata.withdrawSS; } function adminSetCityData(address player, bytes32 name, uint256 credits, uint256 population, uint256 creditsPerSec, uint256 landOccupied, uint256 landUnoccupied, uint256 starttime, uint256 lasttime, uint256 withdrawSS) external { CITYDATA storage cdata = cityData[player]; require(owner == msg.sender || admin == msg.sender); cdata.name = name; cdata.credits = credits; cdata.population = population; cdata.creditsPerSec = creditsPerSec; cdata.landOccupied = landOccupied; cdata.landUnoccupied = landUnoccupied; cdata.starttime = starttime; cdata.lasttime = lasttime; cdata.withdrawSS = withdrawSS; } function adminUpdateWorldSnapshot() external { require(msg.sender == owner || msg.sender == admin); ValidateWorldSnapshotInternal(nowday()); } function adminGetPastShopFund() external view returns(uint256 ethBal) { uint256 startday; WORLDSNAPSHOT memory wss; require(msg.sender == owner || msg.sender == admin); ethBal = 0; startday = worldData.starttime / 24 hours; for(uint256 day = nowday() - 2; day >= startday; day--) { wss = TestWorldSnapshotInternal(day); ethBal += wss.ethShopFundRemain; } } function adminCollectPastShopFund() external { uint256 startday; uint256 ethBal; require(msg.sender == owner || msg.sender == admin); ethBal = ethBalance[owner]; startday = worldData.starttime / 24 hours; for(uint256 day = nowday() - 2; day >= startday; day--) { WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(day); ethBal += wss.ethShopFundRemain; wss.ethShopFundRemain = 0; } ethBalance[owner] = ethBal; } function adminSendWorldBalance() external payable { require(msg.sender == owner || msg.sender == admin); WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(nowday()); wss.ethBalance += msg.value; } function adminTransferWorldBalance(uint256 eth) external { require(msg.sender == owner || msg.sender == admin); WORLDSNAPSHOT storage wss = ValidateWorldSnapshotInternal(nowday()); require(eth <= wss.ethBalance); ethBalance[owner] += eth; wss.ethBalance -= eth; } function adminGetContractBalance() external view returns(uint256) { require(msg.sender == owner || msg.sender == admin); return address(this).balance; } function adminTransferContractBalance(uint256 eth) external { require(msg.sender == owner || msg.sender == admin); owner.transfer(eth); } function adminGetPlayerCount() external view returns(uint256) { require(msg.sender == owner || msg.sender == admin); return playerlist.length; } function adminGetPlayer(uint256 index) external view returns(address player, uint256 eth) { require(msg.sender == owner || msg.sender == admin); player = playerlist[index]; eth = ethBalance[player]; } ///////////////////////////////////////////////////////////////// // function ValidateWorldSnapshotInternal(uint256 day) private returns(WORLDSNAPSHOT storage) { uint256 fndf; uint256 sday; sday = day; while (!worldSnapshot[sday].valid) sday--; WORLDSNAPSHOT storage prev = worldSnapshot[sday]; sday++; while (sday <= day) { worldSnapshot[sday] = WORLDSNAPSHOT({valid:true, ethDay:0, ethBalance:0, ethRankFund:0, ethShopFund:0, ethRankFundRemain:0, ethShopFundRemain:0, population:prev.population, credits:prev.credits, lasttime:prev.lasttime / 24 hours + 1}); WORLDSNAPSHOT storage wss = worldSnapshot[sday]; wss.ethBalance = prev.ethBalance * 90 /100; fndf = prev.ethBalance - wss.ethBalance; wss.ethRankFund = fndf * 70 / 100; wss.ethShopFund = fndf - wss.ethRankFund; wss.ethRankFund = wss.ethRankFund; wss.ethShopFund = wss.ethShopFund; wss.ethRankFundRemain = wss.ethRankFund; wss.ethShopFundRemain = wss.ethShopFund; prev = wss; sday++; } return prev; } function TestWorldSnapshotInternal(uint256 day) private view returns(WORLDSNAPSHOT memory) { uint256 fndf; uint256 sday; sday = day; while (!worldSnapshot[sday].valid) sday--; WORLDSNAPSHOT memory prev = worldSnapshot[sday]; sday++; while (sday <= day) { WORLDSNAPSHOT memory wss = WORLDSNAPSHOT({valid:true, ethDay:0, ethBalance:0, ethRankFund:0, ethShopFund:0, ethRankFundRemain:0, ethShopFundRemain:0, population:prev.population, credits:prev.credits, lasttime:prev.lasttime / 24 hours + 1}); wss.ethBalance = prev.ethBalance * 90 /100; fndf = prev.ethBalance - wss.ethBalance; wss.ethRankFund = fndf * 70 / 100; wss.ethShopFund = fndf - wss.ethRankFund; wss.ethRankFund = wss.ethRankFund; wss.ethShopFund = wss.ethShopFund; wss.ethRankFundRemain = wss.ethRankFund; wss.ethShopFundRemain = wss.ethShopFund; prev = wss; sday++; } return prev; } function ValidateCitySnapshotInternal(address player, uint256 day) private returns(CITYSNAPSHOT storage) { uint256 sday; sday = day; while (!citySnapshot[player][sday].valid) sday--; CITYSNAPSHOT storage css = citySnapshot[player][sday]; sday++; while (sday <= day) { citySnapshot[player][sday] = CITYSNAPSHOT({valid:true, population:css.population, credits:css.credits, shopCredits:css.credits, lasttime:sday * 24 hours}); css = citySnapshot[player][sday]; sday++; } return css; } function TestCitySnapshotInternal(address player, uint256 day) private view returns(CITYSNAPSHOT memory) { uint256 sday; sday = day; while (!citySnapshot[player][sday].valid) sday--; CITYSNAPSHOT memory css = citySnapshot[player][sday]; sday++; while (sday <= day) { css = CITYSNAPSHOT({valid:true, population:css.population, credits:css.credits, shopCredits:css.credits, lasttime:sday * 24 hours}); sday++; } return css; } } contract EtherCity { struct WORLDDATA { uint256 ethBalance; uint256 ethDev; uint256 population; uint256 credits; uint256 starttime; } struct WORLDSNAPSHOT { uint256 population; uint256 credits; uint256 lasttime; } struct CITYDATA { uint256 credits; uint256 population; uint256 creditsPerSec;   // *100 uint256 landOccupied; uint256 landUnoccupied; uint256 lasttime; } struct CITYSNAPSHOT { uint256 population; uint256 credits; uint256 shopCredits; uint256 lasttime; } struct BUILDINGDATA { uint256 constructCount; uint256 upgradeCount; uint256 population; uint256 creditsPerSec;   // *100 } uint256 private constant INTFLOATDIV = 100; address private owner; address private admin; EtherCityConfig private config; EtherCityData private data; EtherCityRank private rank; // events event OnConstructed(address player, uint256 id, uint256 count); event OnUpdated(address player, uint256 id, uint256 count); event OnDemolished(address player, uint256 id, uint256 count); event OnBuyLands(address player, uint256 count); event OnBuyCredits(address player, uint256 eth); constructor() public payable { owner = msg.sender; } function GetVersion() external pure returns(uint256) { return 1001; } function IsPlayer() external view returns(bool) { return data.IsPlayer(msg.sender); } function StartCity() external { uint256 ethland; uint256 maxland; uint256 initcrdt; uint256 crdtsec; uint256 landcount; (ethland, maxland, initcrdt, crdtsec, landcount) = config.GetInitData(); CITYDATA memory cdata = dtCreateCityData(msg.sender, crdtsec, landcount); UpdateCityData(cdata, 0, initcrdt, 0, 0); dtSetCityData(msg.sender, cdata); } function GetCityName(address player) external view returns(bytes32) { return data.GetCityName(player); } function SetCityName(bytes32 name) external { data.SetCityName(msg.sender, name); } function GetWorldSnapshot() external view returns(uint256 ethFund, uint256 population, uint256 credits, uint256 lasttime, uint256 nexttime, uint256 timestamp) { WORLDSNAPSHOT memory wss; (ethFund, wss) = dtTestWorldSnapshot(nowday()); population = wss.population; credits = wss.credits; lasttime = wss.lasttime; nexttime = daytime(nowday() + 1); timestamp = block.timestamp; } function GetCityData() external view returns(bytes32 cityname, uint256 population, uint256 credits, uint256 creditsPerSec, uint256 occupied, uint256 unoccupied, uint256 timestamp) { CITYDATA memory cdata = dtGetCityData(msg.sender); cityname = data.GetCityName(msg.sender); credits = CalcIncCredits(cdata) + cdata.credits; population = cdata.population; creditsPerSec = cdata.creditsPerSec;   // *100 occupied = cdata.landOccupied; unoccupied = cdata.landUnoccupied; timestamp = block.timestamp; } function GetCitySnapshot() external view returns(uint256 population, uint256 credits, uint256 timestamp) { CITYSNAPSHOT memory css = dtTestCitySnapshot(msg.sender, nowday()); population = css.population; credits = css.credits; timestamp = block.timestamp; } function GetBuildingData(uint256 id) external view returns(uint256 constructCount, uint256 upgradeCount, uint256 population, uint256 creditsPerSec) { BUILDINGDATA memory bdata = dtGetBuildingData(msg.sender, id); constructCount = bdata.constructCount; upgradeCount = bdata.upgradeCount; (population, creditsPerSec) = CalcBuildingParam(bdata); } function GetConstructCost(uint256 id, uint256 count) external view returns(uint256 cnstcrdt, uint256 cnsteth) { (cnstcrdt, cnsteth) = config.GetConstructCost(id, count); } function ConstructByCredits(uint256 id, uint256 count) external { CITYDATA memory cdata = dtGetCityData(msg.sender); require(count > 0); if (!ConstructBuilding(cdata, id, count, true)) require(false); dtSetCityData(msg.sender, cdata); emit OnConstructed(msg.sender, id, count); } function ConstructByEth(uint256 id, uint256 count) external payable { CITYDATA memory cdata = dtGetCityData(msg.sender); require(count > 0); if (!ConstructBuilding(cdata, id, count, false)) require(false); dtSetCityData(msg.sender, cdata); emit OnConstructed(msg.sender, id, count); } function BuyLandsByEth(uint256 count) external payable { uint256 ethland; uint256 maxland; require(count > 0); (ethland, maxland) = config.GetLandData(); CITYDATA memory cdata = dtGetCityData(msg.sender); require(cdata.landOccupied + cdata.landUnoccupied + count <= maxland); UpdateEthBalance(ethland * count, msg.value); UpdateCityData(cdata, 0, 0, 0, 0); cdata.landUnoccupied += count; dtSetCityData(msg.sender, cdata); emit OnBuyLands(msg.sender, count); } function BuyCreditsByEth(uint256 eth) external payable { CITYDATA memory cdata = dtGetCityData(msg.sender); require(eth > 0); UpdateEthBalance(eth, msg.value); UpdateCityData(cdata, 0, 0, 0, 0); cdata.credits += eth * config.GetCreditsPerEth(); dtSetCityData(msg.sender, cdata); emit OnBuyCredits(msg.sender, eth); } function GetUpgradeCost(uint256 id, uint256 count) external view returns(uint256) { return config.GetUpgradeCost(id, count); } function UpgradeByCredits(uint256 id, uint256 count) external { uint256 a_population; uint256 a_crdtsec; uint256 updcrdt; CITYDATA memory cdata = dtGetCityData(msg.sender); require(count > 0); (a_population, a_crdtsec) = UpdateBuildingParam(cdata, id, 0, count); require((a_population > 0) || (a_crdtsec > 0)); updcrdt = config.GetUpgradeCost(id, count); UpdateCityData(cdata, a_population, 0, updcrdt, a_crdtsec); if (a_population != 0) rank.UpdateRank(msg.sender, cdata.population, cdata.lasttime); dtSetCityData(msg.sender, cdata); emit OnUpdated(msg.sender, id, count); } function GetDemolishCost(uint256 id, uint256 count) external view returns (uint256) { require(count > 0); return config.GetDemolishCost(id, count); } function DemolishByCredits(uint256 id, uint256 count) external { uint256 a_population; uint256 a_crdtsec; uint256 dmlcrdt; CITYDATA memory cdata = dtGetCityData(msg.sender); require(count > 0); (a_population, a_crdtsec) = UpdateBuildingParam(cdata, id, -count, 0); require((a_population > 0) || (a_crdtsec > 0)); dmlcrdt = config.GetDemolishCost(id, count); UpdateCityData(cdata, a_population, 0, dmlcrdt, a_crdtsec); if (a_population != 0) rank.UpdateRank(msg.sender, cdata.population, cdata.lasttime); dtSetCityData(msg.sender, cdata); emit OnDemolished(msg.sender, id, count); } function GetEthBalance() external view returns(uint256 ethBal) { return data.GetWithdrawBalance(msg.sender); } function WithdrawEther() external { data.WithdrawEther(msg.sender); CITYDATA memory cdata = dtGetCityData(msg.sender); UpdateCityData(cdata, 0, 0, 0, 0); dtSetCityData(msg.sender, cdata); } function GetEthShop() external view returns(uint256 shopEth, uint256 shopCredits) { (shopEth, shopCredits) = data.GetEthShop(msg.sender); } function TradeEthShop(uint256 credits) external { data.TradeEthShop(msg.sender, credits); CITYDATA memory cdata = dtGetCityData(msg.sender); UpdateCityData(cdata, 0, 0, credits, 0); dtSetCityData(msg.sender, cdata); } ///////////////////////////////////////////////////////////////// // admin function adminIsAdmin() external view returns(bool) { return msg.sender == owner || msg.sender == admin; } function adminSetAdmin(address addr) external { require(msg.sender == owner); admin = addr; } function adminSetConfig(address dta, address cfg, address rnk) external { require(msg.sender == owner || msg.sender == admin); data = EtherCityData(dta); config = EtherCityConfig(cfg); rank = EtherCityRank(rnk); } function adminAddWorldBalance() external payable { require(msg.value > 0); require(msg.sender == owner || msg.sender == admin); UpdateEthBalance(msg.value, msg.value); } function adminGetBalance() external view returns(uint256 dta_bal, uint256 cfg_bal, uint256 rnk_bal, uint256 cty_bal) { require(msg.sender == owner || msg.sender == admin); dta_bal = address(data).balance; cfg_bal = address(config).balance; rnk_bal = address(rank).balance; cty_bal = address(this).balance; } ///////////////////////////////////////////////////////////////// // internal function nowday() private view returns(uint256) { return block.timestamp / 24 hours; } function daytime(uint256 day) private pure returns(uint256) { return day * 24 hours; } function ConstructBuilding(CITYDATA memory cdata, uint256 id, uint256 count, bool byCredit) private returns(bool) { uint256 a_population; uint256 a_crdtsec; uint256 cnstcrdt; uint256 cnsteth; if (count > cdata.landUnoccupied) return false; (a_population, a_crdtsec) = UpdateBuildingParam(cdata, id, count, 0); if ((a_population == 0) && (a_crdtsec == 0)) return false; (cnstcrdt, cnsteth) = config.GetConstructCost(id, count); if (!byCredit) UpdateEthBalance(cnsteth, msg.value); UpdateCityData(cdata, a_population, 0, cnstcrdt, a_crdtsec); if (a_population != 0) rank.UpdateRank(msg.sender, cdata.population, cdata.lasttime); return true; } function UpdateBuildingParam(CITYDATA memory cdata, uint256 id, uint256 cnstcount, uint256 updcount) private returns(uint256 a_population, uint256 a_crdtsec) { uint256 population; uint256 crdtsec; uint256 maxupd; BUILDINGDATA memory bdata = dtGetBuildingData(msg.sender, id); if (bdata.upgradeCount == 0) bdata.upgradeCount = 1; a_population = 0; a_crdtsec = 0; (population, crdtsec, maxupd) = config.GetBuildingParam(id); if (cnstcount > cdata.landUnoccupied) return; cdata.landOccupied += cnstcount; cdata.landUnoccupied -= cnstcount; if (bdata.upgradeCount + updcount > maxupd) return; (a_population, a_crdtsec) = CalcBuildingParam(bdata); bdata.population = population; bdata.creditsPerSec = crdtsec; bdata.constructCount += cnstcount; bdata.upgradeCount += updcount; (population, crdtsec) = CalcBuildingParam(bdata); dtSetBuildingData(msg.sender, id, bdata); a_population = population - a_population; a_crdtsec = crdtsec - a_crdtsec; } function CalcBuildingParam(BUILDINGDATA memory bdata) private pure returns(uint256 population, uint256 crdtsec) { uint256 count; count = bdata.constructCount * bdata.upgradeCount; population = bdata.population * count; crdtsec = bdata.creditsPerSec * count; } function CalcIncCredits(CITYDATA memory cdata) private view returns(uint256) { return SafeMath.muldiv(cdata.creditsPerSec, block.timestamp - cdata.lasttime, INTFLOATDIV); } function UpdateCityData(CITYDATA memory cdata, uint256 pop, uint256 inccrdt, uint256 deccrdt, uint256 crdtsec) private { uint256 day; day = nowday(); inccrdt += CalcIncCredits(cdata); require((cdata.credits + inccrdt) >= deccrdt); inccrdt -= deccrdt; cdata.population += pop; cdata.credits += inccrdt; cdata.creditsPerSec += crdtsec; cdata.lasttime = block.timestamp; WORLDDATA memory wdata = dtGetWorldData(); wdata.population += pop; wdata.credits += inccrdt; dtSetWorldData(wdata); WORLDSNAPSHOT memory wss = dtValidateWorldSnapshot(day); wss.population += pop; wss.credits += inccrdt; wss.lasttime = block.timestamp; dtSetWorldSnapshot(day, wss); CITYSNAPSHOT memory css = dtValidateCitySnapshot(msg.sender, day); css.population += pop; css.credits += inccrdt; css.shopCredits += inccrdt; css.lasttime = block.timestamp; dtSetCitySnapshot(msg.sender, day, css); } function UpdateEthBalance(uint256 eth, uint256 val) private returns(bool) { uint256 devf; uint256 fndf; uint256 rnkf; if (eth > val) { fndf = dtGetEthBalance(msg.sender); require(eth - val <= fndf); dtSetEthBalance(msg.sender, fndf - eth + val); } devf = eth * 17 / 100; fndf = eth * 33 / 100; rnkf = fndf * 70 / 100; data.UpdateEthBalance.value(val)(eth - devf - fndf, devf, rnkf, fndf - rnkf); } ///////////////////////////////////////////////////////////////// // function dtGetWorldData() private view returns(WORLDDATA memory wdata) { (wdata.ethBalance, wdata.ethDev, wdata.population, wdata.credits, wdata.starttime) = data.GetWorldData(); } function dtSetWorldData(WORLDDATA memory wdata) private { data.SetWorldData(wdata.ethBalance, wdata.ethDev, wdata.population, wdata.credits, wdata.starttime); } function dtSetWorldSnapshot(uint256 day, WORLDSNAPSHOT memory wss) private { data.SetWorldSnapshot(day, true, wss.population, wss.credits, wss.lasttime); } function dtCreateCityData(address player, uint256 crdtsec, uint256 landcount) private returns(CITYDATA memory) { data.CreateCityData(player, crdtsec, landcount); return dtGetCityData(player); } function dtGetCityData(address player) private view returns(CITYDATA memory cdata) { (cdata.credits, cdata.population, cdata.creditsPerSec, cdata.landOccupied, cdata.landUnoccupied, cdata.lasttime) = data.GetCityData(player); } function dtSetCityData(address player, CITYDATA memory cdata) private { data.SetCityData(player, cdata.credits, cdata.population, cdata.creditsPerSec, cdata.landOccupied, cdata.landUnoccupied, cdata.lasttime); } function dtSetCitySnapshot(address player, uint256 day, CITYSNAPSHOT memory css) private { data.SetCitySnapshot(player, day, true, css.population, css.credits, css.shopCredits, css.lasttime); } function dtGetBuildingData(address player, uint256 id) private view returns(BUILDINGDATA memory bdata) { (bdata.constructCount, bdata.upgradeCount, bdata.population, bdata.creditsPerSec) = data.GetBuildingData(player, id); } function dtSetBuildingData(address player, uint256 id, BUILDINGDATA memory bdata) private { data.SetBuildingData(player, id, bdata.constructCount, bdata.upgradeCount, bdata.population, bdata.creditsPerSec); } function dtGetEthBalance(address player) private view returns(uint256) { return data.GetEthBalance(player); } function dtSetEthBalance(address player, uint256 eth) private { data.SetEthBalance(player, eth); } function dtAddEthBalance(address player, uint256 eth) private { data.AddEthBalance(player, eth); } function dtValidateWorldSnapshot(uint256 day) private returns(WORLDSNAPSHOT memory wss) { uint256 ethRankFund; (ethRankFund, wss.population, wss.credits, wss.lasttime) = data.ValidateWorldSnapshot(day); } function dtTestWorldSnapshot(uint256 day) private view returns(uint256 ethRankFund, WORLDSNAPSHOT memory wss) { (ethRankFund, wss.population, wss.credits, wss.lasttime) = data.TestWorldSnapshot(day); } function dtValidateCitySnapshot(address player, uint256 day) private returns(CITYSNAPSHOT memory css) { (css.population, css.credits, css.shopCredits, css.lasttime) = data.ValidateCitySnapshot(player, day); } function dtTestCitySnapshot(address player, uint256 day) private view returns(CITYSNAPSHOT memory css) { (css.population, css.credits, css.shopCredits, css.lasttime) = data.TestCitySnapshot(player, day); } } "}
{"sol name": "8750.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; library SafeMath { function mul(uint256 _x, uint256 _y) internal pure returns (uint256 z) { if (_x == 0) { return 0; } z = _x * _y; assert(z / _x == _y); return z; } function div(uint256 _x, uint256 _y) internal pure returns (uint256) { return _x / _y; } function sub(uint256 _x, uint256 _y) internal pure returns (uint256) { assert(_y <= _x); return _x - _y; } function add(uint256 _x, uint256 _y) internal pure returns (uint256 z) { z = _x + _y; assert(z >= _x); return z; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed _previousOwner, address indexed _newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner public { require(_newOwner != address(0)); owner = _newOwner; emit OwnershipTransferred(owner, _newOwner); } } contract Erc20Wrapper { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function allowance(address _owner, address _spender) public view returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract LemurTokenSale is Ownable { using SafeMath for uint256; Erc20Wrapper public token; address public wallet; uint256 public rate; uint256 public amountRaised; uint256 public openingTime; uint256 public closingTime; event TokenPurchase(address indexed _purchaser, address indexed _beneficiary, uint256 _value, uint256 _amount); constructor() public { // solium-disable-next-line security/no-block-members openingTime = block.timestamp; closingTime = openingTime.add(90 days); } function setToken(Erc20Wrapper _token) onlyOwner public { require(_token != address(0)); token = _token; } function setWallet(address _wallet) onlyOwner public { require(_wallet != address(0)); wallet = _wallet; } function setRate(uint256 _rate) onlyOwner public { require(_rate > 0); rate = _rate; } function setClosingTime(uint256 _days) onlyOwner public { require(_days >= 1); closingTime = openingTime.add(_days.mul(1 days)); } function hasClosed() public view returns (bool) { // solium-disable-next-line security/no-block-members return block.timestamp > closingTime; } function () external payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) public payable { require(!hasClosed()); require(token != address(0) && wallet != address(0) && rate > 0); require(_beneficiary != address(0)); uint256 amount = msg.value; require(amount >= 0.01 ether); uint256 tokenAmount = amount.mul(rate); amountRaised = amountRaised.add(amount); require(token.transfer(_beneficiary, tokenAmount)); emit TokenPurchase(msg.sender, _beneficiary, amount, tokenAmount); wallet.transfer(amount); } } "}
{"sol name": "11711.sol", "label": 1, "sol content": "pragma solidity ^0.4.18; // File: contracts/IEscrow.sol /** * @title Escrow interface * * @dev https://send.sd/token */ interface IEscrow { event Created( address indexed sender, address indexed recipient, address indexed arbitrator, uint256 transactionId ); event Released(address indexed arbitrator, address indexed sentTo, uint256 transactionId); event Dispute(address indexed arbitrator, uint256 transactionId); event Paid(address indexed arbitrator, uint256 transactionId); function create( address _sender, address _recipient, address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee, uint256 _expiration ) public; function fund( address _sender, address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee ) public; } // File: contracts/ISendToken.sol /** * @title ISendToken - Send Consensus Network Token interface * @dev token interface built on top of ERC20 standard interface * @dev see https://send.sd/token */ interface ISendToken { function transfer(address to, uint256 value) public returns (bool); function isVerified(address _address) public constant returns(bool); function verify(address _address) public; function unverify(address _address) public; function verifiedTransferFrom( address from, address to, uint256 value, uint256 referenceId, uint256 exchangeRate, uint256 fee ) public; function issueExchangeRate( address _from, address _to, address _verifiedAddress, uint256 _value, uint256 _referenceId, uint256 _exchangeRate ) public; event VerifiedTransfer( address indexed from, address indexed to, address indexed verifiedAddress, uint256 value, uint256 referenceId, uint256 exchangeRate ); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: contracts/Escrow.sol /** * @title Vesting contract for SDT * @dev see https://send.sd/token */ contract Escrow is IEscrow, Ownable { using SafeMath for uint256; ISendToken public token; struct Lock { address sender; address recipient; uint256 value; uint256 fee; uint256 expiration; bool paid; } mapping(address => mapping(uint256 => Lock)) internal escrows; function Escrow(address _token) public { token = ISendToken(_token); } modifier tokenRestricted() { require(msg.sender == address(token)); _; } function isUnlocked(address _arbitrator, uint256 _transactionId) public view returns(bool) { return escrows[_arbitrator][_transactionId].expiration == 1; } /** * @dev Create a record for held tokens * @param _arbitrator Address to be authorized to spend locked funds * @param _transactionId Intenral ID for applications implementing this * @param _tokens Amount of tokens to lock * @param _fee A fee to be paid to arbitrator (may be 0) * @param _expiration After this timestamp, user can claim tokens back. */ function create( address _sender, address _recipient, address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee, uint256 _expiration ) public tokenRestricted { require(_tokens > 0); require(_fee >= 0); require(escrows[_arbitrator][_transactionId].value == 0); escrows[_arbitrator][_transactionId].sender = _sender; escrows[_arbitrator][_transactionId].recipient = _recipient; escrows[_arbitrator][_transactionId].value = _tokens; escrows[_arbitrator][_transactionId].fee = _fee; escrows[_arbitrator][_transactionId].expiration = _expiration; Created(_sender, _recipient, _arbitrator, _transactionId); } /** * @dev Fund escrow record * @param _arbitrator Address to be authorized to spend locked funds * @param _transactionId Intenral ID for applications implementing this * @param _tokens Amount of tokens to lock * @param _fee A fee to be paid to arbitrator (may be 0) */ function fund( address _sender, address _arbitrator, uint256 _transactionId, uint256 _tokens, uint256 _fee ) public tokenRestricted { require(escrows[_arbitrator][_transactionId].sender == _sender); require(escrows[_arbitrator][_transactionId].value == _tokens); require(escrows[_arbitrator][_transactionId].fee == _fee); require(escrows[_arbitrator][_transactionId].paid == false); escrows[_arbitrator][_transactionId].paid = true; Paid(_arbitrator, _transactionId); } /** * @dev Transfer a locked amount * @notice Only authorized address * @notice Exchange rate has 18 decimal places * @param _sender Address with locked amount * @param _recipient Address to send funds to * @param _transactionId App/user internal associated ID * @param _exchangeRate Rate to be reported to the blockchain */ function release( address _sender, address _recipient, uint256 _transactionId, uint256 _exchangeRate ) public { Lock memory lock = escrows[msg.sender][_transactionId]; require(lock.expiration != 1); require(lock.sender == _sender); require(lock.recipient == _recipient || lock.sender == _recipient); require(lock.paid); if (lock.fee > 0 && lock.recipient == _recipient) { token.transfer(_recipient, lock.value); token.transfer(msg.sender, lock.fee); } else { token.transfer(_recipient, lock.value.add(lock.fee)); } delete escrows[msg.sender][_transactionId]; token.issueExchangeRate( _sender, _recipient, msg.sender, lock.value, _transactionId, _exchangeRate ); Released(msg.sender, _recipient, _transactionId); } /** * @dev Transfer a locked amount for timeless escrow * @notice Only authorized address * @notice Exchange rate has 18 decimal places * @param _sender Address with locked amount * @param _recipient Address to send funds to * @param _transactionId App/user internal associated ID * @param _exchangeRate Rate to be reported to the blockchain */ function releaseUnlocked( address _sender, address _recipient, uint256 _transactionId, uint256 _exchangeRate ) public { Lock memory lock = escrows[msg.sender][_transactionId]; require(lock.expiration == 1); require(lock.sender == _sender); require(lock.paid); if (lock.fee > 0 && lock.sender != _recipient) { token.transfer(_recipient, lock.value); token.transfer(msg.sender, lock.fee); } else { token.transfer(_recipient, lock.value.add(lock.fee)); } delete escrows[msg.sender][_transactionId]; token.issueExchangeRate( _sender, _recipient, msg.sender, lock.value, _transactionId, _exchangeRate ); Released(msg.sender, _recipient, _transactionId); } /** * @dev Claim back locked amount after expiration time * @dev Cannot be claimed if expiration == 0 or expiration == 1 * @notice Only works after lock expired * @param _arbitrator Authorized lock address * @param _transactionId transactionId ID from App/user */ function claim( address _arbitrator, uint256 _transactionId ) public { Lock memory lock = escrows[_arbitrator][_transactionId]; require(lock.sender == msg.sender); require(lock.paid); require(lock.expiration < block.timestamp); require(lock.expiration != 0); require(lock.expiration != 1); delete escrows[_arbitrator][_transactionId]; token.transfer(msg.sender, lock.value.add(lock.fee)); Released( _arbitrator, msg.sender, _transactionId ); } /** * @dev Remove expiration time on a lock * @notice User wont be able to claim tokens back after this is called by arbitrator address * @notice Only authorized address * @param _transactionId App/user internal associated ID */ function mediate( uint256 _transactionId ) public { require(escrows[msg.sender][_transactionId].paid); require(escrows[msg.sender][_transactionId].expiration != 0); require(escrows[msg.sender][_transactionId].expiration != 1); escrows[msg.sender][_transactionId].expiration = 0; Dispute(msg.sender, _transactionId); } /** This function is a way to get other ETC20 tokens back to their rightful owner if sent by mistake */ function transferToken(address _tokenAddress, address _transferTo, uint256 _value) public onlyOwner { require(_tokenAddress != address(token)); ISendToken erc20Token = ISendToken(_tokenAddress); erc20Token.transfer(_transferTo, _value); } } "}
{"sol name": "7627.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; contract Engine { uint256 public VERSION; string public VERSION_NAME; enum Status { initial, lent, paid, destroyed } struct Approbation { bool approved; bytes data; bytes32 checksum; } function getTotalLoans() public view returns (uint256); function getOracle(uint index) public view returns (Oracle); function getBorrower(uint index) public view returns (address); function getCosigner(uint index) public view returns (address); function ownerOf(uint256) public view returns (address owner); function getCreator(uint index) public view returns (address); function getAmount(uint index) public view returns (uint256); function getPaid(uint index) public view returns (uint256); function getDueTime(uint index) public view returns (uint256); function getApprobation(uint index, address _address) public view returns (bool); function getStatus(uint index) public view returns (Status); function isApproved(uint index) public view returns (bool); function getPendingAmount(uint index) public returns (uint256); function getCurrency(uint index) public view returns (bytes32); function cosign(uint index, uint256 cost) external returns (bool); function approveLoan(uint index) public returns (bool); function transfer(address to, uint256 index) public returns (bool); function takeOwnership(uint256 index) public returns (bool); function withdrawal(uint index, address to, uint256 amount) public returns (bool); } /** @dev Defines the interface of a standard RCN cosigner. The cosigner is an agent that gives an insurance to the lender in the event of a defaulted loan, the confitions of the insurance and the cost of the given are defined by the cosigner. The lender will decide what cosigner to use, if any; the address of the cosigner and the valid data provided by the agent should be passed as params when the lender calls the \"lend\" method on the engine. When the default conditions defined by the cosigner aligns with the status of the loan, the lender of the engine should be able to call the \"claim\" method to receive the benefit; the cosigner can define aditional requirements to call this method, like the transfer of the ownership of the loan. */ contract Cosigner { uint256 public constant VERSION = 2; /** @return the url of the endpoint that exposes the insurance offers. */ function url() public view returns (string); /** @dev Retrieves the cost of a given insurance, this amount should be exact. @return the cost of the cosign, in RCN wei */ function cost(address engine, uint256 index, bytes data, bytes oracleData) public view returns (uint256); /** @dev The engine calls this method for confirmation of the conditions, if the cosigner accepts the liability of the insurance it must call the method \"cosign\" of the engine. If the cosigner does not call that method, or does not return true to this method, the operation fails. @return true if the cosigner accepts the liability */ function requestCosign(Engine engine, uint256 index, bytes data, bytes oracleData) public returns (bool); /** @dev Claims the benefit of the insurance if the loan is defaulted, this method should be only calleable by the current lender of the loan. @return true if the claim was done correctly. */ function claim(address engine, uint256 index, bytes oracleData) public returns (bool); } contract ERC721 { // ERC20 compatible functions function name() public view returns (string _name); function symbol() public view returns (string _symbol); function totalSupply() public view returns (uint256 _totalSupply); function balanceOf(address _owner) public view returns (uint _balance); // Functions that define ownership function ownerOf(uint256) public view returns (address owner); function approve(address, uint256) public returns (bool); function takeOwnership(uint256) public returns (bool); function transfer(address, uint256) public returns (bool); function setApprovalForAll(address _operator, bool _approved) public returns (bool); function getApproved(uint256 _tokenId) public view returns (address); function isApprovedForAll(address _owner, address _operator) public view returns (bool); // Token metadata function tokenMetadata(uint256 _tokenId) public view returns (string info); // Events event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); } contract Token { function transfer(address _to, uint _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); function approve(address _spender, uint256 _value) public returns (bool success); function increaseApproval (address _spender, uint _addedValue) public returns (bool success); function balanceOf(address _owner) public view returns (uint256 balance); } contract Ownable { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } function Ownable() public { owner = msg.sender; } /** @dev Transfers the ownership of the contract. @param _to Address of the new owner */ function transferTo(address _to) public onlyOwner returns (bool) { require(_to != address(0)); owner = _to; return true; } } /** @dev Defines the interface of a standard RCN oracle. The oracle is an agent in the RCN network that supplies a convertion rate between RCN and any other currency, it's primarily used by the exchange but could be used by any other agent. */ contract Oracle is Ownable { uint256 public constant VERSION = 3; event NewSymbol(bytes32 _currency, string _ticker); struct Symbol { string ticker; bool supported; } mapping(bytes32 => Symbol) public currencies; /** @dev Returns the url where the oracle exposes a valid \"oracleData\" if needed */ function url() public view returns (string); /** @dev Returns a valid convertion rate from the currency given to RCN @param symbol Symbol of the currency @param data Generic data field, could be used for off-chain signing */ function getRate(bytes32 symbol, bytes data) public returns (uint256 rate, uint256 decimals); /** @dev Adds a currency to the oracle, once added it cannot be removed @param ticker Symbol of the currency @return the hash of the currency, calculated keccak256(ticker) */ function addCurrency(string ticker) public onlyOwner returns (bytes32) { NewSymbol(currency, ticker); bytes32 currency = keccak256(ticker); currencies[currency] = Symbol(ticker, true); return currency; } /** @return true If the currency is supported */ function supported(bytes32 symbol) public view returns (bool) { return currencies[symbol].supported; } } contract RpSafeMath { function safeAdd(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x + y; require((z >= x) && (z >= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal pure returns(uint256) { require(x >= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x * y; require((x == 0)||(z/x == y)); return z; } function min(uint256 a, uint256 b) internal pure returns(uint256) { if (a < b) { return a; } else { return b; } } function max(uint256 a, uint256 b) internal pure returns(uint256) { if (a > b) { return a; } else { return b; } } } contract TokenLockable is RpSafeMath, Ownable { mapping(address => uint256) public lockedTokens; /** @dev Locked tokens cannot be withdrawn using the withdrawTokens function. */ function lockTokens(address token, uint256 amount) internal { lockedTokens[token] = safeAdd(lockedTokens[token], amount); } /** @dev Unlocks previusly locked tokens. */ function unlockTokens(address token, uint256 amount) internal { lockedTokens[token] = safeSubtract(lockedTokens[token], amount); } /** @dev Withdraws tokens from the contract. @param token Token to withdraw @param to Destination of the tokens @param amount Amount to withdraw */ function withdrawTokens(Token token, address to, uint256 amount) public onlyOwner returns (bool) { require(safeSubtract(token.balanceOf(this), lockedTokens[token]) >= amount); require(to != address(0)); return token.transfer(to, amount); } } contract NanoLoanEngine is ERC721, Engine, Ownable, TokenLockable { uint256 constant internal PRECISION = (10**18); uint256 constant internal RCN_DECIMALS = 18; uint256 public constant VERSION = 233; string public constant VERSION_NAME = \"Basalt\"; uint256 private activeLoans = 0; mapping(address => uint256) private lendersBalance; function name() public view returns (string _name) { _name = \"RCN - Nano loan engine - Basalt 233\"; } function symbol() public view returns (string _symbol) { _symbol = \"RCN-NLE-233\"; } /** @notice Returns the number of active loans in total, active loans are the loans with \"lent\" status. @dev Required for ERC-721 compliance @return _totalSupply Total amount of loans */ function totalSupply() public view returns (uint _totalSupply) { _totalSupply = activeLoans; } /** @notice Returns the number of active loans that a lender possess; active loans are the loans with \"lent\" status. @dev Required for ERC-721 compliance @param _owner The owner address to search @return _balance Amount of loans */ function balanceOf(address _owner) public view returns (uint _balance) { _balance = lendersBalance[_owner]; } /** @notice Returns all the loans that a lender possess @dev This method MUST NEVER be called by smart contract code; it walks the entire loans array, and will probably create a transaction bigger than the gas limit. @param _owner The owner address @return ownerTokens List of all the loans of the _owner */ function tokensOfOwner(address _owner) external view returns(uint256[] ownerTokens) { uint256 tokenCount = balanceOf(_owner); if (tokenCount == 0) { // Return an empty array return new uint256[](0); } else { uint256[] memory result = new uint256[](tokenCount); uint256 totalLoans = loans.length - 1; uint256 resultIndex = 0; uint256 loanId; for (loanId = 0; loanId <= totalLoans; loanId++) { if (loans[loanId].lender == _owner && loans[loanId].status == Status.lent) { result[resultIndex] = loanId; resultIndex++; } } return result; } } /** @notice Returns true if the _operator can transfer the loans of the _owner @dev Required for ERC-721 compliance */ function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operators[_owner][_operator]; } /** @notice Returns the loan metadata, this field can be set by the creator of the loan with his own criteria. @param index Index of the loan @return The string with the metadata */ function tokenMetadata(uint256 index) public view returns (string) { return loans[index].metadata; } /** @notice Returns the loan metadata, hashed with keccak256. @dev This emthod is useful to evaluate metadata from a smart contract. @param index Index of the loan @return The metadata hashed with keccak256 */ function tokenMetadataHash(uint256 index) public view returns (bytes32) { return keccak256(loans[index].metadata); } Token public rcn; bool public deprecated; event CreatedLoan(uint _index, address _borrower, address _creator); event ApprovedBy(uint _index, address _address); event Lent(uint _index, address _lender, address _cosigner); event DestroyedBy(uint _index, address _address); event PartialPayment(uint _index, address _sender, address _from, uint256 _amount); event TotalPayment(uint _index); function NanoLoanEngine(Token _rcn) public { owner = msg.sender; rcn = _rcn; // The loan 0 is a Invalid loan loans.length++; } struct Loan { Status status; Oracle oracle; address borrower; address lender; address creator; address cosigner; uint256 amount; uint256 interest; uint256 punitoryInterest; uint256 interestTimestamp; uint256 paid; uint256 interestRate; uint256 interestRatePunitory; uint256 dueTime; uint256 duesIn; bytes32 currency; uint256 cancelableAt; uint256 lenderBalance; address approvedTransfer; uint256 expirationRequest; string metadata; mapping(address => bool) approbations; } mapping(address => mapping(address => bool)) private operators; mapping(bytes32 => uint256) public identifierToIndex; Loan[] private loans; /** @notice Creates a loan request, the loan can be generated with any borrower and conditions; if the borrower agrees it must call the \"approve\" function. If the creator of the loan is the borrower the approve is done automatically. @dev The creator of the loan is the caller of this function; this is useful to track which wallet created the loan. Two identical loans cannot exist, a clone of another loan will fail. @param _oracleContract Address of the Oracle contract, if the loan does not use any oracle, this field should be 0x0. @param _borrower Address of the borrower @param _currency The currency to use with the oracle, the currency code is generated with the following formula, keccak256(ticker), is always stored as the minimum divisible amount. (Ej: ETH Wei, USD Cents) @param _amount The requested amount; currency and unit are defined by the Oracle, if there is no Oracle present the currency is RCN, and the unit is wei. @param _interestRate The non-punitory interest rate by second, defined as a denominator of 10 000 000. @param _interestRatePunitory The punitory interest rate by second, defined as a denominator of 10 000 000. Ej: interestRate 11108571428571 = 28% Anual interest @param _duesIn The time in seconds that the borrower has in order to pay the debt after the lender lends the money. @param _cancelableAt Delta in seconds specifying how much interest should be added in advance, if the borrower pays entirely or partially the loan before this term, no extra interest will be deducted. @param _expirationRequest Timestamp of when the loan request expires, if the loan is not filled before this date, the request is no longer valid. @param _metadata String with loan metadata. */ function createLoan(Oracle _oracleContract, address _borrower, bytes32 _currency, uint256 _amount, uint256 _interestRate, uint256 _interestRatePunitory, uint256 _duesIn, uint256 _cancelableAt, uint256 _expirationRequest, string _metadata) public returns (uint256) { require(!deprecated); require(_cancelableAt <= _duesIn); require(_oracleContract != address(0) || _currency == 0x0); require(_borrower != address(0)); require(_amount != 0); require(_interestRatePunitory != 0); require(_interestRate != 0); require(_expirationRequest > block.timestamp); var loan = Loan(Status.initial, _oracleContract, _borrower, 0x0, msg.sender, 0x0, _amount, 0, 0, 0, 0, _interestRate, _interestRatePunitory, 0, _duesIn, _currency, _cancelableAt, 0, 0x0, _expirationRequest, _metadata); uint index = loans.push(loan) - 1; CreatedLoan(index, _borrower, msg.sender); bytes32 identifier = getIdentifier(index); require(identifierToIndex[identifier] == 0); identifierToIndex[identifier] = index; if (msg.sender == _borrower) { approveLoan(index); } return index; } function ownerOf(uint256 index) public view returns (address owner) { owner = loans[index].lender; } function getTotalLoans() public view returns (uint256) { return loans.length; } function getOracle(uint index) public view returns (Oracle) { return loans[index].oracle; } function getBorrower(uint index) public view returns (address) { return loans[index].borrower; } function getCosigner(uint index) public view returns (address) { return loans[index].cosigner; } function getCreator(uint index) public view returns (address) { return loans[index].creator; } function getAmount(uint index) public view returns (uint256) { return loans[index].amount; } function getPunitoryInterest(uint index) public view returns (uint256) { return loans[index].punitoryInterest; } function getInterestTimestamp(uint index) public view returns (uint256) { return loans[index].interestTimestamp; } function getPaid(uint index) public view returns (uint256) { return loans[index].paid; } function getInterestRate(uint index) public view returns (uint256) { return loans[index].interestRate; } function getInterestRatePunitory(uint index) public view returns (uint256) { return loans[index].interestRatePunitory; } function getDueTime(uint index) public view returns (uint256) { return loans[index].dueTime; } function getDuesIn(uint index) public view returns (uint256) { return loans[index].duesIn; } function getCancelableAt(uint index) public view returns (uint256) { return loans[index].cancelableAt; } function getApprobation(uint index, address _address) public view returns (bool) { return loans[index].approbations[_address]; } function getStatus(uint index) public view returns (Status) { return loans[index].status; } function getLenderBalance(uint index) public view returns (uint256) { return loans[index].lenderBalance; } function getApproved(uint index) public view returns (address) {return loans[index].approvedTransfer; } function getCurrency(uint index) public view returns (bytes32) { return loans[index].currency; } function getExpirationRequest(uint index) public view returns (uint256) { return loans[index].expirationRequest; } function getInterest(uint index) public view returns (uint256) { return loans[index].interest; } function getIdentifier(uint index) public view returns (bytes32) { Loan memory loan = loans[index]; return buildIdentifier(loan.oracle, loan.borrower, loan.creator, loan.currency, loan.amount, loan.interestRate, loan.interestRatePunitory, loan.duesIn, loan.cancelableAt, loan.expirationRequest, loan.metadata); } /** @notice Used to reference a loan that is not yet created, and by that does not have an index @dev Two identical loans cannot exist, only one loan per signature is allowed @return The signature hash of the loan configuration */ function buildIdentifier(Oracle oracle, address borrower, address creator, bytes32 currency, uint256 amount, uint256 interestRate, uint256 interestRatePunitory, uint256 duesIn, uint256 cancelableAt, uint256 expirationRequest, string metadata) view returns (bytes32) { return keccak256(this, oracle, borrower, creator, currency, amount, interestRate, interestRatePunitory, duesIn, cancelableAt, expirationRequest, metadata); } /** @notice Used to know if a loan is ready to lend @param index Index of the loan @return true if the loan has been approved by the borrower and cosigner. */ function isApproved(uint index) public view returns (bool) { Loan storage loan = loans[index]; return loan.approbations[loan.borrower]; } /** @notice Called by the members of the loan to show that they agree with the terms of the loan; the borrower must call this method before any lender could call the method \"lend\". @dev Any address can call this method to be added to the \"approbations\" mapping. @param index Index of the loan @return true if the approve was done successfully */ function approveLoan(uint index) public returns(bool) { Loan storage loan = loans[index]; require(loan.status == Status.initial); loan.approbations[msg.sender] = true; ApprovedBy(index, msg.sender); return true; } /** @notice Approves a loan using the Identifier and not the index @param identifier Identifier of the loan @return true if the approve was done successfully */ function approveLoanIdentifier(bytes32 identifier) public returns (bool) { uint256 index = identifierToIndex[identifier]; require(index != 0); return approveLoan(index); } /** @notice Register an approvation made by a borrower in the past @dev The loan should exist and have an index @param identifier Identifier of the loan @return true if the approve was done successfully */ function registerApprove(bytes32 identifier, uint8 v, bytes32 r, bytes32 s) public returns (bool) { uint256 index = identifierToIndex[identifier]; require(index != 0); Loan storage loan = loans[index]; require(loan.borrower == ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", identifier), v, r, s)); loan.approbations[loan.borrower] = true; ApprovedBy(index, loan.borrower); return true; } /** @notice Performs the lend of the RCN equivalent to the requested amount, and transforms the msg.sender in the new lender. @dev The loan must be previously approved by the borrower; before calling this function, the lender candidate must call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of the requested amount, and the cosigner fee. @param index Index of the loan @param oracleData Data required by the oracle to return the rate, the content of this field must be provided by the url exposed in the url() method of the oracle. @param cosigner Address of the cosigner, 0x0 for lending without cosigner. @param cosignerData Data required by the cosigner to process the request. @return true if the lend was done successfully */ function lend(uint index, bytes oracleData, Cosigner cosigner, bytes cosignerData) public returns (bool) { Loan storage loan = loans[index]; require(loan.status == Status.initial); require(isApproved(index)); require(block.timestamp <= loan.expirationRequest); loan.lender = msg.sender; loan.dueTime = safeAdd(block.timestamp, loan.duesIn); loan.interestTimestamp = block.timestamp; loan.status = Status.lent; // ERC721, create new loan and transfer it to the lender Transfer(0x0, loan.lender, index); activeLoans += 1; lendersBalance[loan.lender] += 1; if (loan.cancelableAt > 0) internalAddInterest(loan, safeAdd(block.timestamp, loan.cancelableAt)); // Transfer the money to the borrower before handling the cosigner // so the cosigner could require a specific usage for that money. uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, loan.amount); require(rcn.transferFrom(msg.sender, loan.borrower, transferValue)); if (cosigner != address(0)) { // The cosigner it's temporary set to the next address (cosigner + 2), it's expected that the cosigner will // call the method \"cosign\" to accept the conditions; that method also sets the cosigner to the right // address. If that does not happen, the transaction fails. loan.cosigner = address(uint256(cosigner) + 2); require(cosigner.requestCosign(this, index, cosignerData, oracleData)); require(loan.cosigner == address(cosigner)); } Lent(index, loan.lender, cosigner); return true; } /** @notice The cosigner must call this method to accept the conditions of a loan, this method pays the cosigner his fee. @dev If the cosigner does not call this method the whole \"lend\" call fails. @param index Index of the loan @param cost Fee set by the cosigner @return true If the cosign was successfull */ function cosign(uint index, uint256 cost) external returns (bool) { Loan storage loan = loans[index]; require(loan.status == Status.lent && (loan.dueTime - loan.duesIn) == block.timestamp); require(loan.cosigner != address(0)); require(loan.cosigner == address(uint256(msg.sender) + 2)); loan.cosigner = msg.sender; require(rcn.transferFrom(loan.lender, msg.sender, cost)); return true; } /** @notice Destroys a loan, the borrower could call this method if they performed an accidental or regretted \"approve\" of the loan, this method only works for them if the loan is in \"pending\" status. The lender can call this method at any moment, in case of a loan with status \"lent\" the lender is pardoning the debt. @param index Index of the loan @return true if the destroy was done successfully */ function destroy(uint index) public returns (bool) { Loan storage loan = loans[index]; require(loan.status != Status.destroyed); require(msg.sender == loan.lender || (msg.sender == loan.borrower && loan.status == Status.initial)); DestroyedBy(index, msg.sender); // ERC721, remove loan from circulation if (loan.status != Status.initial) { lendersBalance[loan.lender] -= 1; activeLoans -= 1; Transfer(loan.lender, 0x0, index); } loan.status = Status.destroyed; return true; } /** @notice Destroys a loan using the signature and not the Index @param identifier Identifier of the loan @return true if the destroy was done successfully */ function destroyIdentifier(bytes32 identifier) public returns (bool) { uint256 index = identifierToIndex[identifier]; require(index != 0); return destroy(index); } /** @notice Transfers a loan to a different lender, the caller must be the current lender or previously being approved with the method \"approveTransfer\"; only loans with the Status.lent status can be transfered. @dev Required for ERC-721 compliance @param index Index of the loan @param to New lender @return true if the transfer was done successfully */ function transfer(address to, uint256 index) public returns (bool) { Loan storage loan = loans[index]; require(msg.sender == loan.lender || msg.sender == loan.approvedTransfer || operators[loan.lender][msg.sender]); require(to != address(0)); // ERC721, transfer loan to another address lendersBalance[loan.lender] -= 1; lendersBalance[to] += 1; Transfer(loan.lender, to, index); loan.lender = to; loan.approvedTransfer = address(0); return true; } /** @notice Transfers the loan to the msg.sender, the msg.sender must be approved using the \"approve\" method. @dev Required for ERC-721 compliance @param _index Index of the loan @return true if the transfer was successfull */ function takeOwnership(uint256 _index) public returns (bool) { return transfer(msg.sender, _index); } /** @notice Transfers the loan to an address, only if the current owner is the \"from\" address @dev Required for ERC-721 compliance @param from Current owner of the loan @param to New owner of the loan @param index Index of the loan @return true if the transfer was successfull */ function transferFrom(address from, address to, uint256 index) public returns (bool) { require(loans[index].lender == from); return transfer(to, index); } /** @notice Approves the transfer of a given loan in the name of the lender, the behavior of this function is similar to \"approve\" in the ERC20 standard, but only one approved address is allowed at a time. The same method can be called passing 0x0 as parameter \"to\" to erase a previously approved address. @dev Required for ERC-721 compliance @param to Address allowed to transfer the loan or 0x0 to delete @param index Index of the loan @return true if the approve was done successfully */ function approve(address to, uint256 index) public returns (bool) { Loan storage loan = loans[index]; require(msg.sender == loan.lender); loan.approvedTransfer = to; Approval(msg.sender, to, index); return true; } /** @notice Enable or disable approval for a third party (\"operator\") to manage @param _approved True if the operator is approved, false to revoke approval @param _operator Address to add to the set of authorized operators. */ function setApprovalForAll(address _operator, bool _approved) public returns (bool) { operators[msg.sender][_operator] = _approved; ApprovalForAll(msg.sender, _operator, _approved); return true; } /** @notice Returns the pending amount to complete de payment of the loan, keep in mind that this number increases every second. @dev This method also computes the interest and updates the loan @param index Index of the loan @return Aprox pending payment amount */ function getPendingAmount(uint index) public returns (uint256) { addInterest(index); return getRawPendingAmount(index); } /** @notice Returns the pending amount up to the last time of the interest update. This is not the real pending amount @dev This method is exact only if \"addInterest(loan)\" was before and in the same block. @param index Index of the loan @return The past pending amount */ function getRawPendingAmount(uint index) public view returns (uint256) { Loan memory loan = loans[index]; return safeSubtract(safeAdd(safeAdd(loan.amount, loan.interest), loan.punitoryInterest), loan.paid); } /** @notice Calculates the interest of a given amount, interest rate and delta time. @param timeDelta Elapsed time @param interestRate Interest rate expressed as the denominator of 10 000 000. @param amount Amount to apply interest @return realDelta The real timeDelta applied @return interest The interest gained in the realDelta time */ function calculateInterest(uint256 timeDelta, uint256 interestRate, uint256 amount) internal pure returns (uint256 realDelta, uint256 interest) { if (amount == 0) { interest = 0; realDelta = timeDelta; } else { interest = safeMult(safeMult(100000, amount), timeDelta) / interestRate; realDelta = safeMult(interest, interestRate) / (amount * 100000); } } /** @notice Computes loan interest Computes the punitory and non-punitory interest of a given loan and only applies the change. @param loan Loan to compute interest @param timestamp Target absolute unix time to calculate interest. */ function internalAddInterest(Loan storage loan, uint256 timestamp) internal { if (timestamp > loan.interestTimestamp) { uint256 newInterest = loan.interest; uint256 newPunitoryInterest = loan.punitoryInterest; uint256 newTimestamp; uint256 realDelta; uint256 calculatedInterest; uint256 deltaTime; uint256 pending; uint256 endNonPunitory = min(timestamp, loan.dueTime); if (endNonPunitory > loan.interestTimestamp) { deltaTime = endNonPunitory - loan.interestTimestamp; if (loan.paid < loan.amount) { pending = loan.amount - loan.paid; } else { pending = 0; } (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRate, pending); newInterest = safeAdd(calculatedInterest, newInterest); newTimestamp = loan.interestTimestamp + realDelta; } if (timestamp > loan.dueTime) { uint256 startPunitory = max(loan.dueTime, loan.interestTimestamp); deltaTime = timestamp - startPunitory; uint256 debt = safeAdd(loan.amount, newInterest); pending = min(debt, safeSubtract(safeAdd(debt, newPunitoryInterest), loan.paid)); (realDelta, calculatedInterest) = calculateInterest(deltaTime, loan.interestRatePunitory, pending); newPunitoryInterest = safeAdd(newPunitoryInterest, calculatedInterest); newTimestamp = startPunitory + realDelta; } if (newInterest != loan.interest || newPunitoryInterest != loan.punitoryInterest) { loan.interestTimestamp = newTimestamp; loan.interest = newInterest; loan.punitoryInterest = newPunitoryInterest; } } } /** @notice Updates the loan accumulated interests up to the current Unix time. @param index Index of the loan @return true If the interest was updated */ function addInterest(uint index) public returns (bool) { Loan storage loan = loans[index]; require(loan.status == Status.lent); internalAddInterest(loan, block.timestamp); } /** @notice Pay loan Does a payment of a given Loan, before performing the payment the accumulated interest is computed and added to the total pending amount. Before calling this function, the msg.sender must call the \"approve\" function on the RCN Token, specifying an amount sufficient enough to pay the equivalent of the desired payment and the oracle fee. If the paid pending amount equals zero, the loan changes status to \"paid\" and it is considered closed. @dev Because it is difficult or even impossible to know in advance how much RCN are going to be spent on the transaction*, we recommend performing the \"approve\" using an amount 5% superior to the wallet estimated spending. If the RCN spent results to be less, the extra tokens are never debited from the msg.sender. * The RCN rate can fluctuate on the same block, and it is impossible to know in advance the exact time of the confirmation of the transaction. @param index Index of the loan @param _amount Amount to pay, specified in the loan currency; or in RCN if the loan has no oracle @param _from The identity of the payer @param oracleData Data required by the oracle to return the rate, the content of this field must be provided by the url exposed in the url() method of the oracle. @return true if the payment was executed successfully */ function pay(uint index, uint256 _amount, address _from, bytes oracleData) public returns (bool) { Loan storage loan = loans[index]; require(loan.status == Status.lent); addInterest(index); uint256 toPay = min(getPendingAmount(index), _amount); PartialPayment(index, msg.sender, _from, toPay); loan.paid = safeAdd(loan.paid, toPay); if (getRawPendingAmount(index) == 0) { TotalPayment(index); loan.status = Status.paid; // ERC721, remove loan from circulation lendersBalance[loan.lender] -= 1; activeLoans -= 1; Transfer(loan.lender, 0x0, index); } uint256 transferValue = convertRate(loan.oracle, loan.currency, oracleData, toPay); require(transferValue > 0 || toPay < _amount); lockTokens(rcn, transferValue); require(rcn.transferFrom(msg.sender, this, transferValue)); loan.lenderBalance = safeAdd(transferValue, loan.lenderBalance); return true; } /** @notice Converts an amount to RCN using the loan oracle. @dev If the loan has no oracle the currency must be RCN so the rate is 1 @return The result of the convertion */ function convertRate(Oracle oracle, bytes32 currency, bytes data, uint256 amount) public returns (uint256) { if (oracle == address(0)) { return amount; } else { uint256 rate; uint256 decimals; (rate, decimals) = oracle.getRate(currency, data); require(decimals <= RCN_DECIMALS); return (safeMult(safeMult(amount, rate), (10**(RCN_DECIMALS-decimals)))) / PRECISION; } } /** @notice Withdraw lender funds When a loan is paid, the funds are not transferred automatically to the lender, the funds are stored on the engine contract, and the lender must call this function specifying the amount desired to transfer and the destination. @dev This behavior is defined to allow the temporary transfer of the loan to a smart contract, without worrying that the contract will receive tokens that are not traceable; and it allows the development of decentralized autonomous organizations. @param index Index of the loan @param to Destination of the wiwthdraw funds @param amount Amount to withdraw, in RCN @return true if the withdraw was executed successfully */ function withdrawal(uint index, address to, uint256 amount) public returns (bool) { Loan storage loan = loans[index]; require(msg.sender == loan.lender); loan.lenderBalance = safeSubtract(loan.lenderBalance, amount); require(rcn.transfer(to, amount)); unlockTokens(rcn, amount); return true; } /** @notice Withdraw lender funds in batch, it walks by all the loans passed to the function and withdraws all the funds stored on that loans. @dev This batch withdraw method can be expensive in gas, it must be used with care. @param loanIds Array of the loans to withdraw @param to Destination of the tokens @return the total withdrawed */ function withdrawalList(uint256[] memory loanIds, address to) public returns (uint256) { uint256 inputId; uint256 totalWithdraw = 0; for (inputId = 0; inputId < loanIds.length; inputId++) { Loan storage loan = loans[loanIds[inputId]]; if (loan.lender == msg.sender) { totalWithdraw += loan.lenderBalance; loan.lenderBalance = 0; } } require(rcn.transfer(to, totalWithdraw)); unlockTokens(rcn, totalWithdraw); return totalWithdraw; } /** @dev Deprecates the engine, locks the creation of new loans. */ function setDeprecated(bool _deprecated) public onlyOwner { deprecated = _deprecated; } } "}
{"sol name": "7334.sol", "label": 1, "sol content": "pragma solidity ^0.4.13; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Certifiable is Ownable { Certifier public certifier; event CertifierChanged(address indexed newCertifier); constructor(address _certifier) public { certifier = Certifier(_certifier); } function updateCertifier(address _address) public onlyOwner returns (bool success) { require(_address != address(0)); emit CertifierChanged(_address); certifier = Certifier(_address); return true; } } contract KYCToken is Certifiable { mapping(address => bool) public kycPending; mapping(address => bool) public managers; event ManagerAdded(address indexed newManager); event ManagerRemoved(address indexed removedManager); modifier onlyManager() { require(managers[msg.sender] == true); _; } modifier isKnownCustomer(address _address) { require(!kycPending[_address] || certifier.certified(_address)); if (kycPending[_address]) { kycPending[_address] = false; } _; } constructor(address _certifier) public Certifiable(_certifier) { } function addManager(address _address) external onlyOwner { managers[_address] = true; emit ManagerAdded(_address); } function removeManager(address _address) external onlyOwner { managers[_address] = false; emit ManagerRemoved(_address); } } contract Certifier { event Confirmed(address indexed who); event Revoked(address indexed who); function certified(address) public constant returns (bool); function get(address, string) public constant returns (bytes32); function getAddress(address, string) public constant returns (address); function getUint(address, string) public constant returns (uint); } contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; /** * @dev Reverts if not in crowdsale time range. */ modifier onlyWhileOpen { // solium-disable-next-line security/no-block-members require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; } /** * @dev Constructor, takes crowdsale opening and closing times. * @param _openingTime Crowdsale opening time * @param _closingTime Crowdsale closing time */ function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public { // solium-disable-next-line security/no-block-members require(_openingTime >= block.timestamp); require(_closingTime >= _openingTime); openingTime = _openingTime; closingTime = _closingTime; } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { // solium-disable-next-line security/no-block-members return block.timestamp > closingTime; } /** * @dev Extend parent behavior requiring to be within contributing period * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } contract AllowanceCrowdsale is Crowdsale { using SafeMath for uint256; address public tokenWallet; /** * @dev Constructor, takes token wallet address. * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale */ function AllowanceCrowdsale(address _tokenWallet) public { require(_tokenWallet != address(0)); tokenWallet = _tokenWallet; } /** * @dev Checks the amount of tokens left in the allowance. * @return Amount of tokens left in the allowance */ function remainingTokens() public view returns (uint256) { return token.allowance(tokenWallet, this); } /** * @dev Overrides parent behavior by transferring tokens from wallet. * @param _beneficiary Token purchaser * @param _tokenAmount Amount of tokens purchased */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transferFrom(tokenWallet, _beneficiary, _tokenAmount); } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract ERC827 is ERC20 { function approveAndCall( address _spender, uint256 _value, bytes _data) public payable returns (bool); function transferAndCall( address _to, uint256 _value, bytes _data) public payable returns (bool); function transferFromAndCall( address _from, address _to, uint256 _value, bytes _data ) public payable returns (bool); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ERC827Token is ERC827, StandardToken { /** * @dev Addition to ERC20 token methods. It allows to * @dev approve the transfer of value and execute a call with the sent data. * * @dev Beware that changing an allowance with this method brings the risk that * @dev someone may use both the old and the new allowance by unfortunate * @dev transaction ordering. One possible solution to mitigate this race condition * @dev is to first reduce the spender's allowance to 0 and set the desired value * @dev afterwards: * @dev https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * @param _spender The address that will spend the funds. * @param _value The amount of tokens to be spent. * @param _data ABI-encoded contract call to call `_to` address. * * @return true if the call function was executed successfully */ function approveAndCall(address _spender, uint256 _value, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); // solium-disable-next-line security/no-call-value require(_spender.call.value(msg.value)(_data)); return true; } /** * @dev Addition to ERC20 token methods. Transfer tokens to a specified * @dev address and execute a call with the sent data on the same transaction * * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered * @param _data ABI-encoded contract call to call `_to` address. * * @return true if the call function was executed successfully */ function transferAndCall(address _to, uint256 _value, bytes _data) public payable returns (bool) { require(_to != address(this)); super.transfer(_to, _value); // solium-disable-next-line security/no-call-value require(_to.call.value(msg.value)(_data)); return true; } /** * @dev Addition to ERC20 token methods. Transfer tokens from one address to * @dev another and make a contract call on the same transaction * * @param _from The address which you want to send tokens from * @param _to The address which you want to transfer to * @param _value The amout of tokens to be transferred * @param _data ABI-encoded contract call to call `_to` address. * * @return true if the call function was executed successfully */ function transferFromAndCall( address _from, address _to, uint256 _value, bytes _data ) public payable returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); // solium-disable-next-line security/no-call-value require(_to.call.value(msg.value)(_data)); return true; } /** * @dev Addition to StandardToken methods. Increase the amount of tokens that * @dev an owner allowed to a spender and execute a call with the sent data. * * @dev approve should be called when allowed[_spender] == 0. To increment * @dev allowed value is better to use this function to avoid 2 calls (and wait until * @dev the first transaction is mined) * @dev From MonolithDAO Token.sol * * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. * @param _data ABI-encoded contract call to call `_spender` address. */ function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); // solium-disable-next-line security/no-call-value require(_spender.call.value(msg.value)(_data)); return true; } /** * @dev Addition to StandardToken methods. Decrease the amount of tokens that * @dev an owner allowed to a spender and execute a call with the sent data. * * @dev approve should be called when allowed[_spender] == 0. To decrement * @dev allowed value is better to use this function to avoid 2 calls (and wait until * @dev the first transaction is mined) * @dev From MonolithDAO Token.sol * * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. * @param _data ABI-encoded contract call to call `_spender` address. */ function decreaseApprovalAndCall(address _spender, uint _subtractedValue, bytes _data) public payable returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); // solium-disable-next-line security/no-call-value require(_spender.call.value(msg.value)(_data)); return true; } } contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract EDUToken is BurnableToken, KYCToken, ERC827Token { using SafeMath for uint256; string public constant name = \"EDU Token\"; string public constant symbol = \"EDU\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 48000000 * (10 ** uint256(decimals)); constructor(address _certifier) public KYCToken(_certifier) { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } function transfer(address _to, uint256 _value) public isKnownCustomer(msg.sender) returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public isKnownCustomer(_from) returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public isKnownCustomer(_spender) returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public isKnownCustomer(_spender) returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public isKnownCustomer(_spender) returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } function delayedTransferFrom(address _tokenWallet, address _to, uint256 _value) public onlyManager returns (bool) { transferFrom(_tokenWallet, _to, _value); kycPending[_to] = true; } } contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; /** * @dev Constructor, takes maximum amount of wei accepted in the crowdsale. * @param _cap Max amount of wei to be contributed */ function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Checks whether the cap has been reached. * @return Whether the cap was reached */ function capReached() public view returns (bool) { return weiRaised >= cap; } /** * @dev Extend parent behavior requiring purchase to respect the funding cap. * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } } contract EDUCrowdsale is AllowanceCrowdsale, CappedCrowdsale, TimedCrowdsale, Ownable, Certifiable { using SafeMath for uint256; uint256 constant FIFTY_ETH = 50 * (10 ** 18); uint256 constant HUNDRED_AND_FIFTY_ETH = 150 * (10 ** 18); uint256 constant TWO_HUNDRED_AND_FIFTY_ETH = 250 * (10 ** 18); uint256 constant TEN_ETH = 10 * (10 ** 18); EDUToken public token; event TokenWalletChanged(address indexed newTokenWallet); event WalletChanged(address indexed newWallet); constructor( address _wallet, EDUToken _token, address _tokenWallet, uint256 _cap, uint256 _openingTime, uint256 _closingTime, address _certifier ) public Crowdsale(getCurrentRate(), _wallet, _token) AllowanceCrowdsale(_tokenWallet) CappedCrowdsale(_cap) TimedCrowdsale(_openingTime, _closingTime) Certifiable(_certifier) { token = _token; } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { if (certifier.certified(_beneficiary)) { token.transferFrom(tokenWallet, _beneficiary, _tokenAmount); } else { token.delayedTransferFrom(tokenWallet, _beneficiary, _tokenAmount); } } /** * @dev Returns the rate of tokens per wei at the present time. * Note that, as price _increases_ with time, the rate _decreases_. * @return The number of tokens a buyer gets per wei at a given time */ function getCurrentRate() public view returns (uint256) { if (block.timestamp < 1528156799) {         // 4th of June 2018 23:59:59 GTC return 1050; } else if (block.timestamp < 1528718400) {  // 11th of June 2018 12:00:00 GTC return 940; } else if (block.timestamp < 1529323200) {  // 18th of June 2018 12:00:00 GTC return 865; } else if (block.timestamp < 1529928000) {  // 25th of June 2018 12:00:00 GTC return 790; } else { return 750; } } /** * @dev Overrides parent method taking into account variable rate. * @param _weiAmount The value in wei to be converted into tokens * @return The number of tokens _weiAmount wei will buy at present time */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 currentRate = getCurrentRate(); uint256 volumeBonus = _getVolumeBonus(currentRate, _weiAmount); return currentRate.mul(_weiAmount).add(volumeBonus); } function _getVolumeBonus(uint256 _currentRate, uint256 _weiAmount) internal view returns (uint256) { if (_weiAmount >= TEN_ETH) { return _currentRate.mul(_weiAmount).mul(20).div(100); } return 0; } function changeTokenWallet(address _tokenWallet) external onlyOwner { require(_tokenWallet != address(0x0)); tokenWallet = _tokenWallet; emit TokenWalletChanged(_tokenWallet); } function changeWallet(address _wallet) external onlyOwner { require(_wallet != address(0x0)); wallet = _wallet; emit WalletChanged(_wallet); } } "}
{"sol name": "8305.sol", "label": 1, "sol content": "pragma solidity ^0.4.19; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract GigERC20 is StandardToken, Ownable { /* Public variables of the token */ uint256 public creationBlock; uint8 public decimals; string public name; string public symbol; string public standard; bool public locked; /* Initializes contract with initial supply tokens to the creator of the contract */ function GigERC20( uint256 _totalSupply, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, bool _transferAllSupplyToOwner, bool _locked ) public { standard = 'ERC20 0.1'; locked = _locked; totalSupply_ = _totalSupply; if (_transferAllSupplyToOwner) { balances[msg.sender] = totalSupply_; } else { balances[this] = totalSupply_; } name = _tokenName; // Set the name for display purposes symbol = _tokenSymbol; // Set the symbol for display purposes decimals = _decimalUnits; // Amount of decimals for display purposes creationBlock = block.number; } function setLocked(bool _locked) public onlyOwner { locked = _locked; } /* public methods */ function transfer(address _to, uint256 _value) public returns (bool) { require(locked == false); return super.transfer(_to, _value); } function approve(address _spender, uint256 _value) public returns (bool success) { if (locked) { return false; } return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public returns (bool success) { if (locked) { return false; } return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) { if (locked) { return false; } return super.decreaseApproval(_spender, _subtractedValue); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (locked) { return false; } return super.transferFrom(_from, _to, _value); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /* This contract manages the minters and the modifier to allow mint to happen only if called by minters This contract contains basic minting functionality though */ contract MintingERC20 is GigERC20 { using SafeMath for uint256; //Variables mapping (address => bool) public minters; uint256 public maxSupply; //Modifiers modifier onlyMinters () { require(true == minters[msg.sender]); _; } function MintingERC20( uint256 _initialSupply, uint256 _maxSupply, string _tokenName, uint8 _decimals, string _symbol, bool _transferAllSupplyToOwner, bool _locked ) public GigERC20(_initialSupply, _tokenName, _decimals, _symbol, _transferAllSupplyToOwner, _locked) { standard = 'MintingERC20 0.1'; minters[msg.sender] = true; maxSupply = _maxSupply; } function addMinter(address _newMinter) public onlyOwner { minters[_newMinter] = true; } function removeMinter(address _minter) public onlyOwner { minters[_minter] = false; } function mint(address _addr, uint256 _amount) public onlyMinters returns (uint256) { if (true == locked) { return uint256(0); } if (_amount == uint256(0)) { return uint256(0); } if (totalSupply_.add(_amount) > maxSupply) { return uint256(0); } totalSupply_ = totalSupply_.add(_amount); balances[_addr] = balances[_addr].add(_amount); Transfer(address(0), _addr, _amount); return _amount; } } /* Tests: - check that created token has correct name, symbol, decimals, locked, maxSupply - check that setPrivateSale updates privateSale, and not affects crowdSaleEndTime - check that setCrowdSale updates crowdSale, and changes crowdSaleEndTime - check that trasnferFrom, approve, increaseApproval, decreaseApproval are forbidden to call before end of ICO - check that burn is not allowed to call before end of CrowdSale - check that increaseLockedBalance only increases investor locked amount - check that isTransferAllowed failed if transferFrozen - check that isTransferAllowed failed if user has not enough unlocked balance - check that isTransferAllowed failed if user has not enough unlocked balance, after transfering enough tokens balance - check that isTransferAllowed succeed if user has enough unlocked balance - check that isTransferAllowed succeed if user has enough unlocked balance, after transfering enough tokens balance */ contract GigToken is MintingERC20 { SellableToken public crowdSale; // Pre ICO & ICO SellableToken public privateSale; bool public transferFrozen = false; uint256 public crowdSaleEndTime; mapping(address => uint256) public lockedBalancesReleasedAfterOneYear; modifier onlyCrowdSale() { require(crowdSale != address(0) && msg.sender == address(crowdSale)); _; } modifier onlySales() { require((privateSale != address(0) && msg.sender == address(privateSale)) || (crowdSale != address(0) && msg.sender == address(crowdSale))); _; } event MaxSupplyBurned(uint256 burnedTokens); function GigToken(bool _locked) public MintingERC20(0, maxSupply, 'GigBit', 18, 'GBTC', false, _locked) { standard = 'GBTC 0.1'; maxSupply = uint256(1000000000).mul(uint256(10) ** decimals); } function setCrowdSale(address _crowdSale) public onlyOwner { require(_crowdSale != address(0)); crowdSale = SellableToken(_crowdSale); crowdSaleEndTime = crowdSale.endTime(); } function setPrivateSale(address _privateSale) public onlyOwner { require(_privateSale != address(0)); privateSale = SellableToken(_privateSale); } function freezing(bool _transferFrozen) public onlyOwner { transferFrozen = _transferFrozen; } function isTransferAllowed(address _from, uint256 _value) public view returns (bool status) { uint256 senderBalance = balanceOf(_from); if (transferFrozen == true || senderBalance < _value) { return false; } uint256 lockedBalance = lockedBalancesReleasedAfterOneYear[_from]; // check if holder tries to transfer more than locked tokens if (lockedBalance > 0 && senderBalance.sub(_value) < lockedBalance) { uint256 unlockTime = crowdSaleEndTime + 1 years; // fail if unlock time is not come if (crowdSaleEndTime == 0 || block.timestamp < unlockTime) { return false; } uint256 secsFromUnlock = block.timestamp.sub(unlockTime); // number of months over from unlock uint256 months = secsFromUnlock / 30 days; if (months > 12) { months = 12; } uint256 tokensPerMonth = lockedBalance / 12; uint256 unlockedBalance = tokensPerMonth.mul(months); uint256 actualLockedBalance = lockedBalance.sub(unlockedBalance); if (senderBalance.sub(_value) < actualLockedBalance) { return false; } } if (block.timestamp < crowdSaleEndTime && crowdSale != address(0) && crowdSale.isTransferAllowed(_from, _value) == false ) { return false; } return true; } function transfer(address _to, uint _value) public returns (bool) { require(isTransferAllowed(msg.sender, _value)); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { // transferFrom & approve are disabled before end of ICO require((crowdSaleEndTime <= block.timestamp) && isTransferAllowed(_from, _value)); return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public returns (bool success) { // transferFrom & approve are disabled before end of ICO require(crowdSaleEndTime <= block.timestamp); return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public returns (bool success) { // transferFrom & approve are disabled before end of ICO require(crowdSaleEndTime <= block.timestamp); return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool success) { // transferFrom & approve are disabled before end of ICO require(crowdSaleEndTime <= block.timestamp); return super.decreaseApproval(_spender, _subtractedValue); } function increaseLockedBalance(address _address, uint256 _tokens) public onlySales { lockedBalancesReleasedAfterOneYear[_address] = lockedBalancesReleasedAfterOneYear[_address].add(_tokens); } // burn tokens if soft cap is not reached function burnInvestorTokens( address _address, uint256 _amount ) public onlyCrowdSale returns (uint256) { require(block.timestamp > crowdSaleEndTime); require(_amount <= balances[_address]); balances[_address] = balances[_address].sub(_amount); totalSupply_ = totalSupply_.sub(_amount); Transfer(_address, address(0), _amount); return _amount; } // decrease max supply of tokens that are not sold function burnUnsoldTokens(uint256 _amount) public onlyCrowdSale { require(block.timestamp > crowdSaleEndTime); maxSupply = maxSupply.sub(_amount); MaxSupplyBurned(_amount); } } contract Multivest is Ownable { using SafeMath for uint256; /* public variables */ mapping (address => bool) public allowedMultivests; /* events */ event MultivestSet(address multivest); event MultivestUnset(address multivest); event Contribution(address holder, uint256 value, uint256 tokens); modifier onlyAllowedMultivests(address _addresss) { require(allowedMultivests[_addresss] == true); _; } /* constructor */ function Multivest() public {} function setAllowedMultivest(address _address) public onlyOwner { allowedMultivests[_address] = true; MultivestSet(_address); } function unsetAllowedMultivest(address _address) public onlyOwner { allowedMultivests[_address] = false; MultivestUnset(_address); } function multivestBuy(address _address, uint256 _value) public onlyAllowedMultivests(msg.sender) { require(buy(_address, _value) == true); } function multivestBuy( address _address, uint8 _v, bytes32 _r, bytes32 _s ) public payable onlyAllowedMultivests(verify(keccak256(msg.sender), _v, _r, _s)) { require(_address == msg.sender && buy(msg.sender, msg.value) == true); } function verify(bytes32 _hash, uint8 _v, bytes32 _r, bytes32 _s) internal pure returns (address) { bytes memory prefix = '\\x19Ethereum Signed Message:\\n32'; return ecrecover(keccak256(prefix, _hash), _v, _r, _s); } function buy(address _address, uint256 _value) internal returns (bool); } contract SellableToken is Multivest { uint256 public constant MONTH_IN_SEC = 2629743; GigToken public token; uint256 public minPurchase = 100 * 10 ** 5; uint256 public maxPurchase; uint256 public softCap; uint256 public hardCap; uint256 public startTime; uint256 public endTime; uint256 public maxTokenSupply; uint256 public soldTokens; uint256 public collectedEthers; address public etherHolder; uint256 public collectedUSD; uint256 public etherPriceInUSD; uint256 public priceUpdateAt; mapping(address => uint256) public etherBalances; Tier[] public tiers; struct Tier { uint256 discount; uint256 startTime; uint256 endTime; } event Refund(address _holder, uint256 _ethers, uint256 _tokens); event NewPriceTicker(string _price); function SellableToken( address _token, address _etherHolder, uint256 _startTime, uint256 _endTime, uint256 _maxTokenSupply, uint256 _etherPriceInUSD ) public Multivest() { require(_token != address(0) && _etherHolder != address(0)); token = GigToken(_token); require(_startTime < _endTime); etherHolder = _etherHolder; require((_maxTokenSupply == uint256(0)) || (_maxTokenSupply <= token.maxSupply())); startTime = _startTime; endTime = _endTime; maxTokenSupply = _maxTokenSupply; etherPriceInUSD = _etherPriceInUSD; priceUpdateAt = block.timestamp; } function setTokenContract(address _token) public onlyOwner { require(_token != address(0)); token = GigToken(_token); } function setEtherHolder(address _etherHolder) public onlyOwner { if (_etherHolder != address(0)) { etherHolder = _etherHolder; } } function setPurchaseLimits(uint256 _min, uint256 _max) public onlyOwner { if (_min < _max) { minPurchase = _min; maxPurchase = _max; } } function mint(address _address, uint256 _tokenAmount) public onlyOwner returns (uint256) { return mintInternal(_address, _tokenAmount); } function isActive() public view returns (bool); function isTransferAllowed(address _from, uint256 _value) public view returns (bool); function withinPeriod() public view returns (bool); function getMinEthersInvestment() public view returns (uint256) { return uint256(1 ether).mul(minPurchase).div(etherPriceInUSD); } function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount); function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 bonus); function updatePreICOMaxTokenSupply(uint256 _amount) public; // set ether price in USD with 5 digits after the decimal point //ex. 308.75000 //for updating the price through  multivest function setEtherInUSD(string _price) public onlyAllowedMultivests(msg.sender) { bytes memory bytePrice = bytes(_price); uint256 dot = bytePrice.length.sub(uint256(6)); // check if dot is in 6 position  from  the last require(0x2e == uint(bytePrice[dot])); uint256 newPrice = uint256(10 ** 23).div(parseInt(_price, 5)); require(newPrice > 0); etherPriceInUSD = parseInt(_price, 5); priceUpdateAt = block.timestamp; NewPriceTicker(_price); } function mintInternal(address _address, uint256 _tokenAmount) internal returns (uint256) { uint256 mintedAmount = token.mint(_address, _tokenAmount); require(mintedAmount == _tokenAmount); soldTokens = soldTokens.add(_tokenAmount); if (maxTokenSupply > 0) { require(maxTokenSupply >= soldTokens); } return _tokenAmount; } function transferEthers() internal; function parseInt(string _a, uint _b) internal pure returns (uint) { bytes memory bresult = bytes(_a); uint res = 0; bool decimals = false; for (uint i = 0; i < bresult.length; i++) { if ((bresult[i] >= 48) && (bresult[i] <= 57)) { if (decimals) { if (_b == 0) break; else _b--; } res *= 10; res += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) res *= 10 ** _b; return res; } } contract CrowdSale is SellableToken { uint256 public constant PRE_ICO_TIER_FIRST = 0; uint256 public constant PRE_ICO_TIER_LAST = 4; uint256 public constant ICO_TIER_FIRST = 5; uint256 public constant ICO_TIER_LAST = 8; SellableToken public privateSale; uint256 public price; Stats public preICOStats; mapping(address => uint256) public icoBalances; struct Stats { uint256 soldTokens; uint256 maxTokenSupply; uint256 collectedUSD; uint256 collectedEthers; bool burned; } function CrowdSale( address _token, address _etherHolder, uint256 _maxPreICOTokenSupply, //10000000000000000000000000-527309544043097299200271 + 177500000000000000000000000 = 186972690455956902700799729 uint256 _maxICOTokenSupply, //62500000000000000000000000 uint256 _price, uint256[2] _preIcoDuration, //1530432000  -1533081599 uint256[2] _icoDuration, // 1533110400 - 1538351999 uint256 _etherPriceInUSD ) public SellableToken( _token, _etherHolder, _preIcoDuration[0], _icoDuration[1], _maxPreICOTokenSupply.add(_maxICOTokenSupply), _etherPriceInUSD ) { softCap = 250000000000; hardCap = 3578912800000; price = _price; preICOStats.maxTokenSupply = _maxPreICOTokenSupply; //0.2480* 10^5 //PreICO tiers.push( Tier( uint256(65), _preIcoDuration[0], _preIcoDuration[0].add(1 hours) ) ); tiers.push( Tier( uint256(60), _preIcoDuration[0].add(1 hours), _preIcoDuration[0].add(1 days) ) ); tiers.push( Tier( uint256(57), _preIcoDuration[0].add(1 days), _preIcoDuration[0].add(2 days) ) ); tiers.push( Tier( uint256(55), _preIcoDuration[0].add(2 days), _preIcoDuration[0].add(3 days) ) ); tiers.push( Tier( uint256(50), _preIcoDuration[0].add(3 days), _preIcoDuration[1] ) ); //ICO tiers.push( Tier( uint256(25), _icoDuration[0], _icoDuration[0].add(1 weeks) ) ); tiers.push( Tier( uint256(15), _icoDuration[0].add(1 weeks), _icoDuration[0].add(2 weeks) ) ); tiers.push( Tier( uint256(10), _icoDuration[0].add(2 weeks), _icoDuration[0].add(3 weeks) ) ); tiers.push( Tier( uint256(5), _icoDuration[0].add(3 weeks), _icoDuration[1] ) ); } function changeICODates(uint256 _tierId, uint256 _start, uint256 _end) public onlyOwner { require(_start != 0 && _start < _end && _tierId < tiers.length); Tier storage icoTier = tiers[_tierId]; icoTier.startTime = _start; icoTier.endTime = _end; if (_tierId == PRE_ICO_TIER_FIRST) { startTime = _start; } else if (_tierId == ICO_TIER_LAST) { endTime = _end; } } function isActive() public view returns (bool) { if (hardCap == collectedUSD.add(preICOStats.collectedUSD)) { return false; } if (soldTokens == maxTokenSupply) { return false; } return withinPeriod(); } function withinPeriod() public view returns (bool) { return getActiveTier() != tiers.length; } function setPrivateSale(address _privateSale) public onlyOwner { if (_privateSale != address(0)) { privateSale = SellableToken(_privateSale); } } function getActiveTier() public view returns (uint256) { for (uint256 i = 0; i < tiers.length; i++) { if (block.timestamp >= tiers[i].startTime && block.timestamp <= tiers[i].endTime) { return i; } } return uint256(tiers.length); } function calculateTokensAmount(uint256 _value) public view returns (uint256 tokenAmount, uint256 usdAmount) { if (_value == 0) { return (0, 0); } uint256 activeTier = getActiveTier(); if (activeTier == tiers.length) { if (endTime < block.timestamp) { return (0, 0); } if (startTime > block.timestamp) { activeTier = PRE_ICO_TIER_FIRST; } } usdAmount = _value.mul(etherPriceInUSD); tokenAmount = usdAmount.div(price * (100 - tiers[activeTier].discount) / 100); usdAmount = usdAmount.div(uint256(10) ** 18); if (usdAmount < minPurchase) { return (0, 0); } } function calculateEthersAmount(uint256 _tokens) public view returns (uint256 ethers, uint256 usdAmount) { if (_tokens == 0) { return (0, 0); } uint256 activeTier = getActiveTier(); if (activeTier == tiers.length) { if (endTime < block.timestamp) { return (0, 0); } if (startTime > block.timestamp) { activeTier = PRE_ICO_TIER_FIRST; } } usdAmount = _tokens.mul((price * (100 - tiers[activeTier].discount) / 100)); ethers = usdAmount.div(etherPriceInUSD); if (ethers < getMinEthersInvestment()) { return (0, 0); } usdAmount = usdAmount.div(uint256(10) ** 18); } function getStats(uint256 _ethPerBtc) public view returns ( uint256 sold, uint256 maxSupply, uint256 min, uint256 soft, uint256 hard, uint256 tokenPrice, uint256 tokensPerEth, uint256 tokensPerBtc, uint256[24] tiersData ) { sold = soldTokens; maxSupply = maxTokenSupply.sub(preICOStats.maxTokenSupply); min = minPurchase; soft = softCap; hard = hardCap; tokenPrice = price; uint256 usd; (tokensPerEth, usd) = calculateTokensAmount(1 ether); (tokensPerBtc, usd) = calculateTokensAmount(_ethPerBtc); uint256 j = 0; for (uint256 i = 0; i < tiers.length; i++) { tiersData[j++] = uint256(tiers[i].discount); tiersData[j++] = uint256(tiers[i].startTime); tiersData[j++] = uint256(tiers[i].endTime); } } function burnUnsoldTokens() public onlyOwner { if (block.timestamp >= endTime && maxTokenSupply > soldTokens) { token.burnUnsoldTokens(maxTokenSupply.sub(soldTokens)); maxTokenSupply = soldTokens; } } function isTransferAllowed(address _from, uint256 _value) public view returns (bool status){ if (collectedUSD.add(preICOStats.collectedUSD) < softCap) { if (token.balanceOf(_from) >= icoBalances[_from] && token.balanceOf(_from).sub(icoBalances[_from])> _value) { return true; } return false; } return true; } function isRefundPossible() public view returns (bool) { if (isActive() || block.timestamp < startTime || collectedUSD.add(preICOStats.collectedUSD) >= softCap) { return false; } return true; } function refund() public returns (bool) { if (!isRefundPossible() || etherBalances[msg.sender] == 0) { return false; } uint256 burnedAmount = token.burnInvestorTokens(msg.sender, icoBalances[msg.sender]); if (burnedAmount == 0) { return false; } uint256 etherBalance = etherBalances[msg.sender]; etherBalances[msg.sender] = 0; msg.sender.transfer(etherBalance); Refund(msg.sender, etherBalance, burnedAmount); return true; } function updatePreICOMaxTokenSupply(uint256 _amount) public { if (msg.sender == address(privateSale)) { maxTokenSupply = maxTokenSupply.add(_amount); preICOStats.maxTokenSupply = preICOStats.maxTokenSupply.add(_amount); } } function moveUnsoldTokensToICO() public onlyOwner { uint256 unsoldTokens = preICOStats.maxTokenSupply - preICOStats.soldTokens; if (unsoldTokens > 0) { preICOStats.maxTokenSupply = preICOStats.soldTokens; } } function transferEthers() internal { if (collectedUSD.add(preICOStats.collectedUSD) >= softCap) { etherHolder.transfer(this.balance); } } function mintPreICO( address _address, uint256 _tokenAmount, uint256 _ethAmount, uint256 _usdAmount ) internal returns (uint256) { uint256 mintedAmount = token.mint(_address, _tokenAmount); require(mintedAmount == _tokenAmount); preICOStats.soldTokens = preICOStats.soldTokens.add(_tokenAmount); preICOStats.collectedEthers = preICOStats.collectedEthers.add(_ethAmount); preICOStats.collectedUSD = preICOStats.collectedUSD.add(_usdAmount); require(preICOStats.maxTokenSupply >= preICOStats.soldTokens); require(maxTokenSupply >= preICOStats.soldTokens); return _tokenAmount; } function buy(address _address, uint256 _value) internal returns (bool) { if (_value == 0 || _address == address(0)) { return false; } uint256 activeTier = getActiveTier(); if (activeTier == tiers.length) { return false; } uint256 tokenAmount; uint256 usdAmount; uint256 mintedAmount; (tokenAmount, usdAmount) = calculateTokensAmount(_value); require(usdAmount > 0 && tokenAmount > 0); if (activeTier >= PRE_ICO_TIER_FIRST && activeTier <= PRE_ICO_TIER_LAST) { mintedAmount = mintPreICO(_address, tokenAmount, _value, usdAmount); etherHolder.transfer(this.balance); } else { mintedAmount = mintInternal(_address, tokenAmount); require(soldTokens <= maxTokenSupply.sub(preICOStats.maxTokenSupply)); collectedUSD = collectedUSD.add(usdAmount); require(hardCap >= collectedUSD.add(preICOStats.collectedUSD) && usdAmount > 0 && mintedAmount > 0); collectedEthers = collectedEthers.add(_value); etherBalances[_address] = etherBalances[_address].add(_value); icoBalances[_address] = icoBalances[_address].add(tokenAmount); transferEthers(); } Contribution(_address, _value, tokenAmount); return true; } } "}
{"sol name": "11021.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; /* * Ownable * * Base contract with an owner. * Provides onlyOwner modifier, which prevents function from running if it is called by anyone other than the owner. */ contract Ownable { address public owner; constructor(){ owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { revert(); } _; } //transfer owner to another address function transferOwnership(address _newOwner) onlyOwner { if (_newOwner != address(0)) { owner = _newOwner; } } } /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { revert(); } } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token ,SafeMath{ /** * * Fix for the ERC20 short address attack * * http://vessenes.com/the-erc20-short-address-attack-explained/ */ modifier onlyPayloadSize(uint size) { if(msg.data.length != size + 4) { revert(); } _; } //transfer lock flag bool transferLock = true; //transfer modifier modifier canTransfer() { if (transferLock) { revert(); } _; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) canTransfer returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) canTransfer returns (bool success) { uint256 _allowance = allowed[_from][msg.sender]; allowed[_from][msg.sender] = safeSub(_allowance, _value); balances[_from] = safeSub(balances[_from], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) canTransfer returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert(); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract PAIStandardToken is StandardToken,Ownable{ /* Public variables of the token */ string public name;                   // name: eg pchain uint256 public decimals;              //How many decimals to show. string public symbol;                 //An identifier: eg PAI address public wallet;                //ETH wallet address uint public start;                    //crowd sale start time uint public end;                      //Crowd sale first phase end time uint public deadline;                 // Crowd sale deadline time uint256 public teamShare = 25;        //Team share uint256 public foundationShare = 25;  //Foundation share uint256 public posShare = 15;         //POS share uint256 public saleShare = 35;     //Private share address internal saleAddr;                                 //private sale wallet address uint256 public crowdETHTotal = 0;                 //The ETH amount of current crowdsale mapping (address => uint256) public crowdETHs;    //record user's balance of crowdsale uint256 public crowdPrice = 10000;                //crowdsale price 1(ETH):10000(PAI) uint256 public crowdTarget = 5000 ether;          //The total ETH of crowdsale bool public reflectSwitch = false;                // Whether to allow user to reflect PAI bool public blacklistSwitch = true;               // Whether to allow owner to set blacklist mapping(address => string) public reflects;       // reflect token to PAI address event PurchaseSuccess(address indexed _addr, uint256 _weiAmount,uint256 _crowdsaleEth,uint256 _balance); event EthSweepSuccess(address indexed _addr, uint256 _value); event SetReflectSwitchEvent(bool _b); event ReflectEvent(address indexed _addr,string _paiAddr); event BlacklistEvent(address indexed _addr,uint256 _b); event SetTransferLockEvent(bool _b); event CloseBlacklistSwitchEvent(bool _b); constructor( address _wallet, uint _s, uint _e, uint _d, address _teamAddr, address _fundationAddr, address _saleAddr, address _posAddr ) { totalSupply = 2100000000000000000000000000;       // Update total supply name = \"PCHAIN\";                  // Set the name for display purposes decimals = 18;           // Amount of decimals for display purposes symbol = \"PAI\";              // Set the symbol for display purposes wallet = _wallet;                   // Set ETH wallet address start = _s;                         // Set start time for crowsale end = _e;                           // Set Crowd sale first phase end time deadline = _d;                      // Set Crowd sale deadline time saleAddr = _saleAddr; // Set sale account address balances[_teamAddr] = safeMul(safeDiv(totalSupply,100),teamShare); //Team balance balances[_fundationAddr] = safeMul(safeDiv(totalSupply,100),foundationShare); //Foundation balance balances[_posAddr] = safeMul(safeDiv(totalSupply,100),posShare); //POS balance balances[_saleAddr] = safeMul(safeDiv(totalSupply,100),saleShare) ; //Sale balance Transfer(address(0), _teamAddr,  balances[_teamAddr]); Transfer(address(0), _fundationAddr,  balances[_fundationAddr]); Transfer(address(0), _posAddr,  balances[_posAddr]); Transfer(address(0), _saleAddr,  balances[_saleAddr]); } //set transfer lock function setTransferLock(bool _lock) onlyOwner{ transferLock = _lock; SetTransferLockEvent(_lock); } //Permanently turn off the blacklist switch function closeBlacklistSwitch() onlyOwner{ blacklistSwitch = false; CloseBlacklistSwitchEvent(false); } //set blacklist function setBlacklist(address _addr) onlyOwner{ require(blacklistSwitch); uint256 tokenAmount = balances[_addr];             //calculate user token amount balances[_addr] = 0;//clear user\u2018s PAI balance balances[saleAddr] = safeAdd(balances[saleAddr],tokenAmount);  //add PAI tokenAmount to Sale Transfer(_addr, saleAddr, tokenAmount); BlacklistEvent(_addr,tokenAmount); } //set reflect switch function setReflectSwitch(bool _s) onlyOwner{ reflectSwitch = _s; SetReflectSwitchEvent(_s); } function reflect(string _paiAddress){ require(reflectSwitch); reflects[msg.sender] = _paiAddress; ReflectEvent(msg.sender,_paiAddress); } function purchase() payable{ require(block.timestamp <= deadline);                                 //the timestamp must be less than the deadline time require(tx.gasprice <= 60000000000); require(block.timestamp >= start);                                //the timestamp must be greater than the start time uint256 weiAmount = msg.value;                                    // The amount purchased by the current user require(weiAmount >= 0.1 ether); crowdETHTotal = safeAdd(crowdETHTotal,weiAmount);                 // Calculate the total amount purchased by all users require(crowdETHTotal <= crowdTarget);                            // The total amount is less than or equal to the target amount uint256 userETHTotal = safeAdd(crowdETHs[msg.sender],weiAmount);  // Calculate the total amount purchased by the current user if(block.timestamp <= end){                                       // whether the current timestamp is in the first phase require(userETHTotal <= 0.4 ether);                             // whether the total amount purchased by the current user is less than 0.4ETH }else{ require(userETHTotal <= 10 ether);                              // whether the total amount purchased by the current user is less than 10ETH } crowdETHs[msg.sender] = userETHTotal;                             // Record the total amount purchased by the current user uint256 tokenAmount = safeMul(weiAmount,crowdPrice);             //calculate user token amount balances[msg.sender] = safeAdd(tokenAmount,balances[msg.sender]);//recharge user\u2018s PAI balance balances[saleAddr] = safeSub(balances[saleAddr],tokenAmount);  //sub PAI tokenAmount from  Sale wallet.transfer(weiAmount); Transfer(saleAddr, msg.sender, tokenAmount); PurchaseSuccess(msg.sender,weiAmount,crowdETHs[msg.sender],tokenAmount); } function () payable{ purchase(); } } "}
{"sol name": "11416.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardToken { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state throw; } // Validate input value. if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); // Take tokens out from circulation totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading throw; } if (agent == 0x0) throw; // Only a master can designate the next agent if (msg.sender != upgradeMaster) throw; // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) throw; // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; /* Minimum ammount of tokens every buyer can buy. */ uint public minCap; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; // Create initially all balance on the team multisig balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { throw; // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } /** * Claim tokens that were accidentally sent to this contract. * * @param _token The address of the token contract that you want to recover. */ function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } /** * The default behavior for the crowdsale end. * * Unlock tokens. */ contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } //distributes reserved tokens. Should be called before finalization function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); // How many % of tokens the founders and others get uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; // move reserved tokens for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
{"sol name": "6404.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "10808.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "6403.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardToken { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state throw; } // Validate input value. if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); // Take tokens out from circulation totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading throw; } if (agent == 0x0) throw; // Only a master can designate the next agent if (msg.sender != upgradeMaster) throw; // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) throw; // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; /* Minimum ammount of tokens every buyer can buy. */ uint public minCap; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; // Create initially all balance on the team multisig balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { throw; // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } /** * Claim tokens that were accidentally sent to this contract. * * @param _token The address of the token contract that you want to recover. */ function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } /** * The default behavior for the crowdsale end. * * Unlock tokens. */ contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } //distributes reserved tokens. Should be called before finalization function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); // How many % of tokens the founders and others get uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; // move reserved tokens for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
{"sol name": "6833.sol", "label": 1, "sol content": "pragma solidity ^0.4.21; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract MOEToken is ERC20 { using SafeMath for uint256; address public owner; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; string public name = \"MOE's game art foundation\"; string public constant symbol = \"MOE\"; uint public constant decimals = 18; bool public stopped; modifier stoppable { assert(!stopped); _; } uint256 public totalSupply = 1000000000*(10**18); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event LOCK(address indexed _owner, uint256 _value); mapping (address => uint256) public lockAddress; modifier lock(address _add){ require(_add != address(0)); uint256 releaseTime = lockAddress[_add]; if(releaseTime > 0){ require(block.timestamp >= releaseTime); _; }else{ _; } } modifier onlyOwner() { require(msg.sender == owner); _; } function MOEToken() public { owner = msg.sender; balances[msg.sender] = totalSupply; } function stop() onlyOwner public { stopped = true; } function start() onlyOwner public { stopped = false; } function lockTime(address _to,uint256 _value) onlyOwner public { if(_value > block.timestamp){ lockAddress[_to] = _value; emit LOCK(_to, _value); } } function lockOf(address _owner) constant public returns (uint256) { return lockAddress[_owner]; } function transferOwnership(address _newOwner) onlyOwner public { if (_newOwner != address(0)) { owner = _newOwner; } } function () public payable { address myAddress = this; emit Transfer(msg.sender, myAddress, msg.value); } function balanceOf(address _owner) constant public returns (uint256) { return balances[_owner]; } function transfer(address _to, uint256 _amount) stoppable lock(msg.sender) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(msg.sender, _to, _amount); return true; } function transferFrom(address _from, uint256 _amount) stoppable lock(_from) public returns (bool success) { require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[msg.sender] = balances[msg.sender].add(_amount); emit Transfer(_from, msg.sender, _amount); return true; } function approve(address _spender, uint256 _value) stoppable lock(_spender) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender)  constant public returns (uint256) { return allowed[_owner][_spender]; } function withdraw() onlyOwner public { address myAddress = this; uint256 etherBalance = myAddress.balance; owner.transfer(etherBalance); } function kill() onlyOwner public { selfdestruct(msg.sender); } function setName(string _name) onlyOwner public  { name = _name; } } "}
{"sol name": "9300.sol", "label": 1, "sol content": "pragma solidity 0.4.24; // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei. // The rate is the conversion between wei and the smallest and indivisible token unit. // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK // 1 wei will give you 1 unit, or 0.001 TOK. uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } // File: contracts/DynamicRateCrowdsale.sol contract DynamicRateCrowdsale is Crowdsale { using SafeMath for uint256; // \u5956\u52b1\u6c47\u7387 uint256 public bonusRate; constructor(uint256 _bonusRate) public { require(_bonusRate > 0); bonusRate = _bonusRate; } function getCurrentRate() public view returns (uint256) { return rate.add(bonusRate); } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 currentRate = getCurrentRate(); return currentRate.mul(_weiAmount); } } // File: openzeppelin-solidity/contracts/crowdsale/emission/AllowanceCrowdsale.sol /** * @title AllowanceCrowdsale * @dev Extension of Crowdsale where tokens are held by a wallet, which approves an allowance to the crowdsale. */ contract AllowanceCrowdsale is Crowdsale { using SafeMath for uint256; address public tokenWallet; /** * @dev Constructor, takes token wallet address. * @param _tokenWallet Address holding the tokens, which has approved allowance to the crowdsale */ constructor(address _tokenWallet) public { require(_tokenWallet != address(0)); tokenWallet = _tokenWallet; } /** * @dev Checks the amount of tokens left in the allowance. * @return Amount of tokens left in the allowance */ function remainingTokens() public view returns (uint256) { return token.allowance(tokenWallet, this); } /** * @dev Overrides parent behavior by transferring tokens from wallet. * @param _beneficiary Token purchaser * @param _tokenAmount Amount of tokens purchased */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.transferFrom(tokenWallet, _beneficiary, _tokenAmount); } } // File: openzeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol /** * @title CappedCrowdsale * @dev Crowdsale with a limit for total contributions. */ contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; /** * @dev Constructor, takes maximum amount of wei accepted in the crowdsale. * @param _cap Max amount of wei to be contributed */ constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Checks whether the cap has been reached. * @return Whether the cap was reached */ function capReached() public view returns (bool) { return weiRaised >= cap; } /** * @dev Extend parent behavior requiring purchase to respect the funding cap. * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } } // File: openzeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol /** * @title TimedCrowdsale * @dev Crowdsale accepting contributions only within a time frame. */ contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; /** * @dev Reverts if not in crowdsale time range. */ modifier onlyWhileOpen { // solium-disable-next-line security/no-block-members require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; } /** * @dev Constructor, takes crowdsale opening and closing times. * @param _openingTime Crowdsale opening time * @param _closingTime Crowdsale closing time */ constructor(uint256 _openingTime, uint256 _closingTime) public { // solium-disable-next-line security/no-block-members require(_openingTime >= block.timestamp); require(_closingTime >= _openingTime); openingTime = _openingTime; closingTime = _closingTime; } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { // solium-disable-next-line security/no-block-members return block.timestamp > closingTime; } /** * @dev Extend parent behavior requiring to be within contributing period * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: contracts/EoptCrowdsale.sol contract EoptCrowdsale is Crowdsale, CappedCrowdsale, AllowanceCrowdsale, DynamicRateCrowdsale, TimedCrowdsale, Ownable { constructor( uint256 _rate, uint256 _bonusRate, address _wallet, ERC20 _token, uint256 _cap, address _tokenWallet, uint256 _openingTime, uint256 _closingTime ) Crowdsale(_rate, _wallet, _token) CappedCrowdsale(_cap) AllowanceCrowdsale(_tokenWallet) TimedCrowdsale(_openingTime, _closingTime) DynamicRateCrowdsale(_bonusRate) public { } // \u8d2d\u4e70\u4e8b\u4ef6 event Purchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 weiRaised, uint256 rate, uint256 bonusRate, uint256 cap ); function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { super._updatePurchasingState(_beneficiary, _weiAmount); uint256 tokens = _getTokenAmount(_weiAmount); emit Purchase( msg.sender, _beneficiary, _weiAmount, tokens, weiRaised, rate, bonusRate, cap ); } // \u8bbe\u7f6e\u6c47\u7387\uff0c1 ETH : N TOKEN function setRate(uint256 _rate) onlyOwner public { require(_rate > 0 && _rate < 1000000); rate = _rate; } // \u8bbe\u7f6e\u5956\u52b1\u6c47\u7387\uff0c1 ETH : N TOKEN(bonus) function setBonusRate(uint256 _bonusRate) onlyOwner public { require(_bonusRate > 0 && _bonusRate < 1000000); bonusRate = _bonusRate; } // \u8bbe\u7f6e\u4f17\u7b79\u7ed3\u675f\u65f6\u95f4 function setClosingTime(uint256 _closingTime) onlyOwner public { require(_closingTime >= block.timestamp); require(_closingTime >= openingTime); closingTime = _closingTime; } // \u8bbe\u7f6e\u4f17\u7b79\u603b\u91cf\u9650\u989d 0 < _cap < 50w ETH function setCap(uint256 _cap) onlyOwner public { require(_cap > 0 && _cap < 500000000000000000000000); cap = _cap; } // \u8bbe\u7f6eEOPT\u7684\u4ee3\u5e01\u5408\u7ea6\u5730\u5740 function setToken(ERC20 _token) onlyOwner public { require(_token != address(0)); token = _token; } // \u8bbe\u7f6e\u63d0\u4f9bEOPT\u7684\u94b1\u5305\u5730\u5740 function setTokenWallet(address _tokenWallet) onlyOwner public { require(_tokenWallet != address(0)); tokenWallet = _tokenWallet; } // \u8bbe\u7f6e\u63a5\u6536\u4f17\u7b79ETH\u7684\u94b1\u5305\u5730\u5740 function setWallet(address _wallet) onlyOwner public { require(_wallet != address(0)); wallet = _wallet; } } "}
{"sol name": "1051.sol", "label": 1, "sol content": "pragma solidity 0.4.23; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; constructor() public { owner = msg.sender; emit LogSetOwner(msg.sender); } function setOwner(address owner_) public auth { owner = owner_; emit LogSetOwner(owner); } function setAuthority(DSAuthority authority_) public auth { authority = authority_; emit LogSetAuthority(authority); } modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } } contract DSNote { event LogNote( bytes4   indexed sig, address  indexed guy, bytes32  indexed foo, bytes32  indexed bar, uint wad, bytes fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } emit LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } contract DSStop is DSNote, DSAuth { bool public stopped; modifier stoppable { require(!stopped); _; } function stop() public auth note { stopped = true; } function start() public auth note { stopped = false; } } contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); } function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); } function mul(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x); } } contract ERC20 { /// @return total amount of tokens function totalSupply() constant public returns (uint256 supply); /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant public returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant public returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Coin is ERC20, DSStop { string public name; string public symbol; uint8 public decimals = 18; uint256 internal c_totalSupply; mapping(address => uint256) internal c_balances; mapping(address => mapping(address => uint256)) internal c_approvals; function init(uint256 token_supply, string token_name, string token_symbol) internal { c_balances[msg.sender] = token_supply; c_totalSupply = token_supply; name = token_name; symbol = token_symbol; } function() public { assert(false); } function setName(string _name) auth public { name = _name; } function totalSupply() constant public returns (uint256) { return c_totalSupply; } function balanceOf(address _owner) constant public returns (uint256) { return c_balances[_owner]; } function approve(address _spender, uint256 _value) public stoppable returns (bool) { require(msg.data.length >= (2 * 32) + 4); require(_value == 0 || c_approvals[msg.sender][_spender] == 0); // uint never less than 0. The negative number will become to a big positive number require(_value < c_totalSupply); c_approvals[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns (uint256) { return c_approvals[_owner][_spender]; } } contract FreezerAuthority is DSAuthority { address[] internal c_freezers; // sha3(\"setFreezing(address,uint256,uint256,uint8)\").slice(0,10) bytes4 constant setFreezingSig = bytes4(0x51c3b8a6); // sha3(\"transferAndFreezing(address,uint256,uint256,uint256,uint8)\").slice(0,10) bytes4 constant transferAndFreezingSig = bytes4(0xb8a1fdb6); function canCall(address caller, address, bytes4 sig) public view returns (bool) { // freezer can call setFreezing, transferAndFreezing if (isFreezer(caller) && (sig == setFreezingSig || sig == transferAndFreezingSig)) { return true; } else { return false; } } function addFreezer(address freezer) public { int i = indexOf(c_freezers, freezer); if (i < 0) { c_freezers.push(freezer); } } function removeFreezer(address freezer) public { int index = indexOf(c_freezers, freezer); if (index >= 0) { uint i = uint(index); while (i < c_freezers.length - 1) { c_freezers[i] = c_freezers[i + 1]; } c_freezers.length--; } } /** Finds the index of a given value in an array. */ function indexOf(address[] values, address value) internal pure returns (int) { uint i = 0; while (i < values.length) { if (values[i] == value) { return int(i); } i++; } return int(- 1); } function isFreezer(address addr) public constant returns (bool) { return indexOf(c_freezers, addr) >= 0; } } contract LimitCollectCoin is Coin, DSMath { // freezing struct struct FreezingNode { uint end_stamp; uint num_lccs; uint8 freezing_type; } // freezing account list mapping(address => FreezingNode[]) internal c_freezing_list; constructor(uint256 token_supply, string token_name, string token_symbol) public { init(token_supply, token_name, token_symbol); setAuthority(new FreezerAuthority()); } function addFreezer(address freezer) auth public { FreezerAuthority(authority).addFreezer(freezer); } function removeFreezer(address freezer) auth public { FreezerAuthority(authority).removeFreezer(freezer); } event ClearExpiredFreezingEvent(address indexed addr); event SetFreezingEvent(address indexed addr, uint end_stamp, uint num_lccs, uint8 indexed freezing_type); function clearExpiredFreezing(address addr) public { FreezingNode[] storage nodes = c_freezing_list[addr]; uint length = nodes.length; // find first expired index uint left = 0; while (left < length) { // not freezing any more if (nodes[left].end_stamp <= block.timestamp) { break; } left++; } // next frozen index uint right = left + 1; while (left < length && right < length) { // still freezing if (nodes[right].end_stamp > block.timestamp) { nodes[left] = nodes[right]; left++; } right++; } if (length != left) { nodes.length = left; emit ClearExpiredFreezingEvent(addr); } } function validBalanceOf(address addr) constant public returns (uint) { FreezingNode[] memory nodes = c_freezing_list[addr]; uint length = nodes.length; uint total_lccs = balanceOf(addr); for (uint i = 0; i < length; ++i) { if (nodes[i].end_stamp > block.timestamp) { total_lccs = sub(total_lccs, nodes[i].num_lccs); } } return total_lccs; } function freezingBalanceNumberOf(address addr) constant public returns (uint) { return c_freezing_list[addr].length; } function freezingBalanceInfoOf(address addr, uint index) constant public returns (uint, uint, uint8) { return (c_freezing_list[addr][index].end_stamp, c_freezing_list[addr][index].num_lccs, uint8(c_freezing_list[addr][index].freezing_type)); } function setFreezing(address addr, uint end_stamp, uint num_lccs, uint8 freezing_type) auth stoppable public { require(block.timestamp < end_stamp); // uint never less than 0. The negative number will become to a big positive number require(num_lccs < c_totalSupply); clearExpiredFreezing(addr); uint valid_balance = validBalanceOf(addr); require(valid_balance >= num_lccs); FreezingNode memory node = FreezingNode(end_stamp, num_lccs, freezing_type); c_freezing_list[addr].push(node); emit SetFreezingEvent(addr, end_stamp, num_lccs, freezing_type); } function transferAndFreezing(address _to, uint256 _value, uint256 freeze_amount, uint end_stamp, uint8 freezing_type) auth stoppable public returns (bool) { // uint never less than 0. The negative number will become to a big positive number require(_value < c_totalSupply); require(freeze_amount <= _value); transfer(_to, _value); setFreezing(_to, end_stamp, freeze_amount, freezing_type); return true; } function transfer(address _to, uint256 _value) stoppable public returns (bool) { require(msg.data.length >= (2 * 32) + 4); // uint never less than 0. The negative number will become to a big positive number require(_value < c_totalSupply); clearExpiredFreezing(msg.sender); uint from_lccs = validBalanceOf(msg.sender); require(from_lccs >= _value); c_balances[msg.sender] = sub(c_balances[msg.sender], _value); c_balances[_to] = add(c_balances[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) stoppable public returns (bool) { // uint never less than 0. The negative number will become to a big positive number require(_value < c_totalSupply); require(c_approvals[_from][msg.sender] >= _value); clearExpiredFreezing(_from); uint from_lccs = validBalanceOf(_from); require(from_lccs >= _value); c_approvals[_from][msg.sender] = sub(c_approvals[_from][msg.sender], _value); c_balances[_from] = sub(c_balances[_from], _value); c_balances[_to] = add(c_balances[_to], _value); emit Transfer(_from, _to, _value); return true; } } "}
{"sol name": "10798.sol", "label": 1, "sol content": "pragma solidity 0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } /** * @title TokenTimelock * @dev TokenTimelock is a token holder contract that will allow a * beneficiary to extract the tokens after a given release time */ contract TokenTimelock { using SafeERC20 for ERC20Basic; // ERC20 basic token contract being held ERC20Basic public token; // beneficiary of tokens after they are released address public beneficiary; // timestamp when token release is enabled uint64 public releaseTime; constructor(ERC20Basic _token, address _beneficiary, uint64 _releaseTime) public { require(_releaseTime > uint64(block.timestamp)); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; } /** * @notice Transfers tokens held by timelock to beneficiary. */ function release() public { require(uint64(block.timestamp) >= releaseTime); uint256 amount = token.balanceOf(this); require(amount > 0); token.safeTransfer(beneficiary, amount); } } contract Owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } } contract ReferralDiscountToken is StandardToken, Owned { /// Store the referrers by the referred addresses mapping(address => address) referrerOf; address[] ownersIndex; // Emitted when an investor declares his referrer event Referral(address indexed referred, address indexed referrer); /// Compute the earned discount, topped at 60% function referralDiscountPercentage(address _owner) public view returns (uint256 percent) { uint256 total = 0; /// get one time discount for having been referred if(referrerOf[_owner] != address(0)) { total = total.add(10); } /// get a 10% discount for each one referred for(uint256 i = 0; i < ownersIndex.length; i++) { if(referrerOf[ownersIndex[i]] == _owner) { total = total.add(10); // if(total >= 60) break; } } return total; } // /** //  * Activate referral discounts by declaring one's own referrer //  * @param _referrer can't be self //  * @param _referrer must own tokens at the time of the call //  * You must own tokens at the time of the call //  */ // function setReferrer(address _referrer) public returns (bool success) { //     require(_referrer != address(0)); //     require(_referrer != address(msg.sender)); //     require(balanceOf(msg.sender) > 0); //     require(balanceOf(_referrer) > 0); //     assert(referrerOf[msg.sender] == address(0)); //     ownersIndex.push(msg.sender); //     referrerOf[msg.sender] = _referrer; //     Referral(msg.sender, _referrer); //     return true; // } /** * Activate referral discounts by declaring one's own referrer * @param _referrer the investor who brought another * @param _referred the investor who was brought by another * @dev _referrer and _referred must own tokens at the time of the call */ function setReferrer(address _referred, address _referrer) onlyOwner public returns (bool success) { require(_referrer != address(0)); require(_referrer != address(_referred)); //        require(balanceOf(_referred) > 0); //        require(balanceOf(_referrer) > 0); require(referrerOf[_referred] == address(0)); ownersIndex.push(_referred); referrerOf[_referred] = _referrer; emit Referral(_referred, _referrer); return true; } } contract NaorisToken is ReferralDiscountToken { string public constant name = \"NaorisToken\"; string public constant symbol = \"NAO\"; uint256 public constant decimals = 18; /// The owner of this address will manage the sale process. address public saleTeamAddress; /// The owner of this address will manage the referal and airdrop campaigns. address public referalAirdropsTokensAddress; /// The owner of this address is the Naoris Reserve fund. address public reserveFundAddress; /// The owner of this address is the Naoris Think Tank fund. address public thinkTankFundAddress; /// This address keeps the locked board bonus until 1st of May 2019 address public lockedBoardBonusAddress; /// This is the address of the timelock contract for the locked Board Bonus tokens address public treasuryTimelockAddress; /// After this flag is changed to 'true' no more tokens can be created bool public tokenSaleClosed = false; // seconds since 01.01.1970 to 1st of May 2019 (both 00:00:00 o'clock UTC) uint64 date01May2019 = 1556668800; /// Maximum tokens to be allocated. uint256 public constant TOKENS_HARD_CAP = 400000000 * 10 ** decimals; /// Maximum tokens to be sold. uint256 public constant TOKENS_SALE_HARD_CAP = 300000000 * 10 ** decimals; /// Tokens to be allocated to the Referal tokens fund. uint256 public constant REFERRAL_TOKENS = 10000000 * 10 ** decimals; /// Tokens to be allocated to the Airdrop tokens fund. uint256 public constant AIRDROP_TOKENS = 10000000 * 10 ** decimals; /// Tokens to be allocated to the Think Tank fund. uint256 public constant THINK_TANK_FUND_TOKENS = 40000000 * 10 ** decimals; /// Tokens to be allocated to the Naoris Team fund. uint256 public constant NAORIS_TEAM_TOKENS = 20000000 * 10 ** decimals; /// Tokens to be allocated to the locked Board Bonus. uint256 public constant LOCKED_BOARD_BONUS_TOKENS = 20000000 * 10 ** decimals; /// Only the sale team or the owner are allowed to execute modifier onlyTeam { assert(msg.sender == saleTeamAddress || msg.sender == owner); _; } /// Only allowed to execute while the sale is not yet closed modifier beforeEnd { assert(!tokenSaleClosed); _; } constructor(address _saleTeamAddress, address _referalAirdropsTokensAddress, address _reserveFundAddress, address _thinkTankFundAddress, address _lockedBoardBonusAddress) public { require(_saleTeamAddress != address(0)); require(_referalAirdropsTokensAddress != address(0)); require(_reserveFundAddress != address(0)); require(_thinkTankFundAddress != address(0)); require(_lockedBoardBonusAddress != address(0)); saleTeamAddress = _saleTeamAddress; referalAirdropsTokensAddress = _referalAirdropsTokensAddress; reserveFundAddress = _reserveFundAddress; thinkTankFundAddress = _thinkTankFundAddress; lockedBoardBonusAddress = _lockedBoardBonusAddress; /// The unsold sale tokens will be burnt when the sale is closed balances[saleTeamAddress] = TOKENS_SALE_HARD_CAP; totalSupply_ = TOKENS_SALE_HARD_CAP; emit Transfer(0x0, saleTeamAddress, TOKENS_SALE_HARD_CAP); /// The unspent referal/airdrop tokens will be sent back /// to the reserve fund when the sale is closed balances[referalAirdropsTokensAddress] = REFERRAL_TOKENS; totalSupply_ = totalSupply_.add(REFERRAL_TOKENS); emit Transfer(0x0, referalAirdropsTokensAddress, REFERRAL_TOKENS); balances[referalAirdropsTokensAddress] = balances[referalAirdropsTokensAddress].add(AIRDROP_TOKENS); totalSupply_ = totalSupply_.add(AIRDROP_TOKENS); emit Transfer(0x0, referalAirdropsTokensAddress, AIRDROP_TOKENS); } function close() public onlyTeam beforeEnd { /// burn the unsold sale tokens uint256 unsoldSaleTokens = balances[saleTeamAddress]; if(unsoldSaleTokens > 0) { balances[saleTeamAddress] = 0; totalSupply_ = totalSupply_.sub(unsoldSaleTokens); emit Transfer(saleTeamAddress, 0x0, unsoldSaleTokens); } /// transfer the unspent referal/airdrop tokens to the Reserve fund uint256 unspentReferalAirdropTokens = balances[referalAirdropsTokensAddress]; if(unspentReferalAirdropTokens > 0) { balances[referalAirdropsTokensAddress] = 0; balances[reserveFundAddress] = balances[reserveFundAddress].add(unspentReferalAirdropTokens); emit Transfer(referalAirdropsTokensAddress, reserveFundAddress, unspentReferalAirdropTokens); } /// 40% allocated to the Naoris Think Tank Fund balances[thinkTankFundAddress] = balances[thinkTankFundAddress].add(THINK_TANK_FUND_TOKENS); totalSupply_ = totalSupply_.add(THINK_TANK_FUND_TOKENS); emit Transfer(0x0, thinkTankFundAddress, THINK_TANK_FUND_TOKENS); /// 20% allocated to the Naoris Team and Advisors Fund balances[owner] = balances[owner].add(NAORIS_TEAM_TOKENS); totalSupply_ = totalSupply_.add(NAORIS_TEAM_TOKENS); emit Transfer(0x0, owner, NAORIS_TEAM_TOKENS); /// tokens of the Board Bonus locked until 1st of May 2019 TokenTimelock lockedTreasuryTokens = new TokenTimelock(this, lockedBoardBonusAddress, date01May2019); treasuryTimelockAddress = address(lockedTreasuryTokens); balances[treasuryTimelockAddress] = balances[treasuryTimelockAddress].add(LOCKED_BOARD_BONUS_TOKENS); totalSupply_ = totalSupply_.add(LOCKED_BOARD_BONUS_TOKENS); emit Transfer(0x0, treasuryTimelockAddress, LOCKED_BOARD_BONUS_TOKENS); require(totalSupply_ <= TOKENS_HARD_CAP); tokenSaleClosed = true; } function tokenDiscountPercentage(address _owner) public view returns (uint256 percent) { if(balanceOf(_owner) >= 1000000 * 10**decimals) { return 50; } else if(balanceOf(_owner) >= 500000 * 10**decimals) { return 30; } else if(balanceOf(_owner) >= 250000 * 10**decimals) { return 25; } else if(balanceOf(_owner) >= 100000 * 10**decimals) { return 20; } else if(balanceOf(_owner) >= 50000 * 10**decimals) { return 15; } else if(balanceOf(_owner) >= 10000 * 10**decimals) { return 10; } else if(balanceOf(_owner) >= 1000 * 10**decimals) { return 5; } else { return 0; } } function getTotalDiscount(address _owner) public view returns (uint256 percent) { uint256 total = 0; total += tokenDiscountPercentage(_owner); total += referralDiscountPercentage(_owner); return (total > 60) ? 60 : total; } /// @dev Trading limited - requires the token sale to have closed function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { if(tokenSaleClosed) { return super.transferFrom(_from, _to, _value); } return false; } /// @dev Trading limited - requires the token sale to have closed function transfer(address _to, uint256 _value) public returns (bool) { if(tokenSaleClosed || msg.sender == referalAirdropsTokensAddress || msg.sender == saleTeamAddress) { return super.transfer(_to, _value); } return false; } } "}
{"sol name": "11183.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardToken { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state throw; } // Validate input value. if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); // Take tokens out from circulation totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading throw; } if (agent == 0x0) throw; // Only a master can designate the next agent if (msg.sender != upgradeMaster) throw; // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) throw; // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; /* Minimum ammount of tokens every buyer can buy. */ uint public minCap; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; // Create initially all balance on the team multisig balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { throw; // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } /** * Claim tokens that were accidentally sent to this contract. * * @param _token The address of the token contract that you want to recover. */ function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } /** * The default behavior for the crowdsale end. * * Unlock tokens. */ contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } //distributes reserved tokens. Should be called before finalization function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); // How many % of tokens the founders and others get uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; // move reserved tokens for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
{"sol name": "10129.sol", "label": 1, "sol content": "/** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLib { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20 is ERC20 { uint public decimals; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * Crowdsale state machine without buy functionality. * * Implements basic state machine logic, but leaves out all buy functions, * so that subclasses can implement their own buying logic. * * * For the default buy() implementation see Crowdsale.sol. */ contract CrowdsaleBase is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLib for uint; /* The token we are selling */ FractionalERC20 public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* Calculate incoming funds from presale contracts and addresses */ uint public presaleWeiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* How much wei we have returned back to the contract after a failed crowdfund. */ uint public loadedRefund = 0; /* How much wei we have given back to investors.*/ uint public weiRefunded = 0; /* Has this crowdsale been finalized */ bool public finalized; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => bool) public earlyParticipantWhitelist; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed * - Refunding: Refunds are loaded on the contract for reclaim. */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Refund was processed for a contributor event Refund(address investor, uint weiAmount); // The rules were changed what kind of investments we accept event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress); // Address early participation whitelist status changed event Whitelisted(address addr, bool status); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) { owner = msg.sender; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * @dev Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side' * @param tokenAmount Amount of tokens which be credited to receiver * * @return tokensBought How mony tokens were bought */ function buyTokens(address receiver, uint128 customerId, uint256 tokenAmount) stopInEmergency internal returns(uint tokensBought) { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit if(!earlyParticipantWhitelist[receiver]) { throw; } } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass } else { // Unwanted state throw; } uint weiAmount = msg.value; // Dust transaction require(tokenAmount != 0); if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(pricingStrategy.isPresalePurchase(receiver)) { presaleWeiRaised = presaleWeiRaised.plus(weiAmount); } // Check that we did not bust the cap require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)); assignTokens(receiver, tokenAmount); // Pocket the money, or fail the crowdsale if we for some reason cannot send the money to our multisig if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); return tokenAmount; } /** * @dev Make an investment based on pricing strategy * * This is a wrapper for buyTokens(), but the amount of tokens receiver will * have depends on the pricing strategy used. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side' * * @return tokensBought How mony tokens were bought */ function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) { return buyTokens(receiver, customerId, pricingStrategy.calculatePrice(msg.value, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals())); } /** * @dev Calculate tokens user will have for their purchase * * @param weisTotal How much ethers (in wei) the user putssssss in * @param pricePerToken What is the price for one token * * @return tokensTotal which is received tokens, token decimals included */ function calculateTokens(uint256 weisTotal, uint256 pricePerToken) public constant returns(uint tokensTotal) { // pricePerToken is how many full tokens, token decimal place included, you get for wei amount. // Because, in theory, decimal amount can vary, we do the exponent calculation here, // though gas wise using 10**18 constant would be much simpler. // Furthermore we could use rough amounts and take in raw wei per tokens amount, // but we lose too much accuracy for generic calculations, thus all these are // practically implemented as 10**18 fixed points. uint multiplier = 10 ** token.decimals(); return weisTotal.times(multiplier)/pricePerToken; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) onlyOwner { if(now > time) { throw; // Don't change past } if(startsAt > time) { throw; // Prevent human mistakes } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * Allow load refunds back on the contract for the refunding. * * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached.. */ function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = loadedRefund.plus(msg.value); } /** * Investors can claim refund. * * Note that any refunds from proxy buyers should be handled separately, * and not through this contract. */ function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.plus(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } /** This is for manual testing of multisig wallet interaction */ function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } /** * Allow addresses to do early participation. * * TODO: Fix spelling error in the name */ function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner { earlyParticipantWhitelist[addr] = status; Whitelisted(addr, status); } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) internal; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Deserialize bytes payloads. * * Values are in big-endian byte order. * */ library BytesDeserializer { /** * Extract 256-bit worth of data from the bytes stream. */ function slice32(bytes b, uint offset) constant returns (bytes32) { bytes32 out; for (uint i = 0; i < 32; i++) { out |= bytes32(b[offset + i] & 0xFF) >> (i * 8); } return out; } /** * Extract Ethereum address worth of data from the bytes stream. */ function sliceAddress(bytes b, uint offset) constant returns (address) { bytes32 out; for (uint i = 0; i < 20; i++) { out |= bytes32(b[offset + i] & 0xFF) >> ((i+12) * 8); } return address(uint(out)); } /** * Extract 128-bit worth of data from the bytes stream. */ function slice16(bytes b, uint offset) constant returns (bytes16) { bytes16 out; for (uint i = 0; i < 16; i++) { out |= bytes16(b[offset + i] & 0xFF) >> (i * 8); } return out; } /** * Extract 32-bit worth of data from the bytes stream. */ function slice4(bytes b, uint offset) constant returns (bytes4) { bytes4 out; for (uint i = 0; i < 4; i++) { out |= bytes4(b[offset + i] & 0xFF) >> (i * 8); } return out; } /** * Extract 16-bit worth of data from the bytes stream. */ function slice2(bytes b, uint offset) constant returns (bytes2) { bytes2 out; for (uint i = 0; i < 2; i++) { out |= bytes2(b[offset + i] & 0xFF) >> (i * 8); } return out; } } /** * A mix-in contract to decode different signed KYC payloads. * * @notice This should be a library, but for the complexity and toolchain fragility risks involving of linking library inside library, we currently use this as a helper method mix-in. */ contract KYCPayloadDeserializer { using BytesDeserializer for bytes; // @notice this struct describes what kind of data we include in the payload, we do not use this directly // The bytes payload set on the server side // total 56 bytes struct KYCPayload { /** Customer whitelisted address where the deposit can come from */ address whitelistedAddress; // 20 bytes /** Customer id, UUID v4 */ uint128 customerId; // 16 bytes /** * Min amount this customer needs to invest in ETH. Set zero if no minimum. Expressed as parts of 10000. 1 ETH = 10000. * @notice Decided to use 32-bit words to make the copy-pasted Data field for the ICO transaction less lenghty. */ uint32 minETH; // 4 bytes /** Max amount this customer can to invest in ETH. Set zero if no maximum. Expressed as parts of 10000. 1 ETH = 10000. */ uint32 maxETH; // 4 bytes /** * Information about the price promised for this participant. It can be pricing tier id or directly one token price in weis. * @notice This is a later addition and not supported in all scenarios yet. */ uint256 pricingInfo; } /** * Same as above, but with pricing information included in the payload as the last integer. * * @notice In a long run, deprecate the legacy methods above and only use this payload. */ function getKYCPayload(bytes dataframe) public constant returns(address whitelistedAddress, uint128 customerId, uint32 minEth, uint32 maxEth, uint256 pricingInfo) { address _whitelistedAddress = dataframe.sliceAddress(0); uint128 _customerId = uint128(dataframe.slice16(20)); uint32 _minETH = uint32(dataframe.slice4(36)); uint32 _maxETH = uint32(dataframe.slice4(40)); uint256 _pricingInfo = uint256(dataframe.slice32(44)); return (_whitelistedAddress, _customerId, _minETH, _maxETH, _pricingInfo); } } /** * A presale smart contract that collects money from SAFT/SAFTE agreed buyers. * * Presale contract where we collect money for the token that does not exist yet. * The same KYC rules apply as in KYCCrowdsale. No tokens are issued in this point, * but they are delivered to the buyers after the token sale is over. * */ contract KYCPresale is CrowdsaleBase, KYCPayloadDeserializer { /** The cap of this presale contract in wei */ uint256 public saleWeiCap; /** Server holds the private key to this address to decide if the AML payload is valid or not. */ address public signerAddress; /** A new server-side signer key was set to be effective */ event SignerChanged(address signer); /** An user made a prepurchase through KYC'ed interface. The money has been moved to the token sale multisig wallet. The buyer will receive their tokens in an airdrop after the token sale is over. */ event Prepurchased(address investor, uint weiAmount, uint tokenAmount, uint128 customerId, uint256 pricingInfo); /** The owner changes the presale ETH cap during the sale */ event CapUpdated(uint256 newCap); /** * Constructor. * * Presale does not know about token or pricing strategy, as they will be only available during the future airdrop. * * @dev The parent contract has some unnecessary variables for our use case. For this round of development, we chose to use null value for token and pricing strategy. In the future versions have a parent sale contract that does not assume an existing token. */ function KYCPresale(address _multisigWallet, uint _start, uint _end, uint _saleWeiCap) CrowdsaleBase(FractionalERC20(address(1)), PricingStrategy(address(0)), _multisigWallet, _start, _end, 0) { saleWeiCap = _saleWeiCap; } /** * A token purchase with anti-money laundering * * \u00a9return tokenAmount How many tokens where bought */ function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable returns(uint tokenAmount) { // Presale ended / emergency abort require(!halted); bytes32 hash = sha256(dataframe); var (whitelistedAddress, customerId, minETH, maxETH, pricingInfo) = getKYCPayload(dataframe); uint multiplier = 10 ** 18; address receiver = msg.sender; uint weiAmount = msg.value; // The payload was created by token sale server require(ecrecover(hash, v, r, s) == signerAddress); // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit require(earlyParticipantWhitelist[receiver]); } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass } else { // Unwanted state revert(); } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update per investor amount investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); // Check that we did not bust the cap require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)); require(investedAmountOf[msg.sender] >= minETH * multiplier / 10000); require(investedAmountOf[msg.sender] <= maxETH * multiplier / 10000); // Pocket the money, or fail the crowdsale if we for some reason cannot send the money to our multisig require(multisigWallet.send(weiAmount)); // Tell us invest was success Prepurchased(receiver, weiAmount, tokenAmount, customerId, pricingInfo); return 0; // In presale we do not issue actual tokens tyet } /// @dev This function can set the server side address /// @param _signerAddress The address derived from server's private key function setSignerAddress(address _signerAddress) onlyOwner { signerAddress = _signerAddress; SignerChanged(signerAddress); } /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) { if(weiRaisedTotal > saleWeiCap) { return true; } else { return false; } } /** * We are sold out when our approve pool becomes empty. */ function isCrowdsaleFull() public constant returns (bool) { return weiRaised >= saleWeiCap; } /** * Allow owner to adjust the cap during the presale. * * This allows e.g. US dollar pegged caps. */ function setWeiCap(uint newCap) public onlyOwner { saleWeiCap = newCap; CapUpdated(newCap); } /** * Because this is a presale, we do not issue any tokens yet. * * @dev Have this taken away from the parent contract? */ function assignTokens(address receiver, uint tokenAmount) internal { revert(); } /** * Allow to (re)set pricing strategy. * * @dev Because we do not have token price set in presale, we do nothing. This will be removed in the future versions. */ function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { } /** * Presale state machine management. * * Presale cannot fail; it is running until manually ended. * */ function getState() public constant returns (State) { if (block.timestamp < startsAt) { return State.PreFunding; } else { return State.Funding; } } } "}
{"sol name": "6604.sol", "label": 1, "sol content": "pragma solidity 0.4.24; // File: node_modules/zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: node_modules/zeppelin-solidity/contracts/crowdsale/Crowdsale.sol /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } // File: node_modules/zeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol /** * @title TimedCrowdsale * @dev Crowdsale accepting contributions only within a time frame. */ contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; /** * @dev Reverts if not in crowdsale time range. */ modifier onlyWhileOpen { // solium-disable-next-line security/no-block-members require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; } /** * @dev Constructor, takes crowdsale opening and closing times. * @param _openingTime Crowdsale opening time * @param _closingTime Crowdsale closing time */ function TimedCrowdsale(uint256 _openingTime, uint256 _closingTime) public { // solium-disable-next-line security/no-block-members require(_openingTime >= block.timestamp); require(_closingTime >= _openingTime); openingTime = _openingTime; closingTime = _closingTime; } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { // solium-disable-next-line security/no-block-members return block.timestamp > closingTime; } /** * @dev Extend parent behavior requiring to be within contributing period * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } // File: node_modules/zeppelin-solidity/contracts/crowdsale/distribution/FinalizableCrowdsale.sol /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is TimedCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal { } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: node_modules/zeppelin-solidity/contracts/crowdsale/emission/MintedCrowdsale.sol /** * @title MintedCrowdsale * @dev Extension of Crowdsale contract whose tokens are minted in each purchase. * Token ownership should be transferred to MintedCrowdsale for minting. */ contract MintedCrowdsale is Crowdsale { /** * @dev Overrides delivery by minting tokens upon purchase. * @param _beneficiary Token purchaser * @param _tokenAmount Number of tokens to be minted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { require(MintableToken(token).mint(_beneficiary, _tokenAmount)); } } // File: contracts/PostKYCCrowdsale.sol /// @title PostKYCCrowdsale /// @author Sicos et al. contract PostKYCCrowdsale is Crowdsale, Ownable { struct Investment { bool isVerified;         // wether or not the investor passed the KYC process uint totalWeiInvested;   // total invested wei regardless of verification state // amount of token an unverified investor bought. should be zero for verified investors uint pendingTokenAmount; } // total amount of wei held by unverified investors should never be larger than this.balance uint public pendingWeiAmount = 0; // maps investor addresses to investment information mapping(address => Investment) public investments; /// @dev Log entry on investor verified /// @param investor the investor's Ethereum address event InvestorVerified(address investor); /// @dev Log entry on tokens delivered /// @param investor the investor's Ethereum address /// @param amount token amount delivered event TokensDelivered(address investor, uint amount); /// @dev Log entry on investment withdrawn /// @param investor the investor's Ethereum address /// @param value the wei amount withdrawn event InvestmentWithdrawn(address investor, uint value); /// @dev Verify investors /// @param _investors list of investors' Ethereum addresses function verifyInvestors(address[] _investors) public onlyOwner { for (uint i = 0; i < _investors.length; ++i) { address investor = _investors[i]; Investment storage investment = investments[investor]; if (!investment.isVerified) { investment.isVerified = true; emit InvestorVerified(investor); uint pendingTokenAmount = investment.pendingTokenAmount; // now we issue tokens to the verfied investor if (pendingTokenAmount > 0) { investment.pendingTokenAmount = 0; _forwardFunds(investment.totalWeiInvested); _deliverTokens(investor, pendingTokenAmount); emit TokensDelivered(investor, pendingTokenAmount); } } } } /// @dev Withdraw investment /// @dev Investors that are not verified can withdraw their funds function withdrawInvestment() public { Investment storage investment = investments[msg.sender]; require(!investment.isVerified); uint totalWeiInvested = investment.totalWeiInvested; require(totalWeiInvested > 0); investment.totalWeiInvested = 0; investment.pendingTokenAmount = 0; pendingWeiAmount = pendingWeiAmount.sub(totalWeiInvested); msg.sender.transfer(totalWeiInvested); emit InvestmentWithdrawn(msg.sender, totalWeiInvested); assert(pendingWeiAmount <= address(this).balance); } /// @dev Prevalidate purchase /// @param _beneficiary the investor's Ethereum address /// @param _weiAmount the wei amount invested function _preValidatePurchase(address _beneficiary, uint _weiAmount) internal { // We only want the msg.sender to buy tokens require(_beneficiary == msg.sender); super._preValidatePurchase(_beneficiary, _weiAmount); } /// @dev Process purchase /// @param _tokenAmount the token amount purchased function _processPurchase(address, uint _tokenAmount) internal { Investment storage investment = investments[msg.sender]; investment.totalWeiInvested = investment.totalWeiInvested.add(msg.value); if (investment.isVerified) { // If the investor's KYC is already verified we issue the tokens imediatly _deliverTokens(msg.sender, _tokenAmount); emit TokensDelivered(msg.sender, _tokenAmount); } else { // If the investor's KYC is not verified we store the pending token amount investment.pendingTokenAmount = investment.pendingTokenAmount.add(_tokenAmount); pendingWeiAmount = pendingWeiAmount.add(msg.value); } } /// @dev Forward funds function _forwardFunds() internal { // Ensure the investor was verified, i.e. his purchased tokens were delivered, // before forwarding funds. if (investments[msg.sender].isVerified) { super._forwardFunds(); } } /// @dev Forward funds /// @param _weiAmount the amount to be transfered function _forwardFunds(uint _weiAmount) internal { pendingWeiAmount = pendingWeiAmount.sub(_weiAmount); wallet.transfer(_weiAmount); } /// @dev Postvalidate purchase /// @param _weiAmount the amount invested function _postValidatePurchase(address, uint _weiAmount) internal { super._postValidatePurchase(msg.sender, _weiAmount); // checking invariant assert(pendingWeiAmount <= address(this).balance); } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/CappedToken.sol /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; function CappedToken(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } // File: node_modules/zeppelin-solidity/contracts/lifecycle/Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20/PausableToken.sol /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } // File: contracts/VreoToken.sol /// @title VreoToken /// @author Sicos et al. contract VreoToken is CappedToken, PausableToken, BurnableToken { uint public constant TOTAL_TOKEN_CAP = 700000000e18;  // = 700.000.000 e18 string public name = \"MERO Token\"; string public symbol = \"MERO\"; uint8 public decimals = 18; /// @dev Constructor constructor() public CappedToken(TOTAL_TOKEN_CAP) { pause(); } } // File: contracts/VreoTokenSale.sol /// @title VreoTokenSale /// @author Sicos et al. contract VreoTokenSale is PostKYCCrowdsale, FinalizableCrowdsale, MintedCrowdsale { // Maxmimum number of tokens sold in Presale+Iconiq+Vreo sales uint public constant TOTAL_TOKEN_CAP_OF_SALE = 450000000e18;  // = 450.000.000 e18 // Extra tokens minted upon finalization uint public constant TOKEN_SHARE_OF_TEAM     =  85000000e18;  // =  85.000.000 e18 uint public constant TOKEN_SHARE_OF_ADVISORS =  58000000e18;  // =  58.000.000 e18 uint public constant TOKEN_SHARE_OF_LEGALS   =  57000000e18;  // =  57.000.000 e18 uint public constant TOKEN_SHARE_OF_BOUNTY   =  50000000e18;  // =  50.000.000 e18 // Extra token percentages uint public constant BONUS_PCT_IN_ICONIQ_SALE       = 30;  // TBD uint public constant BONUS_PCT_IN_VREO_SALE_PHASE_1 = 20; uint public constant BONUS_PCT_IN_VREO_SALE_PHASE_2 = 10; // Date/time constants uint public constant ICONIQ_SALE_OPENING_TIME   = 1531123200;  // 2018-07-09 10:00:00 CEST uint public constant ICONIQ_SALE_CLOSING_TIME   = 1532376000;  // 2018-07-23 22:00:00 CEST uint public constant VREO_SALE_OPENING_TIME     = 1533369600;  // 2018-08-04 10:00:00 CEST uint public constant VREO_SALE_PHASE_1_END_TIME = 1533672000;  // 2018-08-07 22:00:00 CEST uint public constant VREO_SALE_PHASE_2_END_TIME = 1534276800;  // 2018-08-14 22:00:00 CEST uint public constant VREO_SALE_CLOSING_TIME     = 1535832000;  // 2018-09-01 22:00:00 CEST uint public constant KYC_VERIFICATION_END_TIME  = 1537041600;  // 2018-09-15 22:00:00 CEST // Amount of ICONIQ token investors need per Wei invested in ICONIQ PreSale. uint public constant ICONIQ_TOKENS_NEEDED_PER_INVESTED_WEI = 450; // ICONIQ Token ERC20Basic public iconiqToken; // addresses token shares are minted to in finalization address public teamAddress; address public advisorsAddress; address public legalsAddress; address public bountyAddress; // Amount of token available for purchase uint public remainingTokensForSale; /// @dev Log entry on rate changed /// @param newRate the new rate event RateChanged(uint newRate); /// @dev Constructor /// @param _token A VreoToken /// @param _rate the initial rate. /// @param _iconiqToken An IconiqInterface /// @param _teamAddress Ethereum address of Team /// @param _advisorsAddress Ethereum address of Advisors /// @param _legalsAddress Ethereum address of Legals /// @param _bountyAddress A VreoTokenBounty /// @param _wallet MultiSig wallet address the ETH is forwarded to. constructor( VreoToken _token, uint _rate, ERC20Basic _iconiqToken, address _teamAddress, address _advisorsAddress, address _legalsAddress, address _bountyAddress, address _wallet ) public Crowdsale(_rate, _wallet, _token) TimedCrowdsale(ICONIQ_SALE_OPENING_TIME, VREO_SALE_CLOSING_TIME) { // Token sanity check require(_token.cap() >= TOTAL_TOKEN_CAP_OF_SALE + TOKEN_SHARE_OF_TEAM + TOKEN_SHARE_OF_ADVISORS + TOKEN_SHARE_OF_LEGALS + TOKEN_SHARE_OF_BOUNTY); // Sanity check of addresses require(address(_iconiqToken) != address(0) && _teamAddress != address(0) && _advisorsAddress != address(0) && _legalsAddress != address(0) && _bountyAddress != address(0)); iconiqToken = _iconiqToken; teamAddress = _teamAddress; advisorsAddress = _advisorsAddress; legalsAddress = _legalsAddress; bountyAddress = _bountyAddress; remainingTokensForSale = TOTAL_TOKEN_CAP_OF_SALE; } /// @dev Distribute presale /// @param _investors  list of investor addresses /// @param _amounts  list of token amounts purchased by investors function distributePresale(address[] _investors, uint[] _amounts) public onlyOwner { require(!hasClosed()); require(_investors.length == _amounts.length); uint totalAmount = 0; for (uint i = 0; i < _investors.length; ++i) { VreoToken(token).mint(_investors[i], _amounts[i]); totalAmount = totalAmount.add(_amounts[i]); } require(remainingTokensForSale >= totalAmount); remainingTokensForSale = remainingTokensForSale.sub(totalAmount); } /// @dev Set rate /// @param _newRate the new rate function setRate(uint _newRate) public onlyOwner { // A rate change by a magnitude order of ten and above is rather a typo than intention. // If it was indeed desired, several setRate transactions have to be sent. require(rate / 10 < _newRate && _newRate < 10 * rate); rate = _newRate; emit RateChanged(_newRate); } /// @dev unverified investors can withdraw their money only after the VREO Sale ended function withdrawInvestment() public { require(hasClosed()); super.withdrawInvestment(); } /// @dev Is the sale for ICONIQ investors ongoing? /// @return bool function iconiqSaleOngoing() public view returns (bool) { return ICONIQ_SALE_OPENING_TIME <= now && now <= ICONIQ_SALE_CLOSING_TIME; } /// @dev Is the Vreo main sale ongoing? /// @return bool function vreoSaleOngoing() public view returns (bool) { return VREO_SALE_OPENING_TIME <= now && now <= VREO_SALE_CLOSING_TIME; } /// @dev Get maximum possible wei investment while Iconiq sale /// @param _investor an investors Ethereum address /// @return Maximum allowed wei investment function getIconiqMaxInvestment(address _investor) public view returns (uint) { uint iconiqBalance = iconiqToken.balanceOf(_investor); uint prorataLimit = iconiqBalance.div(ICONIQ_TOKENS_NEEDED_PER_INVESTED_WEI); // Substract Wei amount already invested. require(prorataLimit >= investments[_investor].totalWeiInvested); return prorataLimit.sub(investments[_investor].totalWeiInvested); } /// @dev Pre validate purchase /// @param _beneficiary an investors Ethereum address /// @param _weiAmount wei amount invested function _preValidatePurchase(address _beneficiary, uint _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(iconiqSaleOngoing() && getIconiqMaxInvestment(msg.sender) >= _weiAmount || vreoSaleOngoing()); } /// @dev Get token amount /// @param _weiAmount wei amount invested /// @return token amount with bonus function _getTokenAmount(uint _weiAmount) internal view returns (uint) { uint tokenAmount = super._getTokenAmount(_weiAmount); if (now <= ICONIQ_SALE_CLOSING_TIME) { return tokenAmount.mul(100 + BONUS_PCT_IN_ICONIQ_SALE).div(100); } if (now <= VREO_SALE_PHASE_1_END_TIME) { return tokenAmount.mul(100 + BONUS_PCT_IN_VREO_SALE_PHASE_1).div(100); } if (now <= VREO_SALE_PHASE_2_END_TIME) { return tokenAmount.mul(100 + BONUS_PCT_IN_VREO_SALE_PHASE_2).div(100); } return tokenAmount;  // No bonus } /// @dev Deliver tokens /// @param _beneficiary an investors Ethereum address /// @param _tokenAmount token amount to deliver function _deliverTokens(address _beneficiary, uint _tokenAmount) internal { require(remainingTokensForSale >= _tokenAmount); remainingTokensForSale = remainingTokensForSale.sub(_tokenAmount); super._deliverTokens(_beneficiary, _tokenAmount); } /// @dev Finalization function finalization() internal { require(now >= KYC_VERIFICATION_END_TIME); VreoToken(token).mint(teamAddress, TOKEN_SHARE_OF_TEAM); VreoToken(token).mint(advisorsAddress, TOKEN_SHARE_OF_ADVISORS); VreoToken(token).mint(legalsAddress, TOKEN_SHARE_OF_LEGALS); VreoToken(token).mint(bountyAddress, TOKEN_SHARE_OF_BOUNTY); VreoToken(token).finishMinting(); VreoToken(token).unpause(); super.finalization(); } } "}
{"sol name": "6586.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/grapevine/crowdsale/TokenTimelockController.sol /** * @title TokenTimelock Controller * @dev This contract allows to create/read/revoke TokenTimelock contracts and to claim the amounts vested. **/ contract TokenTimelockController is Ownable { using SafeMath for uint; struct TokenTimelock { uint256 amount; uint256 releaseTime; bool released; bool revocable; bool revoked; } event TokenTimelockCreated( address indexed beneficiary, uint256 releaseTime, bool revocable, uint256 amount ); event TokenTimelockRevoked( address indexed beneficiary ); event TokenTimelockBeneficiaryChanged( address indexed previousBeneficiary, address indexed newBeneficiary ); event TokenTimelockReleased( address indexed beneficiary, uint256 amount ); uint256 public constant TEAM_LOCK_DURATION_PART1 = 1 * 365 days; uint256 public constant TEAM_LOCK_DURATION_PART2 = 2 * 365 days; uint256 public constant INVESTOR_LOCK_DURATION = 6 * 30 days; mapping (address => TokenTimelock[]) tokenTimeLocks; ERC20 public token; address public crowdsale; bool public activated; /// @notice Constructor for TokenTimelock Controller constructor(ERC20 _token) public { token = _token; } modifier onlyCrowdsale() { require(msg.sender == crowdsale); _; } modifier onlyWhenActivated() { require(activated); _; } modifier onlyValidTokenTimelock(address _beneficiary, uint256 _id) { require(_beneficiary != address(0)); require(_id < tokenTimeLocks[_beneficiary].length); require(!tokenTimeLocks[_beneficiary][_id].revoked); _; } /** * @dev Function to set the crowdsale address * @param _crowdsale address The address of the crowdsale. */ function setCrowdsale(address _crowdsale) external onlyOwner { require(_crowdsale != address(0)); crowdsale = _crowdsale; } /** * @dev Function to activate the controller. * It can be called only by the crowdsale address. */ function activate() external onlyCrowdsale { activated = true; } /** * @dev Creates a lock for the provided _beneficiary with the provided amount * The creation can be peformed only if: * - the sender is the address of the crowdsale; * - the _beneficiary and _tokenHolder are valid addresses; * - the _amount is greater than 0 and was appoved by the _tokenHolder prior to the transaction. * The investors will have a lock with a lock period of 6 months. * @param _beneficiary Address that will own the lock. * @param _amount the amount of the locked tokens. * @param _start when the lock should start. * @param _tokenHolder the account that approved the amount for this contract. */ function createInvestorTokenTimeLock( address _beneficiary, uint256 _amount, uint256 _start, address _tokenHolder ) external onlyCrowdsale returns (bool) { require(_beneficiary != address(0) && _amount > 0); require(_tokenHolder != address(0)); TokenTimelock memory tokenLock = TokenTimelock( _amount, _start.add(INVESTOR_LOCK_DURATION), false, false, false ); tokenTimeLocks[_beneficiary].push(tokenLock); require(token.transferFrom(_tokenHolder, this, _amount)); emit TokenTimelockCreated( _beneficiary, tokenLock.releaseTime, false, _amount); return true; } /** * @dev Creates locks for the provided _beneficiary with the provided amount * The creation can be peformed only if: * - the sender is the owner of the contract; * - the _beneficiary and _tokenHolder are valid addresses; * - the _amount is greater than 0 and was appoved by the _tokenHolder prior to the transaction. * The team members will have two locks with 1 and 2 years lock period, each having half of the amount. * @param _beneficiary Address that will own the lock. * @param _amount the amount of the locked tokens. * @param _start when the lock should start. * @param _tokenHolder the account that approved the amount for this contract. */ function createTeamTokenTimeLock( address _beneficiary, uint256 _amount, uint256 _start, address _tokenHolder ) external onlyOwner returns (bool) { require(_beneficiary != address(0) && _amount > 0); require(_tokenHolder != address(0)); uint256 amount = _amount.div(2); TokenTimelock memory tokenLock1 = TokenTimelock( amount, _start.add(TEAM_LOCK_DURATION_PART1), false, true, false ); tokenTimeLocks[_beneficiary].push(tokenLock1); TokenTimelock memory tokenLock2 = TokenTimelock( amount, _start.add(TEAM_LOCK_DURATION_PART2), false, true, false ); tokenTimeLocks[_beneficiary].push(tokenLock2); require(token.transferFrom(_tokenHolder, this, _amount)); emit TokenTimelockCreated( _beneficiary, tokenLock1.releaseTime, true, amount); emit TokenTimelockCreated( _beneficiary, tokenLock2.releaseTime, true, amount); return true; } /** * @dev Revokes the lock for the provided _beneficiary and _id. * The revoke can be peformed only if: * - the sender is the owner of the contract; * - the controller was activated by the crowdsale contract; * - the _beneficiary and _id reference a valid lock; * - the lock was not revoked; * - the lock is revokable; * - the lock was not released. * @param _beneficiary Address owning the lock. * @param _id id of the lock. */ function revokeTokenTimelock( address _beneficiary, uint256 _id) external onlyWhenActivated onlyOwner onlyValidTokenTimelock(_beneficiary, _id) { require(tokenTimeLocks[_beneficiary][_id].revocable); require(!tokenTimeLocks[_beneficiary][_id].released); TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id]; tokenLock.revoked = true; require(token.transfer(owner, tokenLock.amount)); emit TokenTimelockRevoked(_beneficiary); } /** * @dev Returns the number locks of the provided _beneficiary. * @param _beneficiary Address owning the locks. */ function getTokenTimelockCount(address _beneficiary) view external returns (uint) { return tokenTimeLocks[_beneficiary].length; } /** * @dev Returns the details of the lock referenced by the provided _beneficiary and _id. * @param _beneficiary Address owning the lock. * @param _id id of the lock. */ function getTokenTimelockDetails(address _beneficiary, uint256 _id) view external returns ( uint256 _amount, uint256 _releaseTime, bool _released, bool _revocable, bool _revoked) { require(_id < tokenTimeLocks[_beneficiary].length); _amount = tokenTimeLocks[_beneficiary][_id].amount; _releaseTime = tokenTimeLocks[_beneficiary][_id].releaseTime; _released = tokenTimeLocks[_beneficiary][_id].released; _revocable = tokenTimeLocks[_beneficiary][_id].revocable; _revoked = tokenTimeLocks[_beneficiary][_id].revoked; } /** * @dev Changes the beneficiary of the _id'th lock of the sender with the provided newBeneficiary. * The release can be peformed only if: * - the controller was activated by the crowdsale contract; * - the sender and _id reference a valid lock; * - the lock was not revoked; * @param _id id of the lock. * @param _newBeneficiary Address of the new beneficiary. */ function changeBeneficiary(uint256 _id, address _newBeneficiary) external onlyWhenActivated onlyValidTokenTimelock(msg.sender, _id) { tokenTimeLocks[_newBeneficiary].push(tokenTimeLocks[msg.sender][_id]); if (tokenTimeLocks[msg.sender].length > 1) { tokenTimeLocks[msg.sender][_id] = tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]; delete(tokenTimeLocks[msg.sender][tokenTimeLocks[msg.sender].length.sub(1)]); } tokenTimeLocks[msg.sender].length--; emit TokenTimelockBeneficiaryChanged(msg.sender, _newBeneficiary); } /** * @dev Releases the tokens for the calling sender and _id. * The release can be peformed only if: * - the controller was activated by the crowdsale contract; * - the sender and _id reference a valid lock; * - the lock was not revoked; * - the lock was not released before; * - the lock period has passed. * @param _id id of the lock. */ function release(uint256 _id) external { releaseFor(msg.sender, _id); } /** * @dev Releases the tokens for the provided _beneficiary and _id. * The release can be peformed only if: * - the controller was activated by the crowdsale contract; * - the _beneficiary and _id reference a valid lock; * - the lock was not revoked; * - the lock was not released before; * - the lock period has passed. * @param _beneficiary Address owning the lock. * @param _id id of the lock. */ function releaseFor(address _beneficiary, uint256 _id) public onlyWhenActivated onlyValidTokenTimelock(_beneficiary, _id) { TokenTimelock storage tokenLock = tokenTimeLocks[_beneficiary][_id]; require(!tokenLock.released); // solium-disable-next-line security/no-block-members require(block.timestamp >= tokenLock.releaseTime); tokenLock.released = true; require(token.transfer(_beneficiary, tokenLock.amount)); emit TokenTimelockReleased(_beneficiary, tokenLock.amount); } } "}
{"sol name": "8615.sol", "label": 1, "sol content": "pragma solidity ^0.4.13; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Claimable is Ownable { address public pendingOwner; /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } } contract TokenVestingFactory is Claimable { event Created(VariableRateTokenVesting vesting); function create( address _beneficiary, uint256 _start, uint256[] _cumulativeRates, uint256 _interval ) onlyOwner public returns (VariableRateTokenVesting) { VariableRateTokenVesting vesting = new VariableRateTokenVesting( _beneficiary, _start, _cumulativeRates, _interval); emit Created(vesting); return vesting; } } contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); // beneficiary of tokens after they are released address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; mapping (address => uint256) public released; mapping (address => bool) public revoked; /** * @dev Creates a vesting contract that vests its balance of any ERC20 token to the * _beneficiary, gradually in a linear fashion until _start + _duration. By then all * of the balance will have vested. * @param _beneficiary address of the beneficiary to whom vested tokens are transferred * @param _cliff duration in seconds of the cliff in which tokens will begin to vest * @param _duration duration in seconds of the period in which the tokens will vest * @param _revocable whether the vesting is revocable or not */ function TokenVesting( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable ) public { require(_beneficiary != address(0)); require(_cliff <= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; } /** * @notice Transfers vested tokens to beneficiary. * @param token ERC20 token which is being vested */ function release(ERC20Basic token) public { uint256 unreleased = releasableAmount(token); require(unreleased > 0); released[token] = released[token].add(unreleased); token.safeTransfer(beneficiary, unreleased); emit Released(unreleased); } /** * @notice Allows the owner to revoke the vesting. Tokens already vested * remain in the contract, the rest are returned to the owner. * @param token ERC20 token which is being vested */ function revoke(ERC20Basic token) public onlyOwner { require(revocable); require(!revoked[token]); uint256 balance = token.balanceOf(this); uint256 unreleased = releasableAmount(token); uint256 refund = balance.sub(unreleased); revoked[token] = true; token.safeTransfer(owner, refund); emit Revoked(); } /** * @dev Calculates the amount that has already vested but hasn't been released yet. * @param token ERC20 token which is being vested */ function releasableAmount(ERC20Basic token) public view returns (uint256) { return vestedAmount(token).sub(released[token]); } /** * @dev Calculates the amount that has already vested. * @param token ERC20 token which is being vested */ function vestedAmount(ERC20Basic token) public view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); if (block.timestamp < cliff) { return 0; } else if (block.timestamp >= start.add(duration) || revoked[token]) { return totalBalance; } else { return totalBalance.mul(block.timestamp.sub(start)).div(duration); } } } library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract VariableRateTokenVesting is TokenVesting { using SafeMath for uint256; using SafeERC20 for ERC20Basic; // Every element between 0 and 100, and should increase monotonically. // [10, 20, 30, ..., 100] means releasing 10% for each period. uint256[] public cumulativeRates; // Seconds between each period. uint256 public interval; constructor( address _beneficiary, uint256 _start, uint256[] _cumulativeRates, uint256 _interval ) public // We don't need `duration`, also always allow revoking. TokenVesting(_beneficiary, _start, /*cliff*/0, /*duration: uint max*/~uint256(0), true) { // Validate rates. for (uint256 i = 0; i < _cumulativeRates.length; ++i) { require(_cumulativeRates[i] <= 100); if (i > 0) { require(_cumulativeRates[i] >= _cumulativeRates[i - 1]); } } cumulativeRates = _cumulativeRates; interval = _interval; // Hardcode owner. owner = 0x0298CF0d5B60a0aD885518adCB4c3fc49b36D347; } /// @dev Override to use cumulative rates to calculated amount for vesting. function vestedAmount(ERC20Basic token) public view returns (uint256) { if (now < start) { return 0; } uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); uint256 timeSinceStart = now.sub(start); uint256 currentPeriod = timeSinceStart.div(interval); if (currentPeriod >= cumulativeRates.length) { return totalBalance; } return totalBalance.mul(cumulativeRates[currentPeriod]).div(100); } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } "}
{"sol name": "2646.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "11775.sol", "label": 1, "sol content": "/** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLib { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20 is ERC20 { uint public decimals; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * Crowdsale state machine without buy functionality. * * Implements basic state machine logic, but leaves out all buy functions, * so that subclasses can implement their own buying logic. * * * For the default buy() implementation see Crowdsale.sol. */ contract CrowdsaleBase is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLib for uint; /* The token we are selling */ FractionalERC20 public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* Calculate incoming funds from presale contracts and addresses */ uint public presaleWeiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* How much wei we have returned back to the contract after a failed crowdfund. */ uint public loadedRefund = 0; /* How much wei we have given back to investors.*/ uint public weiRefunded = 0; /* Has this crowdsale been finalized */ bool public finalized; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => bool) public earlyParticipantWhitelist; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed * - Refunding: Refunds are loaded on the contract for reclaim. */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Refund was processed for a contributor event Refund(address investor, uint weiAmount); // The rules were changed what kind of investments we accept event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress); // Address early participation whitelist status changed event Whitelisted(address addr, bool status); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) { owner = msg.sender; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * @dev Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side' * @param tokenAmount Amount of tokens which be credited to receiver * * @return tokensBought How mony tokens were bought */ function buyTokens(address receiver, uint128 customerId, uint256 tokenAmount) stopInEmergency internal returns(uint tokensBought) { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit if(!earlyParticipantWhitelist[receiver]) { throw; } } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass } else { // Unwanted state throw; } uint weiAmount = msg.value; // Dust transaction require(tokenAmount != 0); if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(pricingStrategy.isPresalePurchase(receiver)) { presaleWeiRaised = presaleWeiRaised.plus(weiAmount); } // Check that we did not bust the cap require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)); assignTokens(receiver, tokenAmount); // Pocket the money, or fail the crowdsale if we for some reason cannot send the money to our multisig if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); return tokenAmount; } /** * @dev Make an investment based on pricing strategy * * This is a wrapper for buyTokens(), but the amount of tokens receiver will * have depends on the pricing strategy used. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side' * * @return tokensBought How mony tokens were bought */ function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) { return buyTokens(receiver, customerId, pricingStrategy.calculatePrice(msg.value, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals())); } /** * @dev Calculate tokens user will have for their purchase * * @param weisTotal How much ethers (in wei) the user putssssss in * @param pricePerToken What is the price for one token * * @return tokensTotal which is received tokens, token decimals included */ function calculateTokens(uint256 weisTotal, uint256 pricePerToken) public constant returns(uint tokensTotal) { // pricePerToken is how many full tokens, token decimal place included, you get for wei amount. // Because, in theory, decimal amount can vary, we do the exponent calculation here, // though gas wise using 10**18 constant would be much simpler. // Furthermore we could use rough amounts and take in raw wei per tokens amount, // but we lose too much accuracy for generic calculations, thus all these are // practically implemented as 10**18 fixed points. uint multiplier = 10 ** token.decimals(); return weisTotal.times(multiplier)/pricePerToken; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) onlyOwner { if(now > time) { throw; // Don't change past } if(startsAt > time) { throw; // Prevent human mistakes } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * Allow load refunds back on the contract for the refunding. * * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached.. */ function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = loadedRefund.plus(msg.value); } /** * Investors can claim refund. * * Note that any refunds from proxy buyers should be handled separately, * and not through this contract. */ function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.plus(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } /** This is for manual testing of multisig wallet interaction */ function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } /** * Allow addresses to do early participation. * * TODO: Fix spelling error in the name */ function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner { earlyParticipantWhitelist[addr] = status; Whitelisted(addr, status); } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) internal; } /** * Abstract base contract for token sales with the default buy entry points. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * * Does not Handle * * - Token allocation (minting vs. transfer) * - Cap rules * */ contract Crowdsale is CrowdsaleBase { /* Do we need to have unique contributor id for each customer */ bool public requireCustomerId; /** * Do we verify that contributor has been cleared on the server side (accredited investors only). * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web). */ bool public requiredSignedAddress; /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */ address public signerAddress; function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) { } /** * Preallocate tokens for the early investors. * * Preallocated tokens have been sold before the actual crowdsale opens. * This function mints the tokens and moves the crowdsale needle. * * Investor count is not handled; it is assumed this goes for multiple investors * and the token distribution happens outside the smart contract flow. * * No money is exchanged, as the crowdsale team already have received the payment. * * @param fullTokens tokens as full tokens - decimal places added internally * @param weiPrice Price of a single full token in wei * */ function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner { uint tokenAmount = fullTokens * 10**token.decimals(); uint weiAmount = weiPrice * fullTokens; // This can be also 0, we give out tokens for free weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); assignTokens(receiver, tokenAmount); // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, 0); } /** * Allow anonymous contributions to this crowdsale. */ function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(addr); if (ecrecover(hash, v, r, s) != signerAddress) throw; if(customerId == 0) throw;  // UUIDv4 sanity check investInternal(addr, customerId); } /** * Track who is the customer making the payment so we can send thank you email. */ function investWithCustomerId(address addr, uint128 customerId) public payable { if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants if(customerId == 0) throw;  // UUIDv4 sanity check investInternal(addr, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { if(requireCustomerId) throw; // Crowdsale needs to track participants for thank you email if(requiredSignedAddress) throw; // Crowdsale allows only server-side signed participants investInternal(addr, 0); } /** * Invest to tokens, recognize the payer and clear his address. * */ function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { investWithSignedAddress(msg.sender, customerId, v, r, s); } /** * Invest to tokens, recognize the payer. * */ function buyWithCustomerIdWithChecksum(uint128 customerId, bytes1 checksum) public payable { // see customerid.py if (bytes1(sha3(customerId)) != checksum) throw; investWithCustomerId(msg.sender, customerId); } /** * Legacy API signature. */ function buyWithCustomerId(uint128 customerId) public payable { investWithCustomerId(msg.sender, customerId); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } /** * Set policy do we need to have server-side customer ids for the investments. * */ function setRequireCustomerId(bool value) onlyOwner { requireCustomerId = value; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } /** * Set policy if all investors must be cleared on the server side first. * * This is e.g. for the accredited investor clearing. * */ function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner { requiredSignedAddress = value; signerAddress = _signerAddress; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ contract Recoverable is Ownable { /// @dev Empty constructor (for now) function Recoverable() { } /// @dev This will be invoked by the owner, when owner wants to rescue tokens /// @param token Token which will we rescue to the owner from the contract function recoverTokens(ERC20Basic token) onlyOwner public { token.transfer(owner, tokensToBeReturned(token)); } /// @dev Interface function, can be overwritten by the superclass /// @param token Token which balance we will check and return /// @return The amount of tokens (in smallest denominator) the contract owns function tokensToBeReturned(ERC20Basic token) public returns (uint) { return token.balanceOf(this); } } /** * Standard EIP-20 token with an interface marker. * * @notice Interface marker is used by crowdsale contracts to validate that addresses point a good token contract. * */ contract StandardTokenExt is StandardToken, Recoverable { /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } } /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is StandardTokenExt { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * A finalize agent that does nothing. * * - Token transfer must be manually released by the owner */ contract NullFinalizeAgent is FinalizeAgent { Crowdsale public crowdsale; function NullFinalizeAgent(Crowdsale _crowdsale) { crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return true; } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { } } "}
{"sol name": "1318.sol", "label": 1, "sol content": "pragma solidity ^0.4.0; contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract WorkIt is ERC20Interface { // non-fixed supply ERC20 implementation string public constant name = \"WorkIt Token\"; string public constant symbol = \"WIT\"; uint _totalSupply = 0; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowances; function totalSupply() public constant returns (uint) { return _totalSupply; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowances[tokenOwner][spender]; } function transfer(address to, uint tokens) public returns (bool success) { require(balances[msg.sender] >= tokens); balances[msg.sender] = balances[msg.sender] - tokens; balances[to] = balances[to] + tokens; emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowances[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { require(allowances[from][msg.sender] >= tokens); require(balances[from] >= tokens); allowances[from][msg.sender] = allowances[from][msg.sender] - tokens; balances[from] = balances[from] - tokens; balances[to] = balances[to] + tokens; emit Transfer(from, to, tokens); return true; } // End ERC-20 implementation struct WeekCommittment { uint daysCompleted; uint daysCommitted; mapping(uint => uint) workoutProofs; uint tokensCommitted; uint tokensEarned; bool tokensPaid; } struct WeekData { bool initialized; uint totalPeopleCompleted; uint totalPeople; uint totalDaysCommitted; uint totalDaysCompleted; uint totalTokensCompleted; uint totalTokens; } uint public weiPerToken = 1000000000000000; // 1000 WITs per eth uint secondsPerDay = 86400; uint daysPerWeek = 7; mapping(uint => WeekData) public dataPerWeek; mapping (address => mapping(uint => WeekCommittment)) public commitments; mapping(uint => string) imageHashes; uint imageHashCount; uint public startDate; address public owner; constructor() public { owner = msg.sender; // Round down to the nearest day at 00:00Z (UTC -6) startDate = (block.timestamp / secondsPerDay) * secondsPerDay - 60 * 6; } event Log(string message); // Fallback function executed when ethereum is received with no function call function () public payable { buyTokens(msg.value / weiPerToken); } // Buy tokens function buyTokens(uint tokens) public payable { require(msg.value >= tokens * weiPerToken); balances[msg.sender] += tokens; _totalSupply += tokens; } // Commit to exercising this week function commitToWeek(uint tokens, uint _days) public { // Need at least 10 tokens to participate if (balances[msg.sender] < tokens || tokens < 10) { emit Log(\"You need to bet at least 10 tokens to commit\"); require(false); } if (_days == 0) { emit Log(\"You cannot register for 0 days of activity\"); require(false); } if (_days > daysPerWeek) { emit Log(\"You cannot register for more than 7 days per week\"); require(false); } if (_days > daysPerWeek - currentDayOfWeek()) { emit Log(\"It is too late in the week for you to register\"); require(false); } WeekCommittment storage commitment = commitments[msg.sender][currentWeek()]; if (commitment.tokensCommitted != 0) { emit Log(\"You have already committed to this week\"); require(false); } balances[0x0] = balances[0x0] + tokens; balances[msg.sender] = balances[msg.sender] - tokens; emit Transfer(msg.sender, 0x0, tokens); initializeWeekData(currentWeek()); WeekData storage data = dataPerWeek[currentWeek()]; data.totalPeople++; data.totalTokens += tokens; data.totalDaysCommitted += _days; commitment.daysCommitted = _days; commitment.daysCompleted = 0; commitment.tokensCommitted = tokens; commitment.tokensEarned = 0; commitment.tokensPaid = false; } // Payout your available balance based on your activity in previous weeks function payout() public { require(currentWeek() > 0); for (uint activeWeek = currentWeek() - 1; true; activeWeek--) { WeekCommittment storage committment = commitments[msg.sender][activeWeek]; if (committment.tokensPaid) { break; } if (committment.daysCommitted == 0) { committment.tokensPaid = true; // Handle edge case and avoid -1 if (activeWeek == 0) break; continue; } initializeWeekData(activeWeek); WeekData storage week = dataPerWeek[activeWeek]; uint tokensFromPool = 0; uint tokens = committment.tokensCommitted * committment.daysCompleted / committment.daysCommitted; if (week.totalPeopleCompleted == 0) { tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeople; tokens = 0; } else if (committment.daysCompleted == committment.daysCommitted) { tokensFromPool = (week.totalTokens - week.totalTokensCompleted) / week.totalPeopleCompleted; } uint totalTokens = tokensFromPool + tokens; if (totalTokens == 0) { committment.tokensPaid = true; // Handle edge case and avoid -1 if (activeWeek == 0) break; continue; } balances[0x0] = balances[0x0] - totalTokens; balances[msg.sender] = balances[msg.sender] + totalTokens; emit Transfer(0x0, msg.sender, totalTokens); committment.tokensEarned = totalTokens; committment.tokensPaid = true; // Handle edge case and avoid -1 if (activeWeek == 0) break; } } // Post image data to the blockchain and log completion // TODO: If not committed for this week use last weeks tokens and days (if it exists) function postProof(string proofHash) public { WeekCommittment storage committment = commitments[msg.sender][currentWeek()]; if (committment.daysCompleted > currentDayOfWeek()) { emit Log(\"You have already uploaded proof for today\"); require(false); } if (committment.tokensCommitted == 0) { emit Log(\"You have not committed to this week yet\"); require(false); } if (committment.workoutProofs[currentDayOfWeek()] != 0) { emit Log(\"Proof has already been stored for this day\"); require(false); } if (committment.daysCompleted >= committment.daysCommitted) { // Don't allow us to go over our committed days return; } committment.workoutProofs[currentDayOfWeek()] = storeImageString(proofHash); committment.daysCompleted++; initializeWeekData(currentWeek()); WeekData storage week = dataPerWeek[currentWeek()]; week.totalDaysCompleted++; week.totalTokensCompleted = week.totalTokens * week.totalDaysCompleted / week.totalDaysCommitted; if (committment.daysCompleted >= committment.daysCommitted) { week.totalPeopleCompleted++; } } // Withdraw tokens to eth function withdraw(uint tokens) public returns (bool success) { require(balances[msg.sender] >= tokens); uint weiToSend = tokens * weiPerToken; require(address(this).balance >= weiToSend); balances[msg.sender] = balances[msg.sender] - tokens; _totalSupply -= tokens; return msg.sender.send(tokens * weiPerToken); } // Store an image string and get back a numerical identifier function storeImageString(string hash) public returns (uint index) { imageHashes[++imageHashCount] = hash; return imageHashCount; } // Initialize a week data struct function initializeWeekData(uint _week) public { if (dataPerWeek[_week].initialized) return; WeekData storage week = dataPerWeek[_week]; week.initialized = true; week.totalTokensCompleted = 0; week.totalPeopleCompleted = 0; week.totalTokens = 0; week.totalPeople = 0; week.totalDaysCommitted = 0; week.totalDaysCompleted = 0; } // Get the current day (from contract creation) function currentDay() public view returns (uint day) { return (block.timestamp - startDate) / secondsPerDay; } // Get the current week (from contract creation) function currentWeek() public view returns (uint week) { return currentDay() / daysPerWeek; } // Get current relative day of week (0-6) function currentDayOfWeek() public view returns (uint dayIndex) { // Uses the floor to calculate offset return currentDay() - (currentWeek() * daysPerWeek); } } "}
{"sol name": "6272.sol", "label": 1, "sol content": "pragma solidity ^0.4.18; /* ==================================================================== */ /* Copyright (c) 2018 The MagicAcademy Project.  All rights reserved. /* /* https://www.magicacademy.io One of the world's first idle strategy games of blockchain /* /* authors [email\u00a0protected]/[email\u00a0protected] /* /* ==================================================================== */ /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /* * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract AccessAdmin is Ownable { /// @dev Admin Address mapping (address => bool) adminContracts; /// @dev Trust contract mapping (address => bool) actionContracts; function setAdminContract(address _addr, bool _useful) public onlyOwner { require(_addr != address(0)); adminContracts[_addr] = _useful; } modifier onlyAdmin { require(adminContracts[msg.sender]); _; } function setActionContract(address _actionAddr, bool _useful) public onlyAdmin { actionContracts[_actionAddr] = _useful; } modifier onlyAccess() { require(actionContracts[msg.sender]); _; } } interface ERC20 { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract JadeCoin is ERC20, AccessAdmin { using SafeMath for SafeMath; string public constant name  = \"MAGICACADEMY JADE\"; string public constant symbol = \"Jade\"; uint8 public constant decimals = 0; uint256 public roughSupply; uint256 public totalJadeProduction; uint256[] public totalJadeProductionSnapshots; // The total goo production for each prior day past uint256 public nextSnapshotTime; uint256 public researchDivPercent = 10; // Balances for each player mapping(address => uint256) public jadeBalance; mapping(address => mapping(uint8 => uint256)) public coinBalance; mapping(uint8 => uint256) totalEtherPool; //Total Pool mapping(address => mapping(uint256 => uint256)) public jadeProductionSnapshots; // Store player's jade production for given day (snapshot) mapping(address => mapping(uint256 => bool)) private jadeProductionZeroedSnapshots; // This isn't great but we need know difference between 0 production and an unused/inactive day. mapping(address => uint256) public lastJadeSaveTime; // Seconds (last time player claimed their produced jade) mapping(address => uint256) public lastJadeProductionUpdate; // Days (last snapshot player updated their production) mapping(address => uint256) private lastJadeResearchFundClaim; // Days (snapshot number) mapping(address => uint256) private lastJadeDepositFundClaim; // Days (snapshot number) uint256[] private allocatedJadeResearchSnapshots; // Div pot #1 (research eth allocated to each prior day past) // Mapping of approved ERC20 transfers (by player) mapping(address => mapping(address => uint256)) private allowed; event ReferalGain(address player, address referal, uint256 amount); // Constructor function JadeCoin() public { } function() external payable { totalEtherPool[1] += msg.value; } // Incase community prefers goo deposit payments over production %, can be tweaked for balance function tweakDailyDividends(uint256 newResearchPercent) external { require(msg.sender == owner); require(newResearchPercent > 0 && newResearchPercent <= 10); researchDivPercent = newResearchPercent; } function totalSupply() public constant returns(uint256) { return roughSupply; // Stored jade (rough supply as it ignores earned/unclaimed jade) } /// balance of jade in-game function balanceOf(address player) public constant returns(uint256) { return SafeMath.add(jadeBalance[player],balanceOfUnclaimed(player)); } /// unclaimed jade function balanceOfUnclaimed(address player) public constant returns (uint256) { uint256 lSave = lastJadeSaveTime[player]; if (lSave > 0 && lSave < block.timestamp) { return SafeMath.mul(getJadeProduction(player),SafeMath.div(SafeMath.sub(block.timestamp,lSave),10)); } return 0; } /// production/s function getJadeProduction(address player) public constant returns (uint256){ return jadeProductionSnapshots[player][lastJadeProductionUpdate[player]]; } /// return totalJadeProduction/s function getTotalJadeProduction() external view returns (uint256) { return totalJadeProduction; } function getlastJadeProductionUpdate(address player) public view returns (uint256) { return lastJadeProductionUpdate[player]; } /// increase prodution function increasePlayersJadeProduction(address player, uint256 increase) public onlyAccess { jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = SafeMath.add(getJadeProduction(player),increase); lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length; totalJadeProduction = SafeMath.add(totalJadeProduction,increase); } /// reduce production  20180702 function reducePlayersJadeProduction(address player, uint256 decrease) public onlyAccess { uint256 previousProduction = getJadeProduction(player); uint256 newProduction = SafeMath.sub(previousProduction, decrease); if (newProduction == 0) { jadeProductionZeroedSnapshots[player][allocatedJadeResearchSnapshots.length] = true; delete jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length]; // 0 } else { jadeProductionSnapshots[player][allocatedJadeResearchSnapshots.length] = newProduction; } lastJadeProductionUpdate[player] = allocatedJadeResearchSnapshots.length; totalJadeProduction = SafeMath.sub(totalJadeProduction,decrease); } /// update player's jade balance function updatePlayersCoin(address player) internal { uint256 coinGain = balanceOfUnclaimed(player); lastJadeSaveTime[player] = block.timestamp; roughSupply = SafeMath.add(roughSupply,coinGain); jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain); } /// update player's jade balance function updatePlayersCoinByOut(address player) external onlyAccess { uint256 coinGain = balanceOfUnclaimed(player); lastJadeSaveTime[player] = block.timestamp; roughSupply = SafeMath.add(roughSupply,coinGain); jadeBalance[player] = SafeMath.add(jadeBalance[player],coinGain); } /// transfer function transfer(address recipient, uint256 amount) public returns (bool) { updatePlayersCoin(msg.sender); require(amount <= jadeBalance[msg.sender]); jadeBalance[msg.sender] = SafeMath.sub(jadeBalance[msg.sender],amount); jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount); //event Transfer(msg.sender, recipient, amount); return true; } /// transferfrom function transferFrom(address player, address recipient, uint256 amount) public returns (bool) { updatePlayersCoin(player); require(amount <= allowed[player][msg.sender] && amount <= jadeBalance[player]); jadeBalance[player] = SafeMath.sub(jadeBalance[player],amount); jadeBalance[recipient] = SafeMath.add(jadeBalance[recipient],amount); allowed[player][msg.sender] = SafeMath.sub(allowed[player][msg.sender],amount); Transfer(player, recipient, amount); return true; } function approve(address approvee, uint256 amount) public returns (bool) { allowed[msg.sender][approvee] = amount; Approval(msg.sender, approvee, amount); return true; } function allowance(address player, address approvee) public constant returns(uint256) { return allowed[player][approvee]; } /// update Jade via purchase function updatePlayersCoinByPurchase(address player, uint256 purchaseCost) public onlyAccess { uint256 unclaimedJade = balanceOfUnclaimed(player); if (purchaseCost > unclaimedJade) { uint256 jadeDecrease = SafeMath.sub(purchaseCost, unclaimedJade); require(jadeBalance[player] >= jadeDecrease); roughSupply = SafeMath.sub(roughSupply,jadeDecrease); jadeBalance[player] = SafeMath.sub(jadeBalance[player],jadeDecrease); } else { uint256 jadeGain = SafeMath.sub(unclaimedJade,purchaseCost); roughSupply = SafeMath.add(roughSupply,jadeGain); jadeBalance[player] = SafeMath.add(jadeBalance[player],jadeGain); } lastJadeSaveTime[player] = block.timestamp; } function JadeCoinMining(address _addr, uint256 _amount) external onlyAdmin { roughSupply = SafeMath.add(roughSupply,_amount); jadeBalance[_addr] = SafeMath.add(jadeBalance[_addr],_amount); } function setRoughSupply(uint256 iroughSupply) external onlyAccess { roughSupply = SafeMath.add(roughSupply,iroughSupply); } /// balance of coin  in-game function coinBalanceOf(address player,uint8 itype) external constant returns(uint256) { return coinBalance[player][itype]; } function setJadeCoin(address player, uint256 coin, bool iflag) external onlyAccess { if (iflag) { jadeBalance[player] = SafeMath.add(jadeBalance[player],coin); } else if (!iflag) { jadeBalance[player] = SafeMath.sub(jadeBalance[player],coin); } } function setCoinBalance(address player, uint256 eth, uint8 itype, bool iflag) external onlyAccess { if (iflag) { coinBalance[player][itype] = SafeMath.add(coinBalance[player][itype],eth); } else if (!iflag) { coinBalance[player][itype] = SafeMath.sub(coinBalance[player][itype],eth); } } function setLastJadeSaveTime(address player) external onlyAccess { lastJadeSaveTime[player] = block.timestamp; } function setTotalEtherPool(uint256 inEth, uint8 itype, bool iflag) external onlyAccess { if (iflag) { totalEtherPool[itype] = SafeMath.add(totalEtherPool[itype],inEth); } else if (!iflag) { totalEtherPool[itype] = SafeMath.sub(totalEtherPool[itype],inEth); } } function getTotalEtherPool(uint8 itype) external view returns (uint256) { return totalEtherPool[itype]; } function setJadeCoinZero(address player) external onlyAccess { jadeBalance[player]=0; } function getNextSnapshotTime() external view returns(uint256) { return nextSnapshotTime; } // To display on website function viewUnclaimedResearchDividends() external constant returns (uint256, uint256, uint256) { uint256 startSnapshot = lastJadeResearchFundClaim[msg.sender]; uint256 latestSnapshot = allocatedJadeResearchSnapshots.length - 1; // No snapshots to begin with uint256 researchShare; uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1]; // Underflow won't be a problem as gooProductionSnapshots[][0xfffffffffffff] = 0; for (uint256 i = startSnapshot; i <= latestSnapshot; i++) { // Slightly complex things by accounting for days/snapshots when user made no tx's uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i]; bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i]; if (productionDuringSnapshot == 0 && !soldAllProduction) { productionDuringSnapshot = previousProduction; } else { previousProduction = productionDuringSnapshot; } researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i]; } return (researchShare, startSnapshot, latestSnapshot); } function claimResearchDividends(address referer, uint256 startSnapshot, uint256 endSnapShot) external { require(startSnapshot <= endSnapShot); require(startSnapshot >= lastJadeResearchFundClaim[msg.sender]); require(endSnapShot < allocatedJadeResearchSnapshots.length); uint256 researchShare; uint256 previousProduction = jadeProductionSnapshots[msg.sender][lastJadeResearchFundClaim[msg.sender] - 1]; // Underflow won't be a problem as gooProductionSnapshots[][0xffffffffff] = 0; for (uint256 i = startSnapshot; i <= endSnapShot; i++) { // Slightly complex things by accounting for days/snapshots when user made no tx's uint256 productionDuringSnapshot = jadeProductionSnapshots[msg.sender][i]; bool soldAllProduction = jadeProductionZeroedSnapshots[msg.sender][i]; if (productionDuringSnapshot == 0 && !soldAllProduction) { productionDuringSnapshot = previousProduction; } else { previousProduction = productionDuringSnapshot; } researchShare += (allocatedJadeResearchSnapshots[i] * productionDuringSnapshot) / totalJadeProductionSnapshots[i]; } if (jadeProductionSnapshots[msg.sender][endSnapShot] == 0 && !jadeProductionZeroedSnapshots[msg.sender][endSnapShot] && previousProduction > 0) { jadeProductionSnapshots[msg.sender][endSnapShot] = previousProduction; // Checkpoint for next claim } lastJadeResearchFundClaim[msg.sender] = endSnapShot + 1; uint256 referalDivs; if (referer != address(0) && referer != msg.sender) { referalDivs = researchShare / 100; // 1% coinBalance[referer][1] += referalDivs; ReferalGain(referer, msg.sender, referalDivs); } coinBalance[msg.sender][1] += SafeMath.sub(researchShare,referalDivs); } // Allocate pot divs for the day (00:00 cron job) function snapshotDailyGooResearchFunding() external onlyAdmin { uint256 todaysGooResearchFund = (totalEtherPool[1] * researchDivPercent) / 100; // 10% of pool daily totalEtherPool[1] -= todaysGooResearchFund; totalJadeProductionSnapshots.push(totalJadeProduction); allocatedJadeResearchSnapshots.push(todaysGooResearchFund); nextSnapshotTime = block.timestamp + 24 hours; } } interface GameConfigInterface { function productionCardIdRange() external constant returns (uint256, uint256); function battleCardIdRange() external constant returns (uint256, uint256); function upgradeIdRange() external constant returns (uint256, uint256); function unitCoinProduction(uint256 cardId) external constant returns (uint256); function unitAttack(uint256 cardId) external constant returns (uint256); function unitDefense(uint256 cardId) external constant returns (uint256); function unitStealingCapacity(uint256 cardId) external constant returns (uint256); } /// @notice define the players,cards,jadecoin /// @author rainysiu [email\u00a0protected] /// @dev MagicAcademy Games contract CardsBase is JadeCoin { function CardsBase() public { setAdminContract(msg.sender,true); setActionContract(msg.sender,true); } // player struct Player { address owneraddress; } Player[] players; bool gameStarted; GameConfigInterface public schema; // Stuff owned by each player mapping(address => mapping(uint256 => uint256)) public unitsOwned;  //number of normal card mapping(address => mapping(uint256 => uint256)) public upgradesOwned;  //Lv of upgrade card mapping(address => uint256) public uintsOwnerCount; // total number of cards mapping(address=> mapping(uint256 => uint256)) public uintProduction;  //card's production \u5355\u5f20\u5361\u724c\u603b\u4ea7\u91cf // Rares & Upgrades (Increase unit's production / attack etc.) mapping(address => mapping(uint256 => uint256)) public unitCoinProductionIncreases; // Adds to the coin per second mapping(address => mapping(uint256 => uint256)) public unitCoinProductionMultiplier; // Multiplies the coin per second mapping(address => mapping(uint256 => uint256)) public unitAttackIncreases; mapping(address => mapping(uint256 => uint256)) public unitAttackMultiplier; mapping(address => mapping(uint256 => uint256)) public unitDefenseIncreases; mapping(address => mapping(uint256 => uint256)) public unitDefenseMultiplier; mapping(address => mapping(uint256 => uint256)) public unitJadeStealingIncreases; mapping(address => mapping(uint256 => uint256)) public unitJadeStealingMultiplier; mapping(address => mapping(uint256 => uint256)) private unitMaxCap; // external cap //setting configuration function setConfigAddress(address _address) external onlyOwner { schema = GameConfigInterface(_address); } /// start game function beginGame(uint256 firstDivsTime) external payable onlyOwner { require(!gameStarted); gameStarted = true; nextSnapshotTime = firstDivsTime; totalEtherPool[1] = msg.value;  // Seed pot } function endGame() external payable onlyOwner { require(gameStarted); gameStarted = false; } function getGameStarted() external constant returns (bool) { return gameStarted; } function AddPlayers(address _address) external onlyAccess { Player memory _player= Player({ owneraddress: _address }); players.push(_player); } /// @notice ranking of production /// @notice rainysiu function getRanking() external view returns (address[], uint256[],uint256[]) { uint256 len = players.length; uint256[] memory arr = new uint256[](len); address[] memory arr_addr = new address[](len); uint256[] memory arr_def = new uint256[](len); uint counter =0; for (uint k=0;k<len; k++){ arr[counter] =  getJadeProduction(players[k].owneraddress); arr_addr[counter] = players[k].owneraddress; (,arr_def[counter],,) = getPlayersBattleStats(players[k].owneraddress); counter++; } for(uint i=0;i<len-1;i++) { for(uint j=0;j<len-i-1;j++) { if(arr[j]<arr[j+1]) { uint256 temp = arr[j]; address temp_addr = arr_addr[j]; uint256 temp_def = arr_def[j]; arr[j] = arr[j+1]; arr[j+1] = temp; arr_addr[j] = arr_addr[j+1]; arr_addr[j+1] = temp_addr; arr_def[j] = arr_def[j+1]; arr_def[j+1] = temp_def; } } } return (arr_addr,arr,arr_def); } //total users function getTotalUsers()  external view returns (uint256) { return players.length; } function getMaxCap(address _addr,uint256 _cardId) external view returns (uint256) { return unitMaxCap[_addr][_cardId]; } /// UnitsProuction function getUnitsProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) { return (amount * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]) * (10 + unitCoinProductionMultiplier[player][unitId])) / 10; } /// one card's production function getUnitsInProduction(address player, uint256 unitId, uint256 amount) external constant returns (uint256) { return SafeMath.div(SafeMath.mul(amount,uintProduction[player][unitId]),unitsOwned[player][unitId]); } /// UnitsAttack function getUnitsAttack(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) { return (amount * (schema.unitAttack(unitId) + unitAttackIncreases[player][unitId]) * (10 + unitAttackMultiplier[player][unitId])) / 10; } /// UnitsDefense function getUnitsDefense(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) { return (amount * (schema.unitDefense(unitId) + unitDefenseIncreases[player][unitId]) * (10 + unitDefenseMultiplier[player][unitId])) / 10; } /// UnitsStealingCapacity function getUnitsStealingCapacity(address player, uint256 unitId, uint256 amount) internal constant returns (uint256) { return (amount * (schema.unitStealingCapacity(unitId) + unitJadeStealingIncreases[player][unitId]) * (10 + unitJadeStealingMultiplier[player][unitId])) / 10; } // player's attacking & defending & stealing & battle power function getPlayersBattleStats(address player) public constant returns ( uint256 attackingPower, uint256 defendingPower, uint256 stealingPower, uint256 battlePower) { uint256 startId; uint256 endId; (startId, endId) = schema.battleCardIdRange(); // Not ideal but will only be a small number of units (and saves gas when buying units) while (startId <= endId) { attackingPower = SafeMath.add(attackingPower,getUnitsAttack(player, startId, unitsOwned[player][startId])); stealingPower = SafeMath.add(stealingPower,getUnitsStealingCapacity(player, startId, unitsOwned[player][startId])); defendingPower = SafeMath.add(defendingPower,getUnitsDefense(player, startId, unitsOwned[player][startId])); battlePower = SafeMath.add(attackingPower,defendingPower); startId++; } } // @nitice number of normal card function getOwnedCount(address player, uint256 cardId) external view returns (uint256) { return unitsOwned[player][cardId]; } function setOwnedCount(address player, uint256 cardId, uint256 amount, bool iflag) external onlyAccess { if (iflag) { unitsOwned[player][cardId] = SafeMath.add(unitsOwned[player][cardId],amount); } else if (!iflag) { unitsOwned[player][cardId] = SafeMath.sub(unitsOwned[player][cardId],amount); } } // @notice Lv of upgrade card function getUpgradesOwned(address player, uint256 upgradeId) external view returns (uint256) { return upgradesOwned[player][upgradeId]; } //set upgrade function setUpgradesOwned(address player, uint256 upgradeId) external onlyAccess { upgradesOwned[player][upgradeId] = SafeMath.add(upgradesOwned[player][upgradeId],1); } function getUintsOwnerCount(address _address) external view returns (uint256) { return uintsOwnerCount[_address]; } function setUintsOwnerCount(address _address, uint256 amount, bool iflag) external onlyAccess { if (iflag) { uintsOwnerCount[_address] = SafeMath.add(uintsOwnerCount[_address],amount); } else if (!iflag) { uintsOwnerCount[_address] = SafeMath.sub(uintsOwnerCount[_address],amount); } } function getUnitCoinProductionIncreases(address _address, uint256 cardId) external view returns (uint256) { return unitCoinProductionIncreases[_address][cardId]; } function setUnitCoinProductionIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitCoinProductionIncreases[_address][cardId] = SafeMath.add(unitCoinProductionIncreases[_address][cardId],iValue); } else if (!iflag) { unitCoinProductionIncreases[_address][cardId] = SafeMath.sub(unitCoinProductionIncreases[_address][cardId],iValue); } } function getUnitCoinProductionMultiplier(address _address, uint256 cardId) external view returns (uint256) { return unitCoinProductionMultiplier[_address][cardId]; } function setUnitCoinProductionMultiplier(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess { if (iflag) { unitCoinProductionMultiplier[_address][cardId] = SafeMath.add(unitCoinProductionMultiplier[_address][cardId],iValue); } else if (!iflag) { unitCoinProductionMultiplier[_address][cardId] = SafeMath.sub(unitCoinProductionMultiplier[_address][cardId],iValue); } } function setUnitAttackIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitAttackIncreases[_address][cardId] = SafeMath.add(unitAttackIncreases[_address][cardId],iValue); } else if (!iflag) { unitAttackIncreases[_address][cardId] = SafeMath.sub(unitAttackIncreases[_address][cardId],iValue); } } function getUnitAttackIncreases(address _address, uint256 cardId) external view returns (uint256) { return unitAttackIncreases[_address][cardId]; } function setUnitAttackMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitAttackMultiplier[_address][cardId] = SafeMath.add(unitAttackMultiplier[_address][cardId],iValue); } else if (!iflag) { unitAttackMultiplier[_address][cardId] = SafeMath.sub(unitAttackMultiplier[_address][cardId],iValue); } } function getUnitAttackMultiplier(address _address, uint256 cardId) external view returns (uint256) { return unitAttackMultiplier[_address][cardId]; } function setUnitDefenseIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitDefenseIncreases[_address][cardId] = SafeMath.add(unitDefenseIncreases[_address][cardId],iValue); } else if (!iflag) { unitDefenseIncreases[_address][cardId] = SafeMath.sub(unitDefenseIncreases[_address][cardId],iValue); } } function getUnitDefenseIncreases(address _address, uint256 cardId) external view returns (uint256) { return unitDefenseIncreases[_address][cardId]; } function setunitDefenseMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitDefenseMultiplier[_address][cardId] = SafeMath.add(unitDefenseMultiplier[_address][cardId],iValue); } else if (!iflag) { unitDefenseMultiplier[_address][cardId] = SafeMath.sub(unitDefenseMultiplier[_address][cardId],iValue); } } function getUnitDefenseMultiplier(address _address, uint256 cardId) external view returns (uint256) { return unitDefenseMultiplier[_address][cardId]; } function setUnitJadeStealingIncreases(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitJadeStealingIncreases[_address][cardId] = SafeMath.add(unitJadeStealingIncreases[_address][cardId],iValue); } else if (!iflag) { unitJadeStealingIncreases[_address][cardId] = SafeMath.sub(unitJadeStealingIncreases[_address][cardId],iValue); } } function getUnitJadeStealingIncreases(address _address, uint256 cardId) external view returns (uint256) { return unitJadeStealingIncreases[_address][cardId]; } function setUnitJadeStealingMultiplier(address _address, uint256 cardId, uint256 iValue,bool iflag) external onlyAccess { if (iflag) { unitJadeStealingMultiplier[_address][cardId] = SafeMath.add(unitJadeStealingMultiplier[_address][cardId],iValue); } else if (!iflag) { unitJadeStealingMultiplier[_address][cardId] = SafeMath.sub(unitJadeStealingMultiplier[_address][cardId],iValue); } } function getUnitJadeStealingMultiplier(address _address, uint256 cardId) external view returns (uint256) { return unitJadeStealingMultiplier[_address][cardId]; } function setUintCoinProduction(address _address, uint256 cardId, uint256 iValue, bool iflag) external onlyAccess { if (iflag) { uintProduction[_address][cardId] = SafeMath.add(uintProduction[_address][cardId],iValue); } else if (!iflag) { uintProduction[_address][cardId] = SafeMath.sub(uintProduction[_address][cardId],iValue); } } function getUintCoinProduction(address _address, uint256 cardId) external view returns (uint256) { return uintProduction[_address][cardId]; } function upgradeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess { uint256 productionGain; if (upgradeClass == 0) { unitCoinProductionIncreases[player][unitId] += upgradeValue; productionGain = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]); increasePlayersJadeProduction(player, productionGain); } else if (upgradeClass == 1) { unitCoinProductionMultiplier[player][unitId] += upgradeValue; productionGain = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]); increasePlayersJadeProduction(player, productionGain); } else if (upgradeClass == 2) { unitAttackIncreases[player][unitId] += upgradeValue; } else if (upgradeClass == 3) { unitAttackMultiplier[player][unitId] += upgradeValue; } else if (upgradeClass == 4) { unitDefenseIncreases[player][unitId] += upgradeValue; } else if (upgradeClass == 5) { unitDefenseMultiplier[player][unitId] += upgradeValue; } else if (upgradeClass == 6) { unitJadeStealingIncreases[player][unitId] += upgradeValue; } else if (upgradeClass == 7) { unitJadeStealingMultiplier[player][unitId] += upgradeValue; } else if (upgradeClass == 8) { unitMaxCap[player][unitId] = upgradeValue; // Housing upgrade (new capacity) } } function removeUnitMultipliers(address player, uint256 upgradeClass, uint256 unitId, uint256 upgradeValue) external onlyAccess { uint256 productionLoss; if (upgradeClass == 0) { unitCoinProductionIncreases[player][unitId] -= upgradeValue; productionLoss = unitsOwned[player][unitId] * upgradeValue * (10 + unitCoinProductionMultiplier[player][unitId]); reducePlayersJadeProduction(player, productionLoss); } else if (upgradeClass == 1) { unitCoinProductionMultiplier[player][unitId] -= upgradeValue; productionLoss = unitsOwned[player][unitId] * upgradeValue * (schema.unitCoinProduction(unitId) + unitCoinProductionIncreases[player][unitId]); reducePlayersJadeProduction(player, productionLoss); } else if (upgradeClass == 2) { unitAttackIncreases[player][unitId] -= upgradeValue; } else if (upgradeClass == 3) { unitAttackMultiplier[player][unitId] -= upgradeValue; } else if (upgradeClass == 4) { unitDefenseIncreases[player][unitId] -= upgradeValue; } else if (upgradeClass == 5) { unitDefenseMultiplier[player][unitId] -= upgradeValue; } else if (upgradeClass == 6) { unitJadeStealingIncreases[player][unitId] -= upgradeValue; } else if (upgradeClass == 7) { unitJadeStealingMultiplier[player][unitId] -= upgradeValue; } } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "8254.sol", "label": 1, "sol content": "pragma solidity 0.4.24; // Minimal required STAKE token interface contract StakeToken { function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function balanceOf(address _owner) public view returns (uint256 balance); } contract StakeDiceGame { // Prevent people from losing Ether by accidentally sending it to this contract. function () payable external { revert(); } /////////////////////////////// /////// GAME PARAMETERS StakeDice public stakeDice; // Number between 0 and 10 000. Examples: // 700 indicates 7% chance. // 5000 indicates 50% chance. // 8000 indicates 80% chance. uint256 public winningChance; // Examples of multiplierOnWin() return values: // 10 000 indicates 1x returned. // 13 000 indicated 1.3x returned // 200 000 indicates 20x returned function multiplierOnWin() public view returns (uint256) { uint256 beforeHouseEdge = 10000; uint256 afterHouseEdge = beforeHouseEdge - stakeDice.houseEdge(); return afterHouseEdge * 10000 / winningChance; } function maximumBet() public view returns (uint256) { uint256 availableTokens = stakeDice.stakeTokenContract().balanceOf(address(stakeDice)); return availableTokens * 10000 / multiplierOnWin() / 5; } /////////////////////////////// /////// OWNER FUNCTIONS // Constructor function // Provide a number between 0 and 10 000 to indicate the winning chance and house edge. constructor(StakeDice _stakeDice, uint256 _winningChance) public { // Ensure the parameters are sane require(_winningChance > 0); require(_winningChance < 10000); require(_stakeDice != address(0x0)); require(msg.sender == address(_stakeDice)); stakeDice = _stakeDice; winningChance = _winningChance; } // Allow the owner to change the winning chance function setWinningChance(uint256 _newWinningChance) external { require(msg.sender == stakeDice.owner()); require(_newWinningChance > 0); require(_newWinningChance < 10000); winningChance = _newWinningChance; } // Allow the owner to withdraw STAKE tokens that // may have been accidentally sent here. function withdrawStakeTokens(uint256 _amount, address _to) external { require(msg.sender == stakeDice.owner()); require(_to != address(0x0)); stakeDice.stakeTokenContract().transfer(_to, _amount); } } contract StakeDice { /////////////////////////////// /////// GAME PARAMETERS StakeToken public stakeTokenContract; mapping(address => bool) public addressIsStakeDiceGameContract; StakeDiceGame[] public allGames; uint256 public houseEdge; uint256 public minimumBet; ////////////////////////////// /////// PLAYER STATISTICS address[] public allPlayers; mapping(address => uint256) public playersToTotalBets; mapping(address => uint256[]) public playersToBetIndices; function playerAmountOfBets(address _player) external view returns (uint256) { return playersToBetIndices[_player].length; } function totalUniquePlayers() external view returns (uint256) { return allPlayers.length; } ////////////////////////////// /////// GAME FUNCTIONALITY // Events event BetPlaced(address indexed gambler, uint256 betIndex); event BetWon(address indexed gambler, uint256 betIndex); event BetLost(address indexed gambler, uint256 betIndex); event BetCanceled(address indexed gambler, uint256 betIndex); enum BetStatus { NON_EXISTANT, IN_PROGRESS, WON, LOST, CANCELED } struct Bet { address gambler; uint256 winningChance; uint256 betAmount; uint256 potentialRevenue; uint256 roll; BetStatus status; } Bet[] public bets; uint public betsLength = 0; mapping(bytes32 => uint256) public oraclizeQueryIdsToBetIndices; function betPlaced(address gameContract, uint256 _amount) external { // Only StakeDiceGame contracts are allowed to call this function require(addressIsStakeDiceGameContract[gameContract] == true); // Make sure the bet is within the current limits require(_amount >= minimumBet); require(_amount <= StakeDiceGame(gameContract).maximumBet()); // Tranfer the STAKE tokens from the user's account to the StakeDice contract stakeTokenContract.transferFrom(msg.sender, this, _amount); // Calculate how much the gambler might win uint256 potentialRevenue = StakeDiceGame(gameContract).multiplierOnWin() * _amount / 10000; // Store the bet emit BetPlaced(msg.sender, bets.length); playersToBetIndices[msg.sender].push(bets.length); bets.push(Bet({gambler: msg.sender, winningChance: StakeDiceGame(gameContract).winningChance(), betAmount: _amount, potentialRevenue: potentialRevenue, roll: 0, status: BetStatus.IN_PROGRESS})); betsLength +=1; // Update statistics if (playersToTotalBets[msg.sender] == 0) { allPlayers.push(msg.sender); } playersToTotalBets[msg.sender] += _amount; //uint _result = 1; //the random number uint256 betIndex = betsLength; Bet storage bet = bets[betIndex]; require(bet.status == BetStatus.IN_PROGRESS); // Now that we have generated a random number, let's use it.. uint randomNumber = uint8(uint256(keccak256(abi.encodePacked(block.timestamp, block.difficulty)))%100); // Store the roll in the blockchain permanently bet.roll = randomNumber; // If the random number is smaller than the winningChance, the gambler won! if (randomNumber < bet.winningChance/100) { // If we somehow don't have enough tokens to payout their winnings, // cancel the bet and refund the gambler automatically if (stakeTokenContract.balanceOf(this) < bet.potentialRevenue) { _cancelBet(betIndex); } // Otherwise, (if we do have enough tokens) else { // The gambler won! bet.status = BetStatus.WON; // Send them their winnings stakeTokenContract.transfer(bet.gambler, bet.potentialRevenue); // Trigger BetWon event emit BetWon(bet.gambler, betIndex); } } else { // The gambler lost! bet.status = BetStatus.LOST; // Send them the smallest possible token unit as consolation prize // and as notification that their bet has lost. stakeTokenContract.transfer(bet.gambler, 1); // Send 0.00000001 STAKE // Trigger BetLost event emit BetLost(bet.gambler, betIndex); } } function _cancelBet(uint256 _betIndex) private { // Only bets that are in progress can be canceled require(bets[_betIndex].status == BetStatus.IN_PROGRESS); // Store the fact that the bet has been canceled bets[_betIndex].status = BetStatus.CANCELED; // Refund the bet amount to the gambler stakeTokenContract.transfer(bets[_betIndex].gambler, bets[_betIndex].betAmount); // Trigger BetCanceled event emit BetCanceled(bets[_betIndex].gambler, _betIndex); // Subtract the bet from their total playersToTotalBets[bets[_betIndex].gambler] -= bets[_betIndex].betAmount; } function amountOfGames() external view returns (uint256) { return allGames.length; } function amountOfBets() external view returns (uint256) { return bets.length-1; } /////////////////////////////// /////// OWNER FUNCTIONS address public owner; // Constructor function constructor(StakeToken _stakeTokenContract, uint256 _houseEdge, uint256 _minimumBet) public { // Bet indices start at 1 because the values of the // oraclizeQueryIdsToBetIndices mapping are by default 0. bets.length = 1; // Whoever deployed the contract is made owner owner = msg.sender; // Ensure that the arguments are sane require(_houseEdge < 10000); require(_stakeTokenContract != address(0x0)); // Store the initializing arguments stakeTokenContract = _stakeTokenContract; houseEdge = _houseEdge; minimumBet = _minimumBet; } // Allow the owner to easily create the default dice games function createDefaultGames() public { require(allGames.length == 0); addNewStakeDiceGame(500); // 5% chance addNewStakeDiceGame(1000); // 10% chance addNewStakeDiceGame(1500); // 15% chance addNewStakeDiceGame(2000); // 20% chance addNewStakeDiceGame(2500); // 25% chance addNewStakeDiceGame(3000); // 30% chance addNewStakeDiceGame(3500); // 35% chance addNewStakeDiceGame(4000); // 40% chance addNewStakeDiceGame(4500); // 45% chance addNewStakeDiceGame(5000); // 50% chance addNewStakeDiceGame(5500); // 55% chance addNewStakeDiceGame(6000); // 60% chance addNewStakeDiceGame(6500); // 65% chance addNewStakeDiceGame(7000); // 70% chance addNewStakeDiceGame(7500); // 75% chance addNewStakeDiceGame(8000); // 80% chance addNewStakeDiceGame(8500); // 85% chance addNewStakeDiceGame(9000); // 90% chance addNewStakeDiceGame(9500); // 95% chance } // Allow the owner to cancel a bet when it's in progress. // This will probably never be needed, but it might some day be needed // to refund people if oraclize is not responding. function cancelBet(uint256 _betIndex) public { require(msg.sender == owner); _cancelBet(_betIndex); } // Allow the owner to add new games with different winning chances function addNewStakeDiceGame(uint256 _winningChance) public { require(msg.sender == owner); // Deploy a new StakeDiceGame contract StakeDiceGame newGame = new StakeDiceGame(this, _winningChance); // Store the fact that this new address is a StakeDiceGame contract addressIsStakeDiceGameContract[newGame] = true; allGames.push(newGame); } // Allow the owner to change the house edge function setHouseEdge(uint256 _newHouseEdge) external { require(msg.sender == owner); require(_newHouseEdge < 10000); houseEdge = _newHouseEdge; } // Allow the owner to change the minimum bet // This also allows the owner to temporarily disable the game by setting the // minimum bet to an impossibly high number. function setMinimumBet(uint256 _newMinimumBet) external { require(msg.sender == owner); minimumBet = _newMinimumBet; } // Allow the owner to deposit and withdraw ether // (this contract needs to pay oraclize fees) function depositEther() payable external { require(msg.sender == owner); } function withdrawEther(uint256 _amount) payable external { require(msg.sender == owner); owner.transfer(_amount); } // Allow the owner to make another address the owner function transferOwnership(address _newOwner) external { require(msg.sender == owner); require(_newOwner != 0x0); owner = _newOwner; } // Allow the owner to withdraw STAKE tokens function withdrawStakeTokens(uint256 _amount) external { require(msg.sender == owner); stakeTokenContract.transfer(owner, _amount); } // Prevent people from losing Ether by accidentally sending it to this contract. function () payable external { revert(); } } "}
{"sol name": "11765.sol", "label": 1, "sol content": "/* * This file was generated by MyWish Platform (https://mywish.io/) * The complete code could be found at https://github.com/MyWishPlatform/ * Copyright (C) 2018 MyWish * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with this program. If not, see <http://www.gnu.org/licenses/>. */ pragma solidity ^0.4.20; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract FreezableToken is StandardToken { // freezing chains mapping (bytes32 => uint64) internal chains; // freezing amounts for each chain mapping (bytes32 => uint) internal freezings; // total freezing balance per address mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); /** * @dev Gets the balance of the specified address include freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; } /** * @dev Gets the balance of the specified address without freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function actualBalanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner); } function freezingBalanceOf(address _owner) public view returns (uint256 balance) { return freezingBalance[_owner]; } /** * @dev gets freezing count * @param _addr Address of freeze tokens owner. */ function freezingCount(address _addr) public view returns (uint count) { uint64 release = chains[toKey(_addr, 0)]; while (release != 0) { count ++; release = chains[toKey(_addr, release)]; } } /** * @dev gets freezing end date and freezing balance for the freezing portion specified by index. * @param _addr Address of freeze tokens owner. * @param _index Freezing portion index. It ordered by release date descending. */ function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) { for (uint i = 0; i < _index + 1; i ++) { _release = chains[toKey(_addr, _release)]; if (_release == 0) { return; } } _balance = freezings[toKey(_addr, _release)]; } /** * @dev freeze your tokens to the specified address. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to freeze. * @param _until Release date, must be in future. */ function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); Transfer(msg.sender, _to, _amount); Freezed(_to, _until, _amount); } /** * @dev release first available freezing tokens. */ function releaseOnce() public { bytes32 headKey = toKey(msg.sender, 0); uint64 head = chains[headKey]; require(head != 0); require(uint64(block.timestamp) > head); bytes32 currentKey = toKey(msg.sender, head); uint64 next = chains[currentKey]; uint amount = freezings[currentKey]; delete freezings[currentKey]; balances[msg.sender] = balances[msg.sender].add(amount); freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount); if (next == 0) { delete chains[headKey]; } else { chains[headKey] = next; delete chains[currentKey]; } Released(msg.sender, amount); } /** * @dev release all available for release freezing tokens. Gas usage is not deterministic! * @return how many tokens was released */ function releaseAll() public returns (uint tokens) { uint release; uint balance; (release, balance) = getFreezing(msg.sender, 0); while (release != 0 && block.timestamp > release) { releaseOnce(); tokens += balance; (release, balance) = getFreezing(msg.sender, 0); } } function toKey(address _addr, uint _release) internal pure returns (bytes32 result) { // WISH masc to increase entropy result = 0x5749534800000000000000000000000000000000000000000000000000000000; assembly { result := or(result, mul(_addr, 0x10000000000000000)) result := or(result, _release) } } function freeze(address _to, uint64 _until) internal { require(_until > block.timestamp); bytes32 key = toKey(_to, _until); bytes32 parentKey = toKey(_to, uint64(0)); uint64 next = chains[parentKey]; if (next == 0) { chains[parentKey] = _until; return; } bytes32 nextKey = toKey(_to, next); uint parent; while (next != 0 && _until > next) { parent = next; parentKey = nextKey; next = chains[nextKey]; nextKey = toKey(_to, next); } if (_until == next) { return; } if (next != 0) { chains[key] = next; } chains[parentKey] = _until; } } /** * @title Contract that will work with ERC223 tokens. */ contract ERC223Receiver { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data) public; } contract ERC223Basic is ERC20Basic { function transfer(address to, uint value, bytes data) public returns (bool); event Transfer(address indexed from, address indexed to, uint value, bytes data); } contract SuccessfulERC223Receiver is ERC223Receiver { event Invoked(address from, uint value, bytes data); function tokenFallback(address _from, uint _value, bytes _data) public { Invoked(_from, _value, _data); } } contract FailingERC223Receiver is ERC223Receiver { function tokenFallback(address, uint, bytes) public { revert(); } } contract ERC223ReceiverWithoutTokenFallback { } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract FreezableMintableToken is FreezableToken, MintableToken { /** * @dev Mint the specified amount of token to the specified address and freeze it until the specified date. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to mint and freeze. * @param _until Release date, must be in future. * @return A boolean that indicates if the operation was successful. */ function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); Mint(_to, _amount); Freezed(_to, _until, _amount); Transfer(msg.sender, _to, _amount); return true; } } contract Consts { uint constant TOKEN_DECIMALS = 18; uint8 constant TOKEN_DECIMALS_UINT8 = 18; uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS; string constant TOKEN_NAME = \"DiscountCoins\"; string constant TOKEN_SYMBOL = \"DISC\"; bool constant PAUSED = false; address constant TARGET_USER = 0xBdDcCf71a2557A14d87d16cf554d5544CEBFc1DF; uint constant START_TIME = 1528208460; bool constant CONTINUE_MINTING = true; } /** * @title Reference implementation of the ERC223 standard token. */ contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver { using SafeMath for uint; /** * @dev Transfer the specified amount of tokens to the specified address. *      Invokes the `tokenFallback` function if the recipient is a contract. *      The token transfer fails if the recipient is a contract *      but does not implement the `tokenFallback` function *      or the fallback function to receive funds. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint _value, bytes _data) public returns (bool) { // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . uint codeLength; assembly { // Retrieve the size of the code on target address, this needs assembly. codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength > 0) { ERC223Receiver receiver = ERC223Receiver(_to); receiver.tokenFallback(msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      This function works the same with the previous one *      but doesn't contain `_data` param. *      Added due to backwards compatibility reasons. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { bytes memory empty; return transfer(_to, _value, empty); } } contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable { function name() pure public returns (string _name) { return TOKEN_NAME; } function symbol() pure public returns (string _symbol) { return TOKEN_SYMBOL; } function decimals() pure public returns (uint8 _decimals) { return TOKEN_DECIMALS_UINT8; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transfer(_to, _value); } } "}
{"sol name": "9889.sol", "label": 1, "sol content": "pragma solidity ^0.4.13; interface IAffiliateList { /** * @dev Sets the given address as an affiliate. *      If the address is not currently an affiliate, startTimestamp is required *      and endTimestamp is optional. *      If the address is already registered as an affiliate, both values are optional. * @param startTimestamp Timestamp when the address became/becomes an affiliate. * @param endTimestamp Timestamp when the address will no longer be an affiliate. */ function set(address addr, uint startTimestamp, uint endTimestamp) external; /** * @dev Retrieves the start and end timestamps for the given address. *      It is sufficient to check the start value to determine if the address *      is an affiliate (start will be greater than zero). */ function get(address addr) external view returns (uint start, uint end); /** * @dev Returns true if the address is, was, or will be an affiliate at the given time. */ function inListAsOf(address addr, uint time) external view returns (bool); } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract IInvestorList { string public constant ROLE_REGD = \"regd\"; string public constant ROLE_REGCF = \"regcf\"; string public constant ROLE_REGS = \"regs\"; string public constant ROLE_UNKNOWN = \"unknown\"; function inList(address addr) public view returns (bool); function addAddress(address addr, string role) public; function getRole(address addr) public view returns (string); function hasRole(address addr, string role) public view returns (bool); } contract Ownable { address public owner; address public newOwner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Starts the 2-step process of changing ownership. The new owner * must then call `acceptOwnership()`. */ function changeOwner(address _newOwner) public onlyOwner { newOwner = _newOwner; } /** * @dev Completes the process of transferring ownership to a new owner. */ function acceptOwnership() public { if (msg.sender == newOwner) { owner = newOwner; newOwner = 0; } } } contract AffiliateList is Ownable, IAffiliateList { event AffiliateAdded(address addr, uint startTimestamp, uint endTimestamp); event AffiliateUpdated(address addr, uint startTimestamp, uint endTimestamp); mapping (address => uint) public affiliateStart; mapping (address => uint) public affiliateEnd; function set(address addr, uint startTimestamp, uint endTimestamp) public onlyOwner { require(addr != address(0)); uint existingStart = affiliateStart[addr]; if(existingStart == 0) { // this is a new address require(startTimestamp != 0); affiliateStart[addr] = startTimestamp; if(endTimestamp != 0) { require(endTimestamp > startTimestamp); affiliateEnd[addr] = endTimestamp; } emit AffiliateAdded(addr, startTimestamp, endTimestamp); } else { // this address was previously registered if(startTimestamp == 0) { // don't update the start timestamp if(endTimestamp == 0) { affiliateStart[addr] = 0; affiliateEnd[addr] = 0; } else { require(endTimestamp > existingStart); } } else { // update the start timestamp affiliateStart[addr] = startTimestamp; if(endTimestamp != 0) { require(endTimestamp > startTimestamp); } } affiliateEnd[addr] = endTimestamp; emit AffiliateUpdated(addr, startTimestamp, endTimestamp); } } function get(address addr) public view returns (uint start, uint end) { return (affiliateStart[addr], affiliateEnd[addr]); } function inListAsOf(address addr, uint time) public view returns (bool) { uint start; uint end; (start, end) = get(addr); if(start == 0) { return false; } if(time < start) { return false; } if(end != 0 && time >= end) { return false; } return true; } } contract InvestorList is Ownable, IInvestorList { event AddressAdded(address addr, string role); event AddressRemoved(address addr, string role); mapping (address => string) internal investorList; /** * @dev Throws if called by any account that's not investorListed. * @param role string */ modifier validRole(string role) { require( keccak256(bytes(role)) == keccak256(bytes(ROLE_REGD)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGCF)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_REGS)) || keccak256(bytes(role)) == keccak256(bytes(ROLE_UNKNOWN)) ); _; } /** * @dev Getter to determine if address is in investorList. * @param addr address * @return true if the address was added to the investorList, false if the address was already in the investorList */ function inList(address addr) public view returns (bool) { if (bytes(investorList[addr]).length != 0) { return true; } else { return false; } } /** * @dev Getter for address role if address is in list. * @param addr address * @return string for address role */ function getRole(address addr) public view returns (string) { require(inList(addr)); return investorList[addr]; } /** * @dev Returns a boolean indicating if the given address is in the list *      with the given role. * @param addr address to check * @param role role to check * @ return boolean for whether the address is in the list with the role */ function hasRole(address addr, string role) public view returns (bool) { return keccak256(bytes(role)) == keccak256(bytes(investorList[addr])); } /** * @dev Add single address to the investorList. * @param addr address * @param role string */ function addAddress(address addr, string role) onlyOwner validRole(role) public { investorList[addr] = role; emit AddressAdded(addr, role); } /** * @dev Add multiple addresses to the investorList. * @param addrs addresses * @param role string */ function addAddresses(address[] addrs, string role) onlyOwner validRole(role) public { for (uint256 i = 0; i < addrs.length; i++) { addAddress(addrs[i], role); } } /** * @dev Remove single address from the investorList. * @param addr address */ function removeAddress(address addr) onlyOwner public { // removeRole(addr, ROLE_WHITELISTED); require(inList(addr)); string memory role = investorList[addr]; investorList[addr] = \"\"; emit AddressRemoved(addr, role); } /** * @dev Remove multiple addresses from the investorList. * @param addrs addresses */ function removeAddresses(address[] addrs) onlyOwner public { for (uint256 i = 0; i < addrs.length; i++) { if (inList(addrs[i])) { removeAddress(addrs[i]); } } } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ISecurityController { function balanceOf(address _a) public view returns (uint); function totalSupply() public view returns (uint); function isTransferAuthorized(address _from, address _to) public view returns (bool); function setTransferAuthorized(address from, address to, uint expiry) public; function transfer(address _from, address _to, uint _value) public returns (bool success); function transferFrom(address _spender, address _from, address _to, uint _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint); function approve(address _owner, address _spender, uint _value) public returns (bool success); function increaseApproval(address _owner, address _spender, uint _addedValue) public returns (bool success); function decreaseApproval(address _owner, address _spender, uint _subtractedValue) public returns (bool success); function burn(address _owner, uint _amount) public; function ledgerTransfer(address from, address to, uint val) public; function setLedger(address _ledger) public; function setSale(address _sale) public; function setToken(address _token) public; function setAffiliateList(address _affiliateList) public; } contract SecurityController is ISecurityController, Ownable { ISecurityLedger public ledger; ISecurityToken public token; ISecuritySale public sale; IInvestorList public investorList; ITransferAuthorizations public transferAuthorizations; IAffiliateList public affiliateList; uint public lockoutPeriod = 10 * 60 * 60; // length in seconds of the lockout period // restrict who can grant transfer authorizations mapping(address => bool) public transferAuthPermission; constructor() public { } function setTransferAuthorized(address from, address to, uint expiry) public { // Must be called from address in the transferAuthPermission mapping require(transferAuthPermission[msg.sender]); // don't allow 'from' to be zero require(from != 0); // verify expiry is in future, but not more than 30 days if(expiry > 0) { require(expiry > block.timestamp); require(expiry <= (block.timestamp + 30 days)); } transferAuthorizations.set(from, to, expiry); } // functions below this line are onlyOwner function setLockoutPeriod(uint _lockoutPeriod) public onlyOwner { lockoutPeriod = _lockoutPeriod; } function setToken(address _token) public onlyOwner { token = ISecurityToken(_token); } function setLedger(address _ledger) public onlyOwner { ledger = ISecurityLedger(_ledger); } function setSale(address _sale) public onlyOwner { sale = ISecuritySale(_sale); } function setInvestorList(address _investorList) public onlyOwner { investorList = IInvestorList(_investorList); } function setTransferAuthorizations(address _transferAuthorizations) public onlyOwner { transferAuthorizations = ITransferAuthorizations(_transferAuthorizations); } function setAffiliateList(address _affiliateList) public onlyOwner { affiliateList = IAffiliateList(_affiliateList); } function setTransferAuthPermission(address agent, bool hasPermission) public onlyOwner { require(agent != address(0)); transferAuthPermission[agent] = hasPermission; } modifier onlyToken() { require(msg.sender == address(token)); _; } modifier onlyLedger() { require(msg.sender == address(ledger)); _; } // public functions function totalSupply() public view returns (uint) { return ledger.totalSupply(); } function balanceOf(address _a) public view returns (uint) { return ledger.balanceOf(_a); } function allowance(address _owner, address _spender) public view returns (uint) { return ledger.allowance(_owner, _spender); } function isTransferAuthorized(address _from, address _to) public view returns (bool) { // A `from` address could have both an allowance for the `to` address // and a global allowance (to the zero address). We pick the maximum // of the two. uint expiry = transferAuthorizations.get(_from, _to); uint globalExpiry = transferAuthorizations.get(_from, 0); if(globalExpiry > expiry) { expiry = globalExpiry; } return expiry > block.timestamp; } /** * @dev Determines whether the given transfer is possible. Returns multiple *      boolean flags specifying how the transfer must occur. *      This is kept public to provide for testing and subclasses overriding behavior. * @param _from Address the tokens are being transferred from * @param _to Address the tokens are being transferred to * @param _value Number of tokens that would be transferred * @param lockoutTime A point in time, specified in epoch time, that specifies *                    the lockout period (typically 1 year before now). * @return canTransfer Whether the transfer can occur at all. * @return useLockoutTime Whether the lockoutTime should be used to determine which tokens to transfer. * @return newTokensAreRestricted Whether the transferred tokens should be marked as restricted. * @return preservePurchaseDate Whether the purchase date on the tokens should be preserved, or reset to 'now'. */ function checkTransfer(address _from, address _to, uint _value, uint lockoutTime) public returns (bool canTransfer, bool useLockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) { // DEFAULT BEHAVIOR: // // If there exists a Transfer Agent authorization, allow transfer regardless // // All transfers from an affiliate must be authorized by Transfer Agent //   - tokens become restricted // // From Reg S to Reg S: allowable, regardless of holding period // // otherwise must meet holding period // presently this isn't used, so always setting to false to avoid warning preservePurchaseDate = false; bool transferIsAuthorized = isTransferAuthorized(_from, _to); bool fromIsAffiliate = affiliateList.inListAsOf(_from, block.timestamp); bool toIsAffiliate = affiliateList.inListAsOf(_to, block.timestamp); if(transferIsAuthorized) { canTransfer = true; if(fromIsAffiliate || toIsAffiliate) { newTokensAreRestricted = true; } // useLockoutTime will remain false // preservePurchaseDate will remain false } else if(!fromIsAffiliate) { // see if both are Reg S if(investorList.hasRole(_from, investorList.ROLE_REGS()) && investorList.hasRole(_to, investorList.ROLE_REGS())) { canTransfer = true; // newTokensAreRestricted will remain false // useLockoutTime will remain false // preservePurchaseDate will remain false } else { if(ledger.transferDryRun(_from, _to, _value, lockoutTime) == _value) { canTransfer = true; useLockoutTime = true; // newTokensAreRestricted will remain false // preservePurchaseDate will remain false } } } } // functions below this line are onlyLedger // let the ledger send transfer events (the most obvious case // is when we mint directly to the ledger and need the Transfer() // events to appear in the token) function ledgerTransfer(address from, address to, uint val) public onlyLedger { token.controllerTransfer(from, to, val); } // functions below this line are onlyToken function transfer(address _from, address _to, uint _value) public onlyToken returns (bool success) { //TODO: this could be configurable uint lockoutTime = block.timestamp - lockoutPeriod; bool canTransfer; bool useLockoutTime; bool newTokensAreRestricted; bool preservePurchaseDate; (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate) = checkTransfer(_from, _to, _value, lockoutTime); if(!canTransfer) { return false; } uint overrideLockoutTime = lockoutTime; if(!useLockoutTime) { overrideLockoutTime = 0; } return ledger.transfer(_from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate); } function transferFrom(address _spender, address _from, address _to, uint _value) public onlyToken returns (bool success) { //TODO: this could be configurable uint lockoutTime = block.timestamp - lockoutPeriod; bool canTransfer; bool useLockoutTime; bool newTokensAreRestricted; bool preservePurchaseDate; (canTransfer, useLockoutTime, newTokensAreRestricted, preservePurchaseDate) = checkTransfer(_from, _to, _value, lockoutTime); if(!canTransfer) { return false; } uint overrideLockoutTime = lockoutTime; if(!useLockoutTime) { overrideLockoutTime = 0; } return ledger.transferFrom(_spender, _from, _to, _value, overrideLockoutTime, newTokensAreRestricted, preservePurchaseDate); } function approve(address _owner, address _spender, uint _value) public onlyToken returns (bool success) { return ledger.approve(_owner, _spender, _value); } function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyToken returns (bool success) { return ledger.increaseApproval(_owner, _spender, _addedValue); } function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyToken returns (bool success) { return ledger.decreaseApproval(_owner, _spender, _subtractedValue); } function burn(address _owner, uint _amount) public onlyToken { ledger.burn(_owner, _amount); } } interface ISecurityLedger { function balanceOf(address _a) external view returns (uint); function totalSupply() external view returns (uint); function transferDryRun(address _from, address _to, uint amount, uint lockoutTime) external returns (uint transferrableCount); function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success); function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) external returns (bool success); function allowance(address _owner, address _spender) external view returns (uint); function approve(address _owner, address _spender, uint _value) external returns (bool success); function increaseApproval(address _owner, address _spender, uint _addedValue) external returns (bool success); function decreaseApproval(address _owner, address _spender, uint _subtractedValue) external returns (bool success); function burn(address _owner, uint _amount) external; function setController(address _controller) external; } contract SecurityLedger is Ownable { using SafeMath for uint256; struct TokenLot { uint amount; uint purchaseDate; bool restricted; } mapping(address => TokenLot[]) public tokenLotsOf; SecurityController public controller; mapping(address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; uint public totalSupply; uint public mintingNonce; bool public mintingStopped; constructor() public { } // functions below this line are onlyOwner function setController(address _controller) public onlyOwner { controller = SecurityController(_controller); } function stopMinting() public onlyOwner { mintingStopped = true; } //TODO: not sure if this function should stay long term function mint(address addr, uint value, uint timestamp) public onlyOwner { require(!mintingStopped); uint time = timestamp; if(time == 0) { time = block.timestamp; } balanceOf[addr] = balanceOf[addr].add(value); tokenLotsOf[addr].push(TokenLot(value, time, true)); controller.ledgerTransfer(0, addr, value); totalSupply = totalSupply.add(value); } function multiMint(uint nonce, uint256[] bits, uint timestamp) external onlyOwner { require(!mintingStopped); if (nonce != mintingNonce) return; mintingNonce = mintingNonce.add(1); uint256 lomask = (1 << 96) - 1; uint created = 0; uint time = timestamp; if(time == 0) { time = block.timestamp; } for (uint i = 0; i < bits.length; i++) { address addr = address(bits[i]>>96); uint value = bits[i] & lomask; balanceOf[addr] = balanceOf[addr].add(value); tokenLotsOf[addr].push(TokenLot(value, time, true)); controller.ledgerTransfer(0, addr, value); created = created.add(value); } totalSupply = totalSupply.add(created); } // send received tokens to anyone function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(sender, amount)); } // functions below this line are onlyController modifier onlyController() { require(msg.sender == address(controller)); _; } /** * @dev Walks through the list of TokenLots for the given address, attempting to find *      `amount` tokens that can be transferred. It uses the given `lockoutTime` if *      the supplied value is not zero. If `removeTokens` is true the tokens are *      actually removed from the address, otherwise this function acts as a dry run. *      The value returned is the actual number of transferrable tokens found, up to *      the maximum value of `amount`. */ function walkTokenLots(address from, address to, uint amount, uint lockoutTime, bool removeTokens, bool newTokensAreRestricted, bool preservePurchaseDate) internal returns (uint numTransferrableTokens) { TokenLot[] storage fromTokenLots = tokenLotsOf[from]; for(uint i=0; i<fromTokenLots.length; i++) { TokenLot storage lot = fromTokenLots[i]; uint lotAmount = lot.amount; // skip if there are no available tokens if(lotAmount == 0) { continue; } if(lockoutTime > 0) { // skip if it is more recent than the lockout period AND it's restricted if(lot.restricted && lot.purchaseDate > lockoutTime) { continue; } } uint remaining = amount - numTransferrableTokens; if(lotAmount >= remaining) { numTransferrableTokens = numTransferrableTokens.add(remaining); if(removeTokens) { lot.amount = lotAmount.sub(remaining); if(to != address(0)) { if(preservePurchaseDate) { tokenLotsOf[to].push(TokenLot(remaining, lot.purchaseDate, newTokensAreRestricted)); } else { tokenLotsOf[to].push(TokenLot(remaining, block.timestamp, newTokensAreRestricted)); } } } break; } // If we're here, then amount in this lot is not yet enough. // Take all of it. numTransferrableTokens = numTransferrableTokens.add(lotAmount); if(removeTokens) { lot.amount = 0; if(to != address(0)) { if(preservePurchaseDate) { tokenLotsOf[to].push(TokenLot(lotAmount, lot.purchaseDate, newTokensAreRestricted)); } else { tokenLotsOf[to].push(TokenLot(lotAmount, block.timestamp, newTokensAreRestricted)); } } } } } function transferDryRun(address from, address to, uint amount, uint lockoutTime) public onlyController returns (uint) { return walkTokenLots(from, to, amount, lockoutTime, false, false, false); } function transfer(address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) { if (balanceOf[_from] < _value) return false; // ensure number of tokens removed from TokenLots is as expected uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate); require(tokensTransferred == _value); // adjust balances balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); return true; } function transferFrom(address _spender, address _from, address _to, uint _value, uint lockoutTime, bool newTokensAreRestricted, bool preservePurchaseDate) public onlyController returns (bool success) { if (balanceOf[_from] < _value) return false; // ensure there is enough allowance uint allowed = allowance[_from][_spender]; if (allowed < _value) return false; // ensure number of tokens removed from TokenLots is as expected uint tokensTransferred = walkTokenLots(_from, _to, _value, lockoutTime, true, newTokensAreRestricted, preservePurchaseDate); require(tokensTransferred == _value); // adjust balances balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowance[_from][_spender] = allowed.sub(_value); return true; } function approve(address _owner, address _spender, uint _value) public onlyController returns (bool success) { // require user to set to zero before resetting to nonzero if ((_value != 0) && (allowance[_owner][_spender] != 0)) { return false; } allowance[_owner][_spender] = _value; return true; } function increaseApproval (address _owner, address _spender, uint _addedValue) public onlyController returns (bool success) { uint oldValue = allowance[_owner][_spender]; allowance[_owner][_spender] = oldValue.add(_addedValue); return true; } function decreaseApproval (address _owner, address _spender, uint _subtractedValue) public onlyController returns (bool success) { uint oldValue = allowance[_owner][_spender]; if (_subtractedValue > oldValue) { allowance[_owner][_spender] = 0; } else { allowance[_owner][_spender] = oldValue.sub(_subtractedValue); } return true; } function burn(address _owner, uint _amount) public onlyController { require(balanceOf[_owner] >= _amount); balanceOf[_owner] = balanceOf[_owner].sub(_amount); // remove tokens from TokenLots // (i.e. transfer them to 0) walkTokenLots(_owner, address(0), _amount, 0, true, false, false); totalSupply = totalSupply.sub(_amount); } } interface ISecuritySale { function setLive(bool newLiveness) external; function setInvestorList(address _investorList) external; } contract SecuritySale is Ownable { bool public live;        // sale is live right now IInvestorList public investorList; // approved contributors event SaleLive(bool liveness); event EtherIn(address from, uint amount); event StartSale(); event EndSale(); constructor() public { live = false; } function setInvestorList(address _investorList) public onlyOwner { investorList = IInvestorList(_investorList); } function () public payable { require(live); require(investorList.inList(msg.sender)); emit EtherIn(msg.sender, msg.value); } // set liveness function setLive(bool newLiveness) public onlyOwner { if(live && !newLiveness) { live = false; emit EndSale(); } else if(!live && newLiveness) { live = true; emit StartSale(); } } // withdraw all of the Ether to owner function withdraw() public onlyOwner { msg.sender.transfer(address(this).balance); } // withdraw some of the Ether to owner function withdrawSome(uint value) public onlyOwner { require(value <= address(this).balance); msg.sender.transfer(value); } // withdraw tokens to owner function withdrawTokens(address token) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(msg.sender, t.balanceOf(this))); } // send received tokens to anyone function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(sender, amount)); } } interface ISecurityToken { function balanceOf(address addr) external view returns(uint); function transfer(address to, uint amount) external returns(bool); function controllerTransfer(address _from, address _to, uint _value) external; } contract SecurityToken is Ownable{ using SafeMath for uint256; ISecurityController public controller; // these public fields are set once in constructor string public name; string public symbol; uint8 public decimals; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); constructor(string _name, string  _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } // functions below this line are onlyOwner function setController(address _c) public onlyOwner { controller = ISecurityController(_c); } // send received tokens to anyone function sendReceivedTokens(address token, address sender, uint amount) public onlyOwner { ERC20Basic t = ERC20Basic(token); require(t.transfer(sender, amount)); } // functions below this line are public function balanceOf(address a) public view returns (uint) { return controller.balanceOf(a); } function totalSupply() public view returns (uint) { return controller.totalSupply(); } function allowance(address _owner, address _spender) public view returns (uint) { return controller.allowance(_owner, _spender); } function burn(uint _amount) public { controller.burn(msg.sender, _amount); emit Transfer(msg.sender, 0x0, _amount); } // functions below this line are onlyPayloadSize // TODO: investigate this security optimization more modifier onlyPayloadSize(uint numwords) { assert(msg.data.length >= numwords.mul(32).add(4)); _; } function isTransferAuthorized(address _from, address _to) public onlyPayloadSize(2) view returns (bool) { return controller.isTransferAuthorized(_from, _to); } function transfer(address _to, uint _value) public onlyPayloadSize(2) returns (bool success) { if (controller.transfer(msg.sender, _to, _value)) { emit Transfer(msg.sender, _to, _value); return true; } return false; } function transferFrom(address _from, address _to, uint _value) public onlyPayloadSize(3) returns (bool success) { if (controller.transferFrom(msg.sender, _from, _to, _value)) { emit Transfer(_from, _to, _value); return true; } return false; } function approve(address _spender, uint _value) onlyPayloadSize(2) public returns (bool success) { if (controller.approve(msg.sender, _spender, _value)) { emit Approval(msg.sender, _spender, _value); return true; } return false; } function increaseApproval (address _spender, uint _addedValue) public onlyPayloadSize(2) returns (bool success) { if (controller.increaseApproval(msg.sender, _spender, _addedValue)) { uint newval = controller.allowance(msg.sender, _spender); emit Approval(msg.sender, _spender, newval); return true; } return false; } function decreaseApproval (address _spender, uint _subtractedValue) public onlyPayloadSize(2) returns (bool success) { if (controller.decreaseApproval(msg.sender, _spender, _subtractedValue)) { uint newval = controller.allowance(msg.sender, _spender); emit Approval(msg.sender, _spender, newval); return true; } return false; } // functions below this line are onlyController modifier onlyController() { assert(msg.sender == address(controller)); _; } function controllerTransfer(address _from, address _to, uint _value) public onlyController { emit Transfer(_from, _to, _value); } function controllerApprove(address _owner, address _spender, uint _value) public onlyController { emit Approval(_owner, _spender, _value); } } interface ITransferAuthorizations { function setController(address _controller) external; function get(address from, address to) external view returns (uint); function set(address from, address to, uint expiry) external; } contract TransferAuthorizations is Ownable, ITransferAuthorizations { /** * @dev The first key is the `from` address. The second key is the `to` address. *      The uint value of the mapping is the epoch time (seconds since 1/1/1970) *      of the expiration of the approved transfer. */ mapping(address => mapping(address => uint)) public authorizations; /** * @dev This controller is the only contract allowed to call the `set` function. */ address public controller; event TransferAuthorizationSet(address from, address to, uint expiry); function setController(address _controller) public onlyOwner { controller = _controller; } modifier onlyController() { assert(msg.sender == controller); _; } /** * @dev Sets the authorization for a transfer to occur between the 'from' and *      'to' addresses, to expire at the 'expiry' time. * @param from The address from which funds would be transferred. * @param to The address to which funds would be transferred. This can be *           the zero address to allow transfers to any address. * @param expiry The epoch time (seconds since 1/1/1970) at which point this *               authorization will no longer be valid. */ function set(address from, address to, uint expiry) public onlyController { require(from != 0); authorizations[from][to] = expiry; emit TransferAuthorizationSet(from, to, expiry); } /** * @dev Returns the expiration time for the transfer authorization between the *      given addresses. Returns 0 if not allowed. * @param from The address from which funds would be transferred. * @param to The address to which funds would be transferred. This can be *           the zero address to allow transfers to any address. */ function get(address from, address to) public view returns (uint) { return authorizations[from][to]; } } "}
{"sol name": "6592.sol", "label": 1, "sol content": "pragma solidity 0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /* * @title String & slice utility library for Solidity contracts. * @author Nick Johnson <[email\u00a0protected]> * * @dev Functionality in this library is largely implemented using an *      abstraction called a 'slice'. A slice represents a part of a string - *      anything from the entire string to a single character, or even no *      characters at all (a 0-length slice). Since a slice only has to specify *      an offset and a length, copying and manipulating slices is a lot less *      expensive than copying and manipulating the strings they reference. * *      To further reduce gas costs, most functions on slice that need to return *      a slice modify the original one instead of allocating a new one; for *      instance, `s.split(\".\")` will return the text up to the first '.', *      modifying s to only contain the remainder of the string after the '.'. *      In situations where you do not want to modify the original slice, you *      can make a copy first with `.copy()`, for example: *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since *      Solidity has no memory management, it will result in allocating many *      short-lived slices that are later discarded. * *      Functions that return two slices come in two versions: a non-allocating *      version that takes the second slice as an argument, modifying it in *      place, and an allocating version that allocates and returns the second *      slice; see `nextRune` for example. * *      Functions that have to copy string data will return strings rather than *      slices; these can be cast back to slices for further processing if *      required. * *      For convenience, some functions are provided with non-modifying *      variants that create a new slice and return both; for instance, *      `s.splitNew('.')` leaves s unmodified, and returns two values *      corresponding to the left and right parts of the string. */ library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private pure { // Copy word-length chunks while possible for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } // Copy remaining bytes uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } /* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ function toSlice(string self) internal pure returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } /* * @dev Returns the length of a null-terminated bytes32 string. * @param self The value to find the length of. * @return The length of the string, from 0 to 32. */ function len(bytes32 self) internal pure returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; } /* * @dev Returns a slice containing the entire bytes32, interpreted as a *      null-terminated utf-8 string. * @param self The bytes32 value to convert to a slice. * @return A new slice containing the value of the input argument up to the *         first null. */ function toSliceB32(bytes32 self) internal pure returns (slice ret) { // Allocate space for `self` in memory, copy it there, and point ret at it assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); } /* * @dev Returns a new slice containing the same data as the current slice. * @param self The slice to copy. * @return A new slice containing the same data as `self`. */ function copy(slice self) internal pure returns (slice) { return slice(self._len, self._ptr); } /* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ function toString(slice self) internal pure returns (string) { string memory ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } /* * @dev Returns the length in runes of the slice. Note that this operation *      takes time proportional to the length of the slice; avoid using it *      in loops, and call `slice.empty()` if you only need to know whether *      the slice is empty or not. * @param self The slice to operate on. * @return The length of the slice in runes. */ function len(slice self) internal pure returns (uint l) { // Starting at ptr-31 means the LSB will be the byte we care about uint ptr = self._ptr - 31; uint end = ptr + self._len; for (l = 0; ptr < end; l++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } } /* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ function empty(slice self) internal pure returns (bool) { return self._len == 0; } /* * @dev Returns a positive number if `other` comes lexicographically after *      `self`, a negative number if it comes before, or zero if the *      contents of the two slices are equal. Comparison is done per-rune, *      on unicode codepoints. * @param self The first slice to compare. * @param other The second slice to compare. * @return The result of the comparison. */ function compare(slice self, slice other) internal pure returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; uint selfptr = self._ptr; uint otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { // Mask out irrelevant bytes and check again uint256 mask = uint256(-1); // 0xffff... if(shortest < 32) { mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); } uint256 diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); } /* * @dev Returns true if the two slices contain the same text. * @param self The first slice to compare. * @param self The second slice to compare. * @return True if the slices are equal, false otherwise. */ function equals(slice self, slice other) internal pure returns (bool) { return compare(self, other) == 0; } /* * @dev Extracts the first rune in the slice into `rune`, advancing the *      slice to point to the next rune and returning `self`. * @param self The slice to operate on. * @param rune The slice that will contain the first rune. * @return `rune`. */ function nextRune(slice self, slice rune) internal pure returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint l; uint b; // Load the first byte of the rune into the LSBs of b assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { l = 1; } else if(b < 0xE0) { l = 2; } else if(b < 0xF0) { l = 3; } else { l = 4; } // Check for truncated codepoints if (l > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += l; self._len -= l; rune._len = l; return rune; } /* * @dev Returns the first rune in the slice, advancing the slice to point *      to the next rune. * @param self The slice to operate on. * @return A slice containing only the first rune from `self`. */ function nextRune(slice self) internal pure returns (slice ret) { nextRune(self, ret); } /* * @dev Returns the number of the first codepoint in the slice. * @param self The slice to operate on. * @return The number of the first codepoint in the slice. */ function ord(slice self) internal pure returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint length; uint divisor = 2 ** 248; // Load the rune into the MSBs of b assembly { word:= mload(mload(add(self, 32))) } uint b = word / divisor; if (b < 0x80) { ret = b; length = 1; } else if(b < 0xE0) { ret = b & 0x1F; length = 2; } else if(b < 0xF0) { ret = b & 0x0F; length = 3; } else { ret = b & 0x07; length = 4; } // Check for truncated codepoints if (length > self._len) { return 0; } for (uint i = 1; i < length; i++) { divisor = divisor / 256; b = (word / divisor) & 0xFF; if (b & 0xC0 != 0x80) { // Invalid UTF-8 sequence return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; } /* * @dev Returns the keccak-256 hash of the slice. * @param self The slice to hash. * @return The hash of the slice. */ function keccak(slice self) internal pure returns (bytes32 ret) { assembly { ret := keccak256(mload(add(self, 32)), mload(self)) } } /* * @dev Returns true if `self` starts with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function startsWith(slice self, slice needle) internal pure returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } return equal; } /* * @dev If `self` starts with `needle`, `needle` is removed from the *      beginning of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function beyond(slice self, slice needle) internal pure returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, length), sha3(needleptr, length)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } /* * @dev Returns true if the slice ends with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function endsWith(slice self, slice needle) internal pure returns (bool) { if (self._len < needle._len) { return false; } uint selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let length := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } return equal; } /* * @dev If `self` ends with `needle`, `needle` is removed from the *      end of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function until(slice self, slice needle) internal pure returns (slice) { if (self._len < needle._len) { return self; } uint selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let length := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } } if (equal) { self._len -= needle._len; } return self; } event log_bytemask(bytes32 mask); // Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } // Returns the memory address of the first byte after the last occurrence of // `needle` in `self`, or the address of `self` if not found. function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } ptr = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr <= selfptr) return selfptr; ptr--; assembly { ptrdata := and(mload(ptr), mask) } } return ptr + needlelen; } else { // For long needles, use hashing bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } ptr = selfptr + (selflen - needlelen); while (ptr >= selfptr) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr + needlelen; ptr -= 1; } } } return selfptr; } /* * @dev Modifies `self` to contain everything from the first occurrence of *      `needle` to the end of the slice. `self` is set to the empty slice *      if `needle` is not found. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function find(slice self, slice needle) internal pure returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; } /* * @dev Modifies `self` to contain the part of the string from the start of *      `self` to the end of the first occurrence of `needle`. If `needle` *      is not found, `self` is set to the empty slice. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function rfind(slice self, slice needle) internal pure returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function split(slice self, slice needle, slice token) internal pure returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ function split(slice self, slice needle) internal pure returns (slice token) { split(self, needle, token); } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and `token` to everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function rsplit(slice self, slice needle, slice token) internal pure returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and returning everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` after the last occurrence of `delim`. */ function rsplit(slice self, slice needle) internal pure returns (slice token) { rsplit(self, needle, token); } /* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ function count(slice self, slice needle) internal pure returns (uint cnt) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { cnt++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } /* * @dev Returns True if `self` contains `needle`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return True if `needle` is found in `self`, false otherwise. */ function contains(slice self, slice needle) internal pure returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; } /* * @dev Returns a newly allocated string containing the concatenation of *      `self` and `other`. * @param self The first slice to concatenate. * @param other The second slice to concatenate. * @return The concatenation of the two strings. */ function concat(slice self, slice other) internal pure returns (string) { string memory ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } /* * @dev Joins an array of slices, using `self` as a delimiter, returning a *      newly allocated string. * @param self The delimiter to use. * @param parts A list of slices to join. * @return A newly allocated string containing all the slices in `parts`, *         joined with `self`. */ function join(slice self, slice[] parts) internal pure returns (string) { if (parts.length == 0) return \"\"; uint length = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) length += parts[i]._len; string memory ret = new string(length); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } pragma solidity 0.4.24; contract SparksterToken is StandardToken, Ownable{ using strings for *; using SafeMath for uint256; struct Member { address walletAddress; mapping(uint256 => bool) groupMemberships; // What groups does this member belong to? mapping(uint256 => uint256) ethBalance; // How much eth has this member contributed for this group? mapping(uint256 => uint256) tokenBalance; // The member's token balance in a specific group. uint256 max1; // Maximum amount this user can contribute for phase1. int256 transferred; // The amount of tokens the member has transferred out or been transferred in. Sending tokens out will increase this value and accepting tokens in will decrease it. In other words, the more negative this value is, the more unlocked tokens the member holds. bool exists; // A flag to see if we have a record of this member or not. If we don't, they won't be allowed to purchase. } struct Group { bool distributed; // Whether or not tokens in this group have been distributed. bool distributing; // This flag is set when we first enter the distribute function and is there to prevent race conditions, since distribution might take a long time. bool unlocked; // Whether or not tokens in this group have been unlocked. uint256 groupNumber; // This group's number uint256 ratio; // 1 eth:ratio tokens. This amount represents the decimal amount. ratio*10**decimal = ratio sparks. uint256 startTime; // Epoch of crowdsale start time. uint256 phase1endTime; // Epoch of phase1 end time. uint256 phase2endTime; // Epoch of phase2 end time. uint256 deadline; // No contributions allowed after this epoch. uint256 max2; // cap of phase2 uint256 max3; // Total ether this group can collect in phase 3. uint256 ethTotal; // How much ether has this group collected? uint256 cap; // The hard ether cap. uint256 howManyDistributed; } bool internal transferLock = true; // A Global transfer lock. Set to lock down all tokens from all groups. bool internal allowedToSell = false; bool internal allowedToPurchase = false; string public name;\t\t\t\t\t\t\t\t\t // name for display string public symbol;\t\t\t\t\t\t\t\t //An identifier uint8 public decimals;\t\t\t\t\t\t\t//How many decimals to show. uint256 internal maxGasPrice; // The maximum allowed gas for the purchase function. uint256 internal nextGroupNumber; uint256 public sellPrice; // sellPrice wei:1 spark token; we won't allow to sell back parts of a token. address[] internal allMembers; address[] internal allNonMembers; mapping(address => bool) internal nonMemberTransfers; mapping(address => Member) internal members; mapping(uint256 => Group) internal groups; mapping(uint256 => address[]) internal associations; // Will hold a record of which addresses belong to which group. uint256 internal openGroupNumber; event PurchaseSuccess(address indexed _addr, uint256 _weiAmount,uint256 _totalEthBalance,uint256 _totalTokenBalance); event DistributeDone(uint256 groupNumber); event UnlockDone(uint256 groupNumber); event GroupCreated(uint256 groupNumber, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio); event ChangedAllowedToSell(bool allowedToSell); event ChangedAllowedToPurchase(bool allowedToPurchase); event ChangedTransferLock(bool transferLock); event SetSellPrice(uint256 sellPrice); event Added(address walletAddress, uint256 group, uint256 tokens, uint256 maxContribution1); event SplitTokens(uint256 splitFactor); event ReverseSplitTokens(uint256 splitFactor); // Fix for the ERC20 short address attack http://vessenes.com/the-erc20-short-address-attack-explained/ modifier onlyPayloadSize(uint size) { require(msg.data.length == size + 4); _; } modifier canTransfer() { require(!transferLock); _; } modifier canPurchase() { require(allowedToPurchase); _; } modifier canSell() { require(allowedToSell); _; } function() public payable { purchase(); } constructor() public { name = \"Sparkster\";\t\t\t\t\t\t\t\t\t// Set the name for display purposes decimals = 18;\t\t\t\t\t // Amount of decimals for display purposes symbol = \"SPRK\";\t\t\t\t\t\t\t// Set the symbol for display purposes setMaximumGasPrice(40); // Give all the tokens to the owner to start with. mintTokens(435000000); } function setMaximumGasPrice(uint256 gweiPrice) public onlyOwner returns(bool success) { maxGasPrice = gweiPrice.mul(10**9); // Convert the gwei value to wei. return true; } function parseAddr(string _a) pure internal returns (address){ // From Oraclize bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function parseInt(string _a, uint _b) pure internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decim = false; for (uint i = 0; i < bresult.length; i++) { if ((bresult[i] >= 48) && (bresult[i] <= 57)) { if (decim) { if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decim = true; } return mint; } function mintTokens(uint256 amount) public onlyOwner { // Here, we'll consider amount to be the full token amount, so we have to get its decimal value. uint256 decimalAmount = amount.mul(uint(10)**decimals); totalSupply_ = totalSupply_.add(decimalAmount); balances[msg.sender] = balances[msg.sender].add(decimalAmount); emit Transfer(address(0), msg.sender, decimalAmount); // Per erc20 standards-compliance. } function purchase() public canPurchase payable{ require(msg.sender != address(0)); // Don't allow the 0 address. Member storage memberRecord = members[msg.sender]; Group storage openGroup = groups[openGroupNumber]; require(openGroup.ratio > 0); // Group must be initialized. require(memberRecord.exists && memberRecord.groupMemberships[openGroup.groupNumber] && !openGroup.distributing && !openGroup.distributed && !openGroup.unlocked); // member must exist; Don't allow to purchase if we're in the middle of distributing this group; Don't let someone buy tokens on the current group if that group is already distributed, unlocked or both; don't allow member to purchase if they're not part of the open group. uint256 currentTimestamp = block.timestamp; require(currentTimestamp >= openGroup.startTime && currentTimestamp <= openGroup.deadline);\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t //the timestamp must be greater than or equal to the start time and less than or equal to the deadline time require(tx.gasprice <= maxGasPrice); // Restrict maximum gas this transaction is allowed to consume. uint256 weiAmount = msg.value;\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// The amount purchased by the current member require(weiAmount >= 0.1 ether); uint256 ethTotal = openGroup.ethTotal.add(weiAmount); // Calculate total contribution of all members in this group. require(ethTotal <= openGroup.cap);\t\t\t\t\t\t\t\t\t\t\t\t\t\t// Check to see if accepting these funds will put us above the hard ether cap. uint256 userETHTotal = memberRecord.ethBalance[openGroup.groupNumber].add(weiAmount);\t// Calculate the total amount purchased by the current member if(currentTimestamp <= openGroup.phase1endTime){\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t // whether the current timestamp is in the first phase require(userETHTotal <= memberRecord.max1);\t\t\t\t\t\t\t\t\t\t\t\t\t\t // Will these new funds put the member over their first phase contribution limit? } else if (currentTimestamp <= openGroup.phase2endTime) { // Are we in phase 2? require(userETHTotal <= openGroup.max2); // Allow to contribute no more than max2 in phase 2. } else { // We've passed both phases 1 and 2. require(userETHTotal <= openGroup.max3); // Don't allow to contribute more than max3 in phase 3. } uint256 tokenAmount = weiAmount.mul(openGroup.ratio);\t\t\t\t\t\t //calculate member token amount. uint256 newLeftOver = balances[owner].sub(tokenAmount); // Won't pass if result is < 0. openGroup.ethTotal = ethTotal;\t\t\t\t\t\t\t\t // Calculate the total amount purchased by all members in this group. memberRecord.ethBalance[openGroup.groupNumber] = userETHTotal;\t\t\t\t\t\t\t\t\t\t\t\t\t\t // Record the total amount purchased by the current member memberRecord.tokenBalance[openGroup.groupNumber] = memberRecord.tokenBalance[openGroup.groupNumber].add(tokenAmount); // Update the member's token amount. balances[owner] = newLeftOver; // Update the available number of tokens. owner.transfer(weiAmount); // Transfer to owner, don't keep funds in the contract. emit PurchaseSuccess(msg.sender,weiAmount,memberRecord.ethBalance[openGroup.groupNumber],memberRecord.tokenBalance[openGroup.groupNumber]); } function sell(uint256 amount) public canSell { // Can't sell unless owner has allowed it. uint256 decimalAmount = amount.mul(uint(10)**decimals); // convert the full token value to the smallest unit possible. if (members[msg.sender].exists) { // If this seller exists, they have an unlocked balance we need to take care of. int256 sellValue = members[msg.sender].transferred + int(decimalAmount); require(sellValue >= members[msg.sender].transferred); // Check for overflow. require(sellValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they're not selling more than their unlocked amount. members[msg.sender].transferred = sellValue; } balances[msg.sender] = balances[msg.sender].sub(decimalAmount); // Do this before transferring to avoid re-entrance attacks; will throw if result < 0. // Amount is considered to be how many full tokens the user wants to sell. uint256 totalCost = amount.mul(sellPrice); // sellPrice is the per-full-token value. require(address(this).balance >= totalCost); // The contract must have enough funds to cover the selling. balances[owner] = balances[owner].add(decimalAmount); // Put these tokens back into the available pile. msg.sender.transfer(totalCost); // Pay the seller for their tokens. emit Transfer(msg.sender, owner, decimalAmount); // Notify exchanges of the sell. } function fundContract() public onlyOwner payable { // For the owner to put funds into the contract. } function setSellPrice(uint256 thePrice) public onlyOwner { sellPrice = thePrice; emit SetSellPrice(sellPrice); } function setAllowedToSell(bool value) public onlyOwner { allowedToSell = value; emit ChangedAllowedToSell(allowedToSell); } function setAllowedToPurchase(bool value) public onlyOwner { allowedToPurchase = value; emit ChangedAllowedToPurchase(allowedToPurchase); } function createGroup(uint256 startEpoch, uint256 phase1endEpoch, uint256 phase2endEpoch, uint256 deadlineEpoch, uint256 phase2cap, uint256 phase3cap, uint256 etherCap, uint256 ratio) public onlyOwner returns (bool success, uint256 createdGroupNumber) { Group storage theGroup = groups[nextGroupNumber]; theGroup.groupNumber = nextGroupNumber; theGroup.startTime = startEpoch; theGroup.phase1endTime = phase1endEpoch; theGroup.phase2endTime = phase2endEpoch; theGroup.deadline = deadlineEpoch; theGroup.max2 = phase2cap; theGroup.max3 = phase3cap; theGroup.cap = etherCap; theGroup.ratio = ratio; createdGroupNumber = nextGroupNumber; nextGroupNumber++; success = true; emit GroupCreated(createdGroupNumber, startEpoch, phase1endEpoch, phase2endEpoch, deadlineEpoch, phase2cap, phase3cap, etherCap, ratio); } function createGroup() public onlyOwner returns (bool success, uint256 createdGroupNumber) { return createGroup(0, 0, 0, 0, 0, 0, 0, 0); } function getGroup(uint256 groupNumber) public view onlyOwner returns(bool distributed, bool unlocked, uint256 phase2cap, uint256 phase3cap, uint256 cap, uint256 ratio, uint256 startTime, uint256 phase1endTime, uint256 phase2endTime, uint256 deadline, uint256 ethTotal, uint256 howManyDistributed) { require(groupNumber < nextGroupNumber); Group storage theGroup = groups[groupNumber]; distributed = theGroup.distributed; unlocked = theGroup.unlocked; phase2cap = theGroup.max2; phase3cap = theGroup.max3; cap = theGroup.cap; ratio = theGroup.ratio; startTime = theGroup.startTime; phase1endTime = theGroup.phase1endTime; phase2endTime = theGroup.phase2endTime; deadline = theGroup.deadline; ethTotal = theGroup.ethTotal; howManyDistributed = theGroup.howManyDistributed; } function getHowManyLeftToDistribute(uint256 groupNumber) public view returns(uint256 howManyLeftToDistribute) { require(groupNumber < nextGroupNumber); Group storage theGroup = groups[groupNumber]; howManyLeftToDistribute = associations[groupNumber].length - theGroup.howManyDistributed; // No need to use SafeMath here since we're guaranteed to not underflow on this line. } function getMembersInGroup(uint256 groupNumber) public view returns (address[]) { require(groupNumber < nextGroupNumber); // Check for nonexistent group return associations[groupNumber]; } function addMember(address walletAddress, uint256 groupNumber, uint256 tokens, uint256 maxContribution1) public onlyOwner returns (bool success) { Member storage theMember = members[walletAddress]; Group storage theGroup = groups[groupNumber]; require(groupNumber < nextGroupNumber); // Don't let the owner assign to a group that doesn't exist, protect against mistypes. require(!theGroup.distributed && !theGroup.distributing && !theGroup.unlocked); // Don't let us add to a distributed group, a group that's distributing right now, or a group that's already been unlocked. require(!theMember.exists); // Don't let the owner re-add a member. theMember.walletAddress = walletAddress; theMember.groupMemberships[groupNumber] = true; balances[owner] = balances[owner].sub(tokens); theMember.tokenBalance[groupNumber] = tokens; theMember.max1 = maxContribution1; theMember.transferred = -int(balances[walletAddress]); // Don't lock the tokens they come in with if they already hold a balance. theMember.exists = true; associations[groupNumber].push(walletAddress); // Push this user's address to the associations array so we can easily keep track of which users belong to which group... // ... Solidity doesn't allow to iterate over a map. allMembers.push(walletAddress); // Push this address to allMembers array so we can easily loop through all addresses... // Used for splitTokens and reverseSplitTokens. emit Added(walletAddress, groupNumber, tokens, maxContribution1); return true; } function addMemberToGroup(address walletAddress, uint256 groupNumber) public onlyOwner returns(bool success) { Member storage memberRecord = members[walletAddress]; require(memberRecord.exists && groupNumber < nextGroupNumber && !memberRecord.groupMemberships[groupNumber]); // Don't add this user to a group if they already exist in that group. memberRecord.groupMemberships[groupNumber] = true; associations[groupNumber].push(walletAddress); return true; } function upload(string uploadedData) public onlyOwner returns (bool success) { // We'll separate records by a | and individual entries in the record by a :. strings.slice memory uploadedSlice = uploadedData.toSlice(); strings.slice memory nextRecord = \"\".toSlice(); strings.slice memory nextDatum = \"\".toSlice(); strings.slice memory recordSeparator = \"|\".toSlice(); strings.slice memory datumSeparator = \":\".toSlice(); while (!uploadedSlice.empty()) { nextRecord = uploadedSlice.split(recordSeparator); nextDatum = nextRecord.split(datumSeparator); address memberAddress = parseAddr(nextDatum.toString()); nextDatum = nextRecord.split(datumSeparator); uint256 memberGroup = parseInt(nextDatum.toString(), 0); nextDatum = nextRecord.split(datumSeparator); uint256 memberTokens = parseInt(nextDatum.toString(), 0); nextDatum = nextRecord.split(datumSeparator); uint256 memberMaxContribution1 = parseInt(nextDatum.toString(), 0); addMember(memberAddress, memberGroup, memberTokens, memberMaxContribution1); } return true; } function distribute(uint256 groupNumber, uint256 howMany) public onlyOwner returns (bool success) { Group storage theGroup = groups[groupNumber]; require(groupNumber < nextGroupNumber && !theGroup.distributed ); // can't have already distributed uint256 inclusiveStartIndex = theGroup.howManyDistributed; uint256 exclusiveEndIndex = inclusiveStartIndex.add(howMany); theGroup.distributing = true; uint256 n = associations[groupNumber].length; require(n > 0 ); // We must have more than 0 members in this group if (exclusiveEndIndex > n) { // This batch will overrun the array. exclusiveEndIndex = n; } for (uint256 i = inclusiveStartIndex; i < exclusiveEndIndex; i++) { // This section might be expensive in terms of gas cost! address memberAddress = associations[groupNumber][i]; Member storage currentMember = members[memberAddress]; uint256 balance = currentMember.tokenBalance[groupNumber]; if (balance > 0) { // No need to waste ticks if they have no tokens to distribute balances[memberAddress] = balances[memberAddress].add(balance); emit Transfer(owner, memberAddress, balance); // Notify exchanges of the distribution. } theGroup.howManyDistributed++; } if (theGroup.howManyDistributed == n) { // Done distributing all members. theGroup.distributed = true; theGroup.distributing = false; emit DistributeDone(groupNumber); } return true; } function getUnlockedBalanceLimit(address walletAddress) internal view returns(uint256 balance) { Member storage theMember = members[walletAddress]; if (!theMember.exists) { return balances[walletAddress]; } for (uint256 i = 0; i < nextGroupNumber; i++) { if (groups[i].unlocked) { balance = balance.add(theMember.tokenBalance[i]); } } return balance; } function getUnlockedTokens(address walletAddress) public view returns(uint256 balance) { Member storage theMember = members[walletAddress]; if (!theMember.exists) { return balances[walletAddress]; } return uint256(int(getUnlockedBalanceLimit(walletAddress)) - theMember.transferred); } function unlock(uint256 groupNumber) public onlyOwner returns (bool success) { Group storage theGroup = groups[groupNumber]; require(theGroup.distributed && !theGroup.unlocked); // Distribution must have occurred first. theGroup.unlocked = true; emit UnlockDone(groupNumber); return true; } function setTransferLock(bool value) public onlyOwner { transferLock = value; emit ChangedTransferLock(transferLock); } function burn(uint256 amount) public onlyOwner { // Burns tokens from the owner's supply and doesn't touch allocated tokens. // Decrease totalSupply and leftOver by the amount to burn so we can decrease the circulation. balances[msg.sender] = balances[msg.sender].sub(amount); // Will throw if result < 0 totalSupply_ = totalSupply_.sub(amount); // Will throw if result < 0 emit Transfer(msg.sender, address(0), amount); } function splitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) { // SplitFactor is the multiplier per decimal of spark. splitFactor * 10**decimals = splitFactor sparks uint256 n = allMembers.length; uint256 ownerBalance = balances[msg.sender]; uint256 increaseSupplyBy = ownerBalance.mul(splitFactor).sub(ownerBalance); // We need to mint owner*splitFactor - owner additional tokens. balances[msg.sender] = balances[msg.sender].mul(splitFactor); totalSupply_ = totalSupply_.mul(splitFactor); emit Transfer(address(0), msg.sender, increaseSupplyBy); // Notify exchange that we've minted tokens. for (uint256 i = 0; i < n; i++) { Member storage currentMember = members[allMembers[i]]; // Take care of transferred balance. currentMember.transferred = currentMember.transferred * int(splitFactor); // Iterate over all of this user's balances for all groups. If a user is not a part of a group their balance will be 0. for (uint256 j = 0; j < nextGroupNumber; j++) { uint256 memberBalance = currentMember.tokenBalance[j]; uint256 multiplier = memberBalance.mul(splitFactor); currentMember.tokenBalance[j] = multiplier; } } // Next, increase group ratios by splitFactor, so users will receive ratio + splitFactor tokens per ether. n = nextGroupNumber; require(n > 0); // Must have at least one group. for (i = 0; i < n; i++) { Group storage currentGroup = groups[i]; currentGroup.ratio = currentGroup.ratio.mul(splitFactor); } emit SplitTokens(splitFactor); return true; } function reverseSplitTokensBeforeDistribution(uint256 splitFactor) public onlyOwner returns (bool success) { // SplitFactor is the multiplier per decimal of spark. splitFactor * 10**decimals = splitFactor sparks uint256 n = allMembers.length; uint256 ownerBalance = balances[msg.sender]; uint256 decreaseSupplyBy = ownerBalance.sub(ownerBalance.div(splitFactor)); // We don't use burnTokens here since the amount to subtract might be more than what the owner currently holds in their unallocated supply which will cause the function to throw. totalSupply_ = totalSupply_.div(splitFactor); balances[msg.sender] = ownerBalance.div(splitFactor); // Notify the exchanges of how many tokens were burned. emit Transfer(msg.sender, address(0), decreaseSupplyBy); for (uint256 i = 0; i < n; i++) { Member storage currentMember = members[allMembers[i]]; // Take care of the member's transferred balance. currentMember.transferred = currentMember.transferred / int(splitFactor); for (uint256 j = 0; j < nextGroupNumber; j++) { uint256 memberBalance = currentMember.tokenBalance[j]; uint256 divier = memberBalance.div(splitFactor); currentMember.tokenBalance[j] = divier; } } // Next, decrease group ratios by splitFactor, so users will receive ratio - splitFactor tokens per ether. n = nextGroupNumber; require(n > 0); // Must have at least one group. Groups are 0-indexed. for (i = 0; i < n; i++) { Group storage currentGroup = groups[i]; currentGroup.ratio = currentGroup.ratio.div(splitFactor); } emit ReverseSplitTokens(splitFactor); return true; } function splitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) { splitTokensBeforeDistribution(splitFactor); uint256 n = allMembers.length; for (uint256 i = 0; i < n; i++) { address currentMember = allMembers[i]; uint256 memberBalance = balances[currentMember]; if (memberBalance > 0) { uint256 multiplier1 = memberBalance.mul(splitFactor); uint256 increaseMemberSupplyBy = multiplier1.sub(memberBalance); balances[currentMember] = multiplier1; emit Transfer(address(0), currentMember, increaseMemberSupplyBy); } } n = allNonMembers.length; for (i = 0; i < n; i++) { address currentNonMember = allNonMembers[i]; // If this address started out as a nonmember and then became a member, we've seen them already in allMembers so don't grow or shrink them twice. if (members[currentNonMember].exists) { continue; } uint256 nonMemberBalance = balances[currentNonMember]; if (nonMemberBalance > 0) { uint256 multiplier2 = nonMemberBalance.mul(splitFactor); uint256 increaseNonMemberSupplyBy = multiplier2.sub(nonMemberBalance); balances[currentNonMember] = multiplier2; emit Transfer(address(0), currentNonMember, increaseNonMemberSupplyBy); } } emit SplitTokens(splitFactor); return true; } function reverseSplitTokensAfterDistribution(uint256 splitFactor) public onlyOwner returns (bool success) { reverseSplitTokensBeforeDistribution(splitFactor); uint256 n = allMembers.length; for (uint256 i = 0; i < n; i++) { address currentMember = allMembers[i]; uint256 memberBalance = balances[currentMember]; if (memberBalance > 0) { uint256 divier1 = memberBalance.div(splitFactor); uint256 decreaseMemberSupplyBy = memberBalance.sub(divier1); balances[currentMember] = divier1; emit Transfer(currentMember, address(0), decreaseMemberSupplyBy); } } n = allNonMembers.length; for (i = 0; i < n; i++) { address currentNonMember = allNonMembers[i]; // If this address started out as a nonmember and then became a member, we've seen them already in allMembers so don't grow or shrink them twice. if (members[currentNonMember].exists) { continue; } uint256 nonMemberBalance = balances[currentNonMember]; if (nonMemberBalance > 0) { uint256 divier2 = nonMemberBalance.div(splitFactor); uint256 decreaseNonMemberSupplyBy = nonMemberBalance.sub(divier2); balances[currentNonMember] = divier2; emit Transfer(currentNonMember, address(0), decreaseNonMemberSupplyBy); } } emit ReverseSplitTokens(splitFactor); return true; } function changeMaxContribution(address memberAddress, uint256 newMax1) public onlyOwner { // Allows to change a member's maximum contribution for phase 1. Member storage theMember = members[memberAddress]; require(theMember.exists); // Don't allow to change for a nonexistent member. theMember.max1 = newMax1; } function transfer(address _to, uint256 _value) public onlyPayloadSize(2 * 32) canTransfer returns (bool success) { // If the transferrer has purchased tokens, they must be unlocked before they can be used. Member storage fromMember = members[msg.sender]; if (fromMember.exists) { // If this is the owner, this check will be false so no need to check specifically for owner here. int256 transferValue = fromMember.transferred + int(_value); require(transferValue >= fromMember.transferred); // Check for overflow. require(transferValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they don't transfer out more than their unlocked limit. fromMember.transferred = transferValue; } // If any of the parties involved are not members, add them to the nonmembers list. // Don't add the owner, since they're a special case. if (!fromMember.exists && msg.sender != owner) { bool fromTransferee = nonMemberTransfers[msg.sender]; if (!fromTransferee) { // If we haven't added this transferee before. nonMemberTransfers[msg.sender] = true; allNonMembers.push(msg.sender); } } if (!members[_to].exists && _to != owner) { bool toTransferee = nonMemberTransfers[_to]; if (!toTransferee) { // If we haven't added this transferee before. nonMemberTransfers[_to] = true; allNonMembers.push(_to); } } else if (members[_to].exists) { // Add this transfer to the unlocked balance int256 transferInValue = members[_to].transferred - int(_value); require(transferInValue <= members[_to].transferred); // Check for underflow. members[_to].transferred = transferInValue; } return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3 * 32) canTransfer returns (bool success) { // If the transferrer has purchased tokens, they must be unlocked before they can be used. Member storage fromMember = members[_from]; if (fromMember.exists) { // If _from is the owner, this check will always fail, so we don't need to check specifically for owner here. int256 transferValue = fromMember.transferred + int(_value); require(transferValue >= fromMember.transferred); // Check for overflow. require(transferValue <= int(getUnlockedBalanceLimit(msg.sender))); // Make sure they don't transfer out more than their unlocked limit. fromMember.transferred = transferValue; } // If any of the parties involved are not members, add them to the nonmembers list. // Don't add the owner since they're a special case. if (!fromMember.exists && _from != owner) { bool fromTransferee = nonMemberTransfers[_from]; if (!fromTransferee) { // If we haven't added this transferee before. nonMemberTransfers[_from] = true; allNonMembers.push(_from); } } if (!members[_to].exists && _to != owner) { bool toTransferee = nonMemberTransfers[_to]; if (!toTransferee) { // If we haven't added this transferee before. nonMemberTransfers[_to] = true; allNonMembers.push(_to); } } else if (members[_to].exists) { // Add this transfer to the unlocked balance int256 transferInValue = members[_to].transferred - int(_value); require(transferInValue <= members[_to].transferred); // Check for underflow. members[_to].transferred = transferInValue; } return super.transferFrom(_from, _to, _value); } function setOpenGroup(uint256 groupNumber) public onlyOwner returns (bool success) { require(groupNumber < nextGroupNumber); openGroupNumber = groupNumber; return true; } function getUndistributedBalanceOf(address walletAddress, uint256 groupNumber) public view returns (uint256 balance) { Member storage theMember = members[walletAddress]; require(theMember.exists); if (groups[groupNumber].distributed) // Here, the group will be distributed but tokenBalance will still have a value, so that we know how many tokens to allocate to the unlocked balance. return 0; return theMember.tokenBalance[groupNumber]; } function checkMyUndistributedBalance(uint256 groupNumber) public view returns (uint256 balance) { return getUndistributedBalanceOf(msg.sender, groupNumber); } function transferRecovery(address _from, address _to, uint256 _value) public onlyOwner returns (bool success) { // Will be used if someone sends tokens to an incorrect address by accident. This way, we have the ability to recover the tokens. For example, sometimes there's a problem of lost tokens if someone sends tokens to a contract address that can't utilize the tokens. allowed[_from][msg.sender] = allowed[_from][msg.sender].add(_value); // Authorize the owner to spend on someone's behalf. Member storage fromMember = members[_from]; if (fromMember.exists) { int256 oldTransferred = fromMember.transferred; fromMember.transferred -= int(_value); // Unlock this amount. require(oldTransferred >= fromMember.transferred); // Check for underflow. } return transferFrom(_from, _to, _value); } } "}
