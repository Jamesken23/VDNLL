{"sol name": "10298.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; pragma experimental ABIEncoderV2; contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address owner) public view returns (uint256); function allowance(address owner, address spender) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); } contract FsTKAllocation { uint256 public vestedAmount; uint256 public constant RELEASE_EPOCH = 1642032000; ERC20 public token; function initialize(uint256 _vestedAmount) public { require( address(token) == 0 && _vestedAmount % 5 == 0 ); vestedAmount = _vestedAmount; token = ERC20(msg.sender); } function () external { uint256 amount = vestedAmount / 5; require( token.transfer(0x808b0730252DAA3a12CadC72f42E46E92a5e1bC8, amount) &&                                        true && true && true && true && true &&                  token.transfer(0xdA01fAFaF5E49e9467f99f5969cab499a5759cC6,amount) && token.transfer(0xddab6c29090E6111A490527614Ceac583D02C8De, amount) &&                                 true && true && true && true && true && true &&                 true&&true&&true&&true&&true&& true&& true&&true&&true&&true&&true&& true&&                                                                                            true &&                                                                                            true&& true&&                                                                                          true &&                                                                                              true&& true&&                                                                                       true &&                                                                                                 true&& true&&                                                                                     true &&                                                                                                   true&& true&&                                                                                   true &&                                                                                                     true&& true&&                                                                                  true &&                                                                                                      true&& true&&                                                                                 true &&                                                                                                       true&& true&&                                                                                 true &&                                                                                                       true&& true&&                                                                                true &&                                                                                                        true&& true&&                                                                                true &&                                                                                                        true&& true&&                                                                                true &&                                                                                                        true&& true&&                                                                                 true &&                                                                                                       true&& true&&                                                                                  true &&                                                                                                      true&& true&&                                                                                   true &&                                                                                                     true&& token.transfer(0xFFB5d7C71e8680D0e9482e107F019a2b25D225B5,amount)&&                       true &&                                                                                                    true&& token.transfer(0x91cE537b1a8118Aa20Ef7F3093697a7437a5Dc4B,amount)&&                         true &&                                                                                                  true&& true&&                                                                                         true &&                                                                                               true&& true&&                                                                                            block.timestamp >= RELEASE_EPOCH && true &&                                                        true&& true&&                                                                                                   true && true && true && true && true &&                                                     true&& true&&                                                                                                                                     true &&                                                   true&& true&&                                                                                                                                       true &&                                                 true&& true&&                                                                                                                                          true &&                                              true&& true&&                                                                                                                                            true &&                                            true&& true&&                                                                                                                                             true &&                                           true&& true&&                                                                                                                                              true &&                                          true&& true&&                                                                                                                                               true &&                                         true&& true&&                                                                                                                                                true &&                                        true&& true&&                                                                                                                                                true &&                                        true&& true&&                                                                                                                                                true &&                                        true&& true&&                                                                                                                                               true &&                                         true&& true&&                                                                                                                                              true &&                                          true&& true&&                                                                                                                                             true &&                                           true&& true&&                                                                                                                                           true &&                                             true&& true&&                                                                                                                                         true &&                                               true&& true&&                                                                                                                                       true &&                                                 true&& true&&                                                                                             true && true && true && true && true && true &&                                                   true&& true&&                                                                                          true && true && true && true && true && true &&                                                       true ); } } "}
{"sol name": "7826.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /* Capital Technologies & Research - Capital (CALL) & CapitalGAS (CALLG) - Crowdsale Smart Contract https://www.mycapitalco.in */ /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title CAPITAL GAS (CALLG) Token * @dev Token representing CALLG. */ contract CALLGToken is MintableToken { string public name = \"CAPITAL GAS\"; string public symbol = \"CALLG\"; uint8 public decimals = 18; } /** * @title CAPITAL (CALL) Token * @dev Token representing CALL. */ contract CALLToken is MintableToken { string public name = \"CAPITAL\"; string public symbol = \"CALL\"; uint8 public decimals = 18; } contract TeamVault is Ownable { using SafeMath for uint256; ERC20 public token_call; ERC20 public token_callg; event TeamWithdrawn(address indexed teamWallet, uint256 token_call, uint256 token_callg); constructor (ERC20 _token_call, ERC20 _token_callg) public { require(_token_call != address(0)); require(_token_callg != address(0)); token_call = _token_call; token_callg = _token_callg; } function () public payable { } function withdrawTeam(address teamWallet) public onlyOwner { require(teamWallet != address(0)); uint call_balance = token_call.balanceOf(this); uint callg_balance = token_callg.balanceOf(this); token_call.transfer(teamWallet, call_balance); token_callg.transfer(teamWallet, callg_balance); emit TeamWithdrawn(teamWallet, call_balance, callg_balance); } } contract BountyVault is Ownable { using SafeMath for uint256; ERC20 public token_call; ERC20 public token_callg; event BountyWithdrawn(address indexed bountyWallet, uint256 token_call, uint256 token_callg); constructor (ERC20 _token_call, ERC20 _token_callg) public { require(_token_call != address(0)); require(_token_callg != address(0)); token_call = _token_call; token_callg = _token_callg; } function () public payable { } function withdrawBounty(address bountyWallet) public onlyOwner { require(bountyWallet != address(0)); uint call_balance = token_call.balanceOf(this); uint callg_balance = token_callg.balanceOf(this); token_call.transfer(bountyWallet, call_balance); token_callg.transfer(bountyWallet, callg_balance); emit BountyWithdrawn(bountyWallet, call_balance, callg_balance); } } /** * @title RefundVault * @dev This contract is used for storing funds while a crowdsale * is in progress. Supports refunding the money if crowdsale fails, * and forwarding it if crowdsale is successful. */ contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); /** * @param _wallet Vault address */ constructor(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } /** * @param investor Investor address */ function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; emit Closed(); wallet.transfer(address(this).balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; emit RefundsEnabled(); } /** * @param investor Investor address */ function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); emit Refunded(investor, depositedValue); } } contract FiatContract { function USD(uint _id) constant returns (uint256); } contract CapitalTechCrowdsale is Ownable { using SafeMath for uint256; ERC20 public token_call; ERC20 public token_callg; FiatContract public fiat_contract; RefundVault public vault; TeamVault public teamVault; BountyVault public bountyVault; enum stages { PRIVATE_SALE, PRE_SALE, MAIN_SALE_1, MAIN_SALE_2, MAIN_SALE_3, MAIN_SALE_4, FINALIZED } address public wallet; uint256 public maxContributionPerAddress; uint256 public stageStartTime; uint256 public weiRaised; uint256 public minInvestment; stages public stage; bool public is_finalized; bool public powered_up; bool public distributed_team; bool public distributed_bounty; mapping(address => uint256) public contributions; mapping(address => uint256) public userHistory; mapping(uint256 => uint256) public stages_duration; uint256 public callSoftCap; uint256 public callgSoftCap; uint256 public callDistributed; uint256 public callgDistributed; uint256 public constant decimals = 18; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount_call, uint256 amount_callg); event TokenTransfer(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount_call, uint256 amount_callg); event StageChanged(stages stage, stages next_stage, uint256 stageStartTime); event GoalReached(uint256 callSoftCap, uint256 callgSoftCap); event Finalized(uint256 callDistributed, uint256 callgDistributed); function () external payable { buyTokens(msg.sender); } constructor(address _wallet, address _fiatcontract, ERC20 _token_call, ERC20 _token_callg) public { require(_token_call != address(0)); require(_token_callg != address(0)); require(_wallet != address(0)); require(_fiatcontract != address(0)); token_call = _token_call; token_callg = _token_callg; wallet = _wallet; fiat_contract = FiatContract(_fiatcontract); vault = new RefundVault(_wallet); bountyVault = new BountyVault(_token_call, _token_callg); teamVault = new TeamVault(_token_call, _token_callg); } function powerUpContract() public onlyOwner { require(!powered_up); require(!is_finalized); stageStartTime = block.timestamp; stage = stages.PRIVATE_SALE; weiRaised = 0; distributeTeam(); distributeBounty(); callDistributed = 7875000 * 10 ** decimals; callgDistributed = 1575000000 * 10 ** decimals; callSoftCap = 18049500 * 10 ** decimals; callgSoftCap = 3609900000 * 10 ** decimals; maxContributionPerAddress = 1500 ether; minInvestment = 0.01 ether; is_finalized = false; powered_up = true; stages_duration[uint256(stages.PRIVATE_SALE)] = 30 days; stages_duration[uint256(stages.PRE_SALE)] = 30 days; stages_duration[uint256(stages.MAIN_SALE_1)] = 7 days; stages_duration[uint256(stages.MAIN_SALE_2)] = 7 days; stages_duration[uint256(stages.MAIN_SALE_3)] = 7 days; stages_duration[uint256(stages.MAIN_SALE_4)] = 7 days; } function distributeTeam() public onlyOwner { require(!distributed_team); uint256 _amount = 5250000 * 10 ** decimals; distributed_team = true; MintableToken(token_call).mint(teamVault, _amount); MintableToken(token_callg).mint(teamVault, _amount.mul(200)); emit TokenTransfer(msg.sender, teamVault, _amount, _amount, _amount.mul(200)); } function distributeBounty() public onlyOwner { require(!distributed_bounty); uint256 _amount = 2625000 * 10 ** decimals; distributed_bounty = true; MintableToken(token_call).mint(bountyVault, _amount); MintableToken(token_callg).mint(bountyVault, _amount.mul(200)); emit TokenTransfer(msg.sender, bountyVault, _amount, _amount, _amount.mul(200)); } function withdrawBounty(address _beneficiary) public onlyOwner { require(distributed_bounty); bountyVault.withdrawBounty(_beneficiary); } function withdrawTeam(address _beneficiary) public onlyOwner { require(distributed_team); teamVault.withdrawTeam(_beneficiary); } function getUserContribution(address _beneficiary) public view returns (uint256) { return contributions[_beneficiary]; } function getUserHistory(address _beneficiary) public view returns (uint256) { return userHistory[_beneficiary]; } function getReferrals(address[] _beneficiaries) public view returns (address[], uint256[]) { address[] memory addrs = new address[](_beneficiaries.length); uint256[] memory funds = new uint256[](_beneficiaries.length); for (uint256 i = 0; i < _beneficiaries.length; i++) { addrs[i] = _beneficiaries[i]; funds[i] = getUserHistory(_beneficiaries[i]); } return (addrs, funds); } function getAmountForCurrentStage(uint256 _amount) public view returns(uint256) { uint256 tokenPrice = fiat_contract.USD(0); if(stage == stages.PRIVATE_SALE) { tokenPrice = tokenPrice.mul(35).div(10 ** 8); } else if(stage == stages.PRE_SALE) { tokenPrice = tokenPrice.mul(50).div(10 ** 8); } else if(stage == stages.MAIN_SALE_1) { tokenPrice = tokenPrice.mul(70).div(10 ** 8); } else if(stage == stages.MAIN_SALE_2) { tokenPrice = tokenPrice.mul(80).div(10 ** 8); } else if(stage == stages.MAIN_SALE_3) { tokenPrice = tokenPrice.mul(90).div(10 ** 8); } else if(stage == stages.MAIN_SALE_4) { tokenPrice = tokenPrice.mul(100).div(10 ** 8); } return _amount.div(tokenPrice).mul(10 ** 10); } function _getNextStage() internal view returns (stages) { stages next_stage; if (stage == stages.PRIVATE_SALE) { next_stage = stages.PRE_SALE; } else if (stage == stages.PRE_SALE) { next_stage = stages.MAIN_SALE_1; } else if (stage == stages.MAIN_SALE_1) { next_stage = stages.MAIN_SALE_2; } else if (stage == stages.MAIN_SALE_2) { next_stage = stages.MAIN_SALE_3; } else if (stage == stages.MAIN_SALE_3) { next_stage = stages.MAIN_SALE_4; } else { next_stage = stages.FINALIZED; } return next_stage; } function getHardCap() public view returns (uint256, uint256) { uint256 hardcap_call; uint256 hardcap_callg; if (stage == stages.PRIVATE_SALE) { hardcap_call = 10842563; hardcap_callg = 2168512500; } else if (stage == stages.PRE_SALE) { hardcap_call = 18049500; hardcap_callg = 3609900000; } else if (stage == stages.MAIN_SALE_1) { hardcap_call = 30937200; hardcap_callg = 6187440000; } else if (stage == stages.MAIN_SALE_2) { hardcap_call = 40602975; hardcap_callg = 8120595000; } else if (stage == stages.MAIN_SALE_3) { hardcap_call = 47046825; hardcap_callg = 9409365000; } else { hardcap_call = 52500000; hardcap_callg = 10500000000; } return (hardcap_call.mul(10 ** decimals), hardcap_callg.mul(10 ** decimals)); } function updateStage() public { _updateStage(0, 0); } function _updateStage(uint256 weiAmount, uint256 callAmount) internal { uint256 _duration = stages_duration[uint256(stage)]; uint256 call_tokens = 0; if (weiAmount != 0) { call_tokens = getAmountForCurrentStage(weiAmount); } else { call_tokens = callAmount; } uint256 callg_tokens = call_tokens.mul(200); (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap(); if(stageStartTime.add(_duration) <= block.timestamp || callDistributed.add(call_tokens) >= _hardcapCall || callgDistributed.add(callg_tokens) >= _hardcapCallg) { stages next_stage = _getNextStage(); emit StageChanged(stage, next_stage, stageStartTime); stage = next_stage; if (next_stage != stages.FINALIZED) { stageStartTime = block.timestamp; } else { finalization(); } } } function buyTokens(address _beneficiary) public payable { require(!is_finalized); if (_beneficiary == address(0)) { _beneficiary = msg.sender; } (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap(); uint256 weiAmount = msg.value; require(weiAmount > 0); require(_beneficiary != address(0)); require(weiAmount >= minInvestment); require(contributions[_beneficiary].add(weiAmount) <= maxContributionPerAddress); _updateStage(weiAmount, 0); uint256 call_tokens = getAmountForCurrentStage(weiAmount); uint256 callg_tokens = call_tokens.mul(200); weiRaised = weiRaised.add(weiAmount); callDistributed = callDistributed.add(call_tokens); callgDistributed = callgDistributed.add(callg_tokens); MintableToken(token_call).mint(_beneficiary, call_tokens); MintableToken(token_callg).mint(_beneficiary, callg_tokens); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, call_tokens, callg_tokens); contributions[_beneficiary] = contributions[_beneficiary].add(weiAmount); userHistory[_beneficiary] = userHistory[_beneficiary].add(call_tokens); vault.deposit.value(msg.value)(msg.sender); } function finalize() onlyOwner public { stage = stages.FINALIZED; finalization(); } function extendPeriod(uint256 date) public onlyOwner { stages_duration[uint256(stage)] = stages_duration[uint256(stage)].add(date); } function transferTokens(address _to, uint256 _amount) public onlyOwner { require(!is_finalized); require(_to != address(0)); require(_amount > 0); _updateStage(0, _amount); callDistributed = callDistributed.add(_amount); callgDistributed = callgDistributed.add(_amount.mul(200)); if (stage == stages.FINALIZED) { (uint256 _hardcapCall, uint256 _hardcapCallg) = getHardCap(); require(callDistributed.add(callDistributed) <= _hardcapCall); require(callgDistributed.add(callgDistributed) <= _hardcapCallg); } MintableToken(token_call).mint(_to, _amount); MintableToken(token_callg).mint(_to, _amount.mul(200)); userHistory[_to] = userHistory[_to].add(_amount); emit TokenTransfer(msg.sender, _to, _amount, _amount, _amount.mul(200)); } function claimRefund() public { address _beneficiary = msg.sender; require(is_finalized); require(!goalReached()); userHistory[_beneficiary] = 0; vault.refund(_beneficiary); } function goalReached() public view returns (bool) { if (callDistributed >= callSoftCap && callgDistributed >= callgSoftCap) { return true; } else { return false; } } function finishMinting() public onlyOwner { MintableToken(token_call).finishMinting(); MintableToken(token_callg).finishMinting(); } function finalization() internal { require(!is_finalized); is_finalized = true; finishMinting(); emit Finalized(callDistributed, callgDistributed); if (goalReached()) { emit GoalReached(callSoftCap, callgSoftCap); vault.close(); } else { vault.enableRefunds(); } } } "}
{"sol name": "8497.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function transfer(address to, uint tokens) public returns (bool success); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); } contract CryptoQuantumTradingFund is ERC20Interface { // ERC20 ////////////// function totalSupply()public constant returns (uint) { return fixTotalBalance; } function balanceOf(address tokenOwner)public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens)public returns (bool success) { if (balances[msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) { if(msg.sender == creatorsAddress) //\u521b\u59cb\u56e2\u961f\u9501\u5b9a\u5224\u65ad { TryUnLockCreatorBalance(); if(balances[msg.sender] < (creatorsLocked + tokens)) { return false; } } balances[msg.sender] -= tokens; balances[to] += tokens; emit Transfer(msg.sender, to, tokens); return true; } else { return false; } } function transferFrom(address from, address to, uint tokens)public returns (bool success) { if (balances[from] >= tokens && allowed[from][msg.sender] >= tokens && tokens > 0 && balances[to] + tokens > balances[to]) { if(from == creatorsAddress) //\u521b\u59cb\u56e2\u961f\u9501\u5b9a\u5224\u65ad { TryUnLockCreatorBalance(); if(balances[from] < (creatorsLocked + tokens)) { return false; } } balances[from] -= tokens; allowed[from][msg.sender] -= tokens; balances[to] += tokens; emit Transfer(from, to, tokens); return true; } else { return false; } } function approve(address spender, uint tokens)public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function allowance(address tokenOwner, address spender)public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } event Transfer(address indexed from, address indexed to, uint tokens);//transfer\u65b9\u6cd5\u8c03\u7528\u65f6\u7684\u901a\u77e5\u4e8b\u4ef6 event Approval(address indexed tokenOwner, address indexed spender, uint tokens); //approve\u65b9\u6cd5\u8c03\u7528\u65f6\u7684\u901a\u77e5\u4e8b\u4ef6 // ERC20 ////////////// string public name = \"CryptoQuantumTradingFund\"; string public symbol = \"CQTF\"; uint8 public decimals = 18; uint256 private fixTotalBalance = 100000000000000000000000000; uint256 private _totalBalance =    92000000000000000000000000; uint256   public creatorsLocked =  8000000000000000000000000; //\u521b\u4e16\u56e2\u961f\u5f53\u524d\u9501\u5b9a\u989d\u5ea6 address public owner = 0x0; mapping (address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; uint  constant    private ONE_DAY_TIME_LEN = 86400; //\u4e00\u5929\u7684\u79d2\u6570 uint  constant    private ONE_YEAR_TIME_LEN = 946080000; //\u4e00\u5e74\u7684\u79d2\u6570 uint32 private constant MAX_UINT32 = 0xFFFFFFFF; address public creatorsAddress = 0xbcabf04377034e4eC3C20ACaD2CA093559Ee9742; //\u521b\u4e16\u56e2\u961f\u5730\u5740 uint      public unLockIdx = 2;\t\t//\u9501\u5b9a\u7cfb\u6570 uint      public nextUnLockTime = block.timestamp + ONE_YEAR_TIME_LEN;\t//\u4e0b\u6b21\u89e3\u9501\u65f6\u95f4\u70b9 function CryptoQuantumTradingFund() public { owner = msg.sender; balances[creatorsAddress] = creatorsLocked; balances[owner] = _totalBalance; } //\u89e3\u9501\u521b\u59cb\u56e2\u961f function TryUnLockCreatorBalance() public { while(unLockIdx > 0 && block.timestamp >= nextUnLockTime){ //\u89e3\u9501\u5224\u65ad uint256 append = creatorsLocked/unLockIdx; creatorsLocked -= append; unLockIdx -= 1; nextUnLockTime = block.timestamp + ONE_YEAR_TIME_LEN; } } function () public payable { } function Save() public { if (msg.sender != owner) revert(); owner.transfer(address(this).balance); } function changeOwner(address newOwner) public { if (msg.sender != owner) { revert(); } else { owner = newOwner; } } function destruct() public { if (msg.sender != owner) { revert(); } else { selfdestruct(owner); } } } "}
{"sol name": "2723.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract RSEvents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); } contract modularLastUnicorn is RSEvents {} contract LastUnicorn is modularLastUnicorn { using SafeMath for *; using NameFilter for string; using RSKeysCalc for uint256; // TODO: check address UnicornInterfaceForForwarder constant private TeamUnicorn = UnicornInterfaceForForwarder(0xBB14004A6f3D15945B3786012E00D9358c63c92a); UnicornBookInterface constant private UnicornBook = UnicornBookInterface(0x98547788f328e1011065E4068A8D72bacA1DDB49); string constant public name = \"LastUnicorn Round #1\"; string constant public symbol = \"RS1\"; uint256 private rndGap_ = 0; // TODO: check time uint256 constant private rndInit_ = 1 hours;                // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => RSdatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => RSdatasets.PlayerRounds) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** RSdatasets.Round public round_;   // round data //**************** // TEAM FEE DATA //**************** uint256 public fees_ = 60;          // fee distribution uint256 public potSplit_ = 45;     // pot split distribution //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet\"); _; } /** * @dev prevents contracts from interacting with LastUnicorn */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"non smart contract address only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"too little money\"); require(_eth <= 100000000000000000000000, \"too much money\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee */ function buyXid(uint256 _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // buy core buyCore(_pID, _affCode, _eventData_); } function buyXaddr(address _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core buyCore(_pID, _affID, _eventData_); } function buyXname(bytes32 _affCode) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not RSdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core buyCore(_pID, _affID, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // reload core reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core reLoadCore(_pID, _affID, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_.end && round_.ended == false && round_.plyr != 0) { // set up our tx event data RSdatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_.ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit RSEvents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit RSEvents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = UnicornBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = UnicornBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = UnicornBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit RSEvents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))) return ( (round_.keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // grab time uint256 _now = now; if (_now < round_.end) if (_now > round_.strt + rndGap_) return( (round_.end).sub(_now) ); else return( (round_.strt + rndGap_).sub(_now)); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_.end && round_.ended == false && round_.plyr != 0) { // if player is winner if (round_.plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_.pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID).sub(plyrRnds_[_pID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID).sub(plyrRnds_[_pID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID) private view returns(uint256) { return(  ((((round_.mask).add(((((round_.pot).mul(potSplit_)) / 100).mul(1000000000000000000)) / (round_.keys))).mul(plyrRnds_[_pID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return total keys * @return time ends * @return time started * @return current pot * @return current player ID in lead * @return current player in leads address * @return current player in leads name * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256) { return ( round_.keys,              //0 round_.end,               //1 round_.strt,              //2 round_.pot,               //3 round_.plyr,              //4 plyr_[round_.plyr].addr,  //5 plyr_[round_.plyr].name,  //6 airDropTracker_ + (airDropPot_ * 1000)              //7 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, RSdatasets.EventReturns memory _eventData_) private { // grab time uint256 _now = now; // if round is active if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))) { // call core core(_pID, msg.value, _affID, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_.end && round_.ended == false) { // end the round (distributes pot) & start new round round_.ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit RSEvents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, RSdatasets.EventReturns memory _eventData_) private { // grab time uint256 _now = now; // if round is active if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core(_pID, _eth, _affID, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_.end && round_.ended == false) { // end the round (distributes pot) & start new round round_.ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit RSEvents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter if (round_.eth < 100000000000000000000 && plyrRnds_[_pID].eth.add(_eth) > 10000000000000000000) { uint256 _availableLimit = (10000000000000000000).sub(plyrRnds_[_pID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_.eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys); // set new leaders if (round_.plyr != _pID) round_.plyr = _pID; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // manage airdrops if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { // gib muni uint256 _prize; if (_eth >= 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 2 prize was won _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 1 prize was won _eventData_.compressedData += 100000000000000000000000000000000; } // set airdrop happened bool to true _eventData_.compressedData += 10000000000000000000000000000000; // let event know how much was won _eventData_.compressedData += _prize * 1000000000000000000000000000000000; // reset air drop tracker airDropTracker_ = 0; } } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); // update player plyrRnds_[_pID].keys = _keys.add(plyrRnds_[_pID].keys); plyrRnds_[_pID].eth = _eth.add(plyrRnds_[_pID].eth); // update round round_.keys = _keys.add(round_.keys); round_.eth = _eth.add(round_.eth); // distribute eth _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_pID, _eth, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID) private view returns(uint256) { return((((round_.mask).mul(plyrRnds_[_pID].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID].mask)); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))) return ( (round_.eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_.strt + rndGap_ && (_now <= round_.end || (_now > round_.end && round_.plyr == 0))) return ( (round_.keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(UnicornBook), \"only UnicornBook can call this function\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(UnicornBook), \"only UnicornBook can call this function\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(RSdatasets.EventReturns memory _eventData_) private returns (RSdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of LastUnicorn if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = UnicornBook.getPlayerID(msg.sender); bytes32 _name = UnicornBook.getPlayerName(_pID); uint256 _laff = UnicornBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, RSdatasets.EventReturns memory _eventData_) private returns (RSdatasets.EventReturns) { // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(RSdatasets.EventReturns memory _eventData_) private returns (RSdatasets.EventReturns) { // grab our winning player and team id's uint256 _winPID = round_.plyr; // grab our pot amount // add airdrop pot into the final pot uint256 _pot = round_.pot + airDropPot_; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(45)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_)) / 100; // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_.keys); uint256 _dust = _gen.sub((_ppt.mul(round_.keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _com = _com.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards if (!address(TeamUnicorn).call.value(_com)(bytes4(keccak256(\"deposit()\")))) { _gen = _gen.add(_com); _com = 0; } // distribute gen portion to key holders round_.mask = _ppt.add(round_.mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_.end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.newPot = 0; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID) private { uint256 _earnings = calcUnMaskedEarnings(_pID); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID].mask = _earnings.add(plyrRnds_[_pID].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_.end && round_.plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_.end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_.end = _newTime; else round_.end = rndMax_.add(_now); } /** * @dev generates a random number between 0-99 and checks to see if thats * resulted in an airdrop win * @return do we have a winner? */ function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, RSdatasets.EventReturns memory _eventData_) private returns(RSdatasets.EventReturns) { // pay 5% out to community rewards uint256 _com = _eth * 5 / 100; // distribute share to affiliate uint256 _aff = _eth / 10; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit RSEvents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _pID, _aff, now); } else { // no affiliates, add to community _com += _aff; } if (!address(TeamUnicorn).call.value(_com)(bytes4(keccak256(\"deposit()\")))) { // This ensures TeamUnicorn cannot influence the outcome // bank migrations by breaking outgoing transactions. } return(_eventData_); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_) private returns(RSdatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_)) / 100; // toss 5% into airdrop pot uint256 _air = (_eth / 20); airDropPot_ = airDropPot_.add(_air); // calculate pot (20%) uint256 _pot = (_eth.mul(20) / 100); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_.pot = _pot.add(_dust).add(round_.pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_.keys); round_.mask = _ppt.add(round_.mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID].mask = (((round_.mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_.keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _eth, uint256 _keys, RSdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit RSEvents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public { // only owner can activate // TODO: set owner require( (msg.sender == 0xcD0fce8d255349092496F131f2900DF25f0569F8), \"only owner can activate\" ); // can only be ran once require(activated_ == false, \"LastUnicorn already activated\"); // activate the contract activated_ = true; round_.strt = now - rndGap_; round_.end = now + rndInit_; } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library RSdatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask } struct Round { uint256 plyr;   // pID of player in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask } } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== library RSKeysCalc { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface UnicornInterfaceForForwarder { function deposit() external payable returns(bool); } interface UnicornBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } } "}
{"sol name": "2777.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } pragma solidity ^0.4.24; /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } pragma solidity ^0.4.24; library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } pragma solidity ^0.4.24; // \"./PlayerBookInterface.sol\"; // \"./SafeMath.sol\"; // \"./NameFilter.sol\"; // 'openzeppelin-solidity/contracts/ownership/Ownable.sol'; //============================================================================== //     _    _  _ _|_ _  . //    (/_\\/(/_| | | _\\  . //============================================================================== contract F3Devents { /* event debug ( uint16 code, uint256 value, bytes32 msg ); */ // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 mktAmount, //        uint256 comAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 mktAmount, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 mktAmount, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 mktAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract modularLong is F3Devents {} contract FoMo3DWorld is modularLong, Ownable { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; //    otherFoMo3D private otherF3D_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x789C537cE585595596D3905f401235f5A85B11d7); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== string constant public name = \"FoMo3D World\"; string constant public symbol = \"F3DW\"; //    uint256 private rndExtra_ = extSettings.getLongExtra();     // length of the very first ICO uint256 constant private rndGap_ = 0; // 120 seconds;         // length of ICO phase. uint256 constant private rndInit_ = 1 hours;                // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA //**************** mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team constructor() public { // Team allocation structures // 0 = whales // 1 = bears // 2 = sneks // 3 = bulls // Team allocation percentages // (F3D, P3D) + (Pot , Referrals, Community) // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot. fees_[0] = F3Ddatasets.TeamFee(30, 6);   //50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot fees_[1] = F3Ddatasets.TeamFee(43, 0);   //43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot fees_[2] = F3Ddatasets.TeamFee(56, 10);  //20% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot fees_[3] = F3Ddatasets.TeamFee(43, 8);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot // how to split up the final pot based on which team was picked // (F3D, P3D) potSplit_[0] = F3Ddatasets.PotSplit(15, 10);  //48% to winner, 25% to next round, 2% to com potSplit_[1] = F3Ddatasets.PotSplit(25, 0);   //48% to winner, 25% to next round, 2% to com potSplit_[2] = F3Ddatasets.PotSplit(20, 20);  //48% to winner, 10% to next round, 2% to com potSplit_[3] = F3Ddatasets.PotSplit(30, 10);  //48% to winner, 10% to next round, 2% to com } /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } /** * @dev prevents contracts from interacting with fomo3d */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit F3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.mktAmount, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, _team, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit F3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.mktAmount, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core(_rID, _pID, _eth, _affID, _team, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit F3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.mktAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000) { uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // manage airdrops if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { // gib muni uint256 _prize; if (_eth >= 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 2 prize was won _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } // set airdrop happened bool to true _eventData_.compressedData += 10000000000000000000000000000000; // let event know how much was won _eventData_.compressedData += _prize * 1000000000000000000000000000000000; // reset air drop tracker airDropTracker_ = 0; } } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _team, _eth, _keys, _eventData_); } } /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of fomo3d if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev checks to make sure user picked a valid team.  if not sets team * to default (sneks) */ function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _mkt = (_pot.mul(potSplit_[_winTID].marketing)) / 100; uint256 _res = ((_pot.sub(_win)).sub(_com)).sub(_gen).sub(_mkt); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards _com = _com.add(_mkt); if (!owner.send(_com)) { _com = 0; _res = _res.add(_com); } // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.mktAmount = _mkt; //        _eventData_.comAmount = _com; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev generates a random number between 0-99 and checks to see if thats * resulted in an airdrop win * @return do we have a winner? */ function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked((block.timestamp).add(block.difficulty).add((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add(block.gaslimit).add((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add(block.number)))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { // pay 2% out to community rewards uint256 _com = _eth / 50; // distribute share to affiliate uint256 _aff = _eth / 10; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _com = _com.add(_aff); } uint256 _mkt = _eth.mul(fees_[_team].marketing) / 100; _com = _com.add(_mkt); owner.transfer(_com); _eventData_.mktAmount = _mkt; //        _eventData_.comAmount = _com; return(_eventData_); } function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F3Devents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; // toss 1% into airdrop pot uint256 _air = (_eth / 100); airDropPot_ = airDropPot_.add(_air); uint256 cut = (fees_[_team].marketing).add(13); _eth = _eth.sub(_eth.mul(cut) / 100); // calculate pot uint256 _pot = _eth.sub(_gen); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) { _gen = _gen.sub(_dust); } // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.mktAmount, //            _eventData_.comAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public onlyOwner { // make sure that its been linked. //        require(address(otherF3D_) != address(0), \"must link to other FoMo3D first\"); // can only be ran once require(activated_ == false, \"fomo3d already activated\"); // activate the contract activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now; round_[1].end = now + rndInit_; } } library F3Ddatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 mktAmount;          // amount distributed for marketing //        uint256 comAmount; uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { uint256 gen;          // % of buy in thats paid to key holders of current round uint256 marketing;    // % of buy in thats paid for marketing } struct PotSplit { uint256 gen;          // % of pot thats paid to key holders of current round uint256 marketing;    // % of pot thats paid to for marketing } } library F3DKeysCalcLong { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } "}
{"sol name": "9695.sol", "label": 0, "sol content": "/// @title Contract that supports the receival of ERC223 tokens. contract ERC223ReceivingContract { /// @dev Standard ERC223 function that will handle incoming token transfers. /// @param _from  Token sender address. /// @param _value Amount of tokens. /// @param _data  Transaction metadata. function tokenFallback(address _from, uint _value, bytes _data) public; } contract SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC223Basic is ERC20Basic { /** * @dev Transfer the specified amount of tokens to the specified address. *      Now with a new parameter _data. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint _value, bytes _data) public returns (bool); /** * @dev triggered when transfer is successfully called. * * @param _from  Sender address. * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ event Transfer(address indexed _from, address indexed _to, uint256 indexed _value, bytes _data); } library BytesLib { function concat(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bytes) { bytes memory tempBytes; assembly { // Get a location of some free memory and store it in tempBytes as // Solidity does for memory variables. tempBytes := mload(0x40) // Store the length of the first bytes array at the beginning of // the memory for tempBytes. let length := mload(_preBytes) mstore(tempBytes, length) // Maintain a memory counter for the current write location in the // temp bytes array by adding the 32 bytes for the array length to // the starting location. let mc := add(tempBytes, 0x20) // Stop copying when the memory counter reaches the length of the // first bytes array. let end := add(mc, length) for { // Initialize a copy counter to the start of the _preBytes data, // 32 bytes into its memory. let cc := add(_preBytes, 0x20) } lt(mc, end) { // Increase both counters by 32 bytes each iteration. mc := add(mc, 0x20) cc := add(cc, 0x20) } { // Write the _preBytes data into the tempBytes memory 32 bytes // at a time. mstore(mc, mload(cc)) } // Add the length of _postBytes to the current length of tempBytes // and store it as the new length in the first 32 bytes of the // tempBytes memory. length := mload(_postBytes) mstore(tempBytes, add(length, mload(tempBytes))) // Move the memory counter back from a multiple of 0x20 to the // actual end of the _preBytes data. mc := end // Stop copying when the memory counter reaches the new combined // length of the arrays. end := add(mc, length) for { let cc := add(_postBytes, 0x20) } lt(mc, end) { mc := add(mc, 0x20) cc := add(cc, 0x20) } { mstore(mc, mload(cc)) } // Update the free-memory pointer by padding our last write location // to 32 bytes: add 31 bytes to the end of tempBytes to move to the // next 32 byte block, then round down to the nearest multiple of // 32. If the sum of the length of the two arrays is zero then add // one before rounding down to leave a blank 32 bytes (the length block with 0). mstore(0x40, and( add(add(end, iszero(add(length, mload(_preBytes)))), 31), not(31) // Round down to the nearest 32 bytes. )) } return tempBytes; } function concatStorage(bytes storage _preBytes, bytes memory _postBytes) internal { assembly { // Read the first 32 bytes of _preBytes storage, which is the length // of the array. (We don't need to use the offset into the slot // because arrays use the entire slot.) let fslot := sload(_preBytes_slot) // Arrays of 31 bytes or less have an even value in their slot, // while longer arrays have an odd value. The actual length is // the slot divided by two for odd values, and the lowest order // byte divided by two for even values. // If the slot is even, bitwise and the slot with 255 and divide by // two to get the length. If the slot is odd, bitwise and the slot // with -1 and divide by two. let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2) let mlength := mload(_postBytes) let newlength := add(slength, mlength) // slength can contain both the length and contents of the array // if length < 32 bytes so let's prepare for that // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage switch add(lt(slength, 32), lt(newlength, 32)) case 2 { // Since the new array still fits in the slot, we just need to // update the contents of the slot. // uint256(bytes_storage) = uint256(bytes_storage) + uint256(bytes_memory) + new_length sstore( _preBytes_slot, // all the modifications to the slot are inside this // next block add( // we can just add to the slot contents because the // bytes we want to change are the LSBs fslot, add( mul( div( // load the bytes from memory mload(add(_postBytes, 0x20)), // zero all bytes to the right exp(0x100, sub(32, mlength)) ), // and now shift left the number of bytes to // leave space for the length in the slot exp(0x100, sub(32, newlength)) ), // increase length by the double of the memory // bytes length mul(mlength, 2) ) ) ) } case 1 { // The stored value fits in the slot, but the combined value // will exceed it. // get the keccak hash to get the contents of the array mstore(0x0, _preBytes_slot) let sc := add(keccak256(0x0, 0x20), div(slength, 32)) // save new length sstore(_preBytes_slot, add(mul(newlength, 2), 1)) // The contents of the _postBytes array start 32 bytes into // the structure. Our first read should obtain the `submod` // bytes that can fit into the unused space in the last word // of the stored array. To get this, we read 32 bytes starting // from `submod`, so the data we read overlaps with the array // contents by `submod` bytes. Masking the lowest-order // `submod` bytes allows us to add that value directly to the // stored value. let submod := sub(32, slength) let mc := add(_postBytes, submod) let end := add(_postBytes, mlength) let mask := sub(exp(0x100, submod), 1) sstore( sc, add( and( fslot, 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff00 ), and(mload(mc), mask) ) ) for { mc := add(mc, 0x20) sc := add(sc, 1) } lt(mc, end) { sc := add(sc, 1) mc := add(mc, 0x20) } { sstore(sc, mload(mc)) } mask := exp(0x100, sub(mc, end)) sstore(sc, mul(div(mload(mc), mask), mask)) } default { // get the keccak hash to get the contents of the array mstore(0x0, _preBytes_slot) // Start copying to the last used word of the stored array. let sc := add(keccak256(0x0, 0x20), div(slength, 32)) // save new length sstore(_preBytes_slot, add(mul(newlength, 2), 1)) // Copy over the first `submod` bytes of the new data as in // case 1 above. let slengthmod := mod(slength, 32) let mlengthmod := mod(mlength, 32) let submod := sub(32, slengthmod) let mc := add(_postBytes, submod) let end := add(_postBytes, mlength) let mask := sub(exp(0x100, submod), 1) sstore(sc, add(sload(sc), and(mload(mc), mask))) for { sc := add(sc, 1) mc := add(mc, 0x20) } lt(mc, end) { sc := add(sc, 1) mc := add(mc, 0x20) } { sstore(sc, mload(mc)) } mask := exp(0x100, sub(mc, end)) sstore(sc, mul(div(mload(mc), mask), mask)) } } } function slice(bytes _bytes, uint _start, uint _length) internal  pure returns (bytes) { require(_bytes.length >= (_start + _length)); bytes memory tempBytes; assembly { switch iszero(_length) case 0 { // Get a location of some free memory and store it in tempBytes as // Solidity does for memory variables. tempBytes := mload(0x40) // The first word of the slice result is potentially a partial // word read from the original array. To read it, we calculate // the length of that partial word and start copying that many // bytes into the array. The first word we copy will start with // data we don't care about, but the last `lengthmod` bytes will // land at the beginning of the contents of the new array. When // we're done copying, we overwrite the full first word with // the actual length of the slice. let lengthmod := and(_length, 31) // The multiplication in the next line is necessary // because when slicing multiples of 32 bytes (lengthmod == 0) // the following copy loop was copying the origin's length // and then ending prematurely not copying everything it should. let mc := add(add(tempBytes, lengthmod), mul(0x20, iszero(lengthmod))) let end := add(mc, _length) for { // The multiplication in the next line has the same exact purpose // as the one above. let cc := add(add(add(_bytes, lengthmod), mul(0x20, iszero(lengthmod))), _start) } lt(mc, end) { mc := add(mc, 0x20) cc := add(cc, 0x20) } { mstore(mc, mload(cc)) } mstore(tempBytes, _length) //update free-memory pointer //allocating the array padded to 32 bytes like the compiler does now mstore(0x40, and(add(mc, 31), not(31))) } //if we want a zero-length slice let's just return a zero-length array default { tempBytes := mload(0x40) mstore(0x40, add(tempBytes, 0x20)) } } return tempBytes; } function toAddress(bytes _bytes, uint _start) internal  pure returns (address) { require(_bytes.length >= (_start + 20)); address tempAddress; assembly { tempAddress := div(mload(add(add(_bytes, 0x20), _start)), 0x1000000000000000000000000) } return tempAddress; } function toUint(bytes _bytes, uint _start) internal  pure returns (uint256) { require(_bytes.length >= (_start + 32)); uint256 tempUint; assembly { tempUint := mload(add(add(_bytes, 0x20), _start)) } return tempUint; } function toBytes32(bytes _bytes, uint _start) internal  pure returns (bytes32) { require(_bytes.length >= (_start + 32)); bytes32 tempBytes32; assembly { tempBytes32 := mload(add(add(_bytes, 0x20), _start)) } return tempBytes32; } function toBytes16(bytes _bytes, uint _start) internal  pure returns (bytes16) { require(_bytes.length >= (_start + 16)); bytes16 tempBytes16; assembly { tempBytes16 := mload(add(add(_bytes, 0x20), _start)) } return tempBytes16; } function toBytes2(bytes _bytes, uint _start) internal  pure returns (bytes2) { require(_bytes.length >= (_start + 2)); bytes2 tempBytes2; assembly { tempBytes2 := mload(add(add(_bytes, 0x20), _start)) } return tempBytes2; } function toBytes4(bytes _bytes, uint _start) internal  pure returns (bytes4) { require(_bytes.length >= (_start + 4)); bytes4 tempBytes4; assembly { tempBytes4 := mload(add(add(_bytes, 0x20), _start)) } return tempBytes4; } function toBytes1(bytes _bytes, uint _start) internal  pure returns (bytes1) { require(_bytes.length >= (_start + 1)); bytes1 tempBytes1; assembly { tempBytes1 := mload(add(add(_bytes, 0x20), _start)) } return tempBytes1; } function equal(bytes memory _preBytes, bytes memory _postBytes) internal pure returns (bool) { bool success = true; assembly { let length := mload(_preBytes) // if lengths don't match the arrays are not equal switch eq(length, mload(_postBytes)) case 1 { // cb is a circuit breaker in the for loop since there's //  no said feature for inline assembly loops // cb = 1 - don't breaker // cb = 0 - break let cb := 1 let mc := add(_preBytes, 0x20) let end := add(mc, length) for { let cc := add(_postBytes, 0x20) // the next line is the loop condition: // while(uint(mc < end) + cb == 2) } eq(add(lt(mc, end), cb), 2) { mc := add(mc, 0x20) cc := add(cc, 0x20) } { // if any of these checks fails then arrays are not equal if iszero(eq(mload(mc), mload(cc))) { // unsuccess: success := 0 cb := 0 } } } default { // unsuccess: success := 0 } } return success; } function equalStorage(bytes storage _preBytes, bytes memory _postBytes) internal view returns (bool) { bool success = true; assembly { // we know _preBytes_offset is 0 let fslot := sload(_preBytes_slot) // Decode the length of the stored array like in concatStorage(). let slength := div(and(fslot, sub(mul(0x100, iszero(and(fslot, 1))), 1)), 2) let mlength := mload(_postBytes) // if lengths don't match the arrays are not equal switch eq(slength, mlength) case 1 { // slength can contain both the length and contents of the array // if length < 32 bytes so let's prepare for that // v. http://solidity.readthedocs.io/en/latest/miscellaneous.html#layout-of-state-variables-in-storage if iszero(iszero(slength)) { switch lt(slength, 32) case 1 { // blank the last byte which is the length fslot := mul(div(fslot, 0x100), 0x100) if iszero(eq(fslot, mload(add(_postBytes, 0x20)))) { // unsuccess: success := 0 } } default { // cb is a circuit breaker in the for loop since there's //  no said feature for inline assembly loops // cb = 1 - don't breaker // cb = 0 - break let cb := 1 // get the keccak hash to get the contents of the array mstore(0x0, _preBytes_slot) let sc := keccak256(0x0, 0x20) let mc := add(_postBytes, 0x20) let end := add(mc, mlength) // the next line is the loop condition: // while(uint(mc < end) + cb == 2) for {} eq(add(lt(mc, end), cb), 2) { sc := add(sc, 1) mc := add(mc, 0x20) } { if iszero(eq(sload(sc), mload(mc))) { // unsuccess: success := 0 cb := 0 } } } } } default { // unsuccess: success := 0 } } return success; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract DateTime { /* *  Date and Time utilities for ethereum contracts * */ struct _DateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; } uint constant DAY_IN_SECONDS = 86400; uint constant YEAR_IN_SECONDS = 31536000; uint constant LEAP_YEAR_IN_SECONDS = 31622400; uint constant HOUR_IN_SECONDS = 3600; uint constant MINUTE_IN_SECONDS = 60; uint16 constant ORIGIN_YEAR = 1970; function isLeapYear(uint16 year) public pure returns (bool) { if (year % 4 != 0) { return false; } if (year % 100 != 0) { return true; } if (year % 400 != 0) { return false; } return true; } function leapYearsBefore(uint year) public pure returns (uint) { year -= 1; return year / 4 - year / 100 + year / 400; } function getDaysInMonth(uint8 month, uint16 year) public pure returns (uint8) { if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) { return 31; } else if (month == 4 || month == 6 || month == 9 || month == 11) { return 30; } else if (isLeapYear(year)) { return 29; } else { return 28; } } function parseTimestamp(uint timestamp) internal pure returns (_DateTime dt) { uint secondsAccountedFor = 0; uint buf; uint8 i; // Year dt.year = getYear(timestamp); buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR); secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf; secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf); // Month uint secondsInMonth; for (i = 1; i <= 12; i++) { secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year); if (secondsInMonth + secondsAccountedFor > timestamp) { dt.month = i; break; } secondsAccountedFor += secondsInMonth; } // Day for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) { if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) { dt.day = i; break; } secondsAccountedFor += DAY_IN_SECONDS; } // Hour dt.hour = getHour(timestamp); // Minute dt.minute = getMinute(timestamp); // Second dt.second = getSecond(timestamp); // Day of week. dt.weekday = getWeekday(timestamp); } function getYear(uint timestamp) public pure returns (uint16) { uint secondsAccountedFor = 0; uint16 year; uint numLeapYears; // Year year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS); numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR); secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears; secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears); while (secondsAccountedFor > timestamp) { if (isLeapYear(uint16(year - 1))) { secondsAccountedFor -= LEAP_YEAR_IN_SECONDS; } else { secondsAccountedFor -= YEAR_IN_SECONDS; } year -= 1; } return year; } function getMonth(uint timestamp) public pure returns (uint8) { return parseTimestamp(timestamp).month; } function getDay(uint timestamp) public pure returns (uint8) { return parseTimestamp(timestamp).day; } function getHour(uint timestamp) public pure returns (uint8) { return uint8((timestamp / 60 / 60) % 24); } function getMinute(uint timestamp) public pure returns (uint8) { return uint8((timestamp / 60) % 60); } function getSecond(uint timestamp) public pure returns (uint8) { return uint8(timestamp % 60); } function getWeekday(uint timestamp) public pure returns (uint8) { return uint8((timestamp / DAY_IN_SECONDS + 4) % 7); } function toTimestamp(uint16 year, uint8 month, uint8 day) public pure returns (uint timestamp) { return toTimestamp(year, month, day, 0, 0, 0); } function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour) public pure returns (uint timestamp) { return toTimestamp(year, month, day, hour, 0, 0); } function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute) public pure returns (uint timestamp) { return toTimestamp(year, month, day, hour, minute, 0); } function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) public pure returns (uint timestamp) { uint16 i; // Year for (i = ORIGIN_YEAR; i < year; i++) { if (isLeapYear(i)) { timestamp += LEAP_YEAR_IN_SECONDS; } else { timestamp += YEAR_IN_SECONDS; } } // Month uint8[12] memory monthDayCounts; monthDayCounts[0] = 31; if (isLeapYear(year)) { monthDayCounts[1] = 29; } else { monthDayCounts[1] = 28; } monthDayCounts[2] = 31; monthDayCounts[3] = 30; monthDayCounts[4] = 31; monthDayCounts[5] = 30; monthDayCounts[6] = 31; monthDayCounts[7] = 31; monthDayCounts[8] = 30; monthDayCounts[9] = 31; monthDayCounts[10] = 30; monthDayCounts[11] = 31; for (i = 1; i < month; i++) { timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1]; } // Day timestamp += DAY_IN_SECONDS * (day - 1); // Hour timestamp += HOUR_IN_SECONDS * (hour); // Minute timestamp += MINUTE_IN_SECONDS * (minute); // Second timestamp += second; return timestamp; } } contract DetherBank is ERC223ReceivingContract, Ownable, SafeMath, DateTime { using BytesLib for bytes; /* * Event */ event receiveDth(address _from, uint amount); event receiveEth(address _from, uint amount); event sendDth(address _from, uint amount); event sendEth(address _from, uint amount); mapping(address => uint) public dthShopBalance; mapping(address => uint) public dthTellerBalance; mapping(address => uint) public ethShopBalance; mapping(address => uint) public ethTellerBalance; // store a mapping with per day/month/year a uint256 containing the wei sold amount on that date // //      user               day               month             year      weiSold mapping(address => mapping(uint16 => mapping(uint16 => mapping(uint16 => uint256)))) ethSellsUserToday; ERC223Basic public dth; bool public isInit = false; /** * INIT */ function setDth (address _dth) external onlyOwner { require(!isInit); dth = ERC223Basic(_dth); isInit = true; } /** * Core fonction */ // withdraw DTH when teller delete function withdrawDthTeller(address _receiver) external onlyOwner { require(dthTellerBalance[_receiver] > 0); uint tosend = dthTellerBalance[_receiver]; dthTellerBalance[_receiver] = 0; require(dth.transfer(_receiver, tosend)); } // withdraw DTH when shop delete function withdrawDthShop(address _receiver) external onlyOwner  { require(dthShopBalance[_receiver] > 0); uint tosend = dthShopBalance[_receiver]; dthShopBalance[_receiver] = 0; require(dth.transfer(_receiver, tosend)); } // withdraw DTH when a shop add by admin is delete function withdrawDthShopAdmin(address _from, address _receiver) external onlyOwner  { require(dthShopBalance[_from]  > 0); uint tosend = dthShopBalance[_from]; dthShopBalance[_from] = 0; require(dth.transfer(_receiver, tosend)); } // add DTH when shop register function addTokenShop(address _from, uint _value) external onlyOwner { dthShopBalance[_from] = SafeMath.add(dthShopBalance[_from], _value); } // add DTH when token register function addTokenTeller(address _from, uint _value) external onlyOwner{ dthTellerBalance[_from] = SafeMath.add(dthTellerBalance[_from], _value); } // add ETH for escrow teller function addEthTeller(address _from, uint _value) external payable onlyOwner returns (bool) { ethTellerBalance[_from] = SafeMath.add(ethTellerBalance[_from] ,_value); return true; } // helper function to extra date info from block.timestamp function getDateInfo(uint timestamp) internal view returns(_DateTime) { // use DateTime.sol to extract date info from the timestamp _DateTime memory date = parseTimestamp(timestamp); return date; } // withdraw ETH for teller escrow + save amount sold today for the _from user function withdrawEth(address _from, address _to, uint _amount) external onlyOwner { require(ethTellerBalance[_from] >= _amount); ethTellerBalance[_from] = SafeMath.sub(ethTellerBalance[_from], _amount); uint256 weiSoldToday = getWeiSoldToday(_from); _DateTime memory date = getDateInfo(block.timestamp); // add the sold amount, should not exceed daily limit (checked in DetherCore) ethSellsUserToday[_from][date.day][date.month][date.year] = SafeMath.add(weiSoldToday, _amount); _to.transfer(_amount); } // refund all ETH from teller contract function refundEth(address _from) external onlyOwner { uint toSend = ethTellerBalance[_from]; if (toSend > 0) { ethTellerBalance[_from] = 0; _from.transfer(toSend); } } /** * GETTER */ function getDthTeller(address _user) public view returns (uint) { return dthTellerBalance[_user]; } function getDthShop(address _user) public view returns (uint) { return dthShopBalance[_user]; } function getEthBalTeller(address _user) public view returns (uint) { return ethTellerBalance[_user]; } // get amount wei sold today for this user function getWeiSoldToday(address _user) public view returns (uint256 weiSoldToday) { // use DateTime.sol to extract date info from the timestamp _DateTime memory date = getDateInfo(block.timestamp); weiSoldToday = ethSellsUserToday[_user][date.day][date.month][date.year]; } /// @dev Standard ERC223 function that will handle incoming token transfers. // DO NOTHING but allow to receive token when addToken* function are called // by the dethercore contract function tokenFallback(address _from, uint _value, bytes _data) { require(msg.sender == address(dth)); } } "}
{"sol name": "7330.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract KcashVesting is Ownable { using SafeMath for uint256; address public teamWallet; address public earlyWallet; address public institutionWallet; uint256 public teamTimeLock = 1000 days; uint256 public earlyTimeLock = 5 * 30 days; uint256 public institutionTimeLock = 50 * 30 days; //amount of allocation uint256 public teamAllocation = 15 * (10 ** 7) * (10 ** 18); uint256 public earlyAllocation = 5 * (10 ** 7) * (10 ** 18); uint256 public institutionAllocation = 15 * (10 ** 7) * (10 ** 18); uint256 public totalAllocation = 35 * (10 ** 7) * (10 ** 18); uint256 public teamStageSetting = 34; uint256 public earlyStageSetting = 5; uint256 public institutionStageSetting = 50; ERC20Basic public token; //token start time uint256 public start; //lock start time uint256 public lockStartTime; /** Reserve allocations */ mapping(address => uint256) public allocations; mapping(address => uint256) public stageSettings; mapping(address => uint256) public timeLockDurations; /** How many tokens each reserve wallet has claimed */ mapping(address => uint256) public releasedAmounts; modifier onlyReserveWallets { require(allocations[msg.sender] > 0); _; } function KcashVesting(ERC20Basic _token, address _teamWallet, address _earlyWallet, address _institutionWallet, uint256 _start, uint256 _lockTime)public{ require(_start > 0); require(_lockTime > 0); require(_start.add(_lockTime) > 0); require(_teamWallet != address(0)); require(_earlyWallet != address(0)); require(_institutionWallet != address(0)); token = _token; teamWallet = _teamWallet; earlyWallet = _earlyWallet; institutionWallet = _institutionWallet; start = _start; lockStartTime = start.add(_lockTime); } function allocateToken() onlyOwner public{ require(block.timestamp > lockStartTime); //only claim  once require(allocations[teamWallet] == 0); require(token.balanceOf(address(this)) >= totalAllocation); allocations[teamWallet] = teamAllocation; allocations[earlyWallet] = earlyAllocation; allocations[institutionWallet] = institutionAllocation; stageSettings[teamWallet] = teamStageSetting; stageSettings[earlyWallet] = earlyStageSetting; stageSettings[institutionWallet] = institutionStageSetting; timeLockDurations[teamWallet] = teamTimeLock; timeLockDurations[earlyWallet] = earlyTimeLock; timeLockDurations[institutionWallet] = institutionTimeLock; } function releaseToken() onlyReserveWallets public{ uint256 totalUnlocked = unlockAmount(); require(totalUnlocked <= allocations[msg.sender]); require(releasedAmounts[msg.sender] < totalUnlocked); uint256 payment = totalUnlocked.sub(releasedAmounts[msg.sender]); releasedAmounts[msg.sender] = totalUnlocked; require(token.transfer(msg.sender, payment)); } function unlockAmount() public view onlyReserveWallets returns(uint256){ uint256 stage = vestStage(); uint256 totalUnlocked = stage.mul(allocations[msg.sender]).div(stageSettings[msg.sender]); return totalUnlocked; } function vestStage() public view onlyReserveWallets returns(uint256){ uint256 vestingMonths = timeLockDurations[msg.sender].div(stageSettings[msg.sender]); uint256 stage = (block.timestamp.sub(lockStartTime)).div(vestingMonths); if(stage > stageSettings[msg.sender]){ stage = stageSettings[msg.sender]; } return stage; } } "}
{"sol name": "838.sol", "label": 0, "sol content": "/* https://mycryptochamp.io/ [email\u00a0protected] */ pragma solidity 0.4.24; contract Controller{ function getChampReward(uint _position) public view returns(uint); function changeChampsName(uint _champId, string _name, address _msgsender) external; function withdrawChamp(uint _id, address _msgsender) external; function attack(uint _champId, uint _targetId, address _msgsender) external; function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) external; function cancelTokenSale(uint _id, address _msgsender, bool _isTokenChamp) public; function giveToken(address _to, uint _id, address _msgsender, bool _isTokenChamp) external; function setTokenForSale(uint _id, uint _price, address _msgsender, bool _isTokenChamp) external; function getTokenURIs(uint _id, bool _isTokenChamp) public pure returns(string); function takeOffItem(uint _champId, uint8 _type, address _msgsender) public; function putOn(uint _champId, uint _itemId, address _msgsender) external; function forgeItems(uint _parentItemID, uint _childItemID, address _msgsender) external; } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } } /// @title MyCryptoChamp Core - Stores all of game data. Functions are stored in the replaceable contracts. This solution was required in order to avoid unexpected bugs and make game upgradeable. /// @author Patrik Mojzis contract MyCryptoChampCore { using SafeMath for uint; struct Champ { uint id; //same as position in Champ[] uint attackPower; uint defencePower; uint cooldownTime; //how long does it take to be able attack again uint readyTime; //if is smaller than block.timestamp champ is ready to fight uint winCount; uint lossCount; uint position; //subtract 1 and you get position in leaderboard[] uint price; //sale price uint withdrawCooldown; //if you one of the 800 best champs and withdrawCooldown is less as block.timestamp then you get ETH reward uint eq_sword; uint eq_shield; uint eq_helmet; bool forSale; //is champ for sale? } struct AddressInfo { uint withdrawal; uint champsCount; uint itemsCount; string name; } //Item struct struct Item { uint id; uint8 itemType; // 1 - Sword | 2 - Shield | 3 - Helmet uint8 itemRarity; // 1 - Common | 2 - Uncommon | 3 - Rare | 4 - Epic | 5 - Legendery | 6 - Forged uint attackPower; uint defencePower; uint cooldownReduction; uint price; uint onChampId; //can not be used to decide if item is on champ, because champ's id can be 0, 'bool onChamp' solves it. bool onChamp; bool forSale; //is item for sale? } Champ[] public champs; Item[] public items; mapping (uint => uint) public leaderboard; mapping (address => bool) private trusted; mapping (address => AddressInfo) public addressInfo; mapping (bool => mapping(address => mapping (address => bool))) public tokenOperatorApprovals; mapping (bool => mapping(uint => address)) public tokenApprovals; mapping (bool => mapping(uint => address)) public tokenToOwner; mapping (uint => string) public champToName; mapping (bool => uint) public tokensForSaleCount; uint public pendingWithdrawal = 0; address private contractOwner; Controller internal controller; constructor () public { trusted[msg.sender] = true; contractOwner = msg.sender; } /*============== MODIFIERS ==============*/ modifier onlyTrusted(){ require(trusted[msg.sender]); _; } modifier isPaid(uint _price) { require(msg.value >= _price); _; } modifier onlyNotOwnerOfItem(uint _itemId) { require(_itemId != 0); require(msg.sender != tokenToOwner[false][_itemId]); _; } modifier isItemForSale(uint _id){ require(items[_id].forSale); _; } modifier onlyNotOwnerOfChamp(uint _champId) { require(msg.sender != tokenToOwner[true][_champId]); _; } modifier isChampForSale(uint _id) { require(champs[_id].forSale); _; } /*============== CONTROL COTRACT ==============*/ function loadController(address _address) external onlyTrusted { controller = Controller(_address); } function setTrusted(address _address, bool _trusted) external onlyTrusted { trusted[_address] = _trusted; } function transferOwnership(address newOwner) public onlyTrusted { require(newOwner != address(0)); contractOwner = newOwner; } /*============== PRIVATE FUNCTIONS ==============*/ function _addWithdrawal(address _address, uint _amount) private { addressInfo[_address].withdrawal += _amount; pendingWithdrawal += _amount; } /// @notice Distribute input funds between contract owner and players function _distributeNewSaleInput(address _affiliateAddress) private { //contract owner _addWithdrawal(contractOwner, ((msg.value / 100) * 60)); // 60% //affiliate //checks if _affiliateAddress is set & if affiliate address is not buying player if(_affiliateAddress != address(0) && _affiliateAddress != msg.sender){ _addWithdrawal(_affiliateAddress, ((msg.value / 100) * 25)); //provision is 25% } } /*============== ONLY TRUSTED ==============*/ function addWithdrawal(address _address, uint _amount) public onlyTrusted { _addWithdrawal(_address, _amount); } function clearTokenApproval(address _from, uint _tokenId, bool _isTokenChamp) public onlyTrusted { require(tokenToOwner[_isTokenChamp][_tokenId] == _from); if (tokenApprovals[_isTokenChamp][_tokenId] != address(0)) { tokenApprovals[_isTokenChamp][_tokenId] = address(0); } } function emergencyWithdraw() external onlyTrusted { contractOwner.transfer(address(this).balance); } function setChampsName(uint _champId, string _name) public onlyTrusted { champToName[_champId] = _name; } function setLeaderboard(uint _x, uint _value) public onlyTrusted { leaderboard[_x] = _value; } function setTokenApproval(uint _id, address _to, bool _isTokenChamp) public onlyTrusted { tokenApprovals[_isTokenChamp][_id] = _to; } function setTokenOperatorApprovals(address _from, address _to, bool _approved, bool _isTokenChamp) public onlyTrusted { tokenOperatorApprovals[_isTokenChamp][_from][_to] = _approved; } function setTokenToOwner(uint _id, address _owner, bool _isTokenChamp) public onlyTrusted { tokenToOwner[_isTokenChamp][_id] = _owner; } function setTokensForSaleCount(uint _value, bool _isTokenChamp) public onlyTrusted { tokensForSaleCount[_isTokenChamp] = _value; } function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) public onlyTrusted { controller.transferToken(_from, _to, _id, _isTokenChamp); } function updateAddressInfo(address _address, uint _withdrawal, bool _updatePendingWithdrawal, uint _champsCount, bool _updateChampsCount, uint _itemsCount, bool _updateItemsCount, string _name, bool _updateName) public onlyTrusted { AddressInfo storage ai = addressInfo[_address]; if(_updatePendingWithdrawal){ ai.withdrawal = _withdrawal; } if(_updateChampsCount){ ai.champsCount = _champsCount; } if(_updateItemsCount){ ai.itemsCount = _itemsCount; } if(_updateName){ ai.name = _name; } } function newChamp( uint _attackPower, uint _defencePower, uint _cooldownTime, uint _winCount, uint _lossCount, uint _position, uint _price, uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale, address _owner ) public onlyTrusted returns (uint){ Champ memory champ = Champ({ id: 0, attackPower: 0, //CompilerError: Stack too deep, try removing local variables. defencePower: _defencePower, cooldownTime: _cooldownTime, readyTime: 0, winCount: _winCount, lossCount: _lossCount, position: _position, price: _price, withdrawCooldown: 0, eq_sword: _eq_sword, eq_shield: _eq_shield, eq_helmet: _eq_helmet, forSale: _forSale }); champ.attackPower = _attackPower; uint id = champs.push(champ) - 1; champs[id].id = id; leaderboard[_position] = id; addressInfo[_owner].champsCount++; tokenToOwner[true][id] = _owner; if(_forSale){ tokensForSaleCount[true]++; } return id; } function newItem( uint8 _itemType, uint8 _itemRarity, uint _attackPower, uint _defencePower, uint _cooldownReduction, uint _price, uint _onChampId, bool _onChamp, bool _forSale, address _owner ) public onlyTrusted returns (uint) { //create that struct Item memory item = Item({ id: 0, itemType: _itemType, itemRarity: _itemRarity, attackPower: _attackPower, defencePower: _defencePower, cooldownReduction: _cooldownReduction, price: _price, onChampId: _onChampId, onChamp: _onChamp, forSale: _forSale }); uint id = items.push(item) - 1; items[id].id = id; addressInfo[_owner].itemsCount++; tokenToOwner[false][id] = _owner; if(_forSale){ tokensForSaleCount[false]++; } return id; } function updateChamp( uint _champId, uint _attackPower, uint _defencePower, uint _cooldownTime, uint _readyTime, uint _winCount, uint _lossCount, uint _position, uint _price, uint _withdrawCooldown, uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale ) public onlyTrusted { Champ storage champ = champs[_champId]; if(champ.attackPower != _attackPower){champ.attackPower = _attackPower;} if(champ.defencePower != _defencePower){champ.defencePower = _defencePower;} if(champ.cooldownTime != _cooldownTime){champ.cooldownTime = _cooldownTime;} if(champ.readyTime != _readyTime){champ.readyTime = _readyTime;} if(champ.winCount != _winCount){champ.winCount = _winCount;} if(champ.lossCount != _lossCount){champ.lossCount = _lossCount;} if(champ.position != _position){ champ.position = _position; leaderboard[_position] = _champId; } if(champ.price != _price){champ.price = _price;} if(champ.withdrawCooldown != _withdrawCooldown){champ.withdrawCooldown = _withdrawCooldown;} if(champ.eq_sword != _eq_sword){champ.eq_sword = _eq_sword;} if(champ.eq_shield != _eq_shield){champ.eq_shield = _eq_shield;} if(champ.eq_helmet != _eq_helmet){champ.eq_helmet = _eq_helmet;} if(champ.forSale != _forSale){ champ.forSale = _forSale; if(_forSale){ tokensForSaleCount[true]++; }else{ tokensForSaleCount[true]--; } } } function updateItem( uint _id, uint8 _itemType, uint8 _itemRarity, uint _attackPower, uint _defencePower, uint _cooldownReduction, uint _price, uint _onChampId, bool _onChamp, bool _forSale ) public onlyTrusted { Item storage item = items[_id]; if(item.itemType != _itemType){item.itemType = _itemType;} if(item.itemRarity != _itemRarity){item.itemRarity = _itemRarity;} if(item.attackPower != _attackPower){item.attackPower = _attackPower;} if(item.defencePower != _defencePower){item.defencePower = _defencePower;} if(item.cooldownReduction != _cooldownReduction){item.cooldownReduction = _cooldownReduction;} if(item.price != _price){item.price = _price;} if(item.onChampId != _onChampId){item.onChampId = _onChampId;} if(item.onChamp != _onChamp){item.onChamp = _onChamp;} if(item.forSale != _forSale){ item.forSale = _forSale; if(_forSale){ tokensForSaleCount[false]++; }else{ tokensForSaleCount[false]--; } } } /*============== CALLABLE BY PLAYER ==============*/ function buyItem(uint _id, address _affiliateAddress) external payable onlyNotOwnerOfItem(_id) isItemForSale(_id) isPaid(items[_id].price) { if(tokenToOwner[false][_id] == address(this)){ _distributeNewSaleInput(_affiliateAddress); }else{ _addWithdrawal(tokenToOwner[false][_id], msg.value); } controller.transferToken(tokenToOwner[false][_id], msg.sender, _id, false); } function buyChamp(uint _id, address _affiliateAddress) external payable onlyNotOwnerOfChamp(_id) isChampForSale(_id) isPaid(champs[_id].price) { if(tokenToOwner[true][_id] == address(this)){ _distributeNewSaleInput(_affiliateAddress); }else{ _addWithdrawal(tokenToOwner[true][_id], msg.value); } controller.transferToken(tokenToOwner[true][_id], msg.sender, _id, true); } function changePlayersName(string _name) external { addressInfo[msg.sender].name = _name; } function withdrawToAddress(address _address) external { address playerAddress = _address; if(playerAddress == address(0)){ playerAddress = msg.sender; } uint share = addressInfo[playerAddress].withdrawal; //gets pending funds require(share > 0); //is it more than 0? addressInfo[playerAddress].withdrawal = 0; //set player's withdrawal pendings to 0 pendingWithdrawal = pendingWithdrawal.sub(share); //subtract share from total pendings playerAddress.transfer(share); //transfer } /*============== VIEW FUNCTIONS ==============*/ function getChampsByOwner(address _owner) external view returns(uint256[]) { uint256[] memory result = new uint256[](addressInfo[_owner].champsCount); uint256 counter = 0; for (uint256 i = 0; i < champs.length; i++) { if (tokenToOwner[true][i] == _owner) { result[counter] = i; counter++; } } return result; } function getTokensForSale(bool _isTokenChamp) view external returns(uint256[]){ uint256[] memory result = new uint256[](tokensForSaleCount[_isTokenChamp]); if(tokensForSaleCount[_isTokenChamp] > 0){ uint256 counter = 0; if(_isTokenChamp){ for (uint256 i = 0; i < champs.length; i++) { if (champs[i].forSale == true) { result[counter]=i; counter++; } } }else{ for (uint256 n = 0; n < items.length; n++) { if (items[n].forSale == true) { result[counter]=n; counter++; } } } } return result; } function getChampStats(uint256 _champId) public view returns(uint256,uint256,uint256){ Champ storage champ = champs[_champId]; Item storage sword = items[champ.eq_sword]; Item storage shield = items[champ.eq_shield]; Item storage helmet = items[champ.eq_helmet]; uint totalAttackPower = champ.attackPower + sword.attackPower + shield.attackPower + helmet.attackPower; //Gets champs AP uint totalDefencePower = champ.defencePower + sword.defencePower + shield.defencePower + helmet.defencePower; //Gets champs  DP uint totalCooldownReduction = sword.cooldownReduction + shield.cooldownReduction + helmet.cooldownReduction; //Gets  CR return (totalAttackPower, totalDefencePower, totalCooldownReduction); } function getItemsByOwner(address _owner) external view returns(uint256[]) { uint256[] memory result = new uint256[](addressInfo[_owner].itemsCount); uint256 counter = 0; for (uint256 i = 0; i < items.length; i++) { if (tokenToOwner[false][i] == _owner) { result[counter] = i; counter++; } } return result; } function getTokenCount(bool _isTokenChamp) external view returns(uint) { if(_isTokenChamp){ return champs.length - addressInfo[address(0)].champsCount; }else{ return items.length - 1 - addressInfo[address(0)].itemsCount; } } function getTokenURIs(uint _tokenId, bool _isTokenChamp) public view returns(string) { return controller.getTokenURIs(_tokenId,_isTokenChamp); } function onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp) external view returns(bool) { if(!_isTokenChamp){ require(_id != 0); } address owner = tokenToOwner[_isTokenChamp][_id]; return(_msgsender == owner || _msgsender == tokenApprovals[_isTokenChamp][_id] || tokenOperatorApprovals[_isTokenChamp][owner][_msgsender]); } /*============== DELEGATE ==============*/ function attack(uint _champId, uint _targetId) external{ controller.attack(_champId, _targetId, msg.sender); } function cancelTokenSale(uint _id, bool _isTokenChamp) public{ controller.cancelTokenSale(_id, msg.sender, _isTokenChamp); } function changeChampsName(uint _champId, string _name) external{ controller.changeChampsName(_champId, _name, msg.sender); } function forgeItems(uint _parentItemID, uint _childItemID) external{ controller.forgeItems(_parentItemID, _childItemID, msg.sender); } function giveToken(address _to, uint _champId, bool _isTokenChamp) external{ controller.giveToken(_to, _champId, msg.sender, _isTokenChamp); } function setTokenForSale(uint _id, uint _price, bool _isTokenChamp) external{ controller.setTokenForSale(_id, _price, msg.sender, _isTokenChamp); } function putOn(uint _champId, uint _itemId) external{ controller.putOn(_champId, _itemId, msg.sender); } function takeOffItem(uint _champId, uint8 _type) public{ controller.takeOffItem(_champId, _type, msg.sender); } function withdrawChamp(uint _id) external{ controller.withdrawChamp(_id, msg.sender); } function getChampReward(uint _position) public view returns(uint){ return controller.getChampReward(_position); } } "}
{"sol name": "8351.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract Outer { Inner1 public myInner1 = new Inner1(); function callSomeFunctionViaOuter() public { myInner1.callSomeFunctionViaInner1(); } } contract Inner1 { Inner2 public myInner2 = new Inner2(); function callSomeFunctionViaInner1() public { myInner2.doSomething(); } } contract Inner2 { uint256 someValue; event SetValue(uint256 val); function doSomething() public { someValue = block.timestamp; emit SetValue(someValue); } } "}
{"sol name": "8598.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "9967.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title TokenlessCrowdsale * @dev Crowdsale based on OpenZeppelin's Crowdsale but without token-related logic * @author U-Zyn Chua <[email\u00a0protected]> * * Largely similar to OpenZeppelin except the following irrelevant token-related hooks removed: * - function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal * - function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal * - function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) * - event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount) * * Added hooks: * - function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal * - event SaleContribution(address indexed purchaser, address indexed beneficiary, uint256 value) */ contract TokenlessCrowdsale { using SafeMath for uint256; // Address where funds are collected address public wallet; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * similar to TokenPurchase without the token amount * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase */ event SaleContribution(address indexed purchaser, address indexed beneficiary, uint256 value); /** * @param _wallet Address where collected funds will be forwarded to */ constructor (address _wallet) public { require(_wallet != address(0)); wallet = _wallet; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchaseInWei(_beneficiary, weiAmount); emit SaleContribution( msg.sender, _beneficiary, weiAmount ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _weiAmount Number of wei contributed */ function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal { // override with logic on tokens delivery } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title WhitelistedAICrowdsale * @dev Crowdsale in which only whitelisted users can contribute, * with a defined individual cap in wei, * and a bool flag on whether a user is an accredited investor (AI) * Based on OpenZeppelin's WhitelistedCrowdsale and IndividuallyCappedCrowdsale * @author U-Zyn Chua <[email\u00a0protected]> */ contract WhitelistedAICrowdsale is TokenlessCrowdsale, Ownable { using SafeMath for uint256; mapping(address => bool) public accredited; // Individual cap mapping(address => uint256) public contributions; mapping(address => uint256) public caps; /** * @dev Returns if a beneficiary is whitelisted * @return bool */ function isWhitelisted(address _beneficiary) public view returns (bool) { if (caps[_beneficiary] != 0) { return true; } return false; } /** * @dev Adds single address to whitelist. * Use this also to update * @param _beneficiary Address to be added to the whitelist */ function addToWhitelist(address _beneficiary, uint256 _cap, bool _accredited) external onlyOwner { caps[_beneficiary] = _cap; accredited[_beneficiary] = _accredited; } /** * @dev Removes single address from whitelist. * @param _beneficiary Address to be removed to the whitelist */ function removeFromWhitelist(address _beneficiary) external onlyOwner { caps[_beneficiary] = 0; accredited[_beneficiary] = false; } /** * @dev Extend parent behavior requiring beneficiary to be in whitelist. * @param _beneficiary Token beneficiary * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(contributions[_beneficiary].add(_weiAmount) <= caps[_beneficiary]); } /** * @dev Extend parent behavior to update user contributions * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { super._updatePurchasingState(_beneficiary, _weiAmount); contributions[_beneficiary] = contributions[_beneficiary].add(_weiAmount); } } /** * @title FiatCappedCrowdsale * @dev Crowdsale with a limit for total contributions defined in fiat (USD). * Based on OpenZeppelin's CappedCrowdsale * Handles fiat rates, but does not handle token awarding. * @author U-Zyn Chua <[email\u00a0protected]> */ contract FiatCappedCrowdsale is TokenlessCrowdsale, Ownable { using SafeMath for uint256; // 1 USD = 1000 mill (1 mill is USD 0.001) // 1 ETH = 1e18 wei // 1 SPX = 1e18 leconte uint256 public millCap; // cap defined in USD mill uint256 public millRaised; // amount of USD mill raised // Minimum fiat value purchase per transaction uint256 public minMillPurchase; // How many ETH wei per USD 0.001 uint256 public millWeiRate; // How many SPX leconte per USD 0.001, without bonus uint256 public millLeconteRate; // Sanity checks // 1 ETH is between USD 100 and USD 5,000 uint256 constant minMillWeiRate = (10 ** 18) / (5000 * (10 ** 3)); // USD 5,000 uint256 constant maxMillWeiRate = (10 ** 18) / (100 * (10 ** 3)); // USD 100 // 1 SPX is between USD 0.01 and USD 1 uint256 constant minMillLeconteRate = (10 ** 18) / 1000; // USD 1 uint256 constant maxMillLeconteRate = (10 ** 18) / 10; // USD 0.01 /** * @dev Throws if mill rate for ETH wei is not sane */ modifier isSaneETHRate(uint256 _millWeiRate) { require(_millWeiRate >= minMillWeiRate); require(_millWeiRate <= maxMillWeiRate); _; } /** * @dev Throws if mill rate for SPX wei is not sane */ modifier isSaneSPXRate(uint256 _millLeconteRate) { require(_millLeconteRate >= minMillLeconteRate); require(_millLeconteRate <= maxMillLeconteRate); _; } /** * @dev Constructor * @param _millCap Max amount of mill to be contributed * @param _millLeconteRate How many SPX leconte per mill * @param _millWeiRate How many ETH wei per mill, this is updateable with setWeiRate() */ constructor ( uint256 _millCap, uint256 _minMillPurchase, uint256 _millLeconteRate, uint256 _millWeiRate ) public isSaneSPXRate(_millLeconteRate) isSaneETHRate(_millWeiRate) { require(_millCap > 0); require(_minMillPurchase > 0); millCap = _millCap; minMillPurchase = _minMillPurchase; millLeconteRate = _millLeconteRate; millWeiRate = _millWeiRate; } /** * @dev Checks whether the cap has been reached. * @return Whether the cap was reached */ function capReached() public view returns (bool) { return millRaised >= millCap; } /** * @dev Sets the current ETH wei rate - How many ETH wei per mill */ function setWeiRate(uint256 _millWeiRate) external onlyOwner isSaneETHRate(_millWeiRate) { millWeiRate = _millWeiRate; } /** * @dev Extend parent behavior requiring purchase to respect the funding cap, * and that contribution should be >= minMillPurchase * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); // Check for minimum contribution uint256 _millAmount = _toMill(_weiAmount); require(_millAmount >= minMillPurchase); // Check for funding cap uint256 _millRaised = millRaised.add(_millAmount); require(_millRaised <= millCap); millRaised = _millRaised; } /** * @dev Returns the amount in USD mill given ETH wei * @param _weiAmount Amount in ETH wei * @return amount in mill */ function _toMill(uint256 _weiAmount) internal returns (uint256) { return _weiAmount.div(millWeiRate); } /** * @dev Returns the amount in SPX leconte given ETH wei * @param _weiAmount Amount in ETH wei * @return amount in leconte */ function _toLeconte(uint256 _weiAmount) internal returns (uint256) { return _toMill(_weiAmount).mul(millLeconteRate); } } /** * @title PausableCrowdsale * @dev Crowdsale allowing owner to halt sale process * Based on OpenZeppelin's TimedCrowdsale * @author U-Zyn Chua <[email\u00a0protected]> */ contract PausableCrowdsale is TokenlessCrowdsale, Ownable { /** * Owner controllable switch to open or halt sale * This is independent from other checks such as cap, no other processes except owner should alter this value. This also means that even if hardCap is reached, this variable does not set to false on its own. * This variable is revocable, hence behaving more like a pause than close when turned to off. */ bool public open = true; modifier saleIsOpen() { require(open); _; } function unpauseSale() external onlyOwner { require(!open); open = true; } function pauseSale() external onlyOwner saleIsOpen { open = false; } /** * @dev Extend parent behavior requiring sale to be opened */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal saleIsOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC223 Token Receiver Interface * based on https://github.com/Dexaran/ERC223-token-standard/blob/Recommended/Receiver_Interface.sol but much simplified */ contract BasicERC223Receiver { function tokenFallback(address _from, uint256 _value, bytes _data) public pure; } /** * @title RestrictedToken * @dev Standard Mintable ERC20 Token that can only be sent to an authorized address * Based on Consensys' TokenFoundry's ControllableToken * @author U-Zyn Chua <[email\u00a0protected]> */ contract RestrictedToken is BasicToken, Ownable { string public name; string public symbol; uint8 public decimals; // Authorized senders are able to transfer tokens freely, usu. Sale contract address public issuer; // Vesting period for exchanging of RestrictedToken to non-restricted token // This is for reference by exchange contract and no inherit use for this contract uint256 public vestingPeriod; // Holders of RestrictedToken are only able to transfer token to authorizedRecipients, usu. Exchange contract mapping(address => bool) public authorizedRecipients; // Whether recipients are ERC223-compliant mapping(address => bool) public erc223Recipients; // Last issued time of token per recipient mapping(address => uint256) public lastIssuedTime; event Issue(address indexed to, uint256 value); /** * @dev Throws if called by any account other than the issuer. */ modifier onlyIssuer() { require(msg.sender == issuer); _; } /** * @dev Modifier to check if a transfer is allowed */ modifier isAuthorizedRecipient(address _recipient) { require(authorizedRecipients[_recipient]); _; } constructor ( uint256 _supply, string _name, string _symbol, uint8 _decimals, uint256 _vestingPeriod, address _owner, // usu. human address _issuer // usu. sale contract ) public { require(_supply != 0); require(_owner != address(0)); require(_issuer != address(0)); name = _name; symbol = _symbol; decimals = _decimals; vestingPeriod = _vestingPeriod; owner = _owner; issuer = _issuer; totalSupply_ = _supply; balances[_issuer] = _supply; emit Transfer(address(0), _issuer, _supply); } /** * @dev Allows owner to authorize or deauthorize recipients */ function authorize(address _recipient, bool _isERC223) public onlyOwner { require(_recipient != address(0)); authorizedRecipients[_recipient] = true; erc223Recipients[_recipient] = _isERC223; } function deauthorize(address _recipient) public onlyOwner isAuthorizedRecipient(_recipient) { authorizedRecipients[_recipient] = false; erc223Recipients[_recipient] = false; } /** * @dev Only allow transfer to authorized recipients */ function transfer(address _to, uint256 _value) public isAuthorizedRecipient(_to) returns (bool) { if (erc223Recipients[_to]) { BasicERC223Receiver receiver = BasicERC223Receiver(_to); bytes memory empty; receiver.tokenFallback(msg.sender, _value, empty); } return super.transfer(_to, _value); } /** * Issue token * @dev also records the token issued time */ function issue(address _to, uint256 _value) public onlyIssuer returns (bool) { lastIssuedTime[_to] = block.timestamp; emit Issue(_to, _value); return super.transfer(_to, _value); } } /** * @title Sparrow Token private sale */ contract ExtendedPrivateSale is TokenlessCrowdsale, WhitelistedAICrowdsale, FiatCappedCrowdsale, PausableCrowdsale { using SafeMath for uint256; // The 2 tokens being sold RestrictedToken public tokenR0; // SPX-R0 - restricted token with no vesting RestrictedToken public tokenR6; // SPX-R6 - restricted token with 6-month vesting uint8 constant bonusPct = 30; constructor (address _wallet, uint256 _millWeiRate) TokenlessCrowdsale(_wallet) FiatCappedCrowdsale( 2000000 * (10 ** 3), // millCap: USD 2 million 10000 * (10 ** 3), // minMillPurchase: USD 10,000 (10 ** 18) / 50, // millLeconteRate: 1 SPX = USD 0.05 _millWeiRate ) public { tokenR0 = new RestrictedToken( 2 * 40000000 * (10 ** 18), // supply: 40 million (* 2 for edge safety) 'Sparrow Token (Restricted)', // name 'SPX-R0', // symbol 18, // decimals 0, // no vesting msg.sender, // owner this // issuer ); // SPX-R6: Only 12 mil needed if all contributors are AI, 52 mil needed if all contributors are non-AIs tokenR6 = new RestrictedToken( 2 * 52000000 * (10 ** 18), // supply: 52 million (* 2 for edge safety) 'Sparrow Token (Restricted with 6-month vesting)', // name 'SPX-R6', // symbol 18, // decimals 6 * 30 * 86400, // vesting: 6 months msg.sender, // owner this // issuer ); } // If accredited, non-bonus tokens are given as tokenR0, bonus tokens are given as tokenR6 // If non-accredited, non-bonus and bonus tokens are given as tokenR6 function _processPurchaseInWei(address _beneficiary, uint256 _weiAmount) internal { super._processPurchaseInWei(_beneficiary, _weiAmount); uint256 tokens = _toLeconte(_weiAmount); uint256 bonus = tokens.mul(bonusPct).div(100); // Accredited if (accredited[_beneficiary]) { tokenR0.issue(_beneficiary, tokens); tokenR6.issue(_beneficiary, bonus); } else { tokenR6.issue(_beneficiary, tokens.add(bonus)); } } } "}
{"sol name": "11415.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "10559.sol", "label": 1, "sol content": "pragma solidity ^0.4.21; // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: contracts/HoldToken.sol contract HoldToken is MintableToken { using SafeMath for uint256; string public name = 'HOLD'; string public symbol = 'HOLD'; uint8 public decimals = 18; event Burn(address indexed burner, uint256 value); event BurnTransferred(address indexed previousBurner, address indexed newBurner); address burnerRole; modifier onlyBurner() { require(msg.sender == burnerRole); _; } function HoldToken(address _burner) public { burnerRole = _burner; } function transferBurnRole(address newBurner) public onlyBurner { require(newBurner != address(0)); BurnTransferred(burnerRole, newBurner); burnerRole = newBurner; } function burn(uint256 _value) public onlyBurner { require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(msg.sender, _value); Transfer(msg.sender, address(0), _value); } } // File: contracts/Crowdsale.sol /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale. * Crowdsales have a start and end timestamps, where investors can make * token purchases and the crowdsale will assign them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. */ contract Crowdsale { using SafeMath for uint256; // The token being sold HoldToken public token; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; uint256 public rate; // address where funds are collected address public wallet; // amount of raised money in wei uint256 public weiRaised; /** * event for token purchase logging * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased * @param transactionId identifier which corresponds to transaction under which the tokens were purchased */ event TokenPurchase(address indexed beneficiary, uint256 indexed value, uint256 indexed amount, uint256 transactionId); function Crowdsale( uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _initialWeiRaised ) public { require(_startTime >= now); require(_endTime >= _startTime); require(_wallet != address(0)); require(_rate > 0); token = new HoldToken(_wallet); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; weiRaised = _initialWeiRaised; } // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { return now > endTime; } } // File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } // File: zeppelin-solidity/contracts/token/ERC20/TokenTimelock.sol /** * @title TokenTimelock * @dev TokenTimelock is a token holder contract that will allow a * beneficiary to extract the tokens after a given release time */ contract TokenTimelock { using SafeERC20 for ERC20Basic; // ERC20 basic token contract being held ERC20Basic public token; // beneficiary of tokens after they are released address public beneficiary; // timestamp when token release is enabled uint256 public releaseTime; function TokenTimelock(ERC20Basic _token, address _beneficiary, uint256 _releaseTime) public { // solium-disable-next-line security/no-block-members require(_releaseTime > block.timestamp); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; } /** * @notice Transfers tokens held by timelock to beneficiary. */ function release() public { // solium-disable-next-line security/no-block-members require(block.timestamp >= releaseTime); uint256 amount = token.balanceOf(this); require(amount > 0); token.safeTransfer(beneficiary, amount); } } // File: contracts/CappedCrowdsale.sol contract CappedCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; uint256 public hardCap; uint256 public tokensToLock; uint256 public releaseTime; bool public isFinalized = false; TokenTimelock public timeLock; event Finalized(); event FinishMinting(); event TokensMinted( address indexed beneficiary, uint256 indexed amount ); function CappedCrowdsale(uint256 _hardCap, uint256 _tokensToLock, uint256 _releaseTime) public { require(_hardCap > 0); require(_tokensToLock > 0); require(_releaseTime > endTime); hardCap = _hardCap; releaseTime = _releaseTime; tokensToLock = _tokensToLock; timeLock = new TokenTimelock(token, wallet, releaseTime); } /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); token.mint(address(timeLock), tokensToLock); Finalized(); isFinalized = true; } function finishMinting() onlyOwner public { require(token.mintingFinished() == false); require(isFinalized); token.finishMinting(); FinishMinting(); } function mint(address beneficiary, uint256 amount) onlyOwner public { require(!token.mintingFinished()); require(isFinalized); require(amount > 0); require(beneficiary != address(0)); token.mint(beneficiary, amount); TokensMinted(beneficiary, amount); } // overriding Crowdsale#hasEnded to add cap logic // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { bool capReached = weiRaised >= hardCap; return super.hasEnded() || capReached || isFinalized; } } // File: contracts/OnlyWhiteListedAddresses.sol contract OnlyWhiteListedAddresses is Ownable { using SafeMath for uint256; address utilityAccount; mapping (address => bool) whitelist; mapping (address => address) public referrals; modifier onlyOwnerOrUtility() { require(msg.sender == owner || msg.sender == utilityAccount); _; } event WhitelistedAddresses( address[] users ); event ReferralsAdded( address[] user, address[] referral ); function OnlyWhiteListedAddresses(address _utilityAccount) public { utilityAccount = _utilityAccount; } function whitelistAddress (address[] users) public onlyOwnerOrUtility { for (uint i = 0; i < users.length; i++) { whitelist[users[i]] = true; } WhitelistedAddresses(users); } function addAddressReferrals (address[] users, address[] _referrals) public onlyOwnerOrUtility { require(users.length == _referrals.length); for (uint i = 0; i < users.length; i++) { require(isWhiteListedAddress(users[i])); referrals[users[i]] = _referrals[i]; } ReferralsAdded(users, _referrals); } function isWhiteListedAddress (address addr) public view returns (bool) { return whitelist[addr]; } } // File: contracts/HoldCrowdsale.sol contract HoldCrowdsale is CappedCrowdsale, OnlyWhiteListedAddresses { using SafeMath for uint256; struct TokenPurchaseRecord { uint256 timestamp; uint256 weiAmount; address beneficiary; } uint256 transactionId = 1; mapping (uint256 => TokenPurchaseRecord) pendingTransactions; mapping (uint256 => bool) completedTransactions; uint256 public referralPercentage; uint256 public individualCap; /** * event for token purchase logging * @param transactionId transaction identifier * @param beneficiary who will get the tokens * @param timestamp when the token purchase request was made * @param weiAmount wei invested */ event TokenPurchaseRequest( uint256 indexed transactionId, address beneficiary, uint256 indexed timestamp, uint256 indexed weiAmount, uint256 tokensAmount ); event ReferralTokensSent( address indexed beneficiary, uint256 indexed tokensAmount, uint256 indexed transactionId ); event BonusTokensSent( address indexed beneficiary, uint256 indexed tokensAmount, uint256 indexed transactionId ); function HoldCrowdsale( uint256 _startTime, uint256 _endTime, uint256 _icoHardCapWei, uint256 _referralPercentage, uint256 _rate, address _wallet, uint256 _tokensToLock, uint256 _releaseTime, uint256 _privateWeiRaised, uint256 _individualCap, address _utilityAccount ) public OnlyWhiteListedAddresses(_utilityAccount) CappedCrowdsale(_icoHardCapWei, _tokensToLock, _releaseTime) Crowdsale(_startTime, _endTime, _rate, _wallet, _privateWeiRaised) { referralPercentage = _referralPercentage; individualCap = _individualCap; } // fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender); } // low level token purchase function function buyTokens(address beneficiary) public payable { require(!isFinalized); require(beneficiary == msg.sender); require(msg.value != 0); require(msg.value >= individualCap); uint256 weiAmount = msg.value; require(isWhiteListedAddress(beneficiary)); require(validPurchase(weiAmount)); // update state weiRaised = weiRaised.add(weiAmount); uint256 _transactionId = transactionId; uint256 tokensAmount = weiAmount.mul(rate); pendingTransactions[_transactionId] = TokenPurchaseRecord(now, weiAmount, beneficiary); transactionId += 1; TokenPurchaseRequest(_transactionId, beneficiary, now, weiAmount, tokensAmount); forwardFunds(); } function issueTokensMultiple(uint256[] _transactionIds, uint256[] bonusTokensAmounts) public onlyOwner { require(isFinalized); require(_transactionIds.length == bonusTokensAmounts.length); for (uint i = 0; i < _transactionIds.length; i++) { issueTokens(_transactionIds[i], bonusTokensAmounts[i]); } } function issueTokens(uint256 _transactionId, uint256 bonusTokensAmount) internal { require(completedTransactions[_transactionId] != true); require(pendingTransactions[_transactionId].timestamp != 0); TokenPurchaseRecord memory record = pendingTransactions[_transactionId]; uint256 tokens = record.weiAmount.mul(rate); address referralAddress = referrals[record.beneficiary]; token.mint(record.beneficiary, tokens); TokenPurchase(record.beneficiary, record.weiAmount, tokens, _transactionId); completedTransactions[_transactionId] = true; if (bonusTokensAmount != 0) { require(bonusTokensAmount != 0); token.mint(record.beneficiary, bonusTokensAmount); BonusTokensSent(record.beneficiary, bonusTokensAmount, _transactionId); } if (referralAddress != address(0)) { uint256 referralAmount = tokens.mul(referralPercentage).div(uint256(100)); token.mint(referralAddress, referralAmount); ReferralTokensSent(referralAddress, referralAmount, _transactionId); } } function validPurchase(uint256 weiAmount) internal view returns (bool) { bool withinCap = weiRaised.add(weiAmount) <= hardCap; bool withinCrowdsaleInterval = now >= startTime && now <= endTime; return withinCrowdsaleInterval && withinCap; } function forwardFunds() internal { wallet.transfer(msg.value); } } // File: contracts/Migrations.sol contract Migrations { address public owner; uint public last_completed_migration; modifier restricted() { if (msg.sender == owner) _; } function Migrations() public { owner = msg.sender; } function setCompleted(uint completed) public restricted { last_completed_migration = completed; } function upgrade(address new_address) public restricted { Migrations upgraded = Migrations(new_address); upgraded.setCompleted(last_completed_migration); } } "}
{"sol name": "3185.sol", "label": 1, "sol content": "pragma solidity 0.4.24; contract StarmidTransfer { function transfer(address _to, uint256 _value) public returns (bool _result) { _result = true; } } contract StarmidFreezeTokens { StarmidTransfer public StarmidFunc; address public owner; constructor(address _addr) { StarmidFunc = StarmidTransfer(_addr); owner = 0x378B9eea7ab9C15d9818EAdDe1156A079Cd02ba8; } function refundTokens(address _to, uint _amount) public returns(bool) { require(block.timestamp > 1601510400 && msg.sender == owner);//Thu, 01 Oct 2020 00:00:00 GMT StarmidFunc.transfer(_to,_amount); return true; } } "}
{"sol name": "8556.sol", "label": 1, "sol content": "/* * This file was generated by MyWish Platform (https://mywish.io/) * The complete code could be found at https://github.com/MyWishPlatform/ * Copyright (C) 2018 MyWish * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with this program. If not, see <http://www.gnu.org/licenses/>. */ pragma solidity ^0.4.21; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale. * Crowdsales have a start and end timestamps, where investors can make * token purchases and the crowdsale will assign them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. */ contract Crowdsale { using SafeMath for uint256; // The token being sold MintableToken public token; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // address where funds are collected address public wallet; // how many token units a buyer gets per wei uint256 public rate; // amount of raised money in wei uint256 public weiRaised; /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } // creates the token to be sold. // override this method to have crowdsale of a specific mintable token. function createTokenContract() internal returns (MintableToken) { return new MintableToken(); } // fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender); } // low level token purchase function function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = weiAmount.mul(rate); // update state weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } // send ether to the fund collection wallet // override to create custom fund forwarding mechanisms function forwardFunds() internal { wallet.transfer(msg.value); } // @return true if the transaction can buy tokens function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { return now > endTime; } } /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal { } } /** * @title RefundVault * @dev This contract is used for storing funds while a crowdsale * is in progress. Supports refunding the money if crowdsale fails, * and forwarding it if crowdsale is successful. */ contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } contract FreezableToken is StandardToken { // freezing chains mapping (bytes32 => uint64) internal chains; // freezing amounts for each chain mapping (bytes32 => uint) internal freezings; // total freezing balance per address mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); /** * @dev Gets the balance of the specified address include freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; } /** * @dev Gets the balance of the specified address without freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function actualBalanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner); } function freezingBalanceOf(address _owner) public view returns (uint256 balance) { return freezingBalance[_owner]; } /** * @dev gets freezing count * @param _addr Address of freeze tokens owner. */ function freezingCount(address _addr) public view returns (uint count) { uint64 release = chains[toKey(_addr, 0)]; while (release != 0) { count ++; release = chains[toKey(_addr, release)]; } } /** * @dev gets freezing end date and freezing balance for the freezing portion specified by index. * @param _addr Address of freeze tokens owner. * @param _index Freezing portion index. It ordered by release date descending. */ function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) { for (uint i = 0; i < _index + 1; i ++) { _release = chains[toKey(_addr, _release)]; if (_release == 0) { return; } } _balance = freezings[toKey(_addr, _release)]; } /** * @dev freeze your tokens to the specified address. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to freeze. * @param _until Release date, must be in future. */ function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); Transfer(msg.sender, _to, _amount); emit Freezed(_to, _until, _amount); } /** * @dev release first available freezing tokens. */ function releaseOnce() public { bytes32 headKey = toKey(msg.sender, 0); uint64 head = chains[headKey]; require(head != 0); require(uint64(block.timestamp) > head); bytes32 currentKey = toKey(msg.sender, head); uint64 next = chains[currentKey]; uint amount = freezings[currentKey]; delete freezings[currentKey]; balances[msg.sender] = balances[msg.sender].add(amount); freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount); if (next == 0) { delete chains[headKey]; } else { chains[headKey] = next; delete chains[currentKey]; } emit Released(msg.sender, amount); } /** * @dev release all available for release freezing tokens. Gas usage is not deterministic! * @return how many tokens was released */ function releaseAll() public returns (uint tokens) { uint release; uint balance; (release, balance) = getFreezing(msg.sender, 0); while (release != 0 && block.timestamp > release) { releaseOnce(); tokens += balance; (release, balance) = getFreezing(msg.sender, 0); } } function toKey(address _addr, uint _release) internal pure returns (bytes32 result) { // WISH masc to increase entropy result = 0x5749534800000000000000000000000000000000000000000000000000000000; assembly { result := or(result, mul(_addr, 0x10000000000000000)) result := or(result, _release) } } function freeze(address _to, uint64 _until) internal { require(_until > block.timestamp); bytes32 key = toKey(_to, _until); bytes32 parentKey = toKey(_to, uint64(0)); uint64 next = chains[parentKey]; if (next == 0) { chains[parentKey] = _until; return; } bytes32 nextKey = toKey(_to, next); uint parent; while (next != 0 && _until > next) { parent = next; parentKey = nextKey; next = chains[nextKey]; nextKey = toKey(_to, next); } if (_until == next) { return; } if (next != 0) { chains[key] = next; } chains[parentKey] = _until; } } /** * @title Contract that will work with ERC223 tokens. */ contract ERC223Receiver { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data) public; } contract ERC223Basic is ERC20Basic { function transfer(address to, uint value, bytes data) public returns (bool); event Transfer(address indexed from, address indexed to, uint value, bytes data); } contract SuccessfulERC223Receiver is ERC223Receiver { event Invoked(address from, uint value, bytes data); function tokenFallback(address _from, uint _value, bytes _data) public { emit Invoked(_from, _value, _data); } } contract FailingERC223Receiver is ERC223Receiver { function tokenFallback(address, uint, bytes) public { revert(); } } contract ERC223ReceiverWithoutTokenFallback { } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract FreezableMintableToken is FreezableToken, MintableToken { /** * @dev Mint the specified amount of token to the specified address and freeze it until the specified date. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to mint and freeze. * @param _until Release date, must be in future. * @return A boolean that indicates if the operation was successful. */ function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Mint(_to, _amount); emit Freezed(_to, _until, _amount); emit Transfer(msg.sender, _to, _amount); return true; } } contract Consts { uint constant TOKEN_DECIMALS = 18; uint8 constant TOKEN_DECIMALS_UINT8 = 18; uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS; string constant TOKEN_NAME = \"WM PROFESSIONAL\"; string constant TOKEN_SYMBOL = \"WMPRO\"; bool constant PAUSED = false; address constant TARGET_USER = 0xf91189AE847537bdb3a12506F7b58492A4308212; uint constant START_TIME = 1531692000; bool constant CONTINUE_MINTING = false; } /** * @title Reference implementation of the ERC223 standard token. */ contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver { using SafeMath for uint; /** * @dev Transfer the specified amount of tokens to the specified address. *      Invokes the `tokenFallback` function if the recipient is a contract. *      The token transfer fails if the recipient is a contract *      but does not implement the `tokenFallback` function *      or the fallback function to receive funds. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint _value, bytes _data) public returns (bool) { // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . uint codeLength; assembly { // Retrieve the size of the code on target address, this needs assembly. codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength > 0) { ERC223Receiver receiver = ERC223Receiver(_to); receiver.tokenFallback(msg.sender, _value, _data); } emit Transfer(msg.sender, _to, _value, _data); return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      This function works the same with the previous one *      but doesn't contain `_data` param. *      Added due to backwards compatibility reasons. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { bytes memory empty; return transfer(_to, _value, empty); } } contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable { function name() pure public returns (string _name) { return TOKEN_NAME; } function symbol() pure public returns (string _symbol) { return TOKEN_SYMBOL; } function decimals() pure public returns (uint8 _decimals) { return TOKEN_DECIMALS_UINT8; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transfer(_to, _value); } } /** * @title CappedCrowdsale * @dev Extension of Crowdsale with a max amount of funds raised */ contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } // overriding Crowdsale#validPurchase to add extra cap logic // @return true if investors can buy at the moment function validPurchase() internal view returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } // overriding Crowdsale#hasEnded to add cap logic // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } /** * @title RefundableCrowdsale * @dev Extension of Crowdsale contract that adds a funding goal, and * the possibility of users getting a refund if goal is not met. * Uses a RefundVault as the crowdsale's vault. */ contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; // minimum amount of funds to be raised in weis uint256 public goal; // refund vault used to hold funds while crowdsale is running RefundVault public vault; function RefundableCrowdsale(uint256 _goal) public { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; } // We're overriding the fund forwarding from Crowdsale. // In addition to sending the funds, we want to call // the RefundVault deposit function function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } // if crowdsale is unsuccessful, investors can claim refunds here function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } // vault finalization task, called when owner calls finalize() function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public view returns (bool) { return weiRaised >= goal; } } contract MainCrowdsale is Consts, FinalizableCrowdsale { function hasStarted() public constant returns (bool) { return now >= startTime; } function finalization() internal { super.finalization(); if (PAUSED) { MainToken(token).unpause(); } if (!CONTINUE_MINTING) { token.finishMinting(); } token.transferOwnership(TARGET_USER); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = weiAmount.mul(rate).div(1 ether); // update state weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } } contract Checkable { address private serviceAccount; /** * Flag means that contract accident already occurs. */ bool private triggered = false; /** * Occurs when accident happened. */ event Triggered(uint balance); /** * Occurs when check finished. */ event Checked(bool isAccident); function Checkable() public { serviceAccount = msg.sender; } /** * @dev Replace service account with new one. * @param _account Valid service account address. */ function changeServiceAccount(address _account) onlyService public { assert(_account != 0); serviceAccount = _account; } /** * @dev Is caller (sender) service account. */ function isServiceAccount() view public returns (bool) { return msg.sender == serviceAccount; } /** * Public check method. */ function check() onlyService notTriggered payable public { if (internalCheck()) { emit Triggered(this.balance); triggered = true; internalAction(); } } /** * @dev Do inner check. * @return bool true of accident triggered, false otherwise. */ function internalCheck() internal returns (bool); /** * @dev Do inner action if check was success. */ function internalAction() internal; modifier onlyService { require(msg.sender == serviceAccount); _; } modifier notTriggered() { require(!triggered); _; } } contract BonusableCrowdsale is Consts, Crowdsale { function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 bonusRate = getBonusRate(weiAmount); uint256 tokens = weiAmount.mul(bonusRate).div(1 ether); // update state weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function getBonusRate(uint256 weiAmount) internal view returns (uint256) { uint256 bonusRate = rate; // apply bonus for time & weiRaised uint[4] memory weiRaisedStartsBoundaries = [uint(0),uint(0),uint(0),uint(0)]; uint[4] memory weiRaisedEndsBoundaries = [uint(20000000000000000000000),uint(20000000000000000000000),uint(20000000000000000000000),uint(20000000000000000000000)]; uint64[4] memory timeStartsBoundaries = [uint64(1531692000),uint64(1532987940),uint64(1534802340),uint64(1536616740)]; uint64[4] memory timeEndsBoundaries = [uint64(1532987940),uint64(1534802340),uint64(1536616740),uint64(1537826340)]; uint[4] memory weiRaisedAndTimeRates = [uint(400),uint(300),uint(200),uint(100)]; for (uint i = 0; i < 4; i++) { bool weiRaisedInBound = (weiRaisedStartsBoundaries[i] <= weiRaised) && (weiRaised < weiRaisedEndsBoundaries[i]); bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]); if (weiRaisedInBound && timeInBound) { bonusRate += bonusRate * weiRaisedAndTimeRates[i] / 1000; } } // apply amount uint[2] memory weiAmountBoundaries = [uint(20000000000000000000),uint(10000000000000000000)]; uint[2] memory weiAmountRates = [uint(0),uint(50)]; for (uint j = 0; j < 2; j++) { if (weiAmount >= weiAmountBoundaries[j]) { bonusRate += bonusRate * weiAmountRates[j] / 1000; break; } } return bonusRate; } } contract TemplateCrowdsale is Consts, MainCrowdsale , BonusableCrowdsale , RefundableCrowdsale , CappedCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; function TemplateCrowdsale(MintableToken _token) public Crowdsale(START_TIME > now ? START_TIME : now, 1546297140, 1500 * TOKEN_DECIMAL_MULTIPLIER, 0x04B21fe3FBa3E8E548EfC51013E71242a55212cF) CappedCrowdsale(20000000000000000000000) RefundableCrowdsale(1000000000000000000000) { token = _token; } function init() public onlyOwner { require(!initialized); initialized = true; if (PAUSED) { MainToken(token).pause(); } address[4] memory addresses = [address(0xdadc35adc3091329a2a593a6c2ba2f1539aae965),address(0xe99d4d19b23bfe83916b346814ee06043154ae78),address(0xaae82f543abb3abda4faacb887e2f802d48ed2da),address(0xaf2bde98fe39733b0f2a89053a3060c0bf8f77da)]; uint[4] memory amounts = [uint(1500000000000000000000000),uint(5000000000000000000000000),uint(10000000000000000000000000),uint(3500000000000000000000000)]; uint64[4] memory freezes = [uint64(1577746805),uint64(1577746805),uint64(0),uint64(0)]; for (uint i = 0; i < addresses.length; i++) { if (freezes[i] == 0) { MainToken(token).mint(addresses[i], amounts[i]); } else { MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]); } } transferOwnership(TARGET_USER); emit Initialized(); } /** * @dev override token creation to set token address in constructor. */ function createTokenContract() internal returns (MintableToken) { return MintableToken(0); } function setEndTime(uint _endTime) public onlyOwner { // only if CS was not ended require(now < endTime); // only if new end time in future require(now < _endTime); require(_endTime > startTime); emit TimesChanged(startTime, _endTime, startTime, endTime); endTime = _endTime; } } "}
{"sol name": "11727.sol", "label": 1, "sol content": "/* * This file was generated by MyWish Platform (https://mywish.io/) * The complete code could be found at https://github.com/MyWishPlatform/ * Copyright (C) 2018 MyWish * * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with this program. If not, see <http://www.gnu.org/licenses/>. */ pragma solidity ^0.4.20; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract FreezableToken is StandardToken { // freezing chains mapping (bytes32 => uint64) internal chains; // freezing amounts for each chain mapping (bytes32 => uint) internal freezings; // total freezing balance per address mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); /** * @dev Gets the balance of the specified address include freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; } /** * @dev Gets the balance of the specified address without freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function actualBalanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner); } function freezingBalanceOf(address _owner) public view returns (uint256 balance) { return freezingBalance[_owner]; } /** * @dev gets freezing count * @param _addr Address of freeze tokens owner. */ function freezingCount(address _addr) public view returns (uint count) { uint64 release = chains[toKey(_addr, 0)]; while (release != 0) { count ++; release = chains[toKey(_addr, release)]; } } /** * @dev gets freezing end date and freezing balance for the freezing portion specified by index. * @param _addr Address of freeze tokens owner. * @param _index Freezing portion index. It ordered by release date descending. */ function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) { for (uint i = 0; i < _index + 1; i ++) { _release = chains[toKey(_addr, _release)]; if (_release == 0) { return; } } _balance = freezings[toKey(_addr, _release)]; } /** * @dev freeze your tokens to the specified address. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to freeze. * @param _until Release date, must be in future. */ function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); Transfer(msg.sender, _to, _amount); Freezed(_to, _until, _amount); } /** * @dev release first available freezing tokens. */ function releaseOnce() public { bytes32 headKey = toKey(msg.sender, 0); uint64 head = chains[headKey]; require(head != 0); require(uint64(block.timestamp) > head); bytes32 currentKey = toKey(msg.sender, head); uint64 next = chains[currentKey]; uint amount = freezings[currentKey]; delete freezings[currentKey]; balances[msg.sender] = balances[msg.sender].add(amount); freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount); if (next == 0) { delete chains[headKey]; } else { chains[headKey] = next; delete chains[currentKey]; } Released(msg.sender, amount); } /** * @dev release all available for release freezing tokens. Gas usage is not deterministic! * @return how many tokens was released */ function releaseAll() public returns (uint tokens) { uint release; uint balance; (release, balance) = getFreezing(msg.sender, 0); while (release != 0 && block.timestamp > release) { releaseOnce(); tokens += balance; (release, balance) = getFreezing(msg.sender, 0); } } function toKey(address _addr, uint _release) internal pure returns (bytes32 result) { // WISH masc to increase entropy result = 0x5749534800000000000000000000000000000000000000000000000000000000; assembly { result := or(result, mul(_addr, 0x10000000000000000)) result := or(result, _release) } } function freeze(address _to, uint64 _until) internal { require(_until > block.timestamp); bytes32 key = toKey(_to, _until); bytes32 parentKey = toKey(_to, uint64(0)); uint64 next = chains[parentKey]; if (next == 0) { chains[parentKey] = _until; return; } bytes32 nextKey = toKey(_to, next); uint parent; while (next != 0 && _until > next) { parent = next; parentKey = nextKey; next = chains[nextKey]; nextKey = toKey(_to, next); } if (_until == next) { return; } if (next != 0) { chains[key] = next; } chains[parentKey] = _until; } } /** * @title Contract that will work with ERC223 tokens. */ contract ERC223Receiver { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data) public; } contract ERC223Basic is ERC20Basic { function transfer(address to, uint value, bytes data) public returns (bool); event Transfer(address indexed from, address indexed to, uint value, bytes data); } contract SuccessfulERC223Receiver is ERC223Receiver { event Invoked(address from, uint value, bytes data); function tokenFallback(address _from, uint _value, bytes _data) public { Invoked(_from, _value, _data); } } contract FailingERC223Receiver is ERC223Receiver { function tokenFallback(address, uint, bytes) public { revert(); } } contract ERC223ReceiverWithoutTokenFallback { } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract FreezableMintableToken is FreezableToken, MintableToken { /** * @dev Mint the specified amount of token to the specified address and freeze it until the specified date. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to mint and freeze. * @param _until Release date, must be in future. * @return A boolean that indicates if the operation was successful. */ function mintAndFreeze(address _to, uint _amount, uint64 _until) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); Mint(_to, _amount); Freezed(_to, _until, _amount); Transfer(msg.sender, _to, _amount); return true; } } contract Consts { uint constant TOKEN_DECIMALS = 18; uint8 constant TOKEN_DECIMALS_UINT8 = 18; uint constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS; string constant TOKEN_NAME = \"KartingCoins\"; string constant TOKEN_SYMBOL = \"KRTC\"; bool constant PAUSED = false; address constant TARGET_USER = 0x67b8AbF0FA3B6E3a94B84184C37d20A9D69dbB55; bool constant CONTINUE_MINTING = true; } /** * @title Reference implementation of the ERC223 standard token. */ contract ERC223Token is ERC223Basic, BasicToken, FailingERC223Receiver { using SafeMath for uint; /** * @dev Transfer the specified amount of tokens to the specified address. *      Invokes the `tokenFallback` function if the recipient is a contract. *      The token transfer fails if the recipient is a contract *      but does not implement the `tokenFallback` function *      or the fallback function to receive funds. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint _value, bytes _data) public returns (bool) { // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . uint codeLength; assembly { // Retrieve the size of the code on target address, this needs assembly. codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength > 0) { ERC223Receiver receiver = ERC223Receiver(_to); receiver.tokenFallback(msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      This function works the same with the previous one *      but doesn't contain `_data` param. *      Added due to backwards compatibility reasons. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { bytes memory empty; return transfer(_to, _value, empty); } } contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable { event Initialized(); bool public initialized = false; function MainToken() public { init(); transferOwnership(TARGET_USER); } function init() private { require(!initialized); initialized = true; if (PAUSED) { pause(); } address[1] memory addresses = [address(0x15ae04d2aaf288e8826e3b2bcdf044f45489b6a7)]; uint[1] memory amounts = [uint(1000000000000000000000000000)]; uint64[1] memory freezes = [uint64(0)]; for (uint i = 0; i < addresses.length; i++) { if (freezes[i] == 0) { mint(addresses[i], amounts[i]); } else { mintAndFreeze(addresses[i], amounts[i], freezes[i]); } } if (!CONTINUE_MINTING) { finishMinting(); } Initialized(); } function name() pure public returns (string _name) { return TOKEN_NAME; } function symbol() pure public returns (string _symbol) { return TOKEN_SYMBOL; } function decimals() pure public returns (uint8 _decimals) { return TOKEN_DECIMALS_UINT8; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transfer(_to, _value); } } "}
{"sol name": "7419.sol", "label": 1, "sol content": "pragma solidity ^0.4.0; contract SponsoredItemGooRaffle { Goo goo = Goo(0x57b116da40f21f91aec57329ecb763d29c1b2355); address owner; // Raffle tickets mapping(address => TicketPurchases) private ticketsBoughtByPlayer; mapping(uint256 => address[]) private rafflePlayers; // Current Raffle info uint256 private constant RAFFLE_TICKET_BASE_GOO_PRICE = 1000; uint256 private raffleEndTime; uint256 private raffleTicketsBought; uint256 private raffleId; address private raffleWinner; bool private raffleWinningTicketSelected; uint256 private raffleTicketThatWon; // Raffle structures struct TicketPurchases { TicketPurchase[] ticketsBought; uint256 numPurchases; // Allows us to reset without clearing TicketPurchase[] (avoids potential for gas limit) uint256 raffleId; } // Allows us to query winner without looping (avoiding potential for gas limit) struct TicketPurchase { uint256 startId; uint256 endId; } function SponsoredItemGooRaffle() public { owner = msg.sender; } function startTokenRaffle(uint256 endTime, address tokenContract, uint256 id, bool hasItemAlready) external { require(msg.sender == owner); require(block.timestamp < endTime); if (raffleId != 0) { // Sanity to assure raffle has ended before next one starts require(raffleWinner != 0); } // Reset previous raffle info raffleWinningTicketSelected = false; raffleTicketThatWon = 0; raffleWinner = 0; raffleTicketsBought = 0; // Set current raffle info raffleEndTime = endTime; raffleId++; } function buyRaffleTicket(uint256 amount) external { require(raffleEndTime >= block.timestamp); require(amount > 0); uint256 ticketsCost = SafeMath.mul(RAFFLE_TICKET_BASE_GOO_PRICE, amount); goo.transferFrom(msg.sender, this, ticketsCost); // Burn 95% of the Goo (save 5% for contests / marketing fund) goo.transfer(address(0), (ticketsCost * 95) / 100); // Handle new tickets TicketPurchases storage purchases = ticketsBoughtByPlayer[msg.sender]; // If we need to reset tickets from a previous raffle if (purchases.raffleId != raffleId) { purchases.numPurchases = 0; purchases.raffleId = raffleId; rafflePlayers[raffleId].push(msg.sender); // Add user to raffle } // Store new ticket purchase if (purchases.numPurchases == purchases.ticketsBought.length) { purchases.ticketsBought.length += 1; } purchases.ticketsBought[purchases.numPurchases++] = TicketPurchase(raffleTicketsBought, raffleTicketsBought + (amount - 1)); // (eg: buy 10, get id's 0-9) // Finally update ticket total raffleTicketsBought += amount; } function awardRafflePrize(address checkWinner, uint256 checkIndex) external { require(raffleEndTime < block.timestamp); require(raffleWinner == 0); if (!raffleWinningTicketSelected) { drawRandomWinner(); // Ideally do it in one call (gas limit cautious) } // Reduce gas by (optionally) offering an address to _check_ for winner if (checkWinner != 0) { TicketPurchases storage tickets = ticketsBoughtByPlayer[checkWinner]; if (tickets.numPurchases > 0 && checkIndex < tickets.numPurchases && tickets.raffleId == raffleId) { TicketPurchase storage checkTicket = tickets.ticketsBought[checkIndex]; if (raffleTicketThatWon >= checkTicket.startId && raffleTicketThatWon <= checkTicket.endId) { assignRaffleWinner(checkWinner); // WINNER! return; } } } // Otherwise just naively try to find the winner (will work until mass amounts of players) for (uint256 i = 0; i < rafflePlayers[raffleId].length; i++) { address player = rafflePlayers[raffleId][i]; TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player]; uint256 endIndex = playersTickets.numPurchases - 1; // Minor optimization to avoid checking every single player if (raffleTicketThatWon >= playersTickets.ticketsBought[0].startId && raffleTicketThatWon <= playersTickets.ticketsBought[endIndex].endId) { for (uint256 j = 0; j < playersTickets.numPurchases; j++) { TicketPurchase storage playerTicket = playersTickets.ticketsBought[j]; if (raffleTicketThatWon >= playerTicket.startId && raffleTicketThatWon <= playerTicket.endId) { assignRaffleWinner(player); // WINNER! return; } } } } } function assignRaffleWinner(address winner) internal { raffleWinner = winner; } // Random enough for small contests (Owner only to prevent trial & error execution) function drawRandomWinner() public { require(msg.sender == owner); require(raffleEndTime < block.timestamp); require(!raffleWinningTicketSelected); uint256 seed = raffleTicketsBought + block.timestamp; raffleTicketThatWon = addmod(uint256(block.blockhash(block.number-1)), seed, (raffleTicketsBought + 1)); raffleWinningTicketSelected = true; } // 5% of Goo gained will be reinvested into the game (contests / marketing / acquiring more raffle assets) function transferGoo(address recipient, uint256 amount) external { require(msg.sender == owner); goo.transfer(recipient, amount); } // To display on website function getLatestRaffleInfo() external constant returns (uint256, uint256, uint256, address, uint256) { return (raffleEndTime, raffleId, raffleTicketsBought, raffleWinner, raffleTicketThatWon); } // To allow clients to verify contestants function getRafflePlayers(uint256 raffle) external constant returns (address[]) { return (rafflePlayers[raffle]); } // To allow clients to verify contestants function getPlayersTickets(address player) external constant returns (uint256[], uint256[]) { TicketPurchases storage playersTickets = ticketsBoughtByPlayer[player]; if (playersTickets.raffleId == raffleId) { uint256[] memory startIds = new uint256[](playersTickets.numPurchases); uint256[] memory endIds = new uint256[](playersTickets.numPurchases); for (uint256 i = 0; i < playersTickets.numPurchases; i++) { startIds[i] = playersTickets.ticketsBought[i].startId; endIds[i] = playersTickets.ticketsBought[i].endId; } } return (startIds, endIds); } } interface Goo { function transfer(address to, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "6933.sol", "label": 1, "sol content": "pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by requiring a state. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted = false; modifier inNormalState { require(!halted); _; } modifier inEmergencyState { require(halted); _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner inNormalState { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner inEmergencyState { halted = false; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Burnable * * @dev Standard ERC20 token */ contract Burnable is StandardToken { using SafeMath for uint; /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint value); function burn(uint _value) returns (bool success) { require(_value > 0 && balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint _value) returns (bool success) { require(_from != 0x0 && _value > 0 && balances[_from] >= _value); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); totalSupply = totalSupply.sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Burn(_from, _value); return true; } function transfer(address _to, uint _value) returns (bool success) { require(_to != 0x0); //use burn return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) returns (bool success) { require(_to != 0x0); //use burn return super.transferFrom(_from, _to, _value); } } /** * @title Contract that will work with ERC223 tokens. */ contract ERC223ReceivingContract { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data); } /** * @title AnythingAppToken * * @dev Burnable Ownable ERC20 token */ contract AnythingAppToken is Burnable, Ownable { string public constant name = \"AnythingApp Token\"; string public constant symbol = \"ANY\"; uint8 public constant decimals = 18; uint public constant INITIAL_SUPPLY = 400000000 * 1 ether; /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; event Transfer(address indexed from, address indexed to, uint value, bytes data); /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { require(released || transferAgents[_sender]); _; } /** The function can be called only before or after the tokens have been released */ modifier inReleaseState(bool releaseState) { require(releaseState == released); _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { require(msg.sender == releaseAgent); _; } /** * @dev Constructor that gives msg.sender all of existing tokens. */ function AnythingAppToken() { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { require(addr != 0x0); // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } function release() onlyReleaseAgent inReleaseState(false) public { released = true; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { require(addr != 0x0); transferAgents[addr] = state; } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call Burnable.transferForm() return super.transferFrom(_from, _to, _value); } /** * @dev Transfer the specified amount of tokens to the specified address. *      Invokes the `tokenFallback` function if the recipient is a contract. *      The token transfer fails if the recipient is a contract *      but does not implement the `tokenFallback` function *      or the fallback function to receive funds. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint _value, bytes _data) canTransfer(msg.sender) returns (bool success) { require(_to != address(0)); require(_value <= balances[msg.sender]); uint codeLength; assembly { codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      This function works the same with the previous one *      but doesn't contain `_data` param. *      Added due to backwards compatibility reasons. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. */ function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { require(_to != address(0)); require(_value <= balances[msg.sender]); uint codeLength; bytes memory empty; assembly { codeLength := extcodesize(_to) } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, empty); } Transfer(msg.sender, _to, _value, empty); return true; } function burn(uint _value) onlyOwner returns (bool success) { return super.burn(_value); } function burnFrom(address _from, uint _value) onlyOwner returns (bool success) { return super.burnFrom(_from, _value); } } contract InvestorWhiteList is Ownable { mapping (address => bool) public investorWhiteList; mapping (address => address) public referralList; function InvestorWhiteList() { } function addInvestorToWhiteList(address investor) external onlyOwner { require(investor != 0x0 && !investorWhiteList[investor]); investorWhiteList[investor] = true; } function removeInvestorFromWhiteList(address investor) external onlyOwner { require(investor != 0x0 && investorWhiteList[investor]); investorWhiteList[investor] = false; } //when new user will contribute ICO contract will automatically send bonus to referral function addReferralOf(address investor, address referral) external onlyOwner { require(investor != 0x0 && referral != 0x0 && referralList[investor] == 0x0 && investor != referral); referralList[investor] = referral; } function isAllowed(address investor) constant external returns (bool result) { return investorWhiteList[investor]; } function getReferralOf(address investor) constant external returns (address result) { return referralList[investor]; } } contract PriceReceiver { address public ethPriceProvider; modifier onlyEthPriceProvider() { require(msg.sender == ethPriceProvider); _; } function receiveEthPrice(uint ethUsdPrice) external; function setEthPriceProvider(address provider) external; } contract AnythingAppTokenPreSale is Haltable, PriceReceiver { using SafeMath for uint; string public constant name = \"AnythingAppTokenPreSale\"; AnythingAppToken public token; InvestorWhiteList public investorWhiteList; address public beneficiary; uint public tokenPriceUsd; uint public totalTokens;//in wei uint public ethUsdRate; uint public collected = 0; uint public withdrawn = 0; uint public tokensSold = 0; uint public investorCount = 0; uint public weiRefunded = 0; uint public startTime; uint public endTime; bool public crowdsaleFinished = false; mapping (address => bool) public refunded; mapping (address => uint) public deposited; uint public constant MINIMAL_PURCHASE = 250 ether; uint public constant LIMIT_PER_USER = 500000 ether; event NewContribution(address indexed holder, uint tokenAmount, uint etherAmount); event NewReferralTransfer(address indexed investor, address indexed referral, uint tokenAmount); event Refunded(address indexed holder, uint amount); event Deposited(address indexed holder, uint amount); modifier preSaleActive() { require(block.timestamp >= startTime && block.timestamp < endTime); _; } modifier preSaleEnded() { require(block.timestamp >= endTime); _; } function AnythingAppTokenPreSale( address _token, address _beneficiary, address _investorWhiteList, uint _totalTokens, uint _tokenPriceUsd, uint _baseEthUsdPrice, uint _startTime, uint _endTime ) { ethUsdRate = _baseEthUsdPrice; tokenPriceUsd = _tokenPriceUsd; totalTokens = _totalTokens.mul(1 ether); token = AnythingAppToken(_token); investorWhiteList = InvestorWhiteList(_investorWhiteList); beneficiary = _beneficiary; startTime = _startTime; endTime = _endTime; } function() payable { doPurchase(msg.sender); } function tokenFallback(address _from, uint _value, bytes _data) public pure { } function doPurchase(address _owner) private preSaleActive inNormalState { if (token.balanceOf(msg.sender) == 0) investorCount++; uint tokens = msg.value.mul(ethUsdRate).div(tokenPriceUsd); address referral = investorWhiteList.getReferralOf(msg.sender); uint referralBonus = calculateReferralBonus(tokens); uint newTokensSold = tokensSold.add(tokens); if (referralBonus > 0 && referral != 0x0) { newTokensSold = newTokensSold.add(referralBonus); } require(newTokensSold <= totalTokens); require(token.balanceOf(msg.sender).add(tokens) <= LIMIT_PER_USER); tokensSold = newTokensSold; collected = collected.add(msg.value); deposited[msg.sender] = deposited[msg.sender].add(msg.value); token.transfer(msg.sender, tokens); NewContribution(_owner, tokens, msg.value); if (referralBonus > 0 && referral != 0x0) { token.transfer(referral, referralBonus); NewReferralTransfer(msg.sender, referral, referralBonus); } } function calculateReferralBonus(uint _tokens) internal constant returns (uint _bonus) { return _tokens.mul(20).div(100); } function withdraw() external onlyOwner { uint toWithdraw = collected.sub(withdrawn); beneficiary.transfer(toWithdraw); withdrawn = withdrawn.add(toWithdraw); } function withdrawTokens() external onlyOwner { token.transfer(beneficiary, token.balanceOf(this)); } function receiveEthPrice(uint ethUsdPrice) external onlyEthPriceProvider { require(ethUsdPrice > 0); ethUsdRate = ethUsdPrice; } function setEthPriceProvider(address provider) external onlyOwner { require(provider != 0x0); ethPriceProvider = provider; } function setNewWhiteList(address newWhiteList) external onlyOwner { require(newWhiteList != 0x0); investorWhiteList = InvestorWhiteList(newWhiteList); } } "}
{"sol name": "361.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract FreezableToken is StandardToken { mapping (bytes32 => uint64) internal chains; mapping (bytes32 => uint) internal freezings; mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; } function actualBalanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner); } function freezingBalanceOf(address _owner) public view returns (uint256 balance) { return freezingBalance[_owner]; } function freezingCount(address _addr) public view returns (uint count) { uint64 release = chains[toKey(_addr, 0)]; while (release != 0) { count++; release = chains[toKey(_addr, release)]; } } function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) { for (uint i = 0; i < _index + 1; i++) { _release = chains[toKey(_addr, _release)]; if (_release == 0) { return; } } _balance = freezings[toKey(_addr, _release)]; } function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Transfer(msg.sender, _to, _amount); emit Freezed(_to, _until, _amount); } function releaseOnce() public { bytes32 headKey = toKey(msg.sender, 0); uint64 head = chains[headKey]; require(head != 0); require(uint64(block.timestamp) > head); bytes32 currentKey = toKey(msg.sender, head); uint64 next = chains[currentKey]; uint amount = freezings[currentKey]; delete freezings[currentKey]; balances[msg.sender] = balances[msg.sender].add(amount); freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount); if (next == 0) { delete chains[headKey]; } else { chains[headKey] = next; delete chains[currentKey]; } emit Released(msg.sender, amount); } function releaseAll() public returns (uint tokens) { uint release; uint balance; (release, balance) = getFreezing(msg.sender, 0); while (release != 0 && block.timestamp > release) { releaseOnce(); tokens += balance; (release, balance) = getFreezing(msg.sender, 0); } } function toKey(address _addr, uint _release) internal pure returns (bytes32 result) { result = 0x5749534800000000000000000000000000000000000000000000000000000000; assembly { result := or(result, mul(_addr, 0x10000000000000000)) result := or(result, _release) } } function freeze(address _to, uint64 _until) internal { require(_until > block.timestamp); bytes32 key = toKey(_to, _until); bytes32 parentKey = toKey(_to, uint64(0)); uint64 next = chains[parentKey]; if (next == 0) { chains[parentKey] = _until; return; } bytes32 nextKey = toKey(_to, next); uint parent; while (next != 0 && _until > next) { parent = next; parentKey = nextKey; next = chains[nextKey]; nextKey = toKey(_to, next); } if (_until == next) { return; } if (next != 0) { chains[key] = next; } chains[parentKey] = _until; } } contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract FreezableMintableToken is FreezableToken, MintableToken { function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Mint(_to, _amount); emit Freezed(_to, _until, _amount); emit Transfer(msg.sender, _to, _amount); return true; } } contract Consts { uint public constant TOKEN_DECIMALS = 0; uint8 public constant TOKEN_DECIMALS_UINT8 = 0; uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS; string public constant TOKEN_NAME = \"MissYou\"; string public constant TOKEN_SYMBOL = \"MIS\"; bool public constant PAUSED = false; address public constant TARGET_USER = 0x210d60d0ec127f0fff477a1b1b9424bb1c32876d; bool public constant CONTINUE_MINTING = false; } contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable { event Initialized(); bool public initialized = false; constructor() public { init(); transferOwnership(TARGET_USER); } function name() public pure returns (string _name) { return TOKEN_NAME; } function symbol() public pure returns (string _symbol) { return TOKEN_SYMBOL; } function decimals() public pure returns (uint8 _decimals) { return TOKEN_DECIMALS_UINT8; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transfer(_to, _value); } function init() private { require(!initialized); initialized = true; if (PAUSED) { pause(); } address[1] memory addresses = [address(0x210d60d0ec127f0fff477a1b1b9424bb1c32876d)]; uint[1] memory amounts = [uint(690000000000)]; uint64[1] memory freezes = [uint64(0)]; for (uint i = 0; i < addresses.length; i++) { if (freezes[i] == 0) { mint(addresses[i], amounts[i]); } else { mintAndFreeze(addresses[i], amounts[i], freezes[i]); } } if (!CONTINUE_MINTING) { finishMinting(); } emit Initialized(); } } "}
{"sol name": "9531.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title RefundVault * @dev This contract is used for storing funds while a crowdsale * is in progress. Supports refunding the money if crowdsale fails, * and forwarding it if crowdsale is successful. */ contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); /** * @param _wallet Vault address */ constructor(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } /** * @param investor Investor address */ function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; emit Closed(); wallet.transfer(address(this).balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; emit RefundsEnabled(); } /** * @param investor Investor address */ function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); emit Refunded(investor, depositedValue); } } /** * @title CryptualProjectToken * @dev Official ERC20 token contract for the Cryptual Project. * This contract includes both a presale and a crowdsale. */ contract CryptualProjectToken is StandardToken, Ownable { using SafeMath for uint256; // ERC20 optional details string public constant name = \"Cryptual Project Token\"; // solium-disable-line uppercase string public constant symbol = \"CPT\"; // solium-disable-line uppercase uint8 public constant decimals = 0; // solium-disable-line uppercase // Token constants, variables uint256 public constant INITIAL_SUPPLY = 283000000; address public wallet; // Presale constants uint256 public constant PRESALE_OPENING_TIME = 1530356400; // 06/30/2018 11:00:00 GMT uint256 public constant PRESALE_CLOSING_TIME = 1530921600; // 07/07/2018 00:00:00 GMT uint256 public constant PRESALE_RATE = 150000; uint256 public constant PRESALE_WEI_CAP = 500 ether; uint256 public constant PRESALE_WEI_GOAL = 50 ether; // Crowdsale constants uint256 public constant CROWDSALE_OPENING_TIME = 1531047600; // 07/08/2018 11:00:00 GMT uint256 public constant CROWDSALE_CLOSING_TIME = 1533686400; // 08/08/2018 00:00:00 GMT uint256 public constant CROWDSALE_WEI_CAP = 5000 ether; // Combined wei goal for both sales uint256 public constant COMBINED_WEI_GOAL = 750 ether; // More crowdsale parameters uint256[] public crowdsaleWeiAvailableLevels = [1000 ether, 1500 ether, 2000 ether]; uint256[] public crowdsaleRates = [135000, 120000, 100000]; uint256[] public crowdsaleMinElapsedTimeLevels = [0, 12 * 3600, 18 * 3600, 21 * 3600, 22 * 3600]; uint256[] public crowdsaleUserCaps = [1 ether, 2 ether, 4 ether, 8 ether, CROWDSALE_WEI_CAP]; // List of contributions by address for user caps feature mapping(address => uint256) public crowdsaleContributions; // Amount of wei raised uint256 public presaleWeiRaised; uint256 public crowdsaleWeiRaised; /** * @dev Constructor that sends msg.sender the initial token supply */ constructor( address _wallet ) public { require(_wallet != address(0)); wallet = _wallet; vault = new RefundVault(wallet); totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @dev fallback token purchase function */ function () external payable { buyTokens(msg.sender); } /** * @dev token purchase function * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; require(_beneficiary != address(0)); require(weiAmount != 0); bool isPresale = block.timestamp >= PRESALE_OPENING_TIME && block.timestamp <= PRESALE_CLOSING_TIME; bool isCrowdsale = block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME; require(isPresale || isCrowdsale); uint256 tokens; if (isCrowdsale) { require(crowdsaleWeiRaised.add(weiAmount) <= CROWDSALE_WEI_CAP); require(crowdsaleContributions[_beneficiary].add(weiAmount) <= getCrowdsaleUserCap()); // calculate token amount to be created tokens = _getCrowdsaleTokenAmount(weiAmount); require(tokens != 0); // update state crowdsaleWeiRaised = crowdsaleWeiRaised.add(weiAmount); } else if (isPresale) { require(presaleWeiRaised.add(weiAmount) <= PRESALE_WEI_CAP); require(whitelist[_beneficiary]); // calculate token amount to be created tokens = weiAmount.mul(PRESALE_RATE).div(1 ether); require(tokens != 0); // update state presaleWeiRaised = presaleWeiRaised.add(weiAmount); } _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); if (isCrowdsale) crowdsaleContributions[_beneficiary] = crowdsaleContributions[_beneficiary].add(weiAmount); vault.deposit.value(msg.value)(msg.sender); } /** * @dev Returns the current contribution cap per user in wei. * Note that this cap in changes with time. * @return The maximum wei a user may contribute in total */ function getCrowdsaleUserCap() public view returns (uint256) { require(block.timestamp >= CROWDSALE_OPENING_TIME && block.timestamp <= CROWDSALE_CLOSING_TIME); // solium-disable-next-line security/no-block-members uint256 elapsedTime = block.timestamp.sub(CROWDSALE_OPENING_TIME); uint256 currentMinElapsedTime = 0; uint256 currentCap = 0; for (uint i = 0; i < crowdsaleUserCaps.length; i++) { if (elapsedTime < crowdsaleMinElapsedTimeLevels[i]) continue; if (crowdsaleMinElapsedTimeLevels[i] < currentMinElapsedTime) continue; currentCap = crowdsaleUserCaps[i]; } return currentCap; } /** * @dev Function to compute output tokens from input wei * @param _weiAmount The value in wei to be converted into tokens * @return The number of tokens _weiAmount wei will buy at present time */ function _getCrowdsaleTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 uncountedWeiRaised = crowdsaleWeiRaised; uint256 uncountedWeiAmount = _weiAmount; uint256 tokenAmount = 0; for (uint i = 0; i < crowdsaleWeiAvailableLevels.length; i++) { uint256 weiAvailable = crowdsaleWeiAvailableLevels[i]; if (uncountedWeiRaised >= weiAvailable) { uncountedWeiRaised = uncountedWeiRaised.sub(weiAvailable); } else { if (uncountedWeiRaised > 0) { weiAvailable = weiAvailable.sub(uncountedWeiRaised); uncountedWeiRaised = 0; } if (uncountedWeiAmount <= weiAvailable) { tokenAmount = tokenAmount.add(uncountedWeiAmount.mul(crowdsaleRates[i])); break; } else { uncountedWeiAmount = uncountedWeiAmount.sub(weiAvailable); tokenAmount = tokenAmount.add(weiAvailable.mul(crowdsaleRates[i])); } } } return tokenAmount.div(1 ether); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { totalSupply_ = totalSupply_.add(_tokenAmount); balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount); emit Transfer(0x0, _beneficiary, _tokenAmount); } // Private presale buyer whitelist mapping(address => bool) public whitelist; /** * @dev Adds single address to whitelist. * @param _beneficiary Address to be added to the whitelist */ function addToPresaleWhitelist(address _beneficiary) external onlyOwner { whitelist[_beneficiary] = true; } /** * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing. * @param _beneficiaries Addresses to be added to the whitelist */ function addManyToPresaleWhitelist(address[] _beneficiaries) external onlyOwner { for (uint256 i = 0; i < _beneficiaries.length; i++) { whitelist[_beneficiaries[i]] = true; } } /** * @dev Removes single address from whitelist. * @param _beneficiary Address to be removed to the whitelist */ function removeFromPresaleWhitelist(address _beneficiary) external onlyOwner { whitelist[_beneficiary] = false; } // Crowdsale finalization/refunding bool public isCrowdsaleFinalized = false; event CrowdsaleFinalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalizeCrowdsale() external { require(!isCrowdsaleFinalized); require(block.timestamp > CROWDSALE_CLOSING_TIME || (block.timestamp > PRESALE_CLOSING_TIME && presaleWeiRaised < PRESALE_WEI_GOAL)); if (combinedGoalReached()) { vault.close(); } else { vault.enableRefunds(); } emit CrowdsaleFinalized(); isCrowdsaleFinalized = true; } // Refund vault used to hold funds while crowdsale is running RefundVault public vault; /** * @dev Investors can claim refunds here if crowdsale is unsuccessful */ function claimRefund() external { require(isCrowdsaleFinalized); require(!combinedGoalReached()); vault.refund(msg.sender); } /** * @dev Checks whether funding goal was reached. * @return Whether funding goal was reached */ function combinedGoalReached() public view returns (bool) { return presaleWeiRaised.add(crowdsaleWeiRaised) >= COMBINED_WEI_GOAL; } } "}
{"sol name": "9210.sol", "label": 1, "sol content": "/** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ pragma solidity ^0.4.15; // import \"./Crowdsale.sol\"; /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ // pragma solidity ^0.4.15; // import 'zeppelin-solidity/contracts/math/SafeMath.sol'; // pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // import \"./Haltable.sol\"; /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ // pragma solidity ^0.4.15; // import \"zeppelin-solidity/contracts/ownership/Ownable.sol\"; // pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) revert(); _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) revert(); _; } modifier onlyInEmergency { if (!halted) revert(); _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } // import \"./PricingStrategy.sol\"; /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ // pragma solidity ^0.4.15; // import \"zeppelin-solidity/contracts/ownership/Ownable.sol\"; /** * Interface for defining crowdsale pricing. */ contract PricingStrategy is Ownable { /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } // import \"./FinalizeAgent.sol\"; /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ // pragma solidity ^0.4.15; /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } // import \"./FractionalERC20.sol\"; /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ // pragma solidity ^0.4.15; // import \"zeppelin-solidity/contracts/token/ERC20.sol\"; // pragma solidity ^0.4.18; // import './ERC20Basic.sol'; // pragma solidity ^0.4.18; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20 is ERC20 { uint public decimals; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract Crowdsale is Haltable { /* Time period to scale eth cap */ uint public constant TIME_PERIOD_IN_SEC = 1 days; /* Base eth cap */ uint public baseEthCap; /* Max eth per address */ uint public maxEthPerAddress; /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMath for uint; /* The token we are selling */ FractionalERC20 public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint256 public tokensSold = 0; /* How many wei of funding we have raised */ uint256 public weiRaised = 0; /* Calculate incoming funds from presale contracts and addresses */ uint public presaleWeiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* How much wei we have returned back to the contract after a failed crowdfund. */ uint public loadedRefund = 0; /* How much wei we have given back to investors.*/ uint public weiRefunded = 0; /* Has this crowdsale been finalized */ bool public finalized; /* Do we need to have unique contributor id for each customer */ bool public requireCustomerId; /** * Do we verify that contributor has been cleared on the server side (accredited investors only). * This method was first used in FirstBlood crowdsale to ensure all contributors have accepted terms on sale (on the web). */ bool public requiredSignedAddress; /* Server side address that signed allowed contributors (Ethereum addresses) that can participate the crowdsale */ address public signerAddress; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed * - Refunding: Refunds are loaded on the contract for reclaim. */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} // A new investment was made event Invested(address investor, uint256 weiAmount, uint256 tokenAmount, uint128 customerId); // Refund was processed for a contributor event Refund(address investor, uint weiAmount); // The rules were changed what kind of investments we accept event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); // Base eth cap has been changed event BaseEthCapChanged(uint newBaseEthCap); // Max eth per address changed event MaxEthPerAddressChanged(uint newMaxEthPerAddress); function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _baseEthCap, uint _maxEthPerAddress) { owner = msg.sender; baseEthCap = _baseEthCap; maxEthPerAddress = _maxEthPerAddress; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if (multisigWallet == 0) { revert(); } if (_start == 0) { revert(); } startsAt = _start; if (_end == 0) { revert(); } endsAt = _end; // Don't mess the dates if (startsAt >= endsAt) { revert(); } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; } function() payable { buy(); } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals()); if (tokenAmount == 0) { // Dust transaction revert(); } //get the eth cap for the time period uint currentFgcCap = getCurrentFgcCap(); if (tokenAmount > currentFgcCap) { // We don't allow more than the current cap revert(); } if (investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount); // Update totals weiRaised = weiRaised.add(weiAmount); tokensSold = tokensSold.add(tokenAmount); if (pricingStrategy.isPresalePurchase(receiver)) { presaleWeiRaised = presaleWeiRaised.add(weiAmount); } // Check that we did not bust the cap if (isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { revert(); } assignTokens(receiver, tokenAmount); // Pocket the money if (!multisigWallet.send(weiAmount)) revert(); // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } function getCurrentFgcCap() public constant returns (uint) { if (block.timestamp < startsAt) return maxEthPerAddress; uint timeSinceStart = block.timestamp.sub(startsAt); uint currentPeriod = timeSinceStart.div(TIME_PERIOD_IN_SEC).add(1); if (currentPeriod < 2) { return 5000 * 10**token.decimals(); } if (currentPeriod > 2 && currentPeriod < 5) { return 1000 * 10**token.decimals(); } if (currentPeriod > 4 && currentPeriod < 6) { return 500 * 10**token.decimals(); } if (currentPeriod > 5 && currentPeriod < 9) { return 200 * 10**token.decimals(); } if (currentPeriod > 8 && currentPeriod < 11) { return 100 * 10**token.decimals(); } return maxEthPerAddress; } /** * Preallocate tokens for the early investors. * * Preallocated tokens have been sold before the actual crowdsale opens. * This function mints the tokens and moves the crowdsale needle. * * Investor count is not handled; it is assumed this goes for multiple investors * and the token distribution happens outside the smart contract flow. * * No money is exchanged, as the crowdsale team already have received the payment. * * @param fullTokens tokens as full tokens - decimal places added internally * @param weiPrice Price of a single full token in wei * */ function preallocate(address receiver, uint256 fullTokens, uint256 weiPrice) public onlyOwner { uint256 tokenAmount = fullTokens; //uint256 tokenAmount = fullTokens * 10**token.decimals(); uint256 weiAmount = weiPrice * fullTokens; // This can be also 0, we give out tokens for free weiRaised = weiRaised.add(weiAmount); tokensSold = tokensSold.add(tokenAmount); investedAmountOf[receiver] = investedAmountOf[receiver].add(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].add(tokenAmount); assignTokens(receiver, tokenAmount); // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, 0); } /** * Allow anonymous contributions to this crowdsale. */ function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(addr); if (ecrecover(hash, v, r, s) != signerAddress) revert(); if (customerId == 0) revert();  // UUIDv4 sanity check investInternal(addr, customerId); } /** * Track who is the customer making the payment so we can send thank you email. */ function investWithCustomerId(address addr, uint128 customerId) public payable { if (requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants if (customerId == 0) revert();  // UUIDv4 sanity check investInternal(addr, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { if (requireCustomerId) revert(); // Crowdsale needs to track partipants for thank you email if (requiredSignedAddress) revert(); // Crowdsale allows only server-side signed participants investInternal(addr, 0); } /** * Invest to tokens, recognize the payer and clear his address. * */ function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { investWithSignedAddress(msg.sender, customerId, v, r, s); } /** * Invest to tokens, recognize the payer. * */ function buyWithCustomerId(uint128 customerId) public payable { investWithCustomerId(msg.sender, customerId); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if (finalized) { revert(); } // Finalizing is optional. We only call it if we are given a finalizing agent. if (address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; // Don't allow setting bad agent if (!finalizeAgent.isFinalizeAgent()) { revert(); } } /** * Set policy do we need to have server-side customer ids for the investments. * */ function setRequireCustomerId(bool value) onlyOwner { requireCustomerId = value; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } /** * Set policy if all investors must be cleared on the server side first. * * This is e.g. for the accredited investor clearing. * */ function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner { requiredSignedAddress = value; signerAddress = _signerAddress; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } /** * Set the base eth cap */ function setBaseEthCap(uint _baseEthCap) onlyOwner { if (_baseEthCap == 0) revert(); baseEthCap = _baseEthCap; BaseEthCapChanged(baseEthCap); } /** * Set the max eth per address */ function setMaxEthPerAddress(uint _maxEthPerAddress) onlyOwner { if(_maxEthPerAddress == 0) revert(); maxEthPerAddress = _maxEthPerAddress; MaxEthPerAddressChanged(maxEthPerAddress); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) onlyOwner { if (now > time) { revert(); // Don't change past } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if (!pricingStrategy.isPricingStrategy()) { revert(); } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if (investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { revert(); } multisigWallet = addr; } /** * Allow load refunds back on the contract for the refunding. * * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached.. */ function loadRefund() public payable inState(State.Failure) { if (msg.value == 0) revert(); loadedRefund = loadedRefund.add(msg.value); } /** * Investors can claim refund. * * Note that any refunds from proxy buyers should be handled separately, * and not through this contract. */ function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) revert(); investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.add(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) revert(); } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if (finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } /** This is for manual testing of multisig wallet interaction */ function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if (getState() != state) revert(); _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } // import \"./PricingStrategy.sol\"; /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ // pragma solidity ^0.4.15; // import \"zeppelin-solidity/contracts/ownership/Ownable.sol\"; /** * A crowdsale that is selling tokens from a preallocated pool * * * - Tokens have precreated supply \"premined\" * * - Token owner must transfer sellable tokens to the crowdsale contract using ERC20.approve() * */ contract AllocatedCrowdsale is Crowdsale { /* The party who holds the full token pool and has approve()'ed tokens for this crowdsale */ address public beneficiary; function AllocatedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, address _beneficiary, uint baseEthCap, uint maxEthPerAddress) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, baseEthCap, maxEthPerAddress) { beneficiary = _beneficiary; } /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) { if (tokenAmount > getTokensLeft()) { return true; } else { return false; } } /** * We are sold out when our approve pool becomes empty. */ function isCrowdsaleFull() public constant returns (bool) { return getTokensLeft() == 0; } /** * Get the amount of unsold tokens allocated to this contract; */ function getTokensLeft() public constant returns (uint) { return token.allowance(owner, this); } /** * Transfer tokens from approve() pool to the buyer. * * Use approve() given to this crowdsale to distribute the tokens. */ function assignTokens(address receiver, uint256 tokenAmount) private { if (!token.transferFrom(beneficiary, receiver, tokenAmount)) revert(); } } "}
{"sol name": "10025.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "496.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; contract YellowBetterToken { string public constant name = \"Yellow Better\"; string public constant symbol = \"YBT\"; uint8 public constant decimals = 18; uint public constant _totalSupply = 2000000000000000000000000000; uint public totalSupply = _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; event Transfer(address indexed, address indexed, uint); event Approval(address indexed, address indexed, uint); event Burn(address indexed, uint); constructor() { balances[msg.sender] = totalSupply; } function sub(uint a, uint b) private pure returns (uint) { require(a >= b); return a - b; } function balanceOf(address tokenOwner) view returns (uint) { return balances[tokenOwner]; } function transfer(address to, uint tokens) returns (bool) { balances[msg.sender] = sub(balances[msg.sender], tokens); balances[to] += tokens; emit Transfer(msg.sender, to, tokens); return true; } function transferFrom(address from, address to, uint tokens) returns (bool) { // subtract tokens from both balance and allowance, fail if any is smaller balances[from] = sub(balances[from], tokens); allowed[from][msg.sender] = sub(allowed[from][msg.sender], tokens); balances[to] += tokens; emit Transfer(from, to, tokens); return true; } function approve(address spender, uint tokens) returns (bool) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function allowance(address tokenOwner, address spender) view returns (uint) { return allowed[tokenOwner][spender]; } function burn(uint tokens) { balances[msg.sender] = sub(balances[msg.sender], tokens); totalSupply -= tokens; emit Burn(msg.sender, tokens); } } contract TokenSale { address public creator; address public tokenContract; uint public tokenPrice; // in wei uint public deadline; constructor(address source) { creator = msg.sender; tokenContract = source; } function setPrice(uint price) { if (msg.sender == creator) tokenPrice = price; } function setDeadline(uint timestamp) { if (msg.sender == creator) deadline = timestamp; } function buyTokens(address beneficiary) payable { require( block.timestamp < deadline && tokenPrice > 0 && YellowBetterToken(tokenContract).transfer(beneficiary, 1000000000000000000 * msg.value / tokenPrice)); } function payout() { creator.transfer(this.balance); } } "}
{"sol name": "11684.sol", "label": 1, "sol content": "pragma solidity ^0.4.11; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardToken { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state throw; } // Validate input value. if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); // Take tokens out from circulation totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading throw; } if (agent == 0x0) throw; // Only a master can designate the next agent if (msg.sender != upgradeMaster) throw; // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) throw; // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; /* Minimum ammount of tokens every buyer can buy. */ uint public minCap; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; // Create initially all balance on the team multisig balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { throw; // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } /** * Claim tokens that were accidentally sent to this contract. * * @param _token The address of the token contract that you want to recover. */ function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } /** * The default behavior for the crowdsale end. * * Unlock tokens. */ contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } //distributes reserved tokens. Should be called before finalization function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); // How many % of tokens the founders and others get uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; // move reserved tokens for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
{"sol name": "8939.sol", "label": 1, "sol content": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 is Ownable { using SafeMath for uint; // Public variables of the token string public name; string public symbol; uint256 public decimals = 18; uint256 DEC = 10 ** uint256(decimals); uint256 public totalSupply; uint256 public avaliableSupply; uint256 public buyPrice = 1000000000000000000 wei; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply.mul(DEC);  // Update total supply with the decimal amount balanceOf[this] = totalSupply;         // Give the creator all initial tokens avaliableSupply = balanceOf[this];     // Show how much tokens on contract name = tokenName;                      // Set the name for display purposes symbol = tokenSymbol;                  // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract * * @param _from - address of the contract * @param _to - address of the investor * @param _value - tokens for the investor */ function _transfer(address _from, address _to, uint256 _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to].add(_value) > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from].add(balanceOf[_to]); // Subtract from the sender balanceOf[_from] = balanceOf[_from].sub(_value); // Add the same to the recipient balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public onlyOwner returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowance[msg.sender][_spender] = allowance[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowance[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowance[msg.sender][_spender] = 0; } else { allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]); return true; } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public onlyOwner returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);  // Subtract from the sender totalSupply = totalSupply.sub(_value);                      // Updates totalSupply avaliableSupply = avaliableSupply.sub(_value); emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] = balanceOf[_from].sub(_value);    // Subtract from the targeted balance allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);    // Subtract from the sender's allowance totalSupply = totalSupply.sub(_value);              // Update totalSupply avaliableSupply = avaliableSupply.sub(_value); emit Burn(_from, _value); return true; } } contract ERC20Extending is TokenERC20 { using SafeMath for uint; /** * Function for transfer ethereum from contract to any address * * @param _to - address of the recipient * @param amount - ethereum */ function transferEthFromContract(address _to, uint256 amount) public onlyOwner { _to.transfer(amount); } /** * Function for transfer tokens from contract to any address * */ function transferTokensFromContract(address _to, uint256 _value) public onlyOwner { avaliableSupply = avaliableSupply.sub(_value); _transfer(this, _to, _value); } } contract Pauseble is TokenERC20 { event EPause(); event EUnpause(); bool public paused = true; uint public startIcoDate = 0; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() public onlyOwner { paused = true; emit EPause(); } function pauseInternal() internal { paused = true; emit EPause(); } function unpause() public onlyOwner { paused = false; emit EUnpause(); } function unpauseInternal() internal { paused = false; emit EUnpause(); } } contract StreamityCrowdsale is Pauseble { using SafeMath for uint; uint public stage = 0; event CrowdSaleFinished(string info); struct Ico { uint256 tokens;             // Tokens in crowdsale uint startDate;             // Date when crowsale will be starting, after its starting that property will be the 0 uint endDate;               // Date when crowdsale will be stop uint8 discount;             // Discount uint8 discountFirstDayICO;  // Discount. Only for first stage ico } Ico public ICO; /** * Expanding of the functionality * * @param _numerator - Numerator - value (10000) * @param _denominator - Denominator - value (10000) * * example: price 1000 tokens by 1 ether = changeRate(1, 1000) */ function changeRate(uint256 _numerator, uint256 _denominator) public onlyOwner returns (bool success) { if (_numerator == 0) _numerator = 1; if (_denominator == 0) _denominator = 1; buyPrice = (_numerator.mul(DEC)).div(_denominator); return true; } /* * Function show in contract what is now * */ function crowdSaleStatus() internal constant returns (string) { if (1 == stage) { return \"Pre-ICO\"; } else if(2 == stage) { return \"ICO first stage\"; } else if (3 == stage) { return \"ICO second stage\"; } else if (4 >= stage) { return \"feature stage\"; } return \"there is no stage at present\"; } /* * Function for selling tokens in crowd time. * */ function sell(address _investor, uint256 amount) internal { uint256 _amount = (amount.mul(DEC)).div(buyPrice); if (1 == stage) { _amount = _amount.add(withDiscount(_amount, ICO.discount)); } else if (2 == stage) { if (now <= ICO.startDate + 1 days) { if (0 == ICO.discountFirstDayICO) { ICO.discountFirstDayICO = 20; } _amount = _amount.add(withDiscount(_amount, ICO.discountFirstDayICO)); } else { _amount = _amount.add(withDiscount(_amount, ICO.discount)); } } else if (3 == stage) { _amount = _amount.add(withDiscount(_amount, ICO.discount)); } if (ICO.tokens < _amount) { emit CrowdSaleFinished(crowdSaleStatus()); pauseInternal(); revert(); } ICO.tokens = ICO.tokens.sub(_amount); avaliableSupply = avaliableSupply.sub(_amount); _transfer(this, _investor, _amount); } /* * Function for start crowdsale (any) * * @param _tokens - How much tokens will have the crowdsale - amount humanlike value (10000) * @param _startDate - When crowdsale will be start - unix timestamp (1512231703 ) * @param _endDate - When crowdsale will be end - humanlike value (7) same as 7 days * @param _discount - Discount for the crowd - humanlive value (7) same as 7 % * @param _discount - Discount for the crowds first day - humanlive value (7) same as 7 % */ function startCrowd(uint256 _tokens, uint _startDate, uint _endDate, uint8 _discount, uint8 _discountFirstDayICO) public onlyOwner { require(_tokens * DEC <= avaliableSupply);  // require to set correct tokens value for crowd startIcoDate = _startDate; ICO = Ico (_tokens * DEC, _startDate, _startDate + _endDate * 1 days , _discount, _discountFirstDayICO); stage = stage.add(1); unpauseInternal(); } /** * Function for web3js, should be call when somebody will buy tokens from website. This function only delegator. * * @param _investor - address of investor (who payed) * @param _amount - ethereum */ function transferWeb3js(address _investor, uint256 _amount) external onlyOwner { sell(_investor, _amount); } /** * Function for adding discount * */ function withDiscount(uint256 _amount, uint _percent) internal pure returns (uint256) { return (_amount.mul(_percent)).div(100); } } contract StreamityContract is ERC20Extending, StreamityCrowdsale { using SafeMath for uint; uint public weisRaised;  // how many weis was raised on crowdsale /* Streamity tokens Constructor */ function StreamityContract() public TokenERC20(130000000, \"Streamity\", \"STM\") {} //change before send !!! /** * Function payments handler * */ function () public payable { assert(msg.value >= 1 ether / 10); require(now >= ICO.startDate); if (now >= ICO.endDate) { pauseInternal(); emit CrowdSaleFinished(crowdSaleStatus()); } if (0 != startIcoDate) { if (now < startIcoDate) { revert(); } else { startIcoDate = 0; } } if (paused == false) { sell(msg.sender, msg.value); weisRaised = weisRaised.add(msg.value); } } } /** * @title Helps contracts guard agains reentrancy attacks. * @author Remco Bloemen <[email\u00a0protected]\u03c0.com> * @notice If you mark a function `nonReentrant`, you should also * mark it `external`. */ contract ReentrancyGuard { /** * @dev We use a single lock for the whole contract. */ bool private reentrancy_lock = false; /** * @dev Prevents a contract from calling itself, directly or indirectly. * @notice If you mark a function `nonReentrant`, you should also * mark it `external`. Calling one nonReentrant function from * another is not supported. Instead, you can implement a * `private` function doing the actual work, and a `external` * wrapper marked as `nonReentrant`. */ modifier nonReentrant() { require(!reentrancy_lock); reentrancy_lock = true; _; reentrancy_lock = false; } } /** * @title Eliptic curve signature operations * * @dev Based on https://gist.github.com/axic/5b33912c6f61ae6fd96d6c4a47afde6d */ library ECRecovery { /** * @dev Recover signer address from a message by using his signature * @param hash bytes32 message, the hash is the signed message. What is recovered is the signer address. * @param sig bytes signature, the signature is generated using web3.eth.sign() */ function recover(bytes32 hash, bytes sig) public pure returns (address) { bytes32 r; bytes32 s; uint8 v; //Check the signature length if (sig.length != 65) { return (address(0)); } // Divide the signature in r, s and v variables assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } // Version of signature should be 27 or 28, but 0 and 1 are also possible versions if (v < 27) { v += 27; } // If the version is correct return the signer address if (v != 27 && v != 28) { return (address(0)); } else { return ecrecover(hash, v, r, s); } } } contract ContractToken { function transfer(address _to, uint _value) public returns (bool success); function transferFrom(address _from, address _to, uint _value) public returns (bool success); function approve(address _spender, uint _value) public returns (bool success); } contract StreamityEscrow is Ownable, ReentrancyGuard { using SafeMath for uint256; using ECRecovery for bytes32; uint8 constant public STATUS_NO_DEAL = 0x0; uint8 constant public STATUS_DEAL_WAIT_CONFIRMATION = 0x01; uint8 constant public STATUS_DEAL_APPROVE = 0x02; uint8 constant public STATUS_DEAL_RELEASE = 0x03; TokenERC20 public streamityContractAddress; uint256 public availableForWithdrawal; uint32 public requestCancelationTime; mapping(bytes32 => Deal) public streamityTransfers; function StreamityEscrow(address streamityContract) public { owner = msg.sender; requestCancelationTime = 2 hours; streamityContractAddress = TokenERC20(streamityContract); } struct Deal { uint256 value; uint256 cancelTime; address seller; address buyer; uint8 status; uint256 commission; bool isAltCoin; } event StartDealEvent(bytes32 _hashDeal, address _seller, address _buyer); event ApproveDealEvent(bytes32 _hashDeal, address _seller, address _buyer); event ReleasedEvent(bytes32 _hashDeal, address _seller, address _buyer); event SellerCancelEvent(bytes32 _hashDeal, address _seller, address _buyer); function pay(bytes32 _tradeID, address _seller, address _buyer, uint256 _value, uint256 _commission, bytes _sign) external payable { require(msg.value > 0); require(msg.value == _value); require(msg.value > _commission); bytes32 _hashDeal = keccak256(_tradeID, _seller, _buyer, msg.value, _commission); verifyDeal(_hashDeal, _sign); startDealForUser(_hashDeal, _seller, _buyer, _commission, msg.value, false); } function () public payable { availableForWithdrawal = availableForWithdrawal.add(msg.value); } function payAltCoin(bytes32 _tradeID, address _seller, address _buyer, uint256 _value, uint256 _commission, bytes _sign) external { bytes32 _hashDeal = keccak256(_tradeID, _seller, _buyer, _value, _commission); verifyDeal(_hashDeal, _sign); bool result = streamityContractAddress.transferFrom(msg.sender, address(this), _value); require(result == true); startDealForUser(_hashDeal, _seller, _buyer, _commission, _value, true); } function verifyDeal(bytes32 _hashDeal, bytes _sign) private view { require(_hashDeal.recover(_sign) == owner); require(streamityTransfers[_hashDeal].status == STATUS_NO_DEAL); } function startDealForUser(bytes32 _hashDeal, address _seller, address _buyer, uint256 _commission, uint256 _value, bool isAltCoin) private returns(bytes32) { Deal storage userDeals = streamityTransfers[_hashDeal]; userDeals.seller = _seller; userDeals.buyer = _buyer; userDeals.value = _value; userDeals.commission = _commission; userDeals.cancelTime = block.timestamp.add(requestCancelationTime); userDeals.status = STATUS_DEAL_WAIT_CONFIRMATION; userDeals.isAltCoin = isAltCoin; emit StartDealEvent(_hashDeal, _seller, _buyer); return _hashDeal; } function withdrawCommisionToAddress(address _to, uint256 _amount) external onlyOwner { require(_amount <= availableForWithdrawal); availableForWithdrawal = availableForWithdrawal.sub(_amount); _to.transfer(_amount); } function withdrawCommisionToAddressAltCoin(address _to, uint256 _amount) external onlyOwner { streamityContractAddress.transfer(_to, _amount); } function getStatusDeal(bytes32 _hashDeal) external view returns (uint8) { return streamityTransfers[_hashDeal].status; } // _additionalComission is wei uint256 constant GAS_releaseTokens = 60000; function releaseTokens(bytes32 _hashDeal, uint256 _additionalGas) external nonReentrant returns(bool) { Deal storage deal = streamityTransfers[_hashDeal]; if (deal.status == STATUS_DEAL_APPROVE) { deal.status = STATUS_DEAL_RELEASE; bool result = false; if (deal.isAltCoin == false) result = transferMinusComission(deal.buyer, deal.value, deal.commission.add((msg.sender == owner ? (GAS_releaseTokens.add(_additionalGas)).mul(tx.gasprice) : 0))); else result = transferMinusComissionAltCoin(streamityContractAddress, deal.buyer, deal.value, deal.commission); if (result == false) { deal.status = STATUS_DEAL_APPROVE; return false; } emit ReleasedEvent(_hashDeal, deal.seller, deal.buyer); delete streamityTransfers[_hashDeal]; return true; } return false; } function releaseTokensForce(bytes32 _hashDeal) external onlyOwner nonReentrant returns(bool) { Deal storage deal = streamityTransfers[_hashDeal]; uint8 prevStatus = deal.status; if (deal.status != STATUS_NO_DEAL) { deal.status = STATUS_DEAL_RELEASE; bool result = false; if (deal.isAltCoin == false) result = transferMinusComission(deal.buyer, deal.value, deal.commission); else result = transferMinusComissionAltCoin(streamityContractAddress, deal.buyer, deal.value, deal.commission); if (result == false) { deal.status = prevStatus; return false; } emit ReleasedEvent(_hashDeal, deal.seller, deal.buyer); delete streamityTransfers[_hashDeal]; return true; } return false; } uint256 constant GAS_cancelSeller = 30000; function cancelSeller(bytes32 _hashDeal, uint256 _additionalGas) external onlyOwner nonReentrant returns(bool) { Deal storage deal = streamityTransfers[_hashDeal]; if (deal.cancelTime > block.timestamp) return false; if (deal.status == STATUS_DEAL_WAIT_CONFIRMATION) { deal.status = STATUS_DEAL_RELEASE; bool result = false; if (deal.isAltCoin == false) result = transferMinusComission(deal.seller, deal.value, GAS_cancelSeller.add(_additionalGas).mul(tx.gasprice)); else result = transferMinusComissionAltCoin(streamityContractAddress, deal.seller, deal.value, _additionalGas); if (result == false) { deal.status = STATUS_DEAL_WAIT_CONFIRMATION; return false; } emit SellerCancelEvent(_hashDeal, deal.seller, deal.buyer); delete streamityTransfers[_hashDeal]; return true; } return false; } function approveDeal(bytes32 _hashDeal) external onlyOwner nonReentrant returns(bool) { Deal storage deal = streamityTransfers[_hashDeal]; if (deal.status == STATUS_DEAL_WAIT_CONFIRMATION) { deal.status = STATUS_DEAL_APPROVE; emit ApproveDealEvent(_hashDeal, deal.seller, deal.buyer); return true; } return false; } function transferMinusComission(address _to, uint256 _value, uint256 _commission) private returns(bool) { uint256 _totalComission = _commission; require(availableForWithdrawal.add(_totalComission) >= availableForWithdrawal); // Check for overflows availableForWithdrawal = availableForWithdrawal.add(_totalComission); _to.transfer(_value.sub(_totalComission)); return true; } function transferMinusComissionAltCoin(TokenERC20 _contract, address _to, uint256 _value, uint256 _commission) private returns(bool) { uint256 _totalComission = _commission; _contract.transfer(_to, _value.sub(_totalComission)); return true; } function setStreamityContractAddress(address newAddress) external onlyOwner { streamityContractAddress = TokenERC20(newAddress); } // For other Tokens function transferToken(ContractToken _tokenContract, address _transferTo, uint256 _value) onlyOwner external { _tokenContract.transfer(_transferTo, _value); } function transferTokenFrom(ContractToken _tokenContract, address _transferTo, address _transferFrom, uint256 _value) onlyOwner external { _tokenContract.transferFrom(_transferTo, _transferFrom, _value); } function approveToken(ContractToken _tokenContract, address _spender, uint256 _value) onlyOwner external { _tokenContract.approve(_spender, _value); } } "}
{"sol name": "1671.sol", "label": 1, "sol content": "// Ethertote - Official Token Sale Contract // 06.08.18 // // Any unsold tokens can be sent directly to the TokenBurn Contract // by anyone once the Token Sale is complete - // this is a PUBLIC function that anyone can call!! // // All Eth raised during the token sale is automatically sent to the // EthRaised smart contract for distribution pragma solidity ^0.4.24; /////////////////////////////////////////////////////////////////////////////// // SafeMath Library /////////////////////////////////////////////////////////////////////////////// library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // ---------------------------------------------------------------------------- // Imported Token Contract functions // ---------------------------------------------------------------------------- contract EthertoteToken { function thisContractAddress() public pure returns (address) {} function balanceOf(address) public pure returns (uint256) {} function transfer(address, uint) public {} } // ---------------------------------------------------------------------------- // Main Contract // ---------------------------------------------------------------------------- contract TokenSale { using SafeMath for uint256; EthertoteToken public token; address public admin; address public thisContractAddress; // address of the TOTE token original smart contract address public tokenContractAddress = 0x42be9831FFF77972c1D0E1eC0aA9bdb3CaA04D47; // address of TokenBurn contract to \"burn\" unsold tokens // for further details, review the TokenBurn contract and verify code on Etherscan address public tokenBurnAddress = 0xadCa18DC9489C5FE5BdDf1A8a8C2623B66029198; // address of EthRaised contract, that will be used to distribute funds // raised by the token sale. Added as \"wallet address\" address public ethRaisedAddress = 0x9F73D808807c71Af185FEA0c1cE205002c74123C; uint public preIcoPhaseCountdown;       // used for website tokensale uint public icoPhaseCountdown;          // used for website tokensale uint public postIcoPhaseCountdown;      // used for website tokensale // pause token sale in an emergency [true/false] bool public tokenSaleIsPaused; // note the pause time to allow special function to extend closingTime uint public tokenSalePausedTime; // note the resume time uint public tokenSaleResumedTime; // The time (in seconds) that needs to be added on to the closing time // in the event of an emergency pause of the token sale uint public tokenSalePausedDuration; // Amount of wei raised uint256 public weiRaised; // 1000 tokens per Eth - 9,000,000 tokens for sale uint public maxEthRaised = 9000; // Maximum amount of Wei that can be raised // e.g. 9,000,000 tokens for sale with 1000 tokens per 1 eth // means maximum Wei raised would be maxEthRaised * 1000000000000000000 uint public maxWeiRaised = maxEthRaised.mul(1000000000000000000); // starting time and closing time of Crowdsale // scheduled start on Monday, August 27th 2018 at 5:00pm GMT+1 uint public openingTime = 1535990400; uint public closingTime = openingTime.add(7 days); // used as a divider so that 1 eth will buy 1000 tokens // set rate to 1,000,000,000,000,000 uint public rate = 1000000000000000; // minimum and maximum spend of eth per transaction uint public minSpend = 100000000000000000;    // 0.1 Eth uint public maxSpend = 100000000000000000000; // 100 Eth // MODIFIERS modifier onlyAdmin { require(msg.sender == admin ); _; } // EVENTS event Deployed(string, uint); event SalePaused(string, uint); event SaleResumed(string, uint); event TokensBurned(string, uint); // --------------------------------------------------------------------------- // Constructor function // _ethRaisedContract = Address where collected funds will be forwarded to // _tokenContractAddress = Address of the original token contract being sold // --------------------------------------------------------------------------- constructor() public { admin = msg.sender; thisContractAddress = address(this); token = EthertoteToken(tokenContractAddress); require(ethRaisedAddress != address(0)); require(tokenContractAddress != address(0)); require(tokenBurnAddress != address(0)); preIcoPhaseCountdown = openingTime; icoPhaseCountdown = closingTime; // after 14 days the \"post-tokensale\" header section of the homepage // on the website will be removed based on this time postIcoPhaseCountdown = closingTime.add(14 days); emit Deployed(\"Ethertote Token Sale contract deployed\", now); } // check balance of this smart contract function tokenSaleTokenBalance() public view returns(uint) { return token.balanceOf(thisContractAddress); } // check the token balance of any ethereum address function getAnyAddressTokenBalance(address _address) public view returns(uint) { return token.balanceOf(_address); } // confirm if The Token Sale has finished function tokenSaleHasFinished() public view returns (bool) { return now > closingTime; } // this function will send any unsold tokens to the null TokenBurn contract address // once the crowdsale is finished, anyone can publicly call this function! function burnUnsoldTokens() public { require(tokenSaleIsPaused == false); require(tokenSaleHasFinished() == true); token.transfer(tokenBurnAddress, tokenSaleTokenBalance()); emit TokensBurned(\"tokens sent to TokenBurn contract\", now); } // function to temporarily pause token sale if needed function pauseTokenSale() onlyAdmin public { // confirm the token sale hasn't already completed require(tokenSaleHasFinished() == false); // confirm the token sale isn't already paused require(tokenSaleIsPaused == false); // pause the sale and note the time of the pause tokenSaleIsPaused = true; tokenSalePausedTime = now; emit SalePaused(\"token sale has been paused\", now); } // function to resume token sale function resumeTokenSale() onlyAdmin public { // confirm the token sale is currently paused require(tokenSaleIsPaused == true); tokenSaleResumedTime = now; // now calculate the difference in time between the pause time // and the resume time, to establish how long the sale was // paused for. This time now needs to be added to the closingTime. // Note: if the token sale was paused whilst the sale was live and was // paused before the sale ended, then the value of tokenSalePausedTime // will always be less than the value of tokenSaleResumedTime tokenSalePausedDuration = tokenSaleResumedTime.sub(tokenSalePausedTime); // add the total pause time to the closing time. closingTime = closingTime.add(tokenSalePausedDuration); // extend post ICO countdown for the web-site postIcoPhaseCountdown = closingTime.add(14 days); // now resume the token sale tokenSaleIsPaused = false; emit SaleResumed(\"token sale has now resumed\", now); } // ---------------------------------------------------------------------------- // Event for token purchase logging // purchaser = the contract address that paid for the tokens // beneficiary = the address who got the tokens // value = the amount (in Wei) paid for purchase // amount = the amount of tokens purchased // ---------------------------------------------------------------------------- event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- // ---------------------------------------------------------------------------- // fallback function ***DO NOT OVERRIDE*** // allows purchase of tokens directly from MEW and other wallets // will conform to require statements set out in buyTokens() function // ---------------------------------------------------------------------------- function () external payable { buyTokens(msg.sender); } // ---------------------------------------------------------------------------- // function for front-end token purchase on our website ***DO NOT OVERRIDE*** // buyer = Address of the wallet performing the token purchase // ---------------------------------------------------------------------------- function buyTokens(address buyer) public payable { // check Crowdsale is open (can disable for testing) require(openingTime <= block.timestamp); require(block.timestamp < closingTime); // minimum purchase of 100 tokens (0.1 eth) require(msg.value >= minSpend); // maximum purchase per transaction to allow broader // token distribution during tokensale require(msg.value <= maxSpend); // stop sales of tokens if token balance is 0 require(tokenSaleTokenBalance() > 0); // stop sales of tokens if Token sale is paused require(tokenSaleIsPaused == false); // log the amount being sent uint256 weiAmount = msg.value; preValidatePurchase(buyer, weiAmount); // calculate token amount to be sold uint256 tokens = getTokenAmount(weiAmount); // check that the amount of eth being sent by the buyer // does not exceed the equivalent number of tokens remaining require(tokens <= tokenSaleTokenBalance()); // update state weiRaised = weiRaised.add(weiAmount); processPurchase(buyer, tokens); emit TokenPurchase( msg.sender, buyer, weiAmount, tokens ); updatePurchasingState(buyer, weiAmount); forwardFunds(); postValidatePurchase(buyer, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- // ---------------------------------------------------------------------------- // Validation of an incoming purchase // ---------------------------------------------------------------------------- function preValidatePurchase( address buyer, uint256 weiAmount ) internal pure { require(buyer != address(0)); require(weiAmount != 0); } // ---------------------------------------------------------------------------- // Validation of an executed purchase // ---------------------------------------------------------------------------- function postValidatePurchase( address, uint256 ) internal pure { // optional override } // ---------------------------------------------------------------------------- // Source of tokens // ---------------------------------------------------------------------------- function deliverTokens( address buyer, uint256 tokenAmount ) internal { token.transfer(buyer, tokenAmount); } // ---------------------------------------------------------------------------- // The following function is executed when a purchase has been validated // and is ready to be executed // ---------------------------------------------------------------------------- function processPurchase( address buyer, uint256 tokenAmount ) internal { deliverTokens(buyer, tokenAmount); } // ---------------------------------------------------------------------------- // Override for extensions that require an internal state to check for // validity (current user contributions, etc.) // ---------------------------------------------------------------------------- function updatePurchasingState( address, uint256 ) internal pure { // optional override } // ---------------------------------------------------------------------------- // Override to extend the way in which ether is converted to tokens. // _weiAmount Value in wei to be converted into tokens // return Number of tokens that can be purchased with the specified _weiAmount // ---------------------------------------------------------------------------- function getTokenAmount(uint256 weiAmount) internal view returns (uint256) { return weiAmount.div(rate); } // ---------------------------------------------------------------------------- // how ETH is stored/forwarded on purchases. // Sent to the EthRaised Contract // ---------------------------------------------------------------------------- function forwardFunds() internal { ethRaisedAddress.transfer(msg.value); } // functions for tokensale information on the website function maximumRaised() public view returns(uint) { return maxWeiRaised; } function amountRaised() public view returns(uint) { return weiRaised; } function timeComplete() public view returns(uint) { return closingTime; } // special function to delay the token sale if necessary function delayOpeningTime(uint256 _openingTime) onlyAdmin public { openingTime = _openingTime; closingTime = openingTime.add(7 days); preIcoPhaseCountdown = openingTime; icoPhaseCountdown = closingTime; postIcoPhaseCountdown = closingTime.add(14 days); } } "}
{"sol name": "10763.sol", "label": 1, "sol content": "pragma solidity ^0.4.21; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } library DateTime { /* *  Date and Time utilities for ethereum contracts * */ struct MyDateTime { uint16 year; uint8 month; uint8 day; uint8 hour; uint8 minute; uint8 second; uint8 weekday; } uint constant DAY_IN_SECONDS = 86400; uint constant YEAR_IN_SECONDS = 31536000; uint constant LEAP_YEAR_IN_SECONDS = 31622400; uint constant HOUR_IN_SECONDS = 3600; uint constant MINUTE_IN_SECONDS = 60; uint16 constant ORIGIN_YEAR = 1970; function isLeapYear(uint16 year) internal pure returns (bool) { if (year % 4 != 0) { return false; } if (year % 100 != 0) { return true; } if (year % 400 != 0) { return false; } return true; } function leapYearsBefore(uint year) internal pure returns (uint) { year -= 1; return year / 4 - year / 100 + year / 400; } function getDaysInMonth(uint8 month, uint16 year) internal pure returns (uint8) { if (month == 1 || month == 3 || month == 5 || month == 7 || month == 8 || month == 10 || month == 12) { return 31; } else if (month == 4 || month == 6 || month == 9 || month == 11) { return 30; } else if (isLeapYear(year)) { return 29; } else { return 28; } } function parseTimestamp(uint timestamp) internal pure returns (MyDateTime dt) { uint secondsAccountedFor = 0; uint buf; uint8 i; // Year dt.year = getYear(timestamp); buf = leapYearsBefore(dt.year) - leapYearsBefore(ORIGIN_YEAR); secondsAccountedFor += LEAP_YEAR_IN_SECONDS * buf; secondsAccountedFor += YEAR_IN_SECONDS * (dt.year - ORIGIN_YEAR - buf); // Month uint secondsInMonth; for (i = 1; i <= 12; i++) { secondsInMonth = DAY_IN_SECONDS * getDaysInMonth(i, dt.year); if (secondsInMonth + secondsAccountedFor > timestamp) { dt.month = i; break; } secondsAccountedFor += secondsInMonth; } // Day for (i = 1; i <= getDaysInMonth(dt.month, dt.year); i++) { if (DAY_IN_SECONDS + secondsAccountedFor > timestamp) { dt.day = i; break; } secondsAccountedFor += DAY_IN_SECONDS; } // Hour dt.hour = 0;//getHour(timestamp); // Minute dt.minute = 0;//getMinute(timestamp); // Second dt.second = 0;//getSecond(timestamp); // Day of week. dt.weekday = 0;//getWeekday(timestamp); } function getYear(uint timestamp) internal pure returns (uint16) { uint secondsAccountedFor = 0; uint16 year; uint numLeapYears; // Year year = uint16(ORIGIN_YEAR + timestamp / YEAR_IN_SECONDS); numLeapYears = leapYearsBefore(year) - leapYearsBefore(ORIGIN_YEAR); secondsAccountedFor += LEAP_YEAR_IN_SECONDS * numLeapYears; secondsAccountedFor += YEAR_IN_SECONDS * (year - ORIGIN_YEAR - numLeapYears); while (secondsAccountedFor > timestamp) { if (isLeapYear(uint16(year - 1))) { secondsAccountedFor -= LEAP_YEAR_IN_SECONDS; } else { secondsAccountedFor -= YEAR_IN_SECONDS; } year -= 1; } return year; } function getMonth(uint timestamp) internal pure returns (uint8) { return parseTimestamp(timestamp).month; } function getDay(uint timestamp) internal pure returns (uint8) { return parseTimestamp(timestamp).day; } function getHour(uint timestamp) internal pure returns (uint8) { return uint8((timestamp / 60 / 60) % 24); } function getMinute(uint timestamp) internal pure returns (uint8) { return uint8((timestamp / 60) % 60); } function getSecond(uint timestamp) internal pure returns (uint8) { return uint8(timestamp % 60); } function toTimestamp(uint16 year, uint8 month, uint8 day) internal pure returns (uint timestamp) { return toTimestamp(year, month, day, 0, 0, 0); } function toTimestamp(uint16 year, uint8 month, uint8 day, uint8 hour, uint8 minute, uint8 second) internal pure returns (uint timestamp) { uint16 i; // Year for (i = ORIGIN_YEAR; i < year; i++) { if (isLeapYear(i)) { timestamp += LEAP_YEAR_IN_SECONDS; } else { timestamp += YEAR_IN_SECONDS; } } // Month uint8[12] memory monthDayCounts; monthDayCounts[0] = 31; if (isLeapYear(year)) { monthDayCounts[1] = 29; } else { monthDayCounts[1] = 28; } monthDayCounts[2] = 31; monthDayCounts[3] = 30; monthDayCounts[4] = 31; monthDayCounts[5] = 30; monthDayCounts[6] = 31; monthDayCounts[7] = 31; monthDayCounts[8] = 30; monthDayCounts[9] = 31; monthDayCounts[10] = 30; monthDayCounts[11] = 31; for (i = 1; i < month; i++) { timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1]; } // Day timestamp += DAY_IN_SECONDS * (day - 1); // Hour timestamp += HOUR_IN_SECONDS * (hour); // Minute timestamp += MINUTE_IN_SECONDS * (minute); // Second timestamp += second; return timestamp; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Claimable * @dev Extension for the Ownable contract, where the ownership needs to be claimed. * This allows the new owner to accept the transfer. */ contract Claimable is Ownable { address public pendingOwner; /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Helps contracts guard agains reentrancy attacks. * @author Remco Bloemen <[email\u00a0protected]\u03c0.com> * @notice If you mark a function `nonReentrant`, you should also * mark it `external`. */ contract ReentrancyGuard { /** * @dev We use a single lock for the whole contract. */ bool private reentrancyLock = false; /** * @dev Prevents a contract from calling itself, directly or indirectly. * @notice If you mark a function `nonReentrant`, you should also * mark it `external`. Calling one nonReentrant function from * another is not supported. Instead, you can implement a * `private` function doing the actual work, and a `external` * wrapper marked as `nonReentrant`. */ modifier nonReentrant() { require(!reentrancyLock); reentrancyLock = true; _; reentrancyLock = false; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract StandardBurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); return true; } } contract Operational is Claimable { address public operator; function Operational(address _operator) public { operator = _operator; } modifier onlyOperator() { require(msg.sender == operator); _; } function transferOperator(address newOperator) public onlyOwner { require(newOperator != address(0)); operator = newOperator; } } contract Frozenable is Operational, StandardBurnableToken, ReentrancyGuard { using DateTime for uint256; struct FrozenRecord { uint256 value; uint256 unfreezeIndex; } uint256 public frozenBalance; mapping (uint256 => FrozenRecord) public frozenRecords; uint256 mulDecimals = 100000000; // match decimals event SystemFreeze(address indexed owner, uint256 value, uint256 unfreezeIndex); event Unfreeze(address indexed owner, uint256 value, uint256 unfreezeTime); function Frozenable(address _operator) Operational(_operator) public {} // freeze system' balance function systemFreeze(uint256 _value, uint256 _unfreezeTime) internal { uint256 unfreezeIndex = uint256(_unfreezeTime.parseTimestamp().year) * 10000 + uint256(_unfreezeTime.parseTimestamp().month) * 100 + uint256(_unfreezeTime.parseTimestamp().day); balances[owner] = balances[owner].sub(_value); frozenRecords[unfreezeIndex] = FrozenRecord({value: _value, unfreezeIndex: unfreezeIndex}); frozenBalance = frozenBalance.add(_value); emit SystemFreeze(owner, _value, _unfreezeTime); } // unfreeze frozen amount // everyone can call this function to unfreeze balance function unfreeze(uint256 timestamp) public returns (uint256 unfreezeAmount) { require(timestamp <= block.timestamp); uint256 unfreezeIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day); frozenBalance = frozenBalance.sub(frozenRecords[unfreezeIndex].value); balances[owner] = balances[owner].add(frozenRecords[unfreezeIndex].value); unfreezeAmount = frozenRecords[unfreezeIndex].value; emit Unfreeze(owner, unfreezeAmount, timestamp); frozenRecords[unfreezeIndex].value = 0; return unfreezeAmount; } } contract Releaseable is Frozenable { using SafeMath for uint; uint256 public createTime; uint256 public standardReleaseAmount = mulDecimals.mul(512000); // uint256 public releaseAmountPerDay = mulDecimals.mul(512000); uint256 public releasedSupply = 0; event Release(address indexed receiver, uint256 value, uint256 sysAmount, uint256 releaseTime); struct ReleaseRecord { uint256 amount; // release amount uint256 releaseIndex; // release time } mapping (uint256 => ReleaseRecord) public releaseRecords; function Releaseable( address _operator, uint256 _initialSupply ) Frozenable(_operator) public { createTime = 1528732800; releasedSupply = _initialSupply; balances[owner] = _initialSupply; totalSupply_ = mulDecimals.mul(187140000); } function release(uint256 timestamp, uint256 sysAmount) public onlyOperator returns(uint256 _actualRelease) { require(timestamp >= createTime && timestamp <= block.timestamp); require(!checkIsReleaseRecordExist(timestamp)); updateReleaseAmount(timestamp); require(sysAmount <= releaseAmountPerDay.mul(4).div(5)); require(totalSupply_ >= releasedSupply.add(releaseAmountPerDay)); balances[owner] = balances[owner].add(releaseAmountPerDay); releasedSupply = releasedSupply.add(releaseAmountPerDay); uint256 _releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day); releaseRecords[_releaseIndex] = ReleaseRecord(releaseAmountPerDay, _releaseIndex); emit Release(owner, releaseAmountPerDay, sysAmount, timestamp); systemFreeze(sysAmount.div(5), timestamp.add(180 days)); systemFreeze(sysAmount.mul(6).div(10), timestamp.add(200 years)); return releaseAmountPerDay; } // check is release record existed // if existed return true, else return false function checkIsReleaseRecordExist(uint256 timestamp) internal view returns(bool _exist) { bool exist = false; uint256 releaseIndex = uint256(timestamp.parseTimestamp().year) * 10000 + uint256(timestamp.parseTimestamp().month) * 100 + uint256(timestamp.parseTimestamp().day); if (releaseRecords[releaseIndex].releaseIndex == releaseIndex){ exist = true; } return exist; } // update release amount for single day // according to dividend rule in https://coincool.top function updateReleaseAmount(uint256 timestamp) internal { uint256 timeElapse = timestamp.sub(createTime); uint256 cycles = timeElapse.div(180 days); if (cycles > 0) { if (cycles <= 10) { releaseAmountPerDay = standardReleaseAmount; for (uint index = 0; index < cycles; index++) { releaseAmountPerDay = releaseAmountPerDay.div(2); } } else { releaseAmountPerDay = 0; } } } } contract CoinCool is Releaseable { string public standard = '2018061200'; string public name = 'CoolToken'; string public symbol = 'CT'; uint8 public decimals = 8; function CoinCool() Releaseable(0x4068D7c2e286Cb1E72Cef90B74C823E990FaB9C2, mulDecimals.mul(3000000)) public {} } "}
{"sol name": "11448.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; /* \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u255d \u2588\u2588\u2554\u2550\u2550\u255d  \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551     \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2551  \u2588\u2588\u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d     \u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u255d  \u255a\u2550\u255d \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2557   \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2551\u255a\u2550\u2550\u2588\u2588\u2554\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d\u2588\u2588\u2554\u2550\u2550\u2550\u2550\u255d \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2554\u2588\u2588\u2557 \u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2557  \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557 \u2588\u2588\u2551     \u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551   \u2588\u2588\u2551\u2588\u2588\u2551\u255a\u2588\u2588\u2557\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2554\u2550\u2550\u2588\u2588\u2557\u2588\u2588\u2551\u2588\u2588\u2554\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u255a\u2588\u2588\u2588\u2588\u2588\u2588\u2554\u255d\u2588\u2588\u2551 \u255a\u2588\u2588\u2588\u2588\u2551   \u2588\u2588\u2551   \u2588\u2588\u2551  \u2588\u2588\u2551\u2588\u2588\u2551\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2557\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2551 \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u2550\u2550\u2550\u2550\u255d  \u255a\u2550\u2550\u2550\u2550\u2550\u255d \u255a\u2550\u255d  \u255a\u2550\u2550\u2550\u255d   \u255a\u2550\u255d   \u255a\u2550\u255d  \u255a\u2550\u255d\u255a\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u255d \u00a9 2018 SuperCountries \u6240\u6709\u6743 - 4CE434B6058EC7C24889EC2512734B5DBA26E39891C09DF50C3CE3191CE9C51E Xuxuxu - LB - Xufo */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract SuperCountriesEth { using SafeMath for uint256; //////////////////////////// /// \tCONSTRUCTOR\t\t /// //////////////////////////// constructor () public { owner = msg.sender; } address public owner; /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(owner == msg.sender); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); //////////////////////// /// \tEVENTS\t\t /// //////////////////////// event Bought (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Sold (uint256 indexed _itemId, address indexed _owner, uint256 _price); event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event SetReferrerEvent(address indexed referral, address indexed referrer); event PayReferrerEvent(address indexed oldOwner, address indexed referrer1, address indexed referrer2, uint256 referralPart); event BonusConstant(uint256 bonusToDispatch_, uint256 bonusDispatched_, uint256 notYetDispatched_, uint256 indexed _itemSoldId_, uint256 kBonus, uint256 indexed countryScore); event BonusDispatch(uint256 bonusToGet_, uint256 indexed playerScoreForThisCountry_, address indexed player_, uint256 pendingBalanceTotal_, uint256 indexed _itemSoldId); event DivsDispatch(uint256 dividendsCut_, uint256 dividendsScore, uint256 indexed _itemId, uint256 price, uint256 worldScore_); event newRichest(address indexed richest_, uint256 richestScore_, uint256 indexed blocktimestamp_, uint256 indexed blocknumber_); event Withdrawal(address indexed playerAddress, uint256 indexed ethereumWithdrawn, uint256 indexed potVersion_); event ConfirmWithdraw(address indexed playerAddress, uint256 refbonus_, uint256 divs_, uint256 totalPending_, uint256 playerSc_, uint256 _handicap_); event ConfirmPotWithdraw(uint256 contractBalance, address indexed richest_, uint256 richestBalance_, address indexed lastBuyer_, uint256 lastBalance_, uint256 indexed potVersion); event PotWithdrawConstant(uint256 indexed blocktimestamp_, uint256 indexed timestamplimit_, uint256 dividendsScore_, uint256 indexed potVersion, uint256 lastWithdrawPotVersion_); event WithdrawOwner(uint256 indexed potVersion, uint256 indexed lastWithdrawPotVersion_, uint256 indexed balance_); /////////////////////////////////////////// /// \tVARIABLES, MAPPINGS, STRUCTS \t/// /////////////////////////////////////////// bool private erc721Enabled = false; /// Price increase limits uint256 private increaseLimit1 = 0.04 ether; uint256 private increaseLimit2 = 0.6 ether; uint256 private increaseLimit3 = 2.5 ether; uint256 private increaseLimit4 = 7.0 ether; /// All countries uint256[] private listedItems; mapping (uint256 => address) private ownerOfItem; mapping (uint256 => uint256) private priceOfItem; mapping (uint256 => uint256) private previousPriceOfItem; mapping (uint256 => address) private approvedOfItem; /// Referrals and their referrers mapping(address => address) public referrerOf; /// Dividends and score uint256 private worldScore ; /// Worldscore = cumulated price of all owned countries + all spent ethers in this game mapping (address => uint256) private playerScore; /// For each player, the sum of each owned country + the sum of all spent ethers since the beginning of the game uint256 private dividendsScore ; /// Balance of dividends divided by the worldScore mapping(uint256 => mapping(address => uint256)) private pendingBalance; /// Divs from referrals, bonus and dividends calculated after the playerScore change ; if the playerScore didn't change recently, there are some pending divs that can be calculated using dividendsScore and playerScore. The first mapping (uint256) is the jackpot version to use, the value goes up after each pot distribution and the previous pendingBalance are reseted. mapping(uint256 => mapping(address => uint256)) private handicap; /// a player cannot claim a % of all dividends but a % of the cumulated dividends after his join date, this is a handicap mapping(uint256 => mapping(address => uint256)) private balanceToWithdraw; /// A player cannot withdraw pending divs, he must request a withdraw first (pending divs move to balanceToWithdraw) then withdraw. uint256 private potVersion = 1; /// Number of jackpots uint256 private lastWithdrawPotVersion = 1; /// Latest withdraw in the game (pot version) address private richestBuyer ; /// current player with the highest PlayerScore address private lastBuyer ; /// current latest buyer in the game uint256 private timestampLimit = 1528108990; /// after this timestamp, the richestBuyer and the lastBuyer will be allowed to withdraw 1/2 of the contract balance (1/4 each) struct CountryStruct { address[] itemToAddressArray; /// addresses that owned the same country uint256 priceHistory; /// cumulated price of the country uint256 startingPrice; /// starting price of the country } mapping (uint256 => CountryStruct) public countryStructs; mapping (uint256 => mapping(address => uint256)) private itemHistory; /// Store price history (cumulated) for each address for each country uint256 private HUGE = 1e13; //////////////////////////////// /// \tUSEFUL MODIFIER\t\t /// //////////////////////////////// modifier onlyRealAddress() { require(msg.sender != address(0)); _; } //////////////////////////////// /// \tERC721 PRIVILEGES\t /// //////////////////////////////// modifier onlyERC721() { require(erc721Enabled); _; } /** * @dev Unlocks ERC721 behaviour, allowing for trading on third party platforms. */ function enableERC721 () onlyOwner() public { erc721Enabled = true; } /////////////////////////////////// ///\t\tLISTING NEW COUNTRIES \t/// /////////////////////////////////// function listMultipleItems (uint256[] _itemIds, uint256 _price, address _owner) onlyOwner() external { for (uint256 i = 0; i < _itemIds.length; i++) { listItem(_itemIds[i], _price, _owner); } } function listItem (uint256 _itemId, uint256 _price, address _owner) onlyOwner() public { require(_price > 0); require(priceOfItem[_itemId] == 0); require(ownerOfItem[_itemId] == address(0)); ownerOfItem[_itemId] = _owner; priceOfItem[_itemId] = _price; previousPriceOfItem[_itemId] = 0; listedItems.push(_itemId); newEntity(_itemId, _price); } /** * @dev Creates new Struct for a country each time a new country is listed. */ function newEntity(uint256 countryId, uint256 startPrice) private returns(bool success) { countryStructs[countryId].startingPrice = startPrice; return true; } /** * @dev Update the Struc each time a country is sold. * Push the newOwner, update the price history */ function updateEntity(uint256 countryId, address newOwner, uint256 priceUpdate) internal { countryStructs[countryId].priceHistory += priceUpdate; if (itemHistory[countryId][newOwner] == 0 ){ countryStructs[countryId].itemToAddressArray.push(newOwner); } } /////////////////////// /// CALCULATE PRICE /// /////////////////////// function calculateNextPrice (uint256 _price) public view returns (uint256 _nextPrice) { if (_price < increaseLimit1) { return _price.mul(200).div(95); } else if (_price < increaseLimit2) { return _price.mul(160).div(96); } else if (_price < increaseLimit3) { return _price.mul(148).div(97); } else if (_price < increaseLimit4) { return _price.mul(136).div(97); } else { return _price.mul(124).div(98); } } function calculateDevCut (uint256 _price) public view returns (uint256 _devCut) { if (_price < increaseLimit1) { return _price.mul(5).div(100); // 5% } else if (_price < increaseLimit2) { return _price.mul(4).div(100); // 4% } else if (_price < increaseLimit4) { return _price.mul(3).div(100); // 3% } else { return _price.mul(2).div(100); // 2% } } ////////////////////////////// /// BALANCES & WITHDRAWALS /// ////////////////////////////// function getBalance(address _playerAddress) public view returns(uint256 pendingRefBonus_, uint256 pendingFromScore_, uint256 totalPending_, uint256 balanceReadyToWithdraw_, uint256 playerScore_, uint256 handicap_, uint256 dividendsScore_) { uint256 refbonus = pendingBalance[potVersion][_playerAddress]; uint256 playerSc = playerScore[_playerAddress]; uint256 playerHandicap = handicap[potVersion][_playerAddress]; uint256 divs = playerSc.mul(dividendsScore.sub(playerHandicap)).div(HUGE); uint256 totalPending = refbonus.add(divs); uint256 ready = balanceToWithdraw[potVersion][_playerAddress]; return (refbonus, divs, totalPending, ready, playerSc, playerHandicap, dividendsScore); } function getOldBalance(uint256 _potVersion, address _playerAddress) public view returns(uint256 oldPendingRefBonus_, uint256 oldHandicap_, uint256 oldReadyToWithdraw_) { uint256 oldRefBonus = pendingBalance[_potVersion][_playerAddress]; uint256 oldPlayerHandicap = handicap[_potVersion][_playerAddress]; uint256 oldReady = balanceToWithdraw[_potVersion][_playerAddress]; return (oldRefBonus, oldPlayerHandicap, oldReady); } /** * @dev First step to withdraw : players must confirm their pending Divs before withdrawing * this function sums the pending balances (pendingDividends and the pending divs from playerScore) * Then this sum moves to balanceReadyToWithdraw, the player can call the next function and withdraw divs */ function confirmDividends() public onlyRealAddress { require(playerScore[msg.sender] > 0);/// the player exists require (dividendsScore >= handicap[potVersion][msg.sender]); require (dividendsScore >= 0); address _playerAddress = msg.sender; uint256 playerSc = playerScore[_playerAddress]; uint256 handicap_ = handicap[potVersion][_playerAddress]; uint256 refbonus = pendingBalance[potVersion][_playerAddress]; uint256 divs = playerSc.mul(dividendsScore.sub(handicap_)).div(HUGE); uint256 totalPending = refbonus.add(divs); /// Reset the values pendingBalance[potVersion][_playerAddress] = 0; /// Reset the pending balance handicap[potVersion][_playerAddress] = dividendsScore; /// Now the player is ready to withdraw /// balanceToWithdraw[potVersion][_playerAddress] += totalPending; // fire event emit ConfirmWithdraw(_playerAddress, refbonus, divs, totalPending, playerSc, handicap_); } /** * @dev Second step to withdraw : after confirming divs, players can withdraw divs to their wallet */ function withdraw() public onlyRealAddress { require(balanceOf(msg.sender) > 0); require(balanceToWithdraw[potVersion][msg.sender] > 0); address _playerAddress = msg.sender; if (lastWithdrawPotVersion != potVersion){ lastWithdrawPotVersion = potVersion; } /// Add referrals earnings, bonus and divs uint256 divToTransfer = balanceToWithdraw[potVersion][_playerAddress]; balanceToWithdraw[potVersion][_playerAddress] = 0; _playerAddress.transfer(divToTransfer); /// fire event emit Withdrawal(_playerAddress, divToTransfer, potVersion); } /** * @dev After 7 days without any buy, the richest user and the latest player will share the contract balance ! */ function confirmDividendsFromPot() public { require(richestBuyer != address(0) && lastBuyer != address(0)) ; require(address(this).balance > 100000000);\t/// mini 1e8 wei require(block.timestamp > timestampLimit); uint256 confirmation_TimeStamp = timestampLimit; potVersion ++; uint256 balance = address(this).balance; uint256 balanceQuarter = balance.div(4); dividendsScore = 0; /// reset dividends updateTimestampLimit(); /// Reset the timer, if no new buys, the richest and the last buyers will be able to withdraw the left quarter in a week or so balanceToWithdraw[potVersion][richestBuyer] = balanceQuarter; balanceToWithdraw[potVersion][lastBuyer] += balanceQuarter; /// if the richest = last, dividends cumulate // fire events emit ConfirmPotWithdraw( balance, richestBuyer, balanceToWithdraw[potVersion][richestBuyer], lastBuyer, balanceToWithdraw[potVersion][lastBuyer], potVersion ); emit PotWithdrawConstant( block.timestamp, confirmation_TimeStamp, dividendsScore, potVersion, lastWithdrawPotVersion ); } /** * @dev If no new buys occur (dividendsScore = 0) and the richest and latest players don't withdraw their dividends after 3 jackpots, the game can be stuck forever * Prevent from jackpot vicious circle : same dividends are shared between latest and richest users again and again * If the richest and/or the latest player withdraw(s) at least once between 3 jackpots, it means the game is alive * Or if contract balance drops down to 1e8 wei (that means many successful jackpots and that a current withdrawal could cost too much gas for players) */ function withdrawAll() public onlyOwner { require((potVersion > lastWithdrawPotVersion.add(3) && dividendsScore == 0) || (address(this).balance < 100000001) ); require (address(this).balance >0); potVersion ++; updateTimestampLimit(); uint256 balance = address(this).balance; owner.transfer(balance); // fire event emit WithdrawOwner(potVersion, lastWithdrawPotVersion, balance); } /////////////////////////////////////// /// REFERRERS - Setting and payment /// /////////////////////////////////////// /** * @dev Get the referrer of a player. * @param player The address of the player to get the referrer of. */ function getReferrerOf(address player) public view returns (address) { return referrerOf[player]; } /** * @dev Set a referrer. * @param newReferral The address to set the referrer for. * @param referrer The address of the referrer to set. * The referrer must own at least one country to keep his reflink active * Referrals got with an active link are forever, even if all the referrer's countries are sold */ function setReferrer(address newReferral, address referrer) internal { if (getReferrerOf(newReferral) == address(0x0) && newReferral != referrer && balanceOf(referrer) > 0 && playerScore[newReferral] == 0) { /// Set the referrer, if no referrer has been set yet, and the player /// and referrer are not the same address. referrerOf[newReferral] = referrer; /// Emit event. emit SetReferrerEvent(newReferral, referrer); } } /** * @dev Dispatch the referrer bonus when a country is sold * @param referralDivToPay which dividends percentage will be dispatched to refererrs : 0 if no referrer, 2.5% if 1 referrer, 5% if 2 */ function payReferrer (address _oldOwner, uint256 _netProfit) internal returns (uint256 referralDivToPay) { address referrer_1 = referrerOf[_oldOwner]; if (referrer_1 != 0x0) { referralDivToPay = _netProfit.mul(25).div(1000); pendingBalance[potVersion][referrer_1] += referralDivToPay;  /// 2.5% for the first referrer address referrer_2 = referrerOf[referrer_1]; if (referrer_2 != 0x0) { pendingBalance[potVersion][referrer_2] += referralDivToPay;  /// 2.5% for the 2nd referrer referralDivToPay += referralDivToPay; } } emit PayReferrerEvent(_oldOwner, referrer_1, referrer_2, referralDivToPay); return referralDivToPay; } /////////////////////////////////// /// INTERNAL FUNCTIONS WHEN BUY /// /////////////////////////////////// /** * @dev Dispatch dividends to former owners of a country */ function bonusPreviousOwner(uint256 _itemSoldId, uint256 _paidPrice, uint256 _bonusToDispatch) private { require(_bonusToDispatch < (_paidPrice.mul(5).div(100))); require(countryStructs[_itemSoldId].priceHistory > 0); CountryStruct storage c = countryStructs[_itemSoldId]; uint256 countryScore = c.priceHistory; uint256 kBonus = _bonusToDispatch.mul(HUGE).div(countryScore); uint256 bonusDispatched = 0; for (uint256 i = 0; i < c.itemToAddressArray.length && bonusDispatched < _bonusToDispatch ; i++) { address listedBonusPlayer = c.itemToAddressArray[i]; uint256 playerBonusScore = itemHistory[_itemSoldId][listedBonusPlayer]; uint256 bonusToGet = playerBonusScore.mul(kBonus).div(HUGE); if (bonusDispatched.add(bonusToGet) <= _bonusToDispatch) { pendingBalance[potVersion][listedBonusPlayer] += bonusToGet; bonusDispatched += bonusToGet; emitInfo(bonusToGet, playerBonusScore, listedBonusPlayer, pendingBalance[potVersion][listedBonusPlayer], _itemSoldId); } } emit BonusConstant(_bonusToDispatch, bonusDispatched, _bonusToDispatch.sub(bonusDispatched), _itemSoldId, kBonus, countryScore); } function emitInfo(uint256 dividendsToG_, uint256 playerSc_, address player_, uint256 divsBalance_, uint256 itemId_) private { emit BonusDispatch(dividendsToG_, playerSc_, player_, divsBalance_, itemId_); } /** * @dev we need to update the oldOwner and newOwner balances each time a country is sold, their handicap and playerscore will also change * Worldscore and dividendscore : we don't care, it will be updated later. * If accurate, set a new richest player */ function updateScoreAndBalance(uint256 _paidPrice, uint256 _itemId, address _oldOwner, address _newOwner) internal { uint256 _previousPaidPrice = previousPriceOfItem[_itemId]; assert (_paidPrice > _previousPaidPrice); /// OLD OWNER /// uint256 scoreSubHandicap = dividendsScore.sub(handicap[potVersion][_oldOwner]); uint256 playerScore_ = playerScore[_oldOwner]; /// If the old owner is the owner of this contract, we skip this part, the owner of the contract won't get dividends if (_oldOwner != owner && scoreSubHandicap >= 0 && playerScore_ > _previousPaidPrice) { pendingBalance[potVersion][_oldOwner] += playerScore_.mul(scoreSubHandicap).div(HUGE); playerScore[_oldOwner] -= _previousPaidPrice; ///for the oldOwner, the playerScore goes down the previous price handicap[potVersion][_oldOwner] = dividendsScore; /// and setting his handicap to dividendsScore after updating his balance } /// NEW OWNER /// scoreSubHandicap = dividendsScore.sub(handicap[potVersion][_newOwner]); /// Rewrite the var with the newOwner values playerScore_ = playerScore[_newOwner]; /// Rewrite the var playerScore with the newOwner PlayerScore /// If new player, his playerscore = 0, handicap = 0, so the pendingBalance math = 0 if (scoreSubHandicap >= 0) { pendingBalance[potVersion][_newOwner] += playerScore_.mul(scoreSubHandicap).div(HUGE); playerScore[_newOwner] += _paidPrice.mul(2); ///for the newOwner, the playerScore goes up twice the value of the purchase price handicap[potVersion][_newOwner] = dividendsScore; /// and setting his handicap to dividendsScore after updating his balance } /// Change the richest user if this is the case... if (playerScore[_newOwner] > playerScore[richestBuyer]) { richestBuyer = _newOwner; emit newRichest(_newOwner, playerScore[_newOwner], block.timestamp, block.number); } /// Change the last Buyer in any case lastBuyer = _newOwner; } /** * @dev Update the worldScore * After each buy, the worldscore increases : 2x current purchase price - 1x previousPrice */ function updateWorldScore(uint256 _countryId, uint256 _price) internal\t{ worldScore += _price.mul(2).sub(previousPriceOfItem[_countryId]); } /** * @dev Update timestampLimit : the date on which the richest player and the last buyer will be able to share the contract balance (1/4 each) */ function updateTimestampLimit() internal { timestampLimit = block.timestamp.add(604800).add(potVersion.mul(28800)); /// add 7 days + (pot version * X 8hrs) } /** * @dev Refund the buyer if excess */ function excessRefund(address _newOwner, uint256 _price) internal { uint256 excess = msg.value.sub(_price); if (excess > 0) { _newOwner.transfer(excess); } } /////////////////////////// /// \tBUY A COUNTRY \t/// /////////////////////////// /* Buy a country directly from the contract for the calculated price which ensures that the owner gets a profit.  All countries that have been listed can be bought by this method. User funds are sent directly to the previous owner and are never stored in the contract. */ function buy (uint256 _itemId, address referrerAddress) payable public onlyRealAddress { require(priceOf(_itemId) > 0); require(ownerOf(_itemId) != address(0)); require(msg.value >= priceOf(_itemId)); require(ownerOf(_itemId) != msg.sender); require(!isContract(msg.sender)); require(msg.sender != owner); require(block.timestamp < timestampLimit || block.timestamp > timestampLimit.add(3600)); address oldOwner = ownerOf(_itemId); address newOwner = msg.sender; uint256 price = priceOf(_itemId); //////////////////////// /// Set the referrer /// //////////////////////// setReferrer(newOwner, referrerAddress); /////////////////////////////////// /// Update scores and timestamp /// /////////////////////////////////// /// Dividends are dispatched among players accordingly to their \"playerScore\". /// The playerScore equals the sum of all their countries (owned now, paid price) + sum of all their previously owned countries /// After each sell / buy, players that owned at least one country can claim dividends /// DIVS of a player = playerScore * DIVS to dispatch / worldScore /// If a player is a seller or a buyer, his playerScore will change, we need to adjust his parameters /// If a player is not a buyer / seller, his playerScore doesn't change, no need to adjust updateScoreAndBalance(price, _itemId, oldOwner, newOwner); /// worldScore change after each flip, we need to adjust /// To calculate the worldScore after a flip: add buy price x 2, subtract previous price updateWorldScore(_itemId, price); /// If 7 days with no buys, the richest player and the last buyer win the jackpot (1/2 of contract balance ; 1/4 each) /// Waiting time increases after each pot distribution updateTimestampLimit(); /////////////////////// /// Who earns what? /// /////////////////////// /// When a country flips, who earns how much? /// Devs : 2% to 5% of country price /// Seller's reward : current paidPrice - previousPrice - devsCut = net profit. The seller gets the previous Price + ca.65% of net Profit /// The referrers of the seller : % of netProfit from their referrals R+1 & R+2. If no referrers, all the referrers' cut goes to dividends to all players. /// All players, with or without a country now : dividends (% of netProfit) /// All previous owners of the flipped country : a special part of dividends called Bonus. If no previous buyer, all the bonus is also added up to dividends to all players. /// Calculate the devs cut uint256 devCut_ = calculateDevCut(price); /// Calculate the netProfit uint256 netProfit = price.sub(devCut_).sub(previousPriceOfItem[_itemId]); /// Calculate dividends cut from netProfit and what referrers left uint256 dividendsCut_ = netProfit.mul(30).div(100); /// Calculate the seller's reward /// Price sub the cuts : dev cut and 35% including referrer cut (5% max), 30% (25% if referrers) dividends (including 80% divs / 20% bonus max) and 5% (jackpot) uint256 oldOwnerReward = price.sub(devCut_).sub(netProfit.mul(35).div(100)); /// Calculate the referrers cut and store the referrer's cut in the referrer's pending balance /// /// Update dividend's cut : 30% max ; 27,5% if 1 referrer ; 25% if 2 referrers uint256 refCut = payReferrer(oldOwner, netProfit); dividendsCut_ -= refCut; //////////////////////////////////////////////////////////// ///          Dispatch dividends to all players           /// /// Dispatch bonuses to previous owners of this country  /// //////////////////////////////////////////////////////////// /// Dividends = 80% to all country owners (previous and current owners, no matter the country) + 20% bonus to previous owners of this country /// If no previous owners, 100% to all countries owners /// Are there previous owners for the current flipped country? if (price > countryStructs[_itemId].startingPrice && dividendsCut_ > 1000000 && worldScore > 0) { /// Yes, there are previous owners, they will get 20% of dividends of this country bonusPreviousOwner(_itemId, price, dividendsCut_.mul(20).div(100)); /// So dividends for all the country owners are 100% - 20% = 80% dividendsCut_ = dividendsCut_.mul(80).div(100); } /// If else... nothing special to do, there are no previous owners, dividends remain 100% /// Dispatch dividends to all country owners, no matter the country /// Note : to avoid floating numbers, we divide a constant called HUGE (1e13) by worldScore, of course we will multiply by HUGE when retrieving if (worldScore > 0) { /// worldScore must be greater than 0, the opposite is impossible and dividends are not calculated dividendsScore += HUGE.mul(dividendsCut_).div(worldScore); } //////////////////////////////////////////////// /// Update the price history of the newOwner /// //////////////////////////////////////////////// /// The newOwner is now known as an OWNER for this country /// We'll store his cumulated buy price for this country in a mapping /// Bonus : each time a country is flipped, players that previously owned this country get bonuses proportionally to the sum of their buys updateEntity(_itemId, newOwner, price); itemHistory[_itemId][newOwner] += price; //////////////////////// /// Update the price /// //////////////////////// /// The price of purchase becomes the \"previousPrice\", and the \"price\" is the next price previousPriceOfItem[_itemId] = price; priceOfItem[_itemId] = nextPriceOf(_itemId); ///////////////////////////////////////// /// Transfer the reward to the seller /// ///////////////////////////////////////// /// The seller's reward is transfered automatically to his wallet /// The dev cut is transfered automatically out the contract /// The other rewards (bonus, dividends, referrer's cut) will be stored in a pending balance oldOwner.transfer(oldOwnerReward); owner.transfer(devCut_); /// Transfer the token from oldOwner to newOwner _transfer(oldOwner, newOwner, _itemId); /// Emit the events emit Bought(_itemId, newOwner, price); emit Sold(_itemId, oldOwner, price); /////////////////////////////////////////// /// Transfer the excess to the newOwner /// /////////////////////////////////////////// /// If the newOwner sent a higher price than the asked price, the excess is refunded excessRefund(newOwner, price); /// Send informations emit DivsDispatch(dividendsCut_, dividendsScore, _itemId, price, worldScore); /// END OF THE BUY FUNCTION /// } ////////////////////////////// /// Practical informations /// ////////////////////////////// function itemHistoryOfPlayer(uint256 _itemId, address _owner) public view returns (uint256 _valueAddressOne) { return itemHistory[_itemId][_owner]; } function implementsERC721() public view returns (bool _implements) { return erc721Enabled; } function name() public pure returns (string _name) { return \"SuperCountries\"; } function symbol() public pure returns (string _symbol) { return \"SUP\"; } function totalSupply() public view returns (uint256 _totalSupply) { return listedItems.length; } function balanceOf (address _owner) public view returns (uint256 _balance) { uint256 counter = 0; for (uint256 i = 0; i < listedItems.length; i++) { if (ownerOf(listedItems[i]) == _owner) { counter++; } } return counter; } function ownerOf (uint256 _itemId) public view returns (address _owner) { return ownerOfItem[_itemId]; } function tokensOf (address _owner) public view returns (uint256[] _tokenIds) { uint256[] memory items = new uint256[](balanceOf(_owner)); uint256 itemCounter = 0; for (uint256 i = 0; i < listedItems.length; i++) { if (ownerOf(listedItems[i]) == _owner) { items[itemCounter] = listedItems[i]; itemCounter += 1; } } return items; } function tokenExists (uint256 _itemId) public view returns (bool _exists) { return priceOf(_itemId) > 0; } function approvedFor(uint256 _itemId) public view returns (address _approved) { return approvedOfItem[_itemId]; } function approve(address _to, uint256 _itemId) onlyERC721() public { require(msg.sender != _to); require(tokenExists(_itemId)); require(ownerOf(_itemId) == msg.sender); if (_to == 0) { if (approvedOfItem[_itemId] != 0) { delete approvedOfItem[_itemId]; emit Approval(msg.sender, 0, _itemId); } } else { approvedOfItem[_itemId] = _to; emit Approval(msg.sender, _to, _itemId); } } /* Transferring a country to another owner will entitle the new owner the profits from `buy` */ function transfer(address _to, uint256 _itemId) onlyERC721() public { require(msg.sender == ownerOf(_itemId)); _transfer(msg.sender, _to, _itemId); } function transferFrom(address _from, address _to, uint256 _itemId) onlyERC721() public { require(approvedFor(_itemId) == msg.sender); _transfer(_from, _to, _itemId); } function _transfer(address _from, address _to, uint256 _itemId) internal { require(tokenExists(_itemId)); require(ownerOf(_itemId) == _from); require(_to != address(0)); require(_to != address(this)); ownerOfItem[_itemId] = _to; approvedOfItem[_itemId] = 0; emit Transfer(_from, _to, _itemId); } /////////////////////////// /// READ ONLY FUNCTIONS /// /////////////////////////// function gameInfo() public view returns (address richestPlayer_, address lastBuyer_, uint256 thisBalance_, uint256 lastWithdrawPotVersion_, uint256 worldScore_, uint256 potVersion_,  uint256 timestampLimit_) { return (richestBuyer, lastBuyer, address(this).balance, lastWithdrawPotVersion, worldScore, potVersion, timestampLimit); } function priceOf(uint256 _itemId) public view returns (uint256 _price) { return priceOfItem[_itemId]; } function nextPriceOf(uint256 _itemId) public view returns (uint256 _nextPrice) { return calculateNextPrice(priceOf(_itemId)); } function allOf(uint256 _itemId) external view returns (address _owner, uint256 _price, uint256 previous_, uint256 _nextPrice) { return (ownerOf(_itemId), priceOf(_itemId), previousPriceOfItem[_itemId], nextPriceOf(_itemId)); } ///  is Contract /// function isContract(address addr) internal view returns (bool) { uint size; assembly { size := extcodesize(addr) } // solium-disable-line return size > 0; } //////////////////////// /// USEFUL FUNCTIONS /// //////////////////////// /** * @dev Fallback function to accept all ether sent directly to the contract * Nothing is lost, it will raise the jackpot ! */ function() payable public {    } } "}
{"sol name": "8505.sol", "label": 1, "sol content": "/* solium-disable security/no-block-members */ pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title TokenVesting * @dev A token holder contract that can release its token balance gradually like a * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the * owner. */ contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); // beneficiary of tokens after they are released address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; mapping (address => uint256) public released; mapping (address => bool) public revoked; /** * @dev Creates a vesting contract that vests its balance of any ERC20 token to the * _beneficiary, gradually in a linear fashion until _start + _duration. By then all * of the balance will have vested. * @param _beneficiary address of the beneficiary to whom vested tokens are transferred * @param _cliff duration in seconds of the cliff in which tokens will begin to vest * @param _duration duration in seconds of the period in which the tokens will vest * @param _revocable whether the vesting is revocable or not */ constructor( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable ) public { require(_beneficiary != address(0)); require(_cliff <= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; } /** * @notice Transfers vested tokens to beneficiary. * @param token ERC20 token which is being vested */ function release(ERC20Basic token) public { uint256 unreleased = releasableAmount(token); require(unreleased > 0); released[token] = released[token].add(unreleased); token.safeTransfer(beneficiary, unreleased); emit Released(unreleased); } /** * @notice Allows the owner to revoke the vesting. Tokens already vested * remain in the contract, the rest are returned to the owner. * @param token ERC20 token which is being vested */ function revoke(ERC20Basic token) public onlyOwner { require(revocable); require(!revoked[token]); uint256 balance = token.balanceOf(this); uint256 unreleased = releasableAmount(token); uint256 refund = balance.sub(unreleased); revoked[token] = true; token.safeTransfer(owner, refund); emit Revoked(); } /** * @dev Calculates the amount that has already vested but hasn't been released yet. * @param token ERC20 token which is being vested */ function releasableAmount(ERC20Basic token) public view returns (uint256) { return vestedAmount(token).sub(released[token]); } /** * @dev Calculates the amount that has already vested. * @param token ERC20 token which is being vested */ function vestedAmount(ERC20Basic token) public view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); if (block.timestamp < cliff) { return 0; } else if (block.timestamp >= start.add(duration) || revoked[token]) { return totalBalance; } else { return totalBalance.mul(block.timestamp.sub(start)).div(duration); } } } "}
{"sol name": "883.sol", "label": 1, "sol content": "pragma solidity ^0.4.19; library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } } contract RakuRakuEth { using SafeMath for uint256; enum Status { Pending, Requested, Canceled, Paid, Rejected } struct Payment { uint256 amountJpy; uint256 amountWei; uint256 rateEthJpy; uint256 paymentDue; uint256 requestedTime; Status status; //0: pending, 1: requested, 2: canceled, 3: paid, 4: rejected } address public owner; address public creditor; address public debtor; uint256 ethWei = 10**18; Payment[] payments; mapping (address => uint256) balances; modifier onlyCreditor() { require(msg.sender == creditor); _; } modifier onlyDebtor() { require(msg.sender == debtor); _; } modifier onlyStakeholders() { require(msg.sender == debtor || msg.sender == creditor); _; } constructor (address _creditor, address _debtor) public { owner = msg.sender; creditor = _creditor; debtor = _debtor; } // Public Function (anyone can call) function getCurrentTimestamp () external view returns (uint256 timestamp) { return block.timestamp; } function collectPayment(uint256 _index) external returns (bool) { require(payments[_index].status == Status.Requested); require(payments[_index].requestedTime + 24*60*60 < block.timestamp); require(balances[debtor] >= payments[_index].amountWei); balances[debtor] = balances[debtor].sub(payments[_index].amountWei); balances[creditor] = balances[creditor].add(payments[_index].amountWei); payments[_index].status = Status.Paid; return true; } // Function for stakeholders (debtor or creditor) function getBalance(address _address) external view returns (uint256 balance) { return balances[_address]; } function getPayment(uint256 _index) external view returns (uint256 amountJpy, uint256 amountWei, uint256 rateEthJpy, uint256 paymentDue, uint256 requestedTime, Status status) { Payment memory pm = payments[_index]; return (pm.amountJpy, pm.amountWei, pm.rateEthJpy, pm.paymentDue, pm.requestedTime, pm.status); } function getNumPayments() external view returns (uint256 num) { return payments.length; } function withdraw(uint256 _amount) external returns (bool) { require(balances[msg.sender] >= _amount); msg.sender.transfer(_amount); balances[msg.sender] = balances[msg.sender].sub(_amount); return true; } // Functions for creditor function addPayment(uint256 _amountJpy, uint256 _paymentDue) external onlyCreditor returns (uint256 index) { payments.push(Payment(_amountJpy, 0, 0, _paymentDue, 0, Status.Pending)); return payments.length-1; } function requestPayment(uint256 _index, uint256 _rateEthJpy) external onlyCreditor returns (bool) { require(payments[_index].status == Status.Pending || payments[_index].status == Status.Rejected); require(payments[_index].paymentDue <= block.timestamp); payments[_index].rateEthJpy = _rateEthJpy; payments[_index].amountWei = payments[_index].amountJpy.mul(ethWei).div(_rateEthJpy); payments[_index].requestedTime = block.timestamp; payments[_index].status = Status.Requested; return true; } function cancelPayment(uint256 _index) external onlyCreditor returns (bool) { require(payments[_index].status != Status.Paid); payments[_index].status = Status.Canceled; return true; } // Function for debtor function () external payable onlyDebtor { balances[msg.sender] = balances[msg.sender].add(msg.value); } function rejectPayment(uint256 _index) external onlyDebtor returns (bool) { require(payments[_index].status == Status.Requested); require(payments[_index].requestedTime + 24*60*60 > block.timestamp); payments[_index].status = Status.Rejected; return true; } function approvePayment(uint256 _index) external onlyDebtor returns (bool) { require(payments[_index].status == Status.Requested); require(balances[debtor] >= payments[_index].amountWei); balances[debtor] = balances[debtor].sub(payments[_index].amountWei); balances[creditor] = balances[creditor].add(payments[_index].amountWei); payments[_index].status = Status.Paid; return true; } } "}
{"sol name": "7570.sol", "label": 1, "sol content": "pragma solidity ^0.4.18; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statemens to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } contract WhitelistedCrowdsale is Crowdsale, Ownable { mapping(address => bool) public whitelist; /** * @dev Reverts if beneficiary is not whitelisted. Can be used when extending this contract. */ modifier isWhitelisted(address _beneficiary) { require(whitelist[_beneficiary]); _; } /** * @dev Adds single address to whitelist. * @param _beneficiary Address to be added to the whitelist */ function addToWhitelist(address _beneficiary) external onlyOwner { whitelist[_beneficiary] = true; } /** * @dev Adds list of addresses to whitelist. Not overloaded due to limitations with truffle testing. * @param _beneficiaries Addresses to be added to the whitelist */ function addManyToWhitelist(address[] _beneficiaries) external onlyOwner { for (uint256 i = 0; i < _beneficiaries.length; i++) { whitelist[_beneficiaries[i]] = true; } } /** * @dev Removes single address from whitelist. * @param _beneficiary Address to be removed to the whitelist */ function removeFromWhitelist(address _beneficiary) external onlyOwner { whitelist[_beneficiary] = false; } /** * @dev Extend parent behavior requiring beneficiary to be in whitelist. * @param _beneficiary Token beneficiary * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal isWhitelisted(_beneficiary) { super._preValidatePurchase(_beneficiary, _weiAmount); } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract GStarToken is StandardToken, Ownable { using SafeMath for uint256; string public constant name = \"GSTAR Token\"; string public constant symbol = \"GSTAR\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1600000000 * ((10 ** uint256(decimals))); uint256 public currentTotalSupply = 0; event Burn(address indexed burner, uint256 value); /** * @dev Constructor that gives msg.sender all of existing tokens. */ function GStarToken() public { owner = msg.sender; totalSupply_ = INITIAL_SUPPLY; balances[owner] = INITIAL_SUPPLY; currentTotalSupply = INITIAL_SUPPLY; emit Transfer(address(0), owner, INITIAL_SUPPLY); } /** * @dev Burns a specific amount of tokens. * @param value The amount of token to be burned. */ function burn(uint256 value) public onlyOwner { require(value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(value); currentTotalSupply = currentTotalSupply.sub(value); emit Burn(burner, value); } } /** * @title GStarCrowdsale * @dev This contract manages the crowdsale of GStar Tokens. * The crowdsale will involve two key timings - Start and ending of funding. * The earlier the contribution, the larger the bonuses. (according to the bonus structure) * Tokens will be released to the contributors after the crowdsale. * There is only one owner at any one time. The owner can stop or start the crowdsale at anytime. */ contract GStarCrowdsale is WhitelistedCrowdsale { using SafeMath for uint256; // Start and end timestamps where contributions are allowed (both inclusive) // All timestamps are expressed in seconds instead of block number. uint256 constant public presaleStartTime = 1531051200; // 8 Jul 2018 1200h uint256 constant public startTime = 1532260800; // 22 Jul 2018 1200h uint256 constant public endTime = 1534593600; // 18 Aug 2018 1200h // Keeps track of contributors tokens mapping (address => uint256) public depositedTokens; // Minimum amount of ETH contribution during ICO period // Minimum of ETH contributed during ICO is 0.1ETH uint256 constant public MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI = 1 ether; uint256 constant public MINIMUM_PURCHASE_AMOUNT_IN_WEI = 0.1 ether; // Total tokens raised so far, bonus inclusive uint256 public tokensWeiRaised = 0; //Funding goal is 76,000 ETH, includes private contributions uint256 constant public fundingGoal = 76000 ether; uint256 constant public presaleFundingGoal = 1000 ether; bool public fundingGoalReached = false; bool public presaleFundingGoalReached = false; //private contributions uint256 public privateContribution = 0; // Indicates if crowdsale is active bool public crowdsaleActive = false; bool public isCrowdsaleClosed = false; uint256 public tokensReleasedAmount = 0; /*==================================================================== */ /*============================== EVENTS ============================== */ /*==================================================================== */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event GoalReached(uint256 totalEtherAmountRaised); event PresaleGoalReached(uint256 totalEtherAmountRaised); event StartCrowdsale(); event StopCrowdsale(); event ReleaseTokens(address[] _beneficiaries); event Close(); /** * @dev Constructor. Checks validity of the time entered. */ function GStarCrowdsale ( uint256 _rate, address _wallet, GStarToken token ) public Crowdsale(_rate, _wallet, token) { } /*==================================================================== */ /*========================= PUBLIC FUNCTIONS ========================= */ /*==================================================================== */ /** * @dev Override buyTokens function as tokens should only be delivered when released. * @param _beneficiary Address receiving the tokens. */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _processPurchase(_beneficiary, weiAmount); } /** * @dev Calculates the token amount per ETH contributed based on the time now. * @return Rate of amount of GSTAR per Ether as of current time. */ function getRate() public view returns (uint256) { //calculate bonus based on timing if (block.timestamp <= startTime) { return ((rate / 100) * 120); } // 20 percent bonus on presale period, returns 12000 if (block.timestamp <= startTime.add(1 days)) {return ((rate / 100) * 108);} // 8 percent bonus on day one, return 10800 return rate; } /*==================================================================== */ /*======================== EXTERNAL FUNCTIONS ======================== */ /*==================================================================== */ /** * @dev Change the private contribution, in ether, wei units. * Private contribution amount will be calculated into funding goal. */ function changePrivateContribution(uint256 etherWeiAmount) external onlyOwner { privateContribution = etherWeiAmount; } /** * @dev Allows owner to start/unpause crowdsale. */ function startCrowdsale() external onlyOwner { require(!crowdsaleActive); require(!isCrowdsaleClosed); crowdsaleActive = true; emit StartCrowdsale(); } /** * @dev Allows owner to stop/pause crowdsale. */ function stopCrowdsale() external onlyOwner { require(crowdsaleActive); crowdsaleActive = false; emit StopCrowdsale(); } /** * @dev Release tokens to multiple addresses. * @param contributors Addresses to release tokens to */ function releaseTokens(address[] contributors) external onlyOwner { for (uint256 j = 0; j < contributors.length; j++) { // the amount of tokens to be distributed to contributor uint256 tokensAmount = depositedTokens[contributors[j]]; if (tokensAmount > 0) { super._deliverTokens(contributors[j], tokensAmount); depositedTokens[contributors[j]] = 0; //update state of release tokensReleasedAmount = tokensReleasedAmount.add(tokensAmount); } } } /** * @dev Stops crowdsale and release of tokens. Transfer remainining tokens back to owner. */ function close() external onlyOwner { crowdsaleActive = false; isCrowdsaleClosed = true; token.transfer(owner, token.balanceOf(address(this))); emit Close(); } /*==================================================================== */ /*======================== INTERNAL FUNCTIONS ======================== */ /*==================================================================== */ /** * @dev Overrides _preValidatePurchase function in Crowdsale. * Requires purchase is made within crowdsale period. * Requires contributor to be the beneficiary. * Requires purchase value and address to be non-zero. * Requires amount not to exceed funding goal. * Requires purchase value to be higher or equal to minimum amount. * Requires contributor to be whitelisted. */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { bool withinPeriod = now >= presaleStartTime && now <= endTime; bool atLeastMinimumAmount = false; if(block.timestamp <= startTime) { // during presale period require(_weiAmount.add(weiRaised.add(privateContribution)) <= presaleFundingGoal); atLeastMinimumAmount = _weiAmount >= MINIMUM_PRESALE_PURCHASE_AMOUNT_IN_WEI; } else { // during funding period atLeastMinimumAmount = _weiAmount >= MINIMUM_PURCHASE_AMOUNT_IN_WEI; } super._preValidatePurchase(_beneficiary, _weiAmount); require(msg.sender == _beneficiary); require(_weiAmount.add(weiRaised.add(privateContribution)) <= fundingGoal); require(withinPeriod); require(atLeastMinimumAmount); require(crowdsaleActive); } /** * @dev Overrides _getTokenAmount function in Crowdsale. * Calculates token amount, inclusive of bonus, based on ETH contributed. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(getRate()); } /** * @dev Overrides _updatePurchasingState function from Crowdsale. * Updates tokenWeiRaised amount and funding goal status. */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { tokensWeiRaised = tokensWeiRaised.add(_getTokenAmount(_weiAmount)); _updateFundingGoal(); } /** * @dev Overrides _processPurchase function from Crowdsale. * Adds the tokens purchased to the beneficiary. * @param _tokenAmount The token amount in wei before multiplied by the rate. */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { depositedTokens[_beneficiary] = depositedTokens[_beneficiary].add(_getTokenAmount(_tokenAmount)); } /** * @dev Updates fundingGoal status. */ function _updateFundingGoal() internal { if (weiRaised.add(privateContribution) >= fundingGoal) { fundingGoalReached = true; emit GoalReached(weiRaised.add(privateContribution)); } if(block.timestamp <= startTime) { if(weiRaised.add(privateContribution) >= presaleFundingGoal) { presaleFundingGoalReached = true; emit PresaleGoalReached(weiRaised.add(privateContribution)); } } } } "}
{"sol name": "9379.sol", "label": 1, "sol content": "//File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol pragma solidity ^0.4.23; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } //File: node_modules\\openzeppelin-solidity\\contracts\\lifecycle\\Pausable.sol pragma solidity ^0.4.23; /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol pragma solidity ^0.4.23; /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\SafeERC20.sol pragma solidity ^0.4.23; /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } //File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\CanReclaimToken.sol pragma solidity ^0.4.23; /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } //File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } //File: contracts\\ico\\KYCBase.sol pragma solidity ^0.4.24; // Abstract base contract contract KYCBase { using SafeMath for uint256; mapping (address => bool) public isKycSigner; mapping (uint64 => uint256) public alreadyPayed; event KycVerified(address indexed signer, address buyerAddress, uint64 buyerId, uint maxAmount); constructor(address[] kycSigners) internal { for (uint i = 0; i < kycSigners.length; i++) { isKycSigner[kycSigners[i]] = true; } } // Must be implemented in descending contract to assign tokens to the buyers. Called after the KYC verification is passed function releaseTokensTo(address buyer) internal returns(bool); // This method can be overridden to enable some sender to buy token for a different address function senderAllowedFor(address buyer) internal view returns(bool) { return buyer == msg.sender; } function buyTokensFor(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { require(senderAllowedFor(buyerAddress)); return buyImplementation(buyerAddress, buyerId, maxAmount, v, r, s); } function buyTokens(uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) public payable returns (bool) { return buyImplementation(msg.sender, buyerId, maxAmount, v, r, s); } function buyImplementation(address buyerAddress, uint64 buyerId, uint maxAmount, uint8 v, bytes32 r, bytes32 s) private returns (bool) { // check the signature bytes32 hash = sha256(abi.encodePacked(\"Eidoo icoengine authorization\", this, buyerAddress, buyerId, maxAmount)); address signer = ecrecover(hash, v, r, s); if (!isKycSigner[signer]) { revert(); } else { uint256 totalPayed = alreadyPayed[buyerId].add(msg.value); require(totalPayed <= maxAmount); alreadyPayed[buyerId] = totalPayed; emit KycVerified(signer, buyerAddress, buyerId, maxAmount); return releaseTokensTo(buyerAddress); } } // No payable fallback function, the tokens must be buyed using the functions buyTokens and buyTokensFor function () public { revert(); } } //File: contracts\\ico\\ICOEngineInterface.sol pragma solidity ^0.4.24; contract ICOEngineInterface { // false if the ico is not started, true if the ico is started and running, true if the ico is completed function started() public view returns(bool); // false if the ico is not started, false if the ico is started and running, true if the ico is completed function ended() public view returns(bool); // time stamp of the starting time of the ico, must return 0 if it depends on the block number function startTime() public view returns(uint); // time stamp of the ending time of the ico, must retrun 0 if it depends on the block number function endTime() public view returns(uint); // Optional function, can be implemented in place of startTime // Returns the starting block number of the ico, must return 0 if it depends on the time stamp // function startBlock() public view returns(uint); // Optional function, can be implemented in place of endTime // Returns theending block number of the ico, must retrun 0 if it depends on the time stamp // function endBlock() public view returns(uint); // returns the total number of the tokens available for the sale, must not change when the ico is started function totalTokens() public view returns(uint); // returns the number of the tokens available for the ico. At the moment that the ico starts it must be equal to totalTokens(), // then it will decrease. It is used to calculate the percentage of sold tokens as remainingTokens() / totalTokens() function remainingTokens() public view returns(uint); // return the price as number of tokens released for each ether function price() public view returns(uint); } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol pragma solidity ^0.4.23; /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol pragma solidity ^0.4.23; /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\MintableToken.sol pragma solidity ^0.4.23; /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\PausableToken.sol pragma solidity ^0.4.23; /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } //File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BurnableToken.sol pragma solidity ^0.4.23; /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } //File: contracts\\ico\\GotToken.sol /** * @title ParkinGO token * * @version 1.0 * @author ParkinGO */ pragma solidity ^0.4.24; contract GotToken is CanReclaimToken, MintableToken, PausableToken, BurnableToken { string public constant name = \"GOToken\"; string public constant symbol = \"GOT\"; uint8 public constant decimals = 18; /** * @dev Constructor of GotToken that instantiates a new Mintable Pausable Token */ constructor() public { // token should not be transferable until after all tokens have been issued paused = true; } } //File: contracts\\ico\\PGOVault.sol /** * @title PGOVault * @dev A token holder contract that allows the release of tokens to the ParkinGo Wallet. * * @version 1.0 * @author ParkinGo */ pragma solidity ^0.4.24; contract PGOVault { using SafeMath for uint256; using SafeERC20 for GotToken; uint256[4] public vesting_offsets = [ 360 days, 540 days, 720 days, 900 days ]; uint256[4] public vesting_amounts = [ 0.875e7 * 1e18, 0.875e7 * 1e18, 0.875e7 * 1e18, 0.875e7 * 1e18 ]; address public pgoWallet; GotToken public token; uint256 public start; uint256 public released; uint256 public vestingOffsetsLength = vesting_offsets.length; /** * @dev Constructor. * @param _pgoWallet The address that will receive the vested tokens. * @param _token The GOT Token, which is being vested. * @param _start The start time from which each release time will be calculated. */ constructor( address _pgoWallet, address _token, uint256 _start ) public { pgoWallet = _pgoWallet; token = GotToken(_token); start = _start; } /** * @dev Transfers vested tokens to ParkinGo Wallet. */ function release() public { uint256 unreleased = releasableAmount(); require(unreleased > 0); released = released.add(unreleased); token.safeTransfer(pgoWallet, unreleased); } /** * @dev Calculates the amount that has already vested but hasn't been released yet. */ function releasableAmount() public view returns (uint256) { return vestedAmount().sub(released); } /** * @dev Calculates the amount that has already vested. */ function vestedAmount() public view returns (uint256) { uint256 vested = 0; for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) { if (block.timestamp > start.add(vesting_offsets[i])) { vested = vested.add(vesting_amounts[i]); } } return vested; } /** * @dev Calculates the amount that has not yet released. */ function unreleasedAmount() public view returns (uint256) { uint256 unreleased = 0; for (uint256 i = 0; i < vestingOffsetsLength; i = i.add(1)) { unreleased = unreleased.add(vesting_amounts[i]); } return unreleased.sub(released); } } //File: contracts\\ico\\PGOMonthlyInternalVault.sol /** * @title PGOMonthlyVault * @dev A token holder contract that allows the release of tokens after a vesting period. * * @version 1.0 * @author ParkinGO */ pragma solidity ^0.4.24; contract PGOMonthlyInternalVault { using SafeMath for uint256; using SafeERC20 for GotToken; struct Investment { address beneficiary; uint256 totalBalance; uint256 released; } /*** CONSTANTS ***/ uint256 public constant VESTING_DIV_RATE = 21;                  // division rate of monthly vesting uint256 public constant VESTING_INTERVAL = 30 days;             // vesting interval uint256 public constant VESTING_CLIFF = 90 days;                // duration until cliff is reached uint256 public constant VESTING_DURATION = 720 days;            // vesting duration GotToken public token; uint256 public start; uint256 public end; uint256 public cliff; //Investment[] public investments; // key: investor address; value: index in investments array. //mapping(address => uint256) public investorLUT; mapping(address => Investment) public investments; /** * @dev Function to be fired by the initPGOMonthlyInternalVault function from the GotCrowdSale contract to set the * InternalVault's state after deployment. * @param beneficiaries Array of the internal investors addresses to whom vested tokens are transferred. * @param balances Array of token amount per beneficiary. * @param startTime Start time at which the first released will be executed, and from which the cliff for second * release is calculated. * @param _token The address of the GOT Token. */ function init(address[] beneficiaries, uint256[] balances, uint256 startTime, address _token) public { // makes sure this function is only called once require(token == address(0)); require(beneficiaries.length == balances.length); start = startTime; cliff = start.add(VESTING_CLIFF); end = start.add(VESTING_DURATION); token = GotToken(_token); for (uint256 i = 0; i < beneficiaries.length; i = i.add(1)) { investments[beneficiaries[i]] = Investment(beneficiaries[i], balances[i], 0); } } /** * @dev Allows a sender to transfer vested tokens to the beneficiary's address. * @param beneficiary The address that will receive the vested tokens. */ function release(address beneficiary) public { uint256 unreleased = releasableAmount(beneficiary); require(unreleased > 0); investments[beneficiary].released = investments[beneficiary].released.add(unreleased); token.safeTransfer(beneficiary, unreleased); } /** * @dev Transfers vested tokens to the sender's address. */ function release() public { release(msg.sender); } /** * @dev Allows to check an investment. * @param beneficiary The address of the beneficiary of the investment to check. */ function getInvestment(address beneficiary) public view returns(address, uint256, uint256) { return ( investments[beneficiary].beneficiary, investments[beneficiary].totalBalance, investments[beneficiary].released ); } /** * @dev Calculates the amount that has already vested but hasn't been released yet. * @param beneficiary The address that will receive the vested tokens. */ function releasableAmount(address beneficiary) public view returns (uint256) { return vestedAmount(beneficiary).sub(investments[beneficiary].released); } /** * @dev Calculates the amount that has already vested. * @param beneficiary The address that will receive the vested tokens. */ function vestedAmount(address beneficiary) public view returns (uint256) { uint256 vested = 0; if (block.timestamp >= cliff && block.timestamp < end) { // after cliff -> 1/21 of totalBalance every month, must skip first 3 months uint256 totalBalance = investments[beneficiary].totalBalance; uint256 monthlyBalance = totalBalance.div(VESTING_DIV_RATE); uint256 time = block.timestamp.sub(cliff); uint256 elapsedOffsets = time.div(VESTING_INTERVAL); uint256 vestedToSum = elapsedOffsets.mul(monthlyBalance); vested = vested.add(vestedToSum); } if (block.timestamp >= end) { // after end -> all vested vested = investments[beneficiary].totalBalance; } return vested; } } //File: contracts\\ico\\PGOMonthlyPresaleVault.sol /** * @title PGOMonthlyVault * @dev A token holder contract that allows the release of tokens after a vesting period. * * @version 1.0 * @author ParkinGO */ pragma solidity ^0.4.24; contract PGOMonthlyPresaleVault is PGOMonthlyInternalVault { /** * @dev OVERRIDE vestedAmount from PGOMonthlyInternalVault * Calculates the amount that has already vested, release 1/3 of token immediately. * @param beneficiary The address that will receive the vested tokens. */ function vestedAmount(address beneficiary) public view returns (uint256) { uint256 vested = 0; if (block.timestamp >= start) { // after start -> 1/3 released (fixed) vested = investments[beneficiary].totalBalance.div(3); } if (block.timestamp >= cliff && block.timestamp < end) { // after cliff -> 1/27 of totalBalance every month, must skip first 9 month uint256 unlockedStartBalance = investments[beneficiary].totalBalance.div(3); uint256 totalBalance = investments[beneficiary].totalBalance; uint256 lockedBalance = totalBalance.sub(unlockedStartBalance); uint256 monthlyBalance = lockedBalance.div(VESTING_DIV_RATE); uint256 daysToSkip = 90 days; uint256 time = block.timestamp.sub(start).sub(daysToSkip); uint256 elapsedOffsets = time.div(VESTING_INTERVAL); vested = vested.add(elapsedOffsets.mul(monthlyBalance)); } if (block.timestamp >= end) { // after end -> all vested vested = investments[beneficiary].totalBalance; } return vested; } } //File: contracts\\ico\\GotCrowdSale.sol /** * @title GotCrowdSale * * @version 1.0 * @author ParkinGo */ pragma solidity ^0.4.24; contract GotCrowdSale is Pausable, CanReclaimToken, ICOEngineInterface, KYCBase { /*** CONSTANTS ***/ uint256 public constant START_TIME = 1529416800; //uint256 public constant START_TIME = 1529416800;                     // 19 June 2018 14:00:00 GMT uint256 public constant END_TIME = 1530655140;                       // 03 July 2018 21:59:00 GMT //uint256 public constant USD_PER_TOKEN = 75;                          // 0.75$ //uint256 public constant USD_PER_ETHER = 60000;                       // REMEMBER TO CHANGE IT AT ICO START uint256 public constant TOKEN_PER_ETHER = 740;                       // REMEMBER TO CHANGE IT AT ICO START //Token allocation //Team, founder, partners and advisor cap locked using Monthly Internal Vault uint256 public constant MONTHLY_INTERNAL_VAULT_CAP = 2.85e7 * 1e18; //Company unlocked liquidity and Airdrop allocation uint256 public constant PGO_UNLOCKED_LIQUIDITY_CAP = 1.5e7 * 1e18; //Internal reserve fund uint256 public constant PGO_INTERNAL_RESERVE_CAP = 3.5e7 * 1e18; //Reserved Presale Allocation 33% free and 67% locked using Monthly Presale Vault uint256 public constant RESERVED_PRESALE_CAP = 1.5754888e7 * 1e18; //ICO TOKEN ALLOCATION //Public ICO Cap //uint256 public constant CROWDSALE_CAP = 0.15e7 * 1e18; //Reservation contract Cap uint256 public constant RESERVATION_CAP = 0.4297111e7 * 1e18; //TOTAL ICO CAP uint256 public constant TOTAL_ICO_CAP = 0.5745112e7 * 1e18; uint256 public start;                                             // ICOEngineInterface uint256 public end;                                               // ICOEngineInterface uint256 public cap;                                               // ICOEngineInterface uint256 public tokenPerEth; uint256 public availableTokens;                                   // ICOEngineInterface address[] public kycSigners;                                      // KYCBase bool public capReached; uint256 public weiRaised; uint256 public tokensSold; // Vesting contracts. //Unlock funds after 9 months monthly PGOMonthlyInternalVault public pgoMonthlyInternalVault; //Unlock 1/3 funds immediately and remaining after 9 months monthly PGOMonthlyPresaleVault public pgoMonthlyPresaleVault; //Unlock funds after 12 months 25% every 6 months PGOVault public pgoVault; // Vesting wallets. address public pgoInternalReserveWallet; //Unlocked wallets address public pgoUnlockedLiquidityWallet; //ether wallet address public wallet; GotToken public token; // Lets owner manually end crowdsale. bool public didOwnerEndCrowdsale; /** * @dev Constructor. * @param _token address contract got tokens. * @param _wallet The address where funds should be transferred. * @param _pgoInternalReserveWallet The address where token will be send after vesting should be transferred. * @param _pgoUnlockedLiquidityWallet The address where token will be send after vesting should be transferred. * @param _pgoMonthlyInternalVault The address of internal funds vault contract with monthly unlocking after 9 months. * @param _pgoMonthlyPresaleVault The address of presale funds vault contract with 1/3 free funds and monthly unlocking after 9 months. * @param _kycSigners Array of the signers addresses required by the KYCBase constructor, provided by Eidoo. * See https://github.com/eidoo/icoengine */ constructor( address _token, address _wallet, address _pgoInternalReserveWallet, address _pgoUnlockedLiquidityWallet, address _pgoMonthlyInternalVault, address _pgoMonthlyPresaleVault, address[] _kycSigners ) public KYCBase(_kycSigners) { require(END_TIME >= START_TIME); require(TOTAL_ICO_CAP > 0); start = START_TIME; end = END_TIME; cap = TOTAL_ICO_CAP; wallet = _wallet; tokenPerEth = TOKEN_PER_ETHER;// USD_PER_ETHER.div(USD_PER_TOKEN); availableTokens = TOTAL_ICO_CAP; kycSigners = _kycSigners; token = GotToken(_token); pgoMonthlyInternalVault = PGOMonthlyInternalVault(_pgoMonthlyInternalVault); pgoMonthlyPresaleVault = PGOMonthlyPresaleVault(_pgoMonthlyPresaleVault); pgoInternalReserveWallet = _pgoInternalReserveWallet; pgoUnlockedLiquidityWallet = _pgoUnlockedLiquidityWallet; wallet = _wallet; // Creates ParkinGo vault contract pgoVault = new PGOVault(pgoInternalReserveWallet, address(token), END_TIME); } /** * @dev Mints unlocked tokens to unlockedLiquidityWallet and * assings tokens to be held into the internal reserve vault contracts. * To be called by the crowdsale's owner only. */ function mintPreAllocatedTokens() public onlyOwner { mintTokens(pgoUnlockedLiquidityWallet, PGO_UNLOCKED_LIQUIDITY_CAP); mintTokens(address(pgoVault), PGO_INTERNAL_RESERVE_CAP); } /** * @dev Sets the state of the internal monthly locked vault contract and mints tokens. * It will contains all TEAM, FOUNDER, ADVISOR and PARTNERS tokens. * All token are locked for the first 9 months and then unlocked monthly. * It will check that all internal token are correctly allocated. * So far, the internal monthly vault contract has been deployed and this function * needs to be called to set its investments and vesting conditions. * @param beneficiaries Array of the internal addresses to whom vested tokens are transferred. * @param balances Array of token amount per beneficiary. */ function initPGOMonthlyInternalVault(address[] beneficiaries, uint256[] balances) public onlyOwner equalLength(beneficiaries, balances) { uint256 totalInternalBalance = 0; uint256 balancesLength = balances.length; for (uint256 i = 0; i < balancesLength; i++) { totalInternalBalance = totalInternalBalance.add(balances[i]); } //check that all balances matches internal vault allocated Cap require(totalInternalBalance == MONTHLY_INTERNAL_VAULT_CAP); pgoMonthlyInternalVault.init(beneficiaries, balances, END_TIME, token); mintTokens(address(pgoMonthlyInternalVault), MONTHLY_INTERNAL_VAULT_CAP); } /** * @dev Sets the state of the reserved presale vault contract and mints reserved presale tokens. * It will contains all reserved PRESALE token, * 1/3 of tokens are free and the remaining are locked for the first 9 months and then unlocked monthly. * It will check that all reserved presale token are correctly allocated. * So far, the monthly presale vault contract has been deployed and * this function needs to be called to set its investments and vesting conditions. * @param beneficiaries Array of the presale investors addresses to whom vested tokens are transferred. * @param balances Array of token amount per beneficiary. */ function initPGOMonthlyPresaleVault(address[] beneficiaries, uint256[] balances) public onlyOwner equalLength(beneficiaries, balances) { uint256 totalPresaleBalance = 0; uint256 balancesLength = balances.length; for (uint256 i = 0; i < balancesLength; i++) { totalPresaleBalance = totalPresaleBalance.add(balances[i]); } //check that all balances matches internal vault allocated Cap require(totalPresaleBalance == RESERVED_PRESALE_CAP); pgoMonthlyPresaleVault.init(beneficiaries, balances, END_TIME, token); mintTokens(address(pgoMonthlyPresaleVault), totalPresaleBalance); } /** * @dev Mint all token collected by second private presale (called reservation), * all KYC control are made outside contract under responsability of ParkinGO. * Also, updates tokensSold and availableTokens in the crowdsale contract, * it checks that sold token are less than reservation contract cap. * @param beneficiaries Array of the reservation user that bought tokens in private reservation sale. * @param balances Array of token amount per beneficiary. */ function mintReservation(address[] beneficiaries, uint256[] balances) public onlyOwner equalLength(beneficiaries, balances) { //require(tokensSold == 0); uint256 totalReservationBalance = 0; uint256 balancesLength = balances.length; for (uint256 i = 0; i < balancesLength; i++) { totalReservationBalance = totalReservationBalance.add(balances[i]); uint256 amount = balances[i]; //update token sold of crowdsale contract tokensSold = tokensSold.add(amount); //update available token of crowdsale contract availableTokens = availableTokens.sub(amount); mintTokens(beneficiaries[i], amount); } require(totalReservationBalance <= RESERVATION_CAP); } /** * @dev Allows the owner to close the crowdsale manually before the end time. */ function closeCrowdsale() public onlyOwner { require(block.timestamp >= START_TIME && block.timestamp < END_TIME); didOwnerEndCrowdsale = true; } /** * @dev Allows the owner to unpause tokens, stop minting and transfer ownership of the token contract. */ function finalise() public onlyOwner { require(didOwnerEndCrowdsale || block.timestamp > end || capReached); token.finishMinting(); token.unpause(); // Token contract extends CanReclaimToken so the owner can recover // any ERC20 token received in this contract by mistake. // So far, the owner of the token contract is the crowdsale contract. // We transfer the ownership so the owner of the crowdsale is also the owner of the token. token.transferOwnership(owner); } /** * @dev Implements the price function from EidooEngineInterface. * @notice Calculates the price as tokens/ether based on the corresponding bonus bracket. * @return Price as tokens/ether. */ function price() public view returns (uint256 _price) { return tokenPerEth; } /** * @dev Implements the ICOEngineInterface. * @return False if the ico is not started, true if the ico is started and running, true if the ico is completed. */ function started() public view returns(bool) { if (block.timestamp >= start) { return true; } else { return false; } } /** * @dev Implements the ICOEngineInterface. * @return False if the ico is not started, false if the ico is started and running, true if the ico is completed. */ function ended() public view returns(bool) { if (block.timestamp >= end) { return true; } else { return false; } } /** * @dev Implements the ICOEngineInterface. * @return Timestamp of the ico start time. */ function startTime() public view returns(uint) { return start; } /** * @dev Implements the ICOEngineInterface. * @return Timestamp of the ico end time. */ function endTime() public view returns(uint) { return end; } /** * @dev Implements the ICOEngineInterface. * @return The total number of the tokens available for the sale, must not change when the ico is started. */ function totalTokens() public view returns(uint) { return cap; } /** * @dev Implements the ICOEngineInterface. * @return The number of the tokens available for the ico. * At the moment the ico starts it must be equal to totalTokens(), * then it will decrease. */ function remainingTokens() public view returns(uint) { return availableTokens; } /** * @dev Implements the KYCBase senderAllowedFor function to enable a sender to buy tokens for a different address. * @return true. */ function senderAllowedFor(address buyer) internal view returns(bool) { require(buyer != address(0)); return true; } /** * @dev Implements the KYCBase releaseTokensTo function to mint tokens for an investor. * Called after the KYC process has passed. * @return A boolean that indicates if the operation was successful. */ function releaseTokensTo(address buyer) internal returns(bool) { require(validPurchase()); uint256 overflowTokens; uint256 refundWeiAmount; uint256 weiAmount = msg.value; uint256 tokenAmount = weiAmount.mul(price()); if (tokenAmount >= availableTokens) { capReached = true; overflowTokens = tokenAmount.sub(availableTokens); tokenAmount = tokenAmount.sub(overflowTokens); refundWeiAmount = overflowTokens.div(price()); weiAmount = weiAmount.sub(refundWeiAmount); buyer.transfer(refundWeiAmount); } weiRaised = weiRaised.add(weiAmount); tokensSold = tokensSold.add(tokenAmount); availableTokens = availableTokens.sub(tokenAmount); mintTokens(buyer, tokenAmount); forwardFunds(weiAmount); return true; } /** * @dev Fired by the releaseTokensTo function after minting tokens, * to forward the raised wei to the address that collects funds. * @param _weiAmount Amount of wei send by the investor. */ function forwardFunds(uint256 _weiAmount) internal { wallet.transfer(_weiAmount); } /** * @dev Validates an incoming purchase. Required statements revert state when conditions are not met. * @return true If the transaction can buy tokens. */ function validPurchase() internal view returns (bool) { require(!paused && !capReached); require(block.timestamp >= start && block.timestamp <= end); return true; } /** * @dev Mints tokens being sold during the crowdsale phase as part of the implementation of releaseTokensTo function * from the KYCBase contract. * @param to The address that will receive the minted tokens. * @param amount The amount of tokens to mint. */ function mintTokens(address to, uint256 amount) private { token.mint(to, amount); } modifier equalLength(address[] beneficiaries, uint256[] balances) { require(beneficiaries.length == balances.length); _; } } "}
{"sol name": "11418.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardToken { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state throw; } // Validate input value. if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); // Take tokens out from circulation totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading throw; } if (agent == 0x0) throw; // Only a master can designate the next agent if (msg.sender != upgradeMaster) throw; // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) throw; // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; /* Minimum ammount of tokens every buyer can buy. */ uint public minCap; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; // Create initially all balance on the team multisig balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { throw; // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } /** * Claim tokens that were accidentally sent to this contract. * * @param _token The address of the token contract that you want to recover. */ function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } /** * The default behavior for the crowdsale end. * * Unlock tokens. */ contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } //distributes reserved tokens. Should be called before finalization function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); // How many % of tokens the founders and others get uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; // move reserved tokens for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
{"sol name": "11780.sol", "label": 1, "sol content": "/** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLib { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20 is ERC20 { uint public decimals; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * Crowdsale state machine without buy functionality. * * Implements basic state machine logic, but leaves out all buy functions, * so that subclasses can implement their own buying logic. * * * For the default buy() implementation see Crowdsale.sol. */ contract CrowdsaleBase is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLib for uint; /* The token we are selling */ FractionalERC20 public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* Calculate incoming funds from presale contracts and addresses */ uint public presaleWeiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* How much wei we have returned back to the contract after a failed crowdfund. */ uint public loadedRefund = 0; /* How much wei we have given back to investors.*/ uint public weiRefunded = 0; /* Has this crowdsale been finalized */ bool public finalized; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => bool) public earlyParticipantWhitelist; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed * - Refunding: Refunds are loaded on the contract for reclaim. */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Refund was processed for a contributor event Refund(address investor, uint weiAmount); // The rules were changed what kind of investments we accept event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress); // Address early participation whitelist status changed event Whitelisted(address addr, bool status); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleBase(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) { owner = msg.sender; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * @dev Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side' * @param tokenAmount Amount of tokens which be credited to receiver * * @return tokensBought How mony tokens were bought */ function buyTokens(address receiver, uint128 customerId, uint256 tokenAmount) stopInEmergency internal returns(uint tokensBought) { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit if(!earlyParticipantWhitelist[receiver]) { throw; } } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass } else { // Unwanted state throw; } uint weiAmount = msg.value; // Dust transaction require(tokenAmount != 0); if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(pricingStrategy.isPresalePurchase(receiver)) { presaleWeiRaised = presaleWeiRaised.plus(weiAmount); } // Check that we did not bust the cap require(!isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)); assignTokens(receiver, tokenAmount); // Pocket the money, or fail the crowdsale if we for some reason cannot send the money to our multisig if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); return tokenAmount; } /** * @dev Make an investment based on pricing strategy * * This is a wrapper for buyTokens(), but the amount of tokens receiver will * have depends on the pricing strategy used. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side' * * @return tokensBought How mony tokens were bought */ function investInternal(address receiver, uint128 customerId) stopInEmergency internal returns(uint tokensBought) { return buyTokens(receiver, customerId, pricingStrategy.calculatePrice(msg.value, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals())); } /** * @dev Calculate tokens user will have for their purchase * * @param weisTotal How much ethers (in wei) the user putssssss in * @param pricePerToken What is the price for one token * * @return tokensTotal which is received tokens, token decimals included */ function calculateTokens(uint256 weisTotal, uint256 pricePerToken) public constant returns(uint tokensTotal) { // pricePerToken is how many full tokens, token decimal place included, you get for wei amount. // Because, in theory, decimal amount can vary, we do the exponent calculation here, // though gas wise using 10**18 constant would be much simpler. // Furthermore we could use rough amounts and take in raw wei per tokens amount, // but we lose too much accuracy for generic calculations, thus all these are // practically implemented as 10**18 fixed points. uint multiplier = 10 ** token.decimals(); return weisTotal.times(multiplier)/pricePerToken; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) onlyOwner { if(now > time) { throw; // Don't change past } if(startsAt > time) { throw; // Prevent human mistakes } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * Allow load refunds back on the contract for the refunding. * * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached.. */ function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = loadedRefund.plus(msg.value); } /** * Investors can claim refund. * * Note that any refunds from proxy buyers should be handled separately, * and not through this contract. */ function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.plus(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } /** This is for manual testing of multisig wallet interaction */ function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } /** * Allow addresses to do early participation. * * TODO: Fix spelling error in the name */ function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner { earlyParticipantWhitelist[addr] = status; Whitelisted(addr, status); } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) internal; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A mixin that is selling tokens from a preallocated pool * * - Tokens have precreated supply \"premined\" * * - Token owner must transfer sellable tokens to the crowdsale contract using ERC20.approve() * * - The mixin does not implement buy entry point. * */ contract AllocatedCrowdsaleMixin is CrowdsaleBase { /* The party who holds the full token pool and has approve()'ed tokens for this crowdsale */ address public beneficiary; /** * @param _beneficiary The account who has performed approve() to allocate tokens for the token sale. * */ function AllocatedCrowdsaleMixin(address _beneficiary) { beneficiary = _beneficiary; } /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) { if(tokenAmount > getTokensLeft()) { return true; } else { return false; } } /** * We are sold out when our approve pool becomes empty. */ function isCrowdsaleFull() public constant returns (bool) { return getTokensLeft() == 0; } /** * Get the amount of unsold tokens allocated to this contract; */ function getTokensLeft() public constant returns (uint) { return token.allowance(owner, this); } /** * Transfer tokens from approve() pool to the buyer. * * Use approve() given to this crowdsale to distribute the tokens. */ function assignTokens(address receiver, uint tokenAmount) internal { if(!token.transferFrom(beneficiary, receiver, tokenAmount)) throw; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Deserialize bytes payloads. * * Values are in big-endian byte order. * */ library BytesDeserializer { /** * Extract 256-bit worth of data from the bytes stream. */ function slice32(bytes b, uint offset) constant returns (bytes32) { bytes32 out; for (uint i = 0; i < 32; i++) { out |= bytes32(b[offset + i] & 0xFF) >> (i * 8); } return out; } /** * Extract Ethereum address worth of data from the bytes stream. */ function sliceAddress(bytes b, uint offset) constant returns (address) { bytes32 out; for (uint i = 0; i < 20; i++) { out |= bytes32(b[offset + i] & 0xFF) >> ((i+12) * 8); } return address(uint(out)); } /** * Extract 128-bit worth of data from the bytes stream. */ function slice16(bytes b, uint offset) constant returns (bytes16) { bytes16 out; for (uint i = 0; i < 16; i++) { out |= bytes16(b[offset + i] & 0xFF) >> (i * 8); } return out; } /** * Extract 32-bit worth of data from the bytes stream. */ function slice4(bytes b, uint offset) constant returns (bytes4) { bytes4 out; for (uint i = 0; i < 4; i++) { out |= bytes4(b[offset + i] & 0xFF) >> (i * 8); } return out; } /** * Extract 16-bit worth of data from the bytes stream. */ function slice2(bytes b, uint offset) constant returns (bytes2) { bytes2 out; for (uint i = 0; i < 2; i++) { out |= bytes2(b[offset + i] & 0xFF) >> (i * 8); } return out; } } /** * A mix-in contract to decode different signed KYC payloads. * * @notice This should be a library, but for the complexity and toolchain fragility risks involving of linking library inside library, we currently use this as a helper method mix-in. */ contract KYCPayloadDeserializer { using BytesDeserializer for bytes; // @notice this struct describes what kind of data we include in the payload, we do not use this directly // The bytes payload set on the server side // total 56 bytes struct KYCPayload { /** Customer whitelisted address where the deposit can come from */ address whitelistedAddress; // 20 bytes /** Customer id, UUID v4 */ uint128 customerId; // 16 bytes /** * Min amount this customer needs to invest in ETH. Set zero if no minimum. Expressed as parts of 10000. 1 ETH = 10000. * @notice Decided to use 32-bit words to make the copy-pasted Data field for the ICO transaction less lenghty. */ uint32 minETH; // 4 bytes /** Max amount this customer can to invest in ETH. Set zero if no maximum. Expressed as parts of 10000. 1 ETH = 10000. */ uint32 maxETH; // 4 bytes /** * Information about the price promised for this participant. It can be pricing tier id or directly one token price in weis. * @notice This is a later addition and not supported in all scenarios yet. */ uint256 pricingInfo; } /** * Same as above, but with pricing information included in the payload as the last integer. * * @notice In a long run, deprecate the legacy methods above and only use this payload. */ function getKYCPayload(bytes dataframe) public constant returns(address whitelistedAddress, uint128 customerId, uint32 minEth, uint32 maxEth, uint256 pricingInfo) { address _whitelistedAddress = dataframe.sliceAddress(0); uint128 _customerId = uint128(dataframe.slice16(20)); uint32 _minETH = uint32(dataframe.slice4(36)); uint32 _maxETH = uint32(dataframe.slice4(40)); uint256 _pricingInfo = uint256(dataframe.slice32(44)); return (_whitelistedAddress, _customerId, _minETH, _maxETH, _pricingInfo); } } /** * A crowdsale that allows buys only from signed payload with server-side specified limits and price. * * The token distribution happens as in the allocated crowdsale. * */ contract KYCCrowdsale is AllocatedCrowdsaleMixin, KYCPayloadDeserializer { /* Server holds the private key to this address to sign incoming buy payloads to signal we have KYC records in the books for these users. */ address public signerAddress; /* A new server-side signer key was set to be effective */ event SignerChanged(address signer); /** * Constructor. */ function KYCCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, address _beneficiary) CrowdsaleBase(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) AllocatedCrowdsaleMixin(_beneficiary) { } /** * A token purchase with anti-money laundering * * \u00a9return tokenAmount How many tokens where bought */ function buyWithKYCData(bytes dataframe, uint8 v, bytes32 r, bytes32 s) public payable returns(uint tokenAmount) { uint _tokenAmount; uint multiplier = 10 ** 18; // Perform signature check for normal addresses // (not deployment accounts, etc.) if(earlyParticipantWhitelist[msg.sender]) { // Deployment provided early participant list is for deployment and diagnostics // For test purchases use this faux customer id 0x1000 _tokenAmount = investInternal(msg.sender, 0x1000); } else { // User comes through the server, check that the signature to ensure ther server // side KYC has passed for this customer id and whitelisted Ethereum address bytes32 hash = sha256(dataframe); var (whitelistedAddress, customerId, minETH, maxETH, pricingInfo) = getKYCPayload(dataframe); // Check that the KYC data is signed by our server require(ecrecover(hash, v, r, s) == signerAddress); // Only whitelisted address can participate the transaction require(whitelistedAddress == msg.sender); // Server gives us information what is the buy price for this user uint256 tokensTotal = calculateTokens(msg.value, pricingInfo); _tokenAmount = buyTokens(msg.sender, customerId, tokensTotal); } if(!earlyParticipantWhitelist[msg.sender]) { // We assume there is no serious min and max fluctuations for the customer, unless // especially set in the server side per customer manual override. // Otherwise the customer can reuse old data payload with different min or max value // to work around the per customer cap. require(investedAmountOf[msg.sender] >= minETH * multiplier / 10000); require(investedAmountOf[msg.sender] <= maxETH * multiplier / 10000); } return _tokenAmount; } /// @dev This function can set the server side address /// @param _signerAddress The address derived from server's private key function setSignerAddress(address _signerAddress) onlyOwner { signerAddress = _signerAddress; SignerChanged(signerAddress); } } "}
{"sol name": "9560.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // Create Ad on DappVolume // Advertiser can choose 1 hour, 12 hours, 24 hours, or 1 week // half of the money gets sent back to last advertiser // // An investor can earn 10% of the ad revenue // Investors can get bought out by new investors // when an invester is bought out, they get 120% of their investment back contract dappVolumeAd { // import safemath using SafeMath for uint256; // set variables uint256 public dappId; uint256 public purchaseTimestamp; uint256 public purchaseSeconds; uint256 public investmentMin; uint256 public adPriceHour; uint256 public adPriceHalfDay; uint256 public adPriceDay; uint256 public adPriceWeek; uint256 public adPriceMultiple; address public contractOwner; address public lastOwner; address public theInvestor; // only contract owner modifier onlyContractOwner { require(msg.sender == contractOwner); _; } // set constructor constructor() public { investmentMin = 1000000000000000; adPriceHour = 5000000000000000; adPriceHalfDay = 50000000000000000; adPriceDay = 100000000000000000; adPriceWeek = 500000000000000000; adPriceMultiple = 1; contractOwner = msg.sender; theInvestor = contractOwner; lastOwner = contractOwner; } // withdraw funds to contract creator function withdraw() public onlyContractOwner { contractOwner.transfer(address(this).balance); } // set ad price multiple incase we want to up the price in the future function setAdPriceMultiple(uint256 amount) public onlyContractOwner { adPriceMultiple = amount; } // update and set ad function updateAd(uint256 id) public payable { // set minimum amount and make sure ad hasnt expired require(msg.value >= adPriceMultiple.mul(adPriceHour)); require(block.timestamp > purchaseTimestamp + purchaseSeconds); require(id > 0); // set ad time limit in seconds if (msg.value >= adPriceMultiple.mul(adPriceWeek)) { purchaseSeconds = 604800; // 1 week } else if (msg.value >= adPriceMultiple.mul(adPriceDay)) { purchaseSeconds = 86400; // 1 day } else if (msg.value >= adPriceMultiple.mul(adPriceHalfDay)) { purchaseSeconds = 43200; // 12 hours } else { purchaseSeconds = 3600; // 1 hour } // set new timestamp purchaseTimestamp = block.timestamp; // send 50% of the money to the last person lastOwner.transfer(msg.value.div(2)); // send 10% to the investor theInvestor.transfer(msg.value.div(10)); // set last owner lastOwner = msg.sender; // set dapp id dappId = id; } // update the investor function updateInvestor() public payable { require(msg.value >= investmentMin); theInvestor.transfer(msg.value.div(100).mul(60)); // send 60% to last investor (120% of original purchase) theInvestor = msg.sender; // set new investor investmentMin = investmentMin.mul(2); // double the price to become the investor } // get timestamp when ad ends function getPurchaseTimestampEnds() public view returns (uint _getPurchaseTimestampAdEnds) { return purchaseTimestamp.add(purchaseSeconds); } // get contract balance function getBalance() public view returns(uint256){ return address(this).balance; } } "}
{"sol name": "11182.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * ICO crowdsale contract that is capped by amout of tokens. * * - Tokens are dynamically created during the crowdsale * * */ contract MintedTokenCappedCrowdsaleExt is CrowdsaleExt { /* Maximum amount of tokens this crowdsale can sell. */ uint public maximumSellableTokens; function MintedTokenCappedCrowdsaleExt( string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _maximumSellableTokens, bool _isUpdatable, bool _isWhiteListed ) CrowdsaleExt(_name, _token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal, _isUpdatable, _isWhiteListed) { maximumSellableTokens = _maximumSellableTokens; } // Crowdsale maximumSellableTokens has been changed event MaximumSellableTokensChanged(uint newMaximumSellableTokens); /** * Called from invest() to confirm if the curret investment does not break our cap rule. */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken) { return tokensSoldTotal > maximumSellableTokens; } function isBreakingInvestorCap(address addr, uint tokenAmount) public constant returns (bool limitBroken) { assert(isWhiteListed); uint maxCap = earlyParticipantWhitelist[addr].maxCap; return (tokenAmountOf[addr].plus(tokenAmount)) > maxCap; } function isCrowdsaleFull() public constant returns (bool) { return tokensSold >= maximumSellableTokens; } function setMaximumSellableTokens(uint tokens) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); maximumSellableTokens = tokens; MaximumSellableTokensChanged(maximumSellableTokens); } function updateRate(uint newOneTokenInWei) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); assert(!lastTierCntrct.finalized()); pricingStrategy.updateRate(newOneTokenInWei); } /** * Dynamically create tokens and assign them to the investor. */ function assignTokens(address receiver, uint tokenAmount) private { MintableTokenExt mintableToken = MintableTokenExt(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "6534.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } function kill() public onlyOwner { selfdestruct(owner); } }/* * Name: Full Fill TV - XTV Network Utils Contract * Author: Allen Sarkisyan * Copyright: 2017 Full Fill TV, Inc. * Version: 1.0.0 */ library XTVNetworkUtils { function verifyXTVSignatureAddress(bytes32 hash, bytes memory sig) internal pure returns (address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) { return (address(0)); } // solium-disable-next-line security/no-inline-assembly assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } if (v < 27) { v += 27; } if (v != 27 && v != 28) { return (address(0)); } bytes32 prefixedHash = keccak256( abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash) ); // solium-disable-next-line arg-overflow return ecrecover(prefixedHash, v, r, s); } }/* * Name: Full Fill TV Contract * Author: Allen Sarkisyan * Copyright: 2017 Full Fill TV, Inc. * Version: 1.0.0 */ contract XTVNetworkGuard { mapping(address => bool) xtvNetworkEndorser; modifier validateSignature( string memory message, bytes32 verificationHash, bytes memory xtvSignature ) { bytes32 xtvVerificationHash = keccak256(abi.encodePacked(verificationHash, message)); require(verifyXTVSignature(xtvVerificationHash, xtvSignature)); _; } function setXTVNetworkEndorser(address _addr, bool isEndorser) public; function verifyXTVSignature(bytes32 hash, bytes memory sig) public view returns (bool) { address signerAddress = XTVNetworkUtils.verifyXTVSignatureAddress(hash, sig); return xtvNetworkEndorser[signerAddress]; } } /* * Name: Full Fill TV - XTV Token Contract * Author: Allen Sarkisyan * Copyright: 2017 Full Fill TV, Inc. * Version: 1.0.0 */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /* * Name: Full Fill TV Contract * Author: Allen Sarkisyan * Copyright: 2017 Full Fill TV, Inc. * Version: 1.0.0 */ /* * Name: Full Fill TV Contract * Author: Allen Sarkisyan * Copyright: 2017 Full Fill TV, Inc. * Version: 1.0.0 */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { bool public paused = false; bool public mintingFinished = false; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; uint256 totalSupply_; function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); function allowance(address _owner, address spender) public view returns (uint256); function increaseApproval(address spender, uint addedValue) public returns (bool); function decreaseApproval(address spender, uint subtractedValue) public returns (bool); modifier canMint() { require(!mintingFinished); _; } /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Buy(address indexed _recipient, uint _amount); event Mint(address indexed to, uint256 amount); event MintFinished(); event Pause(); event Unpause(); } contract ERC20Token is ERC20, Ownable { using SafeMath for uint256; /** ERC20 Interface Methods */ /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract XTVToken is XTVNetworkGuard, ERC20Token { using SafeMath for uint256; string public constant name = \"XTV\"; string public constant symbol = \"XTV\"; uint public constant decimals = 18; address public fullfillTeamAddress; address public fullfillFounder; address public fullfillAdvisors; address public XTVNetworkContractAddress; bool public airdropActive; uint public startTime; uint public endTime; uint public XTVAirDropped; uint public XTVBurned; mapping(address => bool) public claimed; uint256 private constant TOKEN_MULTIPLIER = 1000000; uint256 private constant DECIMALS = 10 ** decimals; uint256 public constant INITIAL_SUPPLY = 500 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant EXPECTED_TOTAL_SUPPLY = 1000 * TOKEN_MULTIPLIER * DECIMALS; // 33% uint256 public constant ALLOC_TEAM = 330 * TOKEN_MULTIPLIER * DECIMALS; // 7% uint256 public constant ALLOC_ADVISORS = 70 * TOKEN_MULTIPLIER * DECIMALS; // 10% uint256 public constant ALLOC_FOUNDER = 100 * TOKEN_MULTIPLIER * DECIMALS; // 50% uint256 public constant ALLOC_AIRDROP = 500 * TOKEN_MULTIPLIER * DECIMALS; uint256 public constant AIRDROP_CLAIM_AMMOUNT = 500 * DECIMALS; modifier isAirdropActive() { require(airdropActive); _; } modifier canClaimTokens() { uint256 remainingSupply = balances[address(0)]; require(!claimed[msg.sender] && remainingSupply > AIRDROP_CLAIM_AMMOUNT); _; } constructor( address _fullfillTeam, address _fullfillFounder, address _fullfillAdvisors ) public { owner = msg.sender; fullfillTeamAddress = _fullfillTeam; fullfillFounder = _fullfillFounder; fullfillAdvisors = _fullfillAdvisors; airdropActive = true; startTime = block.timestamp; endTime = startTime + 365 days; balances[_fullfillTeam] = ALLOC_TEAM; balances[_fullfillFounder] = ALLOC_FOUNDER; balances[_fullfillAdvisors] = ALLOC_ADVISORS; balances[address(0)] = ALLOC_AIRDROP; totalSupply_ = EXPECTED_TOTAL_SUPPLY; emit Transfer(address(this), address(0), ALLOC_AIRDROP); } function setXTVNetworkEndorser(address _addr, bool isEndorser) public onlyOwner { xtvNetworkEndorser[_addr] = isEndorser; } // @dev 500 XTV Tokens per claimant function claim( string memory token, bytes32 verificationHash, bytes memory xtvSignature ) public isAirdropActive canClaimTokens validateSignature(token, verificationHash, xtvSignature) returns (uint256) { claimed[msg.sender] = true; balances[address(0)] = balances[address(0)].sub(AIRDROP_CLAIM_AMMOUNT); balances[msg.sender] = balances[msg.sender].add(AIRDROP_CLAIM_AMMOUNT); XTVAirDropped = XTVAirDropped.add(AIRDROP_CLAIM_AMMOUNT); emit Transfer(address(0), msg.sender, AIRDROP_CLAIM_AMMOUNT); return balances[msg.sender]; } // @dev Burns tokens at address 0x00 function burnTokens() public onlyOwner { require(block.timestamp > endTime); uint256 remaining = balances[address(0)]; airdropActive = false; XTVBurned = remaining; } function setXTVNetworkContractAddress(address addr) public onlyOwner { XTVNetworkContractAddress = addr; } function setXTVTokenAirdropStatus(bool _status) public onlyOwner { airdropActive = _status; } } "}
{"sol name": "8596.sol", "label": 1, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Temporarily have SafeMath here until all contracts have been migrated to SafeMathLib version from OpenZeppelin /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /* * Haltable * * Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by causing a throw when in halt mode. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner { halted = true; } // called by the owner on end of emergency, returns to normal state function unhalt() external onlyOwner onlyInEmergency { halted = false; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Finalize agent defines what happens at the end of succeseful crowdsale. * * - Allocate tokens for founders, bounties and community * - Make tokens transferable * - etc. */ contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } /** Return true if we can run finalizeCrowdsale() properly. * * This is a safety check function that doesn't allow crowdsale to begin * unless the finalizer has been set up properly. */ function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale(); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * A token that defines fractional units as decimals. */ contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } /** * Abstract base contract for token sales. * * Handle * - start and end dates * - accepting investments * - minimum funding goal and refund * - various statistics during the crowdfund * - different pricing strategies * - different investment policies (require server side customer id, allow only whitelisted addresses) * */ contract CrowdsaleExt is Haltable { /* Max investment count when we are still allowed to change the multisig address */ uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; /* The token we are selling */ FractionalERC20Ext public token; /* How we are going to price our offering */ PricingStrategy public pricingStrategy; /* Post-success callback */ FinalizeAgent public finalizeAgent; /* name of the crowdsale tier */ string public name; /* tokens will be transfered from this address */ address public multisigWallet; /* if the funding goal is not reached, investors may withdraw their funds */ uint public minimumFundingGoal; /* the UNIX timestamp start date of the crowdsale */ uint public startsAt; /* the UNIX timestamp end date of the crowdsale */ uint public endsAt; /* the number of tokens already sold through this contract*/ uint public tokensSold = 0; /* How many wei of funding we have raised */ uint public weiRaised = 0; /* How many distinct addresses have invested */ uint public investorCount = 0; /* Has this crowdsale been finalized */ bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; /** How much ETH each address has invested to this crowdsale */ mapping (address => uint256) public investedAmountOf; /** How much tokens this crowdsale has credited for each investor address */ mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } //is crowdsale updatable bool public isUpdatable; /** Addresses that are allowed to invest even before ICO offical opens. For testing, for ICO partners, etc. */ mapping (address => WhiteListData) public earlyParticipantWhitelist; /** List of whitelisted addresses */ address[] public whitelistedParticipants; /** This is for manul testing for the interaction from owner wallet. You can set it to any value and inspect this in blockchain explorer to see that crowdsale interaction works. */ uint public ownerTestValue; /** State machine * * - Preparing: All contract initialization calls and variables have not been set yet * - Prefunding: We have not passed start time yet * - Funding: Active crowdsale * - Success: Minimum funding goal reached * - Failure: Minimum funding goal not reached before ending time * - Finalized: The finalized has been called and succesfully executed */ enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} // A new investment was made event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); // Address early participation whitelist status changed event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); // Crowdsale start time has been changed event StartsAtChanged(uint newStartsAt); // Crowdsale end time has been changed event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; // Don't mess the dates if(startsAt >= endsAt) { throw; } // Minimum funding goal can be zero minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } /** * Don't expect to just send in money and get tokens. */ function() payable { throw; } /** * Make an investment. * * Crowdsale must be running for one to invest. * We must have not pressed the emergency brake. * * @param receiver The Ethereum address who receives the tokens * @param customerId (optional) UUID v4 to track the successful payments on the server side * */ function investInternal(address receiver, uint128 customerId) stopInEmergency private { // Determine if it's a good time to accept investment from this participant if(getState() == State.PreFunding) { // Are we whitelisted for early deposit throw; } else if(getState() == State.Funding) { // Retail participants can only come in when the crowdsale is running // pass if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { // Unwanted state throw; } uint weiAmount = msg.value; // Account presale sales separately, so that they do not count against pricing tranches uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { // Dust transaction throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { // tokenAmount < minCap for investor throw; } // Check that we did not bust the investor's cap if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { // A new investor investorCount++; } // Update investor investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); // Update totals weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); // Check that we did not bust the cap if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); // Pocket the money if(!multisigWallet.send(weiAmount)) throw; // Tell us invest was success Invested(receiver, weiAmount, tokenAmount, customerId); } /** * Allow anonymous contributions to this crowdsale. */ function invest(address addr) public payable { investInternal(addr, 0); } /** * The basic entry point to participate the crowdsale process. * * Pay for funding, get invested tokens back in the sender address. */ function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } /** * Finalize a succcesful crowdsale. * * The owner can triggre a call the contract that provides post-crowdsale actions, like releasing the tokens. */ function finalize() public inState(State.Success) onlyOwner stopInEmergency { // Already finalized if(finalized) { throw; } // Finalizing is optional. We only call it if we are given a finalizing agent. if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } /** * Allow to (re)set finalize agent. * * Design choice: no state restrictions on setting this, so that we can fix fat finger mistakes. */ function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; // Don't allow setting bad agent if(!finalizeAgent.isFinalizeAgent()) { throw; } } /** * Allow addresses to do early participation. */ function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; //if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time); // Don't change past assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); //start time should be greater then end time of previous tiers for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } /** * Allow crowdsale owner to close early or extend the crowdsale. * * This is useful e.g. for a manual soft cap implementation: * - after X amount is reached determine manual closing * * This may put the crowdsale to an invalid state, * but we trust owners know what they are doing. * */ function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(now <= time);// Don't change past assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } /** * Allow to (re)set pricing strategy. * * Design choice: no state restrictions on the set, so that we can fix fat finger mistakes. */ function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; // Don't allow setting bad agent if(!pricingStrategy.isPricingStrategy()) { throw; } } /** * Allow to change the team multisig address in the case of emergency. * * This allows to save a deployed crowdsale wallet in the case the crowdsale has not yet begun * (we have done only few test transactions). After the crowdsale is going * then multisig address stays locked for the safety reasons. */ function setMultisig(address addr) public onlyOwner { // Change if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } /** * @return true if the crowdsale has raised enough money to be a successful. */ function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } /** * Check if the contract relationship looks good. */ function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } /** * Check if the contract relationship looks good. */ function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } /** * Crowdfund state machine management. * * We make it a function and do not assign the result to a variable, so there is no chance of the variable being stale. */ function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } /** Interface marker. */ function isCrowdsale() public constant returns (bool) { return true; } // // Modifiers // /** Modified allowing execution only if the crowdsale is currently running.  */ modifier inState(State state) { if(getState() != state) throw; _; } // // Abstract functions // /** * Check if the current invested breaks our cap rules. * * * The child contract must define their own cap setting rules. * We allow a lot of flexibility through different capping strategies (ETH, token count) * Called from invest(). * * @param weiAmount The amount of wei the investor tries to invest in the current transaction * @param tokenAmount The amount of tokens we try to give to the investor in the current transaction * @param weiRaisedTotal What would be our total raised balance after this transaction * @param tokensSoldTotal What would be our total sold tokens count after this transaction * * @return true if taking this investment would break our cap rules */ function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); /** * Check if the current crowdsale is full and we can no longer sell any tokens. */ function isCrowdsaleFull() public constant returns (bool); /** * Create new tokens or transfer issued tokens to the investor depending on the cap model. */ function assignTokens(address receiver, uint tokenAmount) private; } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Standard ERC20 token with Short Hand Attack and approve() race condition mitigation. * * Based on code by FirstBlood: * https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, SafeMath { /* Token supply got increased and a new owner received these tokens */ event Minted(address receiver, uint amount); /* Actual balances of token holders */ mapping(address => uint) balances; /* approve() allowances */ mapping (address => mapping (address => uint)) allowed; /* Interface declaration */ function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardToken { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state throw; } // Validate input value. if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); // Take tokens out from circulation totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading throw; } if (agent == 0x0) throw; // Only a master can designate the next agent if (msg.sender != upgradeMaster) throw; // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) throw; // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public constant returns(bool) { return true; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); /** inPercentageUnit is percents of tokens multiplied to 10 up to percents decimals. * For example, for reserved tokens in percents 2.54% * inPercentageUnit = 254 * inPercentageDecimals = 2 */ struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { throw; } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; /* Minimum ammount of tokens every buyer can buy. */ uint public minCap; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; // Create initially all balance on the team multisig balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { throw; // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } /** * Claim tokens that were accidentally sent to this contract. * * @param _token The address of the token contract that you want to recover. */ function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } /** * The default behavior for the crowdsale end. * * Unlock tokens. */ contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } /** Check that we can release the token */ function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } //distributes reserved tokens. Should be called before finalization function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); // How many % of tokens the founders and others get uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; // move reserved tokens for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } /** Called once by crowdsale finalize() if the sale was success. */ function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
