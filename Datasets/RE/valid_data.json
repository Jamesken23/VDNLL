{"sol name": "43465.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract HashnodeTestCoin is StandardToken { // CHANGE THIS. Update the contract name. /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   // Token Name uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18 string public symbol;                 // An identifier: eg SBX, XPR etc.. string public version = 'H1.0'; uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH? uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here. address public fundsWallet;           // Where should the raised ETH go? // This is a constructor function // which means the following function name has to match the contract name declared above function HashnodeTestCoin() { balances[msg.sender] = 100000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS) totalSupply = 100000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS) name = \"Easy Trading Token\";                                   // Set the name for display purposes (CHANGE THIS) decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS) symbol = \"ETT\";                                             // Set the symbol for display purposes (CHANGE THIS) unitsOneEthCanBuy = 40000;                                      // Set the price of your token for the ICO (CHANGE THIS) fundsWallet = msg.sender;                                    // The owner of the contract gets ETH } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain //Transfer ether to fundsWallet fundsWallet.transfer(msg.value); } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33388.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 3000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 6000000;                        // Update total supply (100000 for example) name = \"metacube\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"MTC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "254.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract ChooChooCoin is StandardToken { /* Public variables of the token */ string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; //constructor function function ChooChooCoin() { balances[msg.sender] = 500000000000000000000000000; totalSupply = 500000000000000000000000000; name = \"Choo Choo Coin\"; decimals = 18; symbol = \"Choo\"; unitsOneEthCanBuy = 5800; fundsWallet = msg.sender; } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; emit Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain //Transfer ether to fundsWallet fundsWallet.transfer(msg.value); } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "31454.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract EthereumUranium is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function EthereumUranium( ) { balances[msg.sender] = 2100000000000000; totalSupply = 2100000000000000; name = \"Ethereum Uranium\"; decimals = 8; symbol = \"ETHUC\"; } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35013.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; // From https://github.com/ConsenSys/MultiSigWallet/blob/master/contracts/solidity/MultiSigWallet.sol @ e3240481928e9d2b57517bd192394172e31da487 /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 5; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. function MultiSigWallet() public { address owner1 = address(0x5117afB03e83d180D0059a1Ad733F954220D2734); address owner2 = address(0x4F9049886d8087c7549224383075ffbb3dF2b7a0); address owner3 = address(0x4E63227fcFF602b3Fa9e6F4e86b33194f04236B1); owners.push(address(owner1)); owners.push(address(owner2)); owners.push(address(owner3)); isOwner[owner1] = true; isOwner[owner2] = true; isOwner[owner3] = true; required = 3; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "39397.sol", "label": 0, "sol content": "//just updated the encrypted api key //updated contractBalance -= 57245901639344; //removed safesub from all contractBalance and replaced with operators pragma solidity ^0.4.2; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); return true; } if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); return true; } if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); return true; } if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal returns (bytes) { uint arrlen = arr.length; // get correct cbor output length uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { // if there's a bug with larger strings, this may be the culprit if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } } // </ORACLIZE_API> /* * @title String & slice utility library for Solidity contracts. * @author Nick Johnson <[email\u00a0protected]> * * @dev Functionality in this library is largely implemented using an *      abstraction called a 'slice'. A slice represents a part of a string - *      anything from the entire string to a single character, or even no *      characters at all (a 0-length slice). Since a slice only has to specify *      an offset and a length, copying and manipulating slices is a lot less *      expensive than copying and manipulating the strings they reference. * *      To further reduce gas costs, most functions on slice that need to return *      a slice modify the original one instead of allocating a new one; for *      instance, `s.split(\".\")` will return the text up to the first '.', *      modifying s to only contain the remainder of the string after the '.'. *      In situations where you do not want to modify the original slice, you *      can make a copy first with `.copy()`, for example: *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since *      Solidity has no memory management, it will result in allocating many *      short-lived slices that are later discarded. * *      Functions that return two slices come in two versions: a non-allocating *      version that takes the second slice as an argument, modifying it in *      place, and an allocating version that allocates and returns the second *      slice; see `nextRune` for example. * *      Functions that have to copy string data will return strings rather than *      slices; these can be cast back to slices for further processing if *      required. * *      For convenience, some functions are provided with non-modifying *      variants that create a new slice and return both; for instance, *      `s.splitNew('.')` leaves s unmodified, and returns two values *      corresponding to the left and right parts of the string. */ library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private { // Copy word-length chunks while possible for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } // Copy remaining bytes uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } /* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ function toSlice(string self) internal returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } /* * @dev Returns the length of a null-terminated bytes32 string. * @param self The value to find the length of. * @return The length of the string, from 0 to 32. */ function len(bytes32 self) internal returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; } /* * @dev Returns a slice containing the entire bytes32, interpreted as a *      null-termintaed utf-8 string. * @param self The bytes32 value to convert to a slice. * @return A new slice containing the value of the input argument up to the *         first null. */ function toSliceB32(bytes32 self) internal returns (slice ret) { // Allocate space for `self` in memory, copy it there, and point ret at it assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); } /* * @dev Returns a new slice containing the same data as the current slice. * @param self The slice to copy. * @return A new slice containing the same data as `self`. */ function copy(slice self) internal returns (slice) { return slice(self._len, self._ptr); } /* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ function toString(slice self) internal returns (string) { var ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } /* * @dev Returns the length in runes of the slice. Note that this operation *      takes time proportional to the length of the slice; avoid using it *      in loops, and call `slice.empty()` if you only need to know whether *      the slice is empty or not. * @param self The slice to operate on. * @return The length of the slice in runes. */ function len(slice self) internal returns (uint) { // Starting at ptr-31 means the LSB will be the byte we care about var ptr = self._ptr - 31; var end = ptr + self._len; for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; } /* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ function empty(slice self) internal returns (bool) { return self._len == 0; } /* * @dev Returns a positive number if `other` comes lexicographically after *      `self`, a negative number if it comes before, or zero if the *      contents of the two slices are equal. Comparison is done per-rune, *      on unicode codepoints. * @param self The first slice to compare. * @param other The second slice to compare. * @return The result of the comparison. */ function compare(slice self, slice other) internal returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; var selfptr = self._ptr; var otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { // Mask out irrelevant bytes and check again uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); var diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); } /* * @dev Returns true if the two slices contain the same text. * @param self The first slice to compare. * @param self The second slice to compare. * @return True if the slices are equal, false otherwise. */ function equals(slice self, slice other) internal returns (bool) { return compare(self, other) == 0; } /* * @dev Extracts the first rune in the slice into `rune`, advancing the *      slice to point to the next rune and returning `self`. * @param self The slice to operate on. * @param rune The slice that will contain the first rune. * @return `rune`. */ function nextRune(slice self, slice rune) internal returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint len; uint b; // Load the first byte of the rune into the LSBs of b assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { len = 1; } else if(b < 0xE0) { len = 2; } else if(b < 0xF0) { len = 3; } else { len = 4; } // Check for truncated codepoints if (len > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += len; self._len -= len; rune._len = len; return rune; } /* * @dev Returns the first rune in the slice, advancing the slice to point *      to the next rune. * @param self The slice to operate on. * @return A slice containing only the first rune from `self`. */ function nextRune(slice self) internal returns (slice ret) { nextRune(self, ret); } /* * @dev Returns the number of the first codepoint in the slice. * @param self The slice to operate on. * @return The number of the first codepoint in the slice. */ function ord(slice self) internal returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint len; uint div = 2 ** 248; // Load the rune into the MSBs of b assembly { word:= mload(mload(add(self, 32))) } var b = word / div; if (b < 0x80) { ret = b; len = 1; } else if(b < 0xE0) { ret = b & 0x1F; len = 2; } else if(b < 0xF0) { ret = b & 0x0F; len = 3; } else { ret = b & 0x07; len = 4; } // Check for truncated codepoints if (len > self._len) { return 0; } for (uint i = 1; i < len; i++) { div = div / 256; b = (word / div) & 0xFF; if (b & 0xC0 != 0x80) { // Invalid UTF-8 sequence return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; } /* * @dev Returns the keccak-256 hash of the slice. * @param self The slice to hash. * @return The hash of the slice. */ function keccak(slice self) internal returns (bytes32 ret) { assembly { ret := sha3(mload(add(self, 32)), mload(self)) } } /* * @dev Returns true if `self` starts with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function startsWith(slice self, slice needle) internal returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; } /* * @dev If `self` starts with `needle`, `needle` is removed from the *      beginning of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function beyond(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } /* * @dev Returns true if the slice ends with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function endsWith(slice self, slice needle) internal returns (bool) { if (self._len < needle._len) { return false; } var selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; } /* * @dev If `self` ends with `needle`, `needle` is removed from the *      end of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function until(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } var selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; } return self; } // Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) { uint ptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { // Optimized assembly for 68 gas per byte on short strings assembly { let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1)) let needledata := and(mload(needleptr), mask) let end := add(selfptr, sub(selflen, needlelen)) ptr := selfptr loop: jumpi(exit, eq(and(mload(ptr), mask), needledata)) ptr := add(ptr, 1) jumpi(loop, lt(sub(ptr, 1), end)) ptr := add(selfptr, selflen) exit: } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } ptr = selfptr; for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } // Returns the memory address of the first byte after the last occurrence of // `needle` in `self`, or the address of `self` if not found. function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) { uint ptr; if (needlelen <= selflen) { if (needlelen <= 32) { // Optimized assembly for 69 gas per byte on short strings assembly { let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1)) let needledata := and(mload(needleptr), mask) ptr := add(selfptr, sub(selflen, needlelen)) loop: jumpi(ret, eq(and(mload(ptr), mask), needledata)) ptr := sub(ptr, 1) jumpi(loop, gt(add(ptr, 1), selfptr)) ptr := selfptr jump(exit) ret: ptr := add(ptr, needlelen) exit: } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } ptr = selfptr + (selflen - needlelen); while (ptr >= selfptr) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr + needlelen; ptr -= 1; } } } return selfptr; } /* * @dev Modifies `self` to contain everything from the first occurrence of *      `needle` to the end of the slice. `self` is set to the empty slice *      if `needle` is not found. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function find(slice self, slice needle) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; } /* * @dev Modifies `self` to contain the part of the string from the start of *      `self` to the end of the first occurrence of `needle`. If `needle` *      is not found, `self` is set to the empty slice. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function rfind(slice self, slice needle) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function split(slice self, slice needle, slice token) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ function split(slice self, slice needle) internal returns (slice token) { split(self, needle, token); } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and `token` to everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function rsplit(slice self, slice needle, slice token) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and returning everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` after the last occurrence of `delim`. */ function rsplit(slice self, slice needle) internal returns (slice token) { rsplit(self, needle, token); } /* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ function count(slice self, slice needle) internal returns (uint count) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { count++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } /* * @dev Returns True if `self` contains `needle`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return True if `needle` is found in `self`, false otherwise. */ function contains(slice self, slice needle) internal returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; } /* * @dev Returns a newly allocated string containing the concatenation of *      `self` and `other`. * @param self The first slice to concatenate. * @param other The second slice to concatenate. * @return The concatenation of the two strings. */ function concat(slice self, slice other) internal returns (string) { var ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } /* * @dev Joins an array of slices, using `self` as a delimiter, returning a *      newly allocated string. * @param self The delimiter to use. * @param parts A list of slices to join. * @return A newly allocated string containing all the slices in `parts`, *         joined with `self`. */ function join(slice self, slice[] parts) internal returns (string) { if (parts.length == 0) return \"\"; uint len = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) len += parts[i]._len; var ret = new string(len); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; } } contract DSSafeAddSub { function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a); } function safeAdd(uint a, uint b) internal returns (uint) { if (!safeToAdd(a, b)) throw; return a + b; } function safeToSubtract(uint a, uint b) internal returns (bool) { return (b <= a); } function safeSub(uint a, uint b) internal returns (uint) { if (!safeToSubtract(a, b)) throw; return a - b; } } contract Etheroll is usingOraclize, DSSafeAddSub { using strings for *; /* * checks player profit, bet size and player number is within range */ modifier betIsValid(uint _betSize, uint _playerNumber) { if(((((_betSize * (100-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) throw; _; } /* * checks game is currently active */ modifier gameIsActive { if(gamePaused == true) throw; _; } /* * checks payouts are currently active */ modifier payoutsAreActive { if(payoutsPaused == true) throw; _; } /* * checks only Oraclize address is calling */ modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } /* * checks only owner address is calling */ modifier onlyOwner { if (msg.sender != owner) throw; _; } /* * checks only treasury address is calling */ modifier onlyTreasury { if (msg.sender != treasury) throw; _; } /* * game vars */ uint constant public maxProfitDivisor = 1000000; uint constant public houseEdgeDivisor = 1000; uint constant public maxNumber = 99; uint constant public minNumber = 2; bool public gamePaused; uint32 public gasForOraclize; address public owner; bool public payoutsPaused; address public treasury; uint public contractBalance; uint public houseEdge; uint public maxProfit; uint public maxProfitAsPercentOfHouse; uint public minBet; int public totalBets; uint public maxPendingPayouts; uint public costToCallOraclizeInWei; uint public totalWeiWon; /* * player vars */ mapping (bytes32 => address) playerAddress; mapping (bytes32 => address) playerTempAddress; mapping (bytes32 => bytes32) playerBetId; mapping (bytes32 => uint) playerBetValue; mapping (bytes32 => uint) playerTempBetValue; mapping (bytes32 => uint) playerRandomResult; mapping (bytes32 => uint) playerDieResult; mapping (bytes32 => uint) playerNumber; mapping (address => uint) playerPendingWithdrawals; mapping (bytes32 => uint) playerProfit; mapping (bytes32 => uint) playerTempReward; /* * events */ /* log bets + output to web3 for precise 'payout on win' field in UI */ event LogBet(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RewardValue, uint ProfitValue, uint BetValue, uint PlayerNumber); /* output to web3 UI on bet result*/ /* Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send*/ event LogResult(uint indexed ResultSerialNumber, bytes32 indexed BetID, address indexed PlayerAddress, uint PlayerNumber, uint DiceResult, uint Value, int Status, bytes Proof); /* log manual refunds */ event LogRefund(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RefundValue); /* log owner transfers */ event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred); /* * init */ function Etheroll() { owner = msg.sender; treasury = msg.sender; oraclize_setNetwork(networkID_auto); /* use TLSNotary for oraclize call */ oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); /* init 990 = 99% (1% houseEdge)*/ ownerSetHouseEdge(990); /* init 10,000 = 1%  */ ownerSetMaxProfitAsPercentOfHouse(10000); /* init min bet (0.1 ether) */ ownerSetMinBet(100000000000000000); /* init gas for oraclize */ gasForOraclize = 250000; } /* * public function * player submit bet * only if game is active & bet is valid can query oraclize and set player vars */ function playerRollDice(uint rollUnder) public payable gameIsActive betIsValid(msg.value, rollUnder) { /* * assign partially encrypted query to oraclize * only the apiKey is encrypted * integer query is in plain text */ bytes32 rngId = oraclize_query(\"nested\", \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random[\\\"serialNumber\\\",\\\"data\\\"]', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BKjhlm6SfYJ79hWWmywPWdwaFHZCU9yBavQcnDLajf8Cbxo9W6z8KNnzmS+/0hmoNTnBRZxSgACLlIghH+Zm65EAhJCsE6q/W5YlR55o+HbGWyMEi0o5ngKy1MtUi49eg4HhelENzDMMEynC3eY6SeJeQNe4NsE=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":100,\\\"replacement\\\":true,\\\"base\\\":10${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\", gasForOraclize); /* safely update contract balance to account for cost to call oraclize*/ contractBalance -= 57245901639344; /* total number of bets */ totalBets += 1; /* map bet id to this oraclize query */ playerBetId[rngId] = rngId; /* map player lucky number to this oraclize query */ playerNumber[rngId] = rollUnder; /* map value of wager to this oraclize query */ playerBetValue[rngId] = msg.value; /* map player address to this oraclize query */ playerAddress[rngId] = msg.sender; /* safely map player profit to this oraclize query */ playerProfit[rngId] = ((((msg.value * (100-(safeSub(rollUnder,1)))) / (safeSub(rollUnder,1))+msg.value))*houseEdge/houseEdgeDivisor)-msg.value; /* safely increase maxPendingPayouts liability - calc all pending payouts under assumption they win */ maxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]); /* check contract can payout on win */ if(maxPendingPayouts >= contractBalance) throw; /* provides accurate numbers for web3 and allows for manual refunds in case of no oraclize __callback */ LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]); } /* * semi-public function - only oraclize can call */ /*TLSNotary for oraclize call */ function __callback(bytes32 myid, string result, bytes proof) public onlyOraclize payoutsAreActive { /* player address mapped to query id does not exist */ if (playerAddress[myid]==0x0) throw; /* keep oraclize honest by retrieving the serialNumber from random.org result */ var sl_result = result.toSlice(); sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()); uint serialNumberOfResult = parseInt(sl_result.split(', '.toSlice()).toString()); /* map result to player */ playerRandomResult[myid] = parseInt(sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()).toString()); /* produce integer bounded to 1-100 inclusive *  via sha3 result from random.org and proof (IPFS address of TLSNotary proof) */ playerDieResult[myid] = uint(sha3(playerRandomResult[myid], proof)) % 100 + 1; /* get the playerAddress for this query id */ playerTempAddress[myid] = playerAddress[myid]; /* delete playerAddress for this query id */ delete playerAddress[myid]; /* map the playerProfit for this query id */ playerTempReward[myid] = playerProfit[myid]; /* set  playerProfit for this query id to 0 */ playerProfit[myid] = 0; /* safely reduce maxPendingPayouts liability */ maxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]); /* map the playerBetValue for this query id */ playerTempBetValue[myid] = playerBetValue[myid]; /* set  playerBetValue for this query id to 0 */ playerBetValue[myid] = 0; /* * refund * if result from oraclize is 0 refund only the original bet value * if refund fails save refund value to playerPendingWithdrawals */ if(playerDieResult[myid]==0){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 3, proof); /* * send refund - external call to an untrusted contract * if send fails map refund value to playerPendingWithdrawals[address] * for withdrawal later via playerWithdrawPendingTransactions */ if(!playerTempAddress[myid].send(playerTempBetValue[myid])){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof); /* if send failed let player withdraw via playerWithdrawPendingTransactions */ playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]); } return; } /* * pay winner * update contract balance to calculate new max bet * send reward * if send of reward fails save value to playerPendingWithdrawals */ if(playerDieResult[myid] < playerNumber[myid]){ /* safely reduce contract balance by player profit */ contractBalance -= playerTempReward[myid]; /* update total wei won */ totalWeiWon = safeAdd(totalWeiWon, playerTempReward[myid]); /* safely calculate payout via profit plus original wager */ playerTempReward[myid] = safeAdd(playerTempReward[myid], playerTempBetValue[myid]); LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 1, proof); /* update maximum profit */ setMaxProfit(); /* * send win - external call to an untrusted contract * if send fails map reward value to playerPendingWithdrawals[address] * for withdrawal later via playerWithdrawPendingTransactions */ if(!playerTempAddress[myid].send(playerTempReward[myid])){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof); /* if send failed let player withdraw via playerWithdrawPendingTransactions */ playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]); } return; } /* * no win * send 1 wei to a losing bet * update contract balance to calculate new max bet */ if(playerDieResult[myid] >= playerNumber[myid]){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 0, proof); /* *  safe adjust contractBalance *  setMaxProfit *  send 1 wei to losing bet */ contractBalance += playerTempBetValue[myid]-1; /* update maximum profit */ setMaxProfit(); /* * send 1 wei - external call to an untrusted contract */ if(!playerTempAddress[myid].send(1)){ /* if send failed let player withdraw via playerWithdrawPendingTransactions */ playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1); } return; } } /* * public function * in case of a failed refund or win send */ function playerWithdrawPendingTransactions() public payoutsAreActive returns (bool) { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; /* external call to untrusted contract */ if (msg.sender.call.value(withdrawAmount)()) { return true; } else { /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */ /* player can try to withdraw again later */ playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; } } /* check for pending withdrawals  */ function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) { return playerPendingWithdrawals[addressToCheck]; } /* * internal function * sets max profit */ function setMaxProfit() internal { maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxProfitDivisor; } /* * owner/treasury address only functions */ function () payable onlyTreasury { /* safely update contract balance */ contractBalance += msg.value; /* update the maximum profit */ setMaxProfit(); } /* set gas for oraclize query */ function ownerSetOraclizeSafeGas(uint32 newSafeGasToOraclize) public onlyOwner { gasForOraclize = newSafeGasToOraclize; } /* set house cost to call oraclize query */ function ownerUpdateCostToCallOraclize(uint newCostToCallOraclizeInWei) public onlyOwner { costToCallOraclizeInWei = newCostToCallOraclizeInWei; } /* only owner address can set houseEdge */ function ownerSetHouseEdge(uint newHouseEdge) public onlyOwner { houseEdge = newHouseEdge; } /* only owner address can set maxProfitAsPercentOfHouse */ function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public onlyOwner { /* restrict each bet to a maximum profit of 1% contractBalance */ if(newMaxProfitAsPercent > 10000) throw; maxProfitAsPercentOfHouse = newMaxProfitAsPercent; setMaxProfit(); } /* only owner address can set minBet */ function ownerSetMinBet(uint newMinimumBet) public onlyOwner { minBet = newMinimumBet; } /* only owner address can transfer ether */ function ownerTransferEther(address sendTo, uint amount) public onlyOwner { /* safely update contract balance when sending out funds*/ contractBalance -= amount; /* update max profit */ setMaxProfit(); if(!sendTo.send(amount)) throw; LogOwnerTransfer(sendTo, amount); } /* only owner address can do manual refund * used only if bet placed + oraclize failed to __callback * filter LogBet by address and/or playerBetId: * LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]); * check the following logs do not exist for playerBetId and/or playerAddress[rngId] before refunding: * LogResult or LogRefund * if LogResult exists player should use the withdraw pattern playerWithdrawPendingTransactions */ function ownerRefundPlayer(bytes32 originalPlayerBetId, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public onlyOwner { /* safely reduce pendingPayouts by playerProfit[rngId] */ maxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit); /* send refund */ if(!sendTo.send(originalPlayerBetValue)) throw; /* log refunds */ LogRefund(originalPlayerBetId, sendTo, originalPlayerBetValue); } /* only owner address can set emergency pause #1 */ function ownerPauseGame(bool newStatus) public onlyOwner { gamePaused = newStatus; } /* only owner address can set emergency pause #2 */ function ownerPausePayouts(bool newPayoutStatus) public onlyOwner { payoutsPaused = newPayoutStatus; } /* only owner address can set treasury address */ function ownerSetTreasury(address newTreasury) public onlyOwner { treasury = newTreasury; } /* only owner address can set owner address */ function ownerChangeOwner(address newOwner) public onlyOwner { owner = newOwner; } /* only owner address can suicide - emergency */ function ownerkill() public onlyOwner { suicide(owner); } } "}
{"sol name": "32845.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value);} contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; }} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; }} function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner];} function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true;} function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender];} mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply;} contract Collectorcoin is StandardToken { function () { throw;} /* Public variables of the token */ string public name = 'Collectorcoin'; uint8 public decimals = 2; string public symbol = 'CLC'; string public version = 'H1.0'; function Collectorcoin( ) { balances[msg.sender] = 100000000000; totalSupply = 100000000000; name = \"Collectorcoin\"; decimals = 2; symbol = \"CLC\";} /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true;}} "}
{"sol name": "33980.sol", "label": 0, "sol content": "pragma solidity 0.4.15; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "35904.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract ENJ { mapping (address => uint256) public balances; mapping (address => uint256) public balances_for_refund; bool public bought_tokens; bool public token_set; uint256 public contract_eth_value; uint256 public refund_contract_eth_value; uint256 public refund_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x859271eF2F73A447a1EfD7F95037017667c9d326; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; } function personal_withdraw(uint256 transfer_amount){ require(msg.sender == developer); developer.transfer(transfer_amount); } function withdraw_token(address _token){ ERC20 myToken = ERC20(_token); if (balances[msg.sender] == 0) return; require(msg.sender != sale); if (!bought_tokens) { uint256 eth_to_withdraw = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw); } else { uint256 contract_token_balance = myToken.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; uint256 fee = tokens_to_withdraw / 100; require(myToken.transfer(developer, fee)); require(myToken.transfer(msg.sender, tokens_to_withdraw - fee)); } } // This handles the withdrawal of refunds. Also works with partial refunds. function withdraw_refund(){ require(refund_eth_value!=0); require(balances_for_refund[msg.sender] != 0); uint256 eth_to_withdraw = (balances_for_refund[msg.sender] * refund_eth_value) / refund_contract_eth_value; refund_contract_eth_value -= balances_for_refund[msg.sender]; refund_eth_value -= eth_to_withdraw; balances_for_refund[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw); } function () payable { if (!bought_tokens) { balances[msg.sender] += msg.value; balances_for_refund[msg.sender] += msg.value; if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; refund_contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); } else { require(msg.sender == sale); refund_eth_value += msg.value; } } } "}
{"sol name": "33864.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 100000000;                        // Update total supply (100000 for example) name = \"TonTonToken\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"TON\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "39493.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; // // FOR REFERENCE - INCLUDE  iE4RowEscrow  (interface) CONTRACT at the top ..... // contract iE4RowEscrow { function getNumGamesStarted() constant returns (int ngames); } // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 // --------------------------------- // ABSTRACT standard token class // --------------------------------- contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } // -------------------------- //  E4RowRewards - abstract e4 dividend contract // -------------------------- contract E4RowRewards { function checkDividends(address _addr) constant returns(uint _amount); function withdrawDividends() public returns (uint namount); } // -------------------------- //  Finney Chip - token contract // -------------------------- contract E4Token is Token, E4RowRewards { event StatEvent(string msg); event StatEventI(string msg, uint val); enum SettingStateValue  {debug, release, lockedRelease} enum IcoStatusValue {anouncement, saleOpen, saleClosed, failed, succeeded} struct tokenAccount { bool alloced; // flag to ascert prior allocation uint tokens; // num tokens uint balance; // rewards balance } // ----------------------------- //  data storage // ---------------------------------------- address developers; // developers token holding address address public owner; // deployer executor address founderOrg; // founder orginaization contract address auxPartner; // aux partner (pr/auditing) - 1 percent upon close address e4_partner; // e4row  contract addresses mapping (address => tokenAccount) holderAccounts ; // who holds how many tokens (high two bytes contain curPayId) mapping (uint => address) holderIndexes ; // for iteration thru holder uint numAccounts; uint partnerCredits; // amount partner (e4row)  has paid mapping (address => mapping (address => uint256)) allowed; // approvals uint maxMintableTokens; // ... uint minIcoTokenGoal;// token goal by sale end uint minUsageGoal; //  num games goal by usage deadline uint public  tokenPrice; // price per token uint public payoutThreshold; // threshold till payout uint totalTokenFundsReceived;   // running total of token funds received uint public totalTokensMinted;  // total number of tokens minted uint public holdoverBalance;            // hold this amount until threshhold before reward payout int public payoutBalance;               // hold this amount until threshhold before reward payout int prOrigPayoutBal;                    // original payout balance before run uint prOrigTokensMint;                  // tokens minted at start of pay run uint public curPayoutId;                // current payout id uint public lastPayoutIndex;            // payout idx between run segments uint public maxPaysPer;                 // num pays per segment uint public minPayInterval;             // min interval between start pay run uint fundingStart;              // funding start time immediately after anouncement uint fundingDeadline;           // funding end time uint usageDeadline;             // deadline where minimum usage needs to be met before considered success uint public lastPayoutTime;     // timestamp of last payout time uint vestTime;          // 1 year past sale vest developer tokens uint numDevTokens;      // 10 per cent of tokens after close to developers bool developersGranted;                 // flag uint remunerationStage;         // 0 for not yet, 1 for 10 percent, 2 for remaining  upon succeeded. uint public remunerationBalance;        // remuneration balance to release token funds uint auxPartnerBalance;         // aux partner balance - 1 percent uint rmGas; // remuneration gas uint rwGas; // reward gas uint rfGas; // refund gas IcoStatusValue icoStatus;  // current status of ico SettingStateValue public settingsState; // -------------------- // contract constructor // -------------------- function E4Token() { owner = msg.sender; developers = msg.sender; } // ----------------------------------- // use this to reset everything, will never be called after lockRelease // ----------------------------------- function applySettings(SettingStateValue qState, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _minUsage, uint _tokGoal, uint  _maxMintable, uint _threshold, uint _price, uint _mpp, uint _mpi ) { if (msg.sender != owner) return; // these settings are permanently tweakable for performance adjustments payoutThreshold = _threshold; maxPaysPer = _mpp; minPayInterval = _mpi; if (settingsState == SettingStateValue.lockedRelease) return; settingsState = qState; icoStatus = IcoStatusValue.anouncement; rmGas = 100000; // remuneration gas rwGas = 10000; // reward gas rfGas = 10000; // refund gas // zero out all token holders. // leave alloced on, leave num accounts // cant delete them anyways if (totalTokensMinted > 0) { for (uint i = 0; i < numAccounts; i++ ) { address a = holderIndexes[i]; if (a != address(0)) { holderAccounts[a].tokens = 0; holderAccounts[a].balance = 0; } } } // do not reset numAccounts! totalTokensMinted = 0; // this will erase totalTokenFundsReceived = 0; // this will erase. e4_partner = address(0); // must be reset again fundingStart =  _saleStart; fundingDeadline = _saleEnd; usageDeadline = _usageEnd; minUsageGoal = _minUsage; minIcoTokenGoal = _tokGoal; maxMintableTokens = _maxMintable; tokenPrice = _price; vestTime = fundingStart + (365 days); numDevTokens = 0; holdoverBalance = 0; payoutBalance = 0; curPayoutId = 1; lastPayoutIndex = 0; remunerationStage = 0; remunerationBalance = 0; auxPartnerBalance = 0; if (this.balance > 0) { if (!owner.call.gas(rfGas).value(this.balance)()) StatEvent(\"ERROR!\"); } StatEvent(\"ok\"); } // --------------------------------------------------- // tokens held reserve the top two bytes for the payid last paid. // this is so holders at the top of the list dont transfer tokens // to themselves on the bottom of the list thus scamming the // system. this function deconstructs the tokenheld value. // --------------------------------------------------- function getPayIdAndHeld(uint _tokHeld) internal returns (uint _payId, uint _held) { _payId = (_tokHeld / (2 ** 48)) & 0xffff; _held = _tokHeld & 0xffffffffffff; } function getHeld(uint _tokHeld) internal  returns (uint _held) { _held = _tokHeld & 0xffffffffffff; } // --------------------------------------------------- // allocate a new account by setting alloc to true // set the top to bytes of tokens to cur pay id to leave out of current round // add holder index, bump the num accounts // --------------------------------------------------- function addAccount(address _addr) internal  { holderAccounts[_addr].alloced = true; holderAccounts[_addr].tokens = (curPayoutId * (2 ** 48)); holderIndexes[numAccounts++] = _addr; } // -------------------------------------- // BEGIN ERC-20 from StandardToken // -------------------------------------- function totalSupply() constant returns (uint256 supply) { if (icoStatus == IcoStatusValue.saleOpen || icoStatus == IcoStatusValue.anouncement) supply = maxMintableTokens; else supply = totalTokensMinted; } function transfer(address _to, uint256 _value) returns (bool success) { if ((msg.sender == developers) &&  (now < vestTime)) { //statEvent(\"Tokens not yet vested.\"); return false; } //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (holderAccounts[msg.sender] >= _value && balances[_to] + _value > holderAccounts[_to]) { var (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[msg.sender].tokens); if (heldFrom >= _value && _value > 0) { holderAccounts[msg.sender].tokens -= _value; if (!holderAccounts[_to].alloced) { addAccount(_to); } uint newHeld = _value + getHeld(holderAccounts[_to].tokens); holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48)); Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if ((_from == developers) &&  (now < vestTime)) { //statEvent(\"Tokens not yet vested.\"); return false; } //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { var (pidFrom, heldFrom) = getPayIdAndHeld(holderAccounts[_from].tokens); if (heldFrom >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { holderAccounts[_from].tokens -= _value; if (!holderAccounts[_to].alloced) addAccount(_to); uint newHeld = _value + getHeld(holderAccounts[_to].tokens); holderAccounts[_to].tokens = newHeld | (pidFrom * (2 ** 48)); allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { // vars default to 0 if (holderAccounts[_owner].alloced) { balance = getHeld(holderAccounts[_owner].tokens); } } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } // ---------------------------------- // END ERC20 // ---------------------------------- // ------------------------------------------- // check the alloced // ------------------------------------------- function holderExists(address _addr) returns(bool _exist) { _exist = holderAccounts[_addr].alloced; } // ------------------------------------------- // default payable function. // if sender is e4row  partner, this is a rake fee payment // otherwise this is a token purchase. // tokens only purchaseable between tokenfundingstart and end // ------------------------------------------- function () payable { if (msg.sender == e4_partner) { feePayment(); // from e4row game escrow contract } else { purchaseToken(); } } // ----------------------------- // purchase token function - tokens only sold during sale period up until the max tokens // purchase price is tokenPrice.  all units in wei. // purchaser will not be included in current pay run // ----------------------------- function purchaseToken() payable { uint nvalue = msg.value; // being careful to preserve msg.value address npurchaser = msg.sender; if (nvalue < tokenPrice) throw; uint qty = nvalue/tokenPrice; updateIcoStatus(); if (icoStatus != IcoStatusValue.saleOpen) // purchase is closed throw; if (totalTokensMinted + qty > maxMintableTokens) throw; if (!holderAccounts[npurchaser].alloced) addAccount(npurchaser); // purchaser waits for next payrun. otherwise can disrupt cur pay run uint newHeld = qty + getHeld(holderAccounts[npurchaser].tokens); holderAccounts[npurchaser].tokens = newHeld | (curPayoutId * (2 ** 48)); totalTokensMinted += qty; totalTokenFundsReceived += nvalue; if (totalTokensMinted == maxMintableTokens) { icoStatus = IcoStatusValue.saleClosed; //test unnecessary -  if (getNumTokensPurchased() >= minIcoTokenGoal) doDeveloperGrant(); StatEventI(\"Purchased,Granted\", qty); } else StatEventI(\"Purchased\", qty); } // --------------------------- // accept payment from e4row contract // --------------------------- function feePayment() payable { if (msg.sender != e4_partner) { StatEvent(\"forbidden\"); return; // thank you } uint nfvalue = msg.value; // preserve value in case changed in dev grant updateIcoStatus(); holdoverBalance += nfvalue; partnerCredits += nfvalue; StatEventI(\"Payment\", nfvalue); if (holdoverBalance > payoutThreshold || payoutBalance > 0) doPayout(); } // --------------------------- // set the e4row partner, this is only done once // --------------------------- function setE4RowPartner(address _addr) public { // ONLY owner can set and ONLY ONCE! (unless \"unlocked\" debug) // once its locked. ONLY ONCE! if (msg.sender == owner) { if ((e4_partner == address(0)) || (settingsState == SettingStateValue.debug)) { e4_partner = _addr; partnerCredits = 0; //StatEventI(\"E4-Set\", 0); } else { StatEvent(\"Already Set\"); } } } // ---------------------------- // return the total tokens purchased // ---------------------------- function getNumTokensPurchased() constant returns(uint _purchased) { _purchased = totalTokensMinted-numDevTokens; } // ---------------------------- // return the num games as reported from the e4row  contract // ---------------------------- function getNumGames() constant returns(uint _games) { //_games = 0; if (e4_partner != address(0)) { iE4RowEscrow pe4 = iE4RowEscrow(e4_partner); _games = uint(pe4.getNumGamesStarted()); } //else //StatEvent(\"Empty E4\"); } // ------------------------------------------------ // get the founders, auxPartner, developer // -------------------------------------------------- function getSpecialAddresses() constant returns (address _fndr, address _aux, address _dev, address _e4) { //if (_sender == owner) { // no msg.sender on constant functions at least in mew _fndr = founderOrg; _aux = auxPartner; _dev = developers; _e4  = e4_partner; //} } // ---------------------------- // update the ico status // ---------------------------- function updateIcoStatus() public { if (icoStatus == IcoStatusValue.succeeded || icoStatus == IcoStatusValue.failed) return; else if (icoStatus == IcoStatusValue.anouncement) { if (now > fundingStart && now <= fundingDeadline) { icoStatus = IcoStatusValue.saleOpen; } else if (now > fundingDeadline) { // should not be here - this will eventually fail icoStatus = IcoStatusValue.saleClosed; } } else { uint numP = getNumTokensPurchased(); uint numG = getNumGames(); if ((now > fundingDeadline && numP < minIcoTokenGoal) || (now > usageDeadline && numG < minUsageGoal)) { icoStatus = IcoStatusValue.failed; } else if ((now > fundingDeadline) // dont want to prevent more token sales && (numP >= minIcoTokenGoal) && (numG >= minUsageGoal)) { icoStatus = IcoStatusValue.succeeded; // hooray } if (icoStatus == IcoStatusValue.saleOpen && ((numP >= maxMintableTokens) || (now > fundingDeadline))) { icoStatus = IcoStatusValue.saleClosed; } } if (!developersGranted && icoStatus != IcoStatusValue.saleOpen && icoStatus != IcoStatusValue.anouncement && getNumTokensPurchased() >= minIcoTokenGoal) { doDeveloperGrant(); // grant whenever status goes from open to anything... } } // ---------------------------- // request refund. Caller must call to request and receive refund // WARNING - withdraw rewards/dividends before calling. // YOU HAVE BEEN WARNED // ---------------------------- function requestRefund() { address nrequester = msg.sender; updateIcoStatus(); uint ntokens = getHeld(holderAccounts[nrequester].tokens); if (icoStatus != IcoStatusValue.failed) StatEvent(\"No Refund\"); else if (ntokens == 0) StatEvent(\"No Tokens\"); else { uint nrefund = ntokens * tokenPrice; if (getNumTokensPurchased() >= minIcoTokenGoal) nrefund -= (nrefund /10); // only 90 percent b/c 10 percent payout holderAccounts[developers].tokens += ntokens; holderAccounts[nrequester].tokens = 0; if (holderAccounts[nrequester].balance > 0) { // see above warning!! if (!holderAccounts[developers].alloced) addAccount(developers); holderAccounts[developers].balance += holderAccounts[nrequester].balance; holderAccounts[nrequester].balance = 0; } if (!nrequester.call.gas(rfGas).value(nrefund)()) throw; //StatEventI(\"Refunded\", nrefund); } } // --------------------------------------------------- // payout rewards to all token holders // use a second holding variable called PayoutBalance to do // the actual payout from b/c too much gas to iterate thru // each payee. Only start a new run at most once per \"minpayinterval\". // Its done in runs of \"maxPaysPer\" // we use special coding for the holderAccounts to avoid a hack // of getting paid at the top of the list then transfering tokens // to another address at the bottom of the list. // because of that each holderAccounts entry gets the payoutid stamped upon it (top two bytes) // also a token transfer will transfer the payout id. // --------------------------------------------------- function doPayout()  internal { if (totalTokensMinted == 0) return; if ((holdoverBalance > 0) && (payoutBalance == 0) && (now > (lastPayoutTime+minPayInterval))) { // start a new run curPayoutId++; if (curPayoutId >= 32768) curPayoutId = 1; lastPayoutTime = now; payoutBalance = int(holdoverBalance); prOrigPayoutBal = payoutBalance; prOrigTokensMint = totalTokensMinted; holdoverBalance = 0; lastPayoutIndex = 0; StatEventI(\"StartRun\", uint(curPayoutId)); } else if (payoutBalance > 0) { // work down the p.o.b uint nAmount; uint nPerTokDistrib = uint(prOrigPayoutBal)/prOrigTokensMint; uint paids = 0; uint i; // intentional for (i = lastPayoutIndex; (paids < maxPaysPer) && (i < numAccounts) && (payoutBalance > 0); i++ ) { address a = holderIndexes[i]; if (a == address(0)) { continue; } var (pid, held) = getPayIdAndHeld(holderAccounts[a].tokens); if ((held > 0) && (pid != curPayoutId)) { nAmount = nPerTokDistrib * held; if (int(nAmount) <= payoutBalance){ holderAccounts[a].balance += nAmount; holderAccounts[a].tokens = (curPayoutId * (2 ** 48)) | held; payoutBalance -= int(nAmount); paids++; } } } lastPayoutIndex = i; if (lastPayoutIndex >= numAccounts || payoutBalance <= 0) { lastPayoutIndex = 0; if (payoutBalance > 0) holdoverBalance += uint(payoutBalance);// put back any leftovers payoutBalance = 0; StatEventI(\"RunComplete\", uint(prOrigPayoutBal) ); } else { StatEventI(\"PayRun\", nPerTokDistrib ); } } } // ---------------------------- // sender withdraw entire rewards/dividends // ---------------------------- function withdrawDividends() public returns (uint _amount) { if (holderAccounts[msg.sender].balance == 0) { //_amount = 0; StatEvent(\"0 Balance\"); return; } else { if ((msg.sender == developers) &&  (now < vestTime)) { //statEvent(\"Tokens not yet vested.\"); //_amount = 0; return; } _amount = holderAccounts[msg.sender].balance; holderAccounts[msg.sender].balance = 0; if (!msg.sender.call.gas(rwGas).value(_amount)()) throw; //StatEventI(\"Paid\", _amount); } } // ---------------------------- // set gas for operations // ---------------------------- function setOpGas(uint _rm, uint _rf, uint _rw) { if (msg.sender != owner && msg.sender != developers) { //StatEvent(\"only owner calls\"); return; } else { rmGas = _rm; rfGas = _rf; rwGas = _rw; } } // ---------------------------- // get gas for operations // ---------------------------- function getOpGas() constant returns (uint _rm, uint _rf, uint _rw) { _rm = rmGas; _rf = rfGas; _rw = rwGas; } // ---------------------------- // check rewards.  pass in address of token holder // ---------------------------- function checkDividends(address _addr) constant returns(uint _amount) { if (holderAccounts[_addr].alloced) _amount = holderAccounts[_addr].balance; } // ------------------------------------------------ // icoCheckup - check up call for administrators // after sale is closed if min ico tokens sold, 10 percent will be distributed to // company to cover various operating expenses // after sale and usage dealines have been met, remaining 90 percent will be distributed to // company. // ------------------------------------------------ function icoCheckup() public { if (msg.sender != owner && msg.sender != developers) throw; uint nmsgmask; //nmsgmask = 0; if (icoStatus == IcoStatusValue.saleClosed) { if ((getNumTokensPurchased() >= minIcoTokenGoal) && (remunerationStage == 0 )) { remunerationStage = 1; remunerationBalance = (totalTokenFundsReceived/100)*9; // 9 percent auxPartnerBalance =  (totalTokenFundsReceived/100); // 1 percent nmsgmask |= 1; } } if (icoStatus == IcoStatusValue.succeeded) { if (remunerationStage == 0 ) { remunerationStage = 1; remunerationBalance = (totalTokenFundsReceived/100)*9; auxPartnerBalance =  (totalTokenFundsReceived/100); nmsgmask |= 4; } if (remunerationStage == 1) { // we have already suceeded remunerationStage = 2; remunerationBalance += totalTokenFundsReceived - (totalTokenFundsReceived/10); // 90 percent nmsgmask |= 8; } } uint ntmp; if (remunerationBalance > 0) { // only pay one entity per call, dont want to run out of gas ntmp = remunerationBalance; remunerationBalance = 0; if (!founderOrg.call.gas(rmGas).value(ntmp)()) { remunerationBalance = ntmp; nmsgmask |= 32; } else { nmsgmask |= 64; } } else  if (auxPartnerBalance > 0) { // note the \"else\" only pay one entity per call, dont want to run out of gas ntmp = auxPartnerBalance; auxPartnerBalance = 0; if (!auxPartner.call.gas(rmGas).value(ntmp)()) { auxPartnerBalance = ntmp; nmsgmask |= 128; }  else { nmsgmask |= 256; } } StatEventI(\"ico-checkup\", nmsgmask); } // ---------------------------- // swap executor // ---------------------------- function changeOwner(address _addr) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; owner = _addr; } // ---------------------------- // swap developers account // ---------------------------- function changeDevevoperAccont(address _addr) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; developers = _addr; } // ---------------------------- // change founder // ---------------------------- function changeFounder(address _addr) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; founderOrg = _addr; } // ---------------------------- // change auxPartner // ---------------------------- function changeAuxPartner(address _aux) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; auxPartner = _aux; } // ---------------------------- // DEBUG ONLY - end this contract, suicide to developers // ---------------------------- function haraKiri() { if (settingsState != SettingStateValue.debug) throw; if (msg.sender != owner) throw; suicide(developers); } // ---------------------------- // get all ico status, funding and usage info // ---------------------------- function getIcoInfo() constant returns(IcoStatusValue _status, uint _saleStart, uint _saleEnd, uint _usageEnd, uint _saleGoal, uint _usageGoal, uint _sold, uint _used, uint _funds, uint _credits, uint _remuStage, uint _vest) { _status = icoStatus; _saleStart = fundingStart; _saleEnd = fundingDeadline; _usageEnd = usageDeadline; _vest = vestTime; _saleGoal = minIcoTokenGoal; _usageGoal = minUsageGoal; _sold = getNumTokensPurchased(); _used = getNumGames(); _funds = totalTokenFundsReceived; _credits = partnerCredits; _remuStage = remunerationStage; } function flushDividends() { if ((msg.sender != owner) && (msg.sender != developers)) return; if (holdoverBalance > 0 || payoutBalance > 0) doPayout(); } function doDeveloperGrant() internal { if (!developersGranted) { developersGranted = true; numDevTokens = totalTokensMinted/10; totalTokensMinted += numDevTokens; if (!holderAccounts[developers].alloced) addAccount(developers); uint newHeld = getHeld(holderAccounts[developers].tokens) + numDevTokens; holderAccounts[developers].tokens = newHeld |  (curPayoutId * (2 ** 48)); } } } "}
{"sol name": "40734.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Owner{ mapping (address => uint) private userBalances; mapping (address => bool) private claimedBonus; mapping (address => uint) private rewardsForA; function untrustedWithdrawReward(address recipient) public { uint amountToWithdraw = rewardsForA[recipient]; rewardsForA[recipient] = 0; if (recipient.call.value(amountToWithdraw)() == false) {  throw;} } function untrustedGetFirstWithdrawalBonus(address recipient) public { if (claimedBonus[recipient] == false) {throw;} claimedBonus[recipient] = true; rewardsForA[recipient] += 100; untrustedWithdrawReward(recipient); } } "}
{"sol name": "34713.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract PPYCOIN is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function PPYCOIN( ) { balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000;                        // Update total supply (100000 for example) name = \"PPYForever\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"PPY\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "43887.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; interface ERC20 { //ERC-20 Token Standard https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md function name() public view returns (string); function symbol() public view returns (string); function decimals() public view returns (uint8); function totalSupply() public view returns (uint256); function balanceOf(address _owner) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } interface TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } interface ERC223Receiver { function tokenFallback(address _from, uint256 _value, bytes _data) public; } contract ERC223 is ERC20 { //ERC223 token standard https://github.com/Dexaran/ERC223-token-standard function transfer(address _to, uint256 _value, bytes _data) public returns (bool success); function transfer(address _to, uint256 _value, bytes _data, string _customFallback) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value, bytes _data); } contract NGToken is ERC223 { string constant private NAME \t\t\t= \"NEO Genesis Token\"; string constant private SYMBOL\t \t\t= \"NGT\"; uint8 constant private DECIMALS \t\t= 18; uint256 constant private INITIAL_SUPPLY\t= 20000000000 * (10 ** uint256(DECIMALS)); uint256 private totalBurned\t\t\t\t= 0; mapping(address => uint256) private balances; mapping(address => mapping(address => uint256)) private allowed; function NGToken() public { balances[msg.sender] = INITIAL_SUPPLY; } //ERC20 function name() public view returns (string) { return NAME; } function symbol() public view returns (string) { return SYMBOL; } function decimals() public view returns (uint8) { return DECIMALS; } function totalSupply() public view returns (uint256) { return INITIAL_SUPPLY - totalBurned; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool success) { if (isContract(_to)) { bytes memory empty; return transferToContract(_to, _value, empty); } else { require(_to != address(0x0)); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); // Transfer(msg.sender, _to, _value, _data); } return true; } function multipleTransfer(address[] _to, uint256 _value) public returns (bool success) { require(_value * _to.length > 0); require(balances[msg.sender] >= _value * _to.length); balances[msg.sender] -= _value * _to.length; for (uint256 i = 0; i < _to.length; ++i) { balances[_to[i]] += _value; Transfer(msg.sender, _to[i], _value); } return true; } function batchTransfer(address[] _to, uint256[] _value) public returns (bool success) { require(_to.length > 0); require(_value.length > 0); require(_to.length == _value.length); for (uint256 i = 0; i < _to.length; ++i) { address to = _to[i]; uint256 value = _value[i]; require(balances[msg.sender] >= value); balances[msg.sender] -= value; balances[to] += value; Transfer(msg.sender, to, value); } return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != address(0x0)); require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_from] -= _value; balances[_to] += _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); bytes memory empty; Transfer(_from, _to, _value, empty); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { //https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/ //force to 0 before calling \"approve\" again require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } return false; } function increaseApproval(address _spender, uint256 _addValue) public returns (bool) { allowed[msg.sender][_spender] += _addValue; Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subValue) public returns (bool) { if (_subValue > allowed[msg.sender][_spender]) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] -= _subValue; } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } //ERC233 function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) { if (isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data, string _customFallback) public returns (bool success) { if (isContract(_to)) { require(_to != address(0x0)); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; assert(_to.call.value(0)(bytes4(keccak256(_customFallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transferToAddress(address _to, uint256 _value, bytes _data) private returns (bool success) { require(_to != address(0x0)); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint256 _value, bytes _data) private returns (bool success) { require(_to != address(0x0)); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; ERC223Receiver receiver = ERC223Receiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function isContract(address _addr) private view returns (bool) { // if (_addr == address(0x0)) // \treturn false; uint256 length; assembly { length := extcodesize(_addr) } return (length > 0); } //Burn event Burn(address indexed burner, uint256 value, uint256 currentSupply, bytes data); function burn(uint256 _value, bytes _data) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; totalBurned += _value; Burn(msg.sender, _value, totalSupply(), _data); return true; } function burnFrom(address _from, uint256 _value, bytes _data) public returns (bool success) { if (transferFrom(_from, msg.sender, _value)) { return burn(_value, _data); } return false; } function initialSupply() public pure returns (uint256) { return INITIAL_SUPPLY; } function currentBurned() public view returns (uint256) { return totalBurned; } //Stop function () public { require(false); } } "}
{"sol name": "38371.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "39079.sol", "label": 0, "sol content": "pragma solidity ^0.4.10; contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } contract Owned { address owner; bool frozen = false; function Owned() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier publicMethod() { require(!frozen); _; } function drain() onlyOwner { owner.transfer(this.balance); } function freeze() onlyOwner { frozen = true; } function unfreeze() onlyOwner { frozen = false; } function destroy() onlyOwner { selfdestruct(owner); } } contract Pixel is Owned, HumanStandardToken { uint32 public size = 1000; uint32 public size2 = size*size; mapping (uint32 => uint24) public pixels; mapping (uint32 => address) public owners; event Set(address indexed _from, uint32[] _xys, uint24[] _rgbs); event Unset(address indexed _from, uint32[] _xys); // Constructor. function Pixel() HumanStandardToken(size2, \"Pixel\", 0, \"PXL\") { } // Public interface. function set(uint32[] _xys, uint24[] _rgbs) publicMethod() { address _from = msg.sender; require(_xys.length == _rgbs.length); require(balances[_from] >= _xys.length); uint32 _xy; uint24 _rgb; for (uint i = 0; i < _xys.length; i++) { _xy = _xys[i]; _rgb = _rgbs[i]; require(_xy < size2); require(owners[_xy] == 0); owners[_xy] = _from; pixels[_xy] = _rgb; } balances[_from] -= _xys.length; Set(_from, _xys, _rgbs); } function unset(uint32[] _xys) publicMethod() { address _from = msg.sender; uint32 _xy; for (uint i = 0; i < _xys.length; i++) { _xy = _xys[i]; require(owners[_xy] == _from); balances[_from] += 1; owners[_xy] = 0; pixels[_xy] = 0; } Unset(_from, _xys); } // Constants. function row(uint32 _y) constant returns (uint24[1000], address[1000]) { uint32 _start = _y * size; uint24[1000] memory rgbs; address[1000] memory addrs; for (uint32 i = 0; i < 1000; i++) { rgbs[i] = pixels[_start + i]; addrs[i] = owners[_start + i]; } return (rgbs, addrs); } } "}
{"sol name": "40090.sol", "label": 0, "sol content": "// \u00a9 2016 Ambisafe Inc. No reuse without written permission is allowed. contract Delegate { mapping(address => mapping(address => bool)) public senderDelegates; modifier onlyDelegate(address _sender) { if (_sender == msg.sender || address(this) == msg.sender || senderDelegates[_sender][msg.sender]) { _ } } function setDelegate(address _delegate, bool _trust) returns(bool) { senderDelegates[msg.sender][_delegate] = _trust; return true; } } contract MultiAccess is Delegate { address public multiAccessRecipient; struct PendingOperation { bool[] ownersDone; uint yetNeeded; bytes32 op; } struct PendingState { PendingOperation[] pending; mapping(bytes32 => uint) pendingIndex; } mapping(uint => PendingState) pendingState; uint currentPendingState; uint public multiAccessRequired; mapping(address => uint) ownerIndex; address[] public multiAccessOwners; event Confirmation(address indexed owner, bytes32 indexed operation, bool completed); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); function MultiAccess() { multiAccessOwners.length = 2; multiAccessOwners[1] = msg.sender; ownerIndex[msg.sender] = 1; multiAccessRequired = 1; pendingState[0].pending.length = 1; } function _state() internal constant returns(PendingState storage) { return pendingState[currentPendingState]; } function multiAccessHasConfirmed(bytes32 _operation, address _owner) constant returns(bool) { uint pos = _state().pendingIndex[_operation]; if (pos == 0) { return false; } uint index = ownerIndex[_owner]; var pendingOp = _state().pending[pos]; if (index >= pendingOp.ownersDone.length) { return false; } return pendingOp.ownersDone[index]; } function multiAccessGetOwners() constant returns(address[]) { address[] memory owners = new address[](multiAccessOwners.length - 1); for (uint i = 1; i < multiAccessOwners.length; i++) { owners[i-1] = multiAccessOwners[i]; } return owners; } modifier onlyowner(address _owner) { if (multiAccessIsOwner(_owner)) { _ } } modifier onlymanyowners(address _owner, bytes32 _operation) { if (_confirmAndCheck(_owner, _operation)) { _ } } function _confirmAndCheck(address _owner, bytes32 _operation) onlyowner(_owner) internal returns(bool) { uint index = ownerIndex[_owner]; if (multiAccessHasConfirmed(_operation, _owner)) { return false; } uint pos = _state().pendingIndex[_operation]; if (pos == 0) { pos = _state().pending.length++; _state().pending[pos].yetNeeded = multiAccessRequired; _state().pending[pos].op = _operation; _state().pendingIndex[_operation] = pos; } var pendingOp = _state().pending[pos]; if (pendingOp.yetNeeded <= 1) { Confirmation(_owner, _operation, true); _removeOperation(_operation); return true; } else { Confirmation(_owner, _operation, false); pendingOp.yetNeeded--; if (index >= pendingOp.ownersDone.length) { pendingOp.ownersDone.length = index+1; } pendingOp.ownersDone[index] = true; } return false; } function _incrementState() internal { currentPendingState++; pendingState[currentPendingState].pending.length++; } function _removeOperation(bytes32 _operation) internal { uint pos = _state().pendingIndex[_operation]; if (pos < _state().pending.length-1) { PendingOperation last = _state().pending[_state().pending.length-1]; _state().pending[pos] = last; _state().pendingIndex[last.op] = pos; } _state().pending.length--; delete _state().pendingIndex[_operation]; } function multiAccessIsOwner(address _addr) constant returns(bool) { return ownerIndex[_addr] > 0; } function multiAccessRevoke(bytes32 _operation) returns(bool) { return multiAccessRevokeD(_operation, msg.sender); } function multiAccessRevokeD(bytes32 _operation, address _sender) onlyDelegate(_sender) onlyowner(_sender) returns(bool) { uint index = ownerIndex[_sender]; if (!multiAccessHasConfirmed(_operation, _sender)) { return false; } var pendingOp = _state().pending[_state().pendingIndex[_operation]]; pendingOp.ownersDone[index] = false; pendingOp.yetNeeded++; if (pendingOp.yetNeeded == multiAccessRequired) { _removeOperation(_operation); } Revoke(_sender, _operation); return true; } function multiAccessChangeOwner(address _from, address _to) returns(bool) { return this.multiAccessChangeOwnerD(_from, _to, msg.sender); } function multiAccessChangeOwnerD(address _from, address _to, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _from, _to)) returns(bool) { if (multiAccessIsOwner(_to)) { return false; } uint index = ownerIndex[_from]; if (index == 0) { return false; } multiAccessOwners[index] = _to; delete ownerIndex[_from]; ownerIndex[_to] = index; _incrementState(); OwnerChanged(_from, _to); return true; } function multiAccessAddOwner(address _owner) returns(bool) { return this.multiAccessAddOwnerD(_owner, msg.sender); } function multiAccessAddOwnerD(address _owner, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _owner)) returns(bool) { if (multiAccessIsOwner(_owner)) { return false; } uint pos = multiAccessOwners.length++; multiAccessOwners[pos] = _owner; ownerIndex[_owner] = pos; OwnerAdded(_owner); return true; } function multiAccessRemoveOwner(address _owner) returns(bool) { return this.multiAccessRemoveOwnerD(_owner, msg.sender); } function multiAccessRemoveOwnerD(address _owner, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _owner)) returns(bool) { uint index = ownerIndex[_owner]; if (index == 0) { return false; } if (multiAccessRequired >= multiAccessOwners.length-1) { return false; } if (index < multiAccessOwners.length-1) { address last = multiAccessOwners[multiAccessOwners.length-1]; multiAccessOwners[index] = last; ownerIndex[last] = index; } multiAccessOwners.length--; delete ownerIndex[_owner]; _incrementState(); OwnerRemoved(_owner); return true; } function multiAccessChangeRequirement(uint _newRequired) returns(bool) { return this.multiAccessChangeRequirementD(_newRequired, msg.sender); } function multiAccessChangeRequirementD(uint _newRequired, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _newRequired)) returns(bool) { if (_newRequired == 0 || _newRequired > multiAccessOwners.length-1) { return false; } multiAccessRequired = _newRequired; _incrementState(); RequirementChanged(_newRequired); return true; } function multiAccessSetRecipient(address _address) returns(bool) { return this.multiAccessSetRecipientD(_address, msg.sender); } function multiAccessSetRecipientD(address _address, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _address)) returns(bool) { multiAccessRecipient = _address; return true; } function multiAccessCall(address _to, uint _value, bytes _data) returns(bool) { return this.multiAccessCallD(_to, _value, _data, msg.sender); } function multiAccessCallD(address _to, uint _value, bytes _data, address _sender) external onlyDelegate(_sender) onlymanyowners(_sender, sha3(msg.sig, _to, _value, _data)) returns(bool) { return _to.call.value(_value)(_data); } function() returns(bool) { return multiAccessCall(multiAccessRecipient, msg.value, msg.data); } } "}
{"sol name": "31956.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract Millenium is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function Millenium( ) { balances[msg.sender] = 50000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 50000000;                        // Update total supply (100000 for example) name = \"Milleniuim\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"MLL\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "40362.sol", "label": 0, "sol content": "contract AmIOnTheFork { function forked() constant returns(bool); } contract SellETCSafely { // fork oracle to use AmIOnTheFork amIOnTheFork = AmIOnTheFork(0x2bd2326c993dfaef84f696526064ff22eba5b362); // recipient of the 1 % fee on the ETC side address feeRecipient = 0x46a1e8814af10Ef6F1a8449dA0EC72a59B29EA54; function split(address ethDestination, address etcDestination) { if (amIOnTheFork.forked()) { // The following happens on the forked chain: // 100 % is forwarded to the provided destination for ETH ethDestination.call.value(msg.value); } else { // The following happens on the classic chain: // 1 % is forwarded to the fee recipient // 99 % is forwarded to the provided destination for ETC uint fee = msg.value / 100; feeRecipient.send(fee); etcDestination.call.value(msg.value - fee)(); } } function () { throw;  // do not accept value transfers } } "}
{"sol name": "35016.sol", "label": 0, "sol content": "/* Darth Jahus Token (DJX) */ /* For personal use only.  */ /* Forked from TokenFactory (https://github.com/ConsenSys/Token-Factory) */ pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* This implements ONLY the standard functions and NOTHING else. For a token like you would want to deploy in something like Mist, see HumanStandardToken.sol. If you deploy this, you won't have anything useful. Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 .*/ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } /* This Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans. In other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans. Imagine coins, currencies, shares, voting weight, etc. Machine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners. 1) Initial Finite Supply (upon creation one specifies how much is minted). 2) In the absence of a token registry: Optional Decimal, Symbol & Name. 3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred. .*/ contract DarthJahusToken is StandardToken { function () { //if ether is sent to this address, send it back. revert(); } /* Public variables of the token */ uint256 _initialAmount = 1000000; string _tokenName = \"Darth Jahus Token\"; uint8 _decimalUnits = 0; string _tokenSymbol = \"DJX\"; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function DarthJahusToken() { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); } return true; } } "}
{"sol name": "33516.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; contract PullPayInterface { function asyncSend(address _dest) public payable; } contract Governable { // list of admins, council at first spot address[] public admins; function Governable() { admins.length = 1; admins[0] = msg.sender; } modifier onlyAdmins() { bool isAdmin = false; for (uint256 i = 0; i < admins.length; i++) { if (msg.sender == admins[i]) { isAdmin = true; } } require(isAdmin == true); _; } function addAdmin(address _admin) public onlyAdmins { for (uint256 i = 0; i < admins.length; i++) { require(_admin != admins[i]); } require(admins.length < 10); admins[admins.length++] = _admin; } function removeAdmin(address _admin) public onlyAdmins { uint256 pos = admins.length; for (uint256 i = 0; i < admins.length; i++) { if (_admin == admins[i]) { pos = i; } } require(pos < admins.length); // if not last element, switch with last if (pos < admins.length - 1) { admins[pos] = admins[admins.length - 1]; } // then cut off the tail admins.length--; } } contract StorageEnabled { // satelite contract addresses address public storageAddr; function StorageEnabled(address _storageAddr) { storageAddr = _storageAddr; } // ############################################ // ########### NUTZ FUNCTIONS  ################ // ############################################ // all Nutz balances function babzBalanceOf(address _owner) constant returns (uint256) { return Storage(storageAddr).getBal('Nutz', _owner); } function _setBabzBalanceOf(address _owner, uint256 _newValue) internal { Storage(storageAddr).setBal('Nutz', _owner, _newValue); } // active supply - sum of balances above function activeSupply() constant returns (uint256) { return Storage(storageAddr).getUInt('Nutz', 'activeSupply'); } function _setActiveSupply(uint256 _newActiveSupply) internal { Storage(storageAddr).setUInt('Nutz', 'activeSupply', _newActiveSupply); } // burn pool - inactive supply function burnPool() constant returns (uint256) { return Storage(storageAddr).getUInt('Nutz', 'burnPool'); } function _setBurnPool(uint256 _newBurnPool) internal { Storage(storageAddr).setUInt('Nutz', 'burnPool', _newBurnPool); } // power pool - inactive supply function powerPool() constant returns (uint256) { return Storage(storageAddr).getUInt('Nutz', 'powerPool'); } function _setPowerPool(uint256 _newPowerPool) internal { Storage(storageAddr).setUInt('Nutz', 'powerPool', _newPowerPool); } // ############################################ // ########### POWER   FUNCTIONS  ############# // ############################################ // all power balances function powerBalanceOf(address _owner) constant returns (uint256) { return Storage(storageAddr).getBal('Power', _owner); } function _setPowerBalanceOf(address _owner, uint256 _newValue) internal { Storage(storageAddr).setBal('Power', _owner, _newValue); } function outstandingPower() constant returns (uint256) { return Storage(storageAddr).getUInt('Power', 'outstandingPower'); } function _setOutstandingPower(uint256 _newOutstandingPower) internal { Storage(storageAddr).setUInt('Power', 'outstandingPower', _newOutstandingPower); } function authorizedPower() constant returns (uint256) { return Storage(storageAddr).getUInt('Power', 'authorizedPower'); } function _setAuthorizedPower(uint256 _newAuthorizedPower) internal { Storage(storageAddr).setUInt('Power', 'authorizedPower', _newAuthorizedPower); } function downs(address _user) constant public returns (uint256 total, uint256 left, uint256 start) { uint256 rawBytes = Storage(storageAddr).getBal('PowerDown', _user); start = uint64(rawBytes); left = uint96(rawBytes >> (64)); total = uint96(rawBytes >> (96 + 64)); return; } function _setDownRequest(address _holder, uint256 total, uint256 left, uint256 start) internal { uint256 result = uint64(start) + (left << 64) + (total << (96 + 64)); Storage(storageAddr).setBal('PowerDown', _holder, result); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Governable { bool public paused = true; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyAdmins whenNotPaused { paused = true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyAdmins whenPaused { //TODO: do some checks paused = false; } } /* * ERC20Basic * Simpler version of ERC20 interface * see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20Basic { function totalSupply() constant returns (uint256); function balanceOf(address _owner) constant returns (uint256); function transfer(address _to, uint256 _value) returns (bool); event Transfer(address indexed from, address indexed to, uint value); } contract ERC223Basic is ERC20Basic { function transfer(address to, uint value, bytes data) returns (bool); } /* * ERC20 interface * see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC223Basic { // active supply of tokens function activeSupply() constant returns (uint256); function allowance(address _owner, address _spender) constant returns (uint256); function transferFrom(address _from, address _to, uint _value) returns (bool); function approve(address _spender, uint256 _value); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract Power is Ownable, ERC20Basic { event Slashing(address indexed holder, uint value, bytes32 data); string public name = \"Acebusters Power\"; string public symbol = \"ABP\"; uint256 public decimals = 12; function balanceOf(address _holder) constant returns (uint256) { return ControllerInterface(owner).powerBalanceOf(_holder); } function totalSupply() constant returns (uint256) { return ControllerInterface(owner).powerTotalSupply(); } function activeSupply() constant returns (uint256) { return ControllerInterface(owner).outstandingPower(); } // ############################################ // ########### ADMIN FUNCTIONS ################ // ############################################ function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyOwner { Slashing(_holder, _value, _data); } function powerUp(address _holder, uint256 _value) public onlyOwner { // NTZ transfered from user's balance to power pool Transfer(address(0), _holder, _value); } // ############################################ // ########### PUBLIC FUNCTIONS ############### // ############################################ // registers a powerdown request function transfer(address _to, uint256 _amountPower) public returns (bool success) { // make Power not transferable require(_to == address(0)); ControllerInterface(owner).createDownRequest(msg.sender, _amountPower); Transfer(msg.sender, address(0), _amountPower); return true; } function downtime() public returns (uint256) { ControllerInterface(owner).downtime; } function downTick(address _owner) public { ControllerInterface(owner).downTick(_owner, now); } function downs(address _owner) constant public returns (uint256, uint256, uint256) { return ControllerInterface(owner).downs(_owner); } } contract Storage is Ownable { struct Crate { mapping(bytes32 => uint256) uints; mapping(bytes32 => address) addresses; mapping(bytes32 => bool) bools; mapping(address => uint256) bals; } mapping(bytes32 => Crate) crates; function setUInt(bytes32 _crate, bytes32 _key, uint256 _value) onlyOwner { crates[_crate].uints[_key] = _value; } function getUInt(bytes32 _crate, bytes32 _key) constant returns(uint256) { return crates[_crate].uints[_key]; } function setAddress(bytes32 _crate, bytes32 _key, address _value) onlyOwner { crates[_crate].addresses[_key] = _value; } function getAddress(bytes32 _crate, bytes32 _key) constant returns(address) { return crates[_crate].addresses[_key]; } function setBool(bytes32 _crate, bytes32 _key, bool _value) onlyOwner { crates[_crate].bools[_key] = _value; } function getBool(bytes32 _crate, bytes32 _key) constant returns(bool) { return crates[_crate].bools[_key]; } function setBal(bytes32 _crate, address _key, uint256 _value) onlyOwner { crates[_crate].bals[_key] = _value; } function getBal(bytes32 _crate, address _key) constant returns(uint256) { return crates[_crate].bals[_key]; } } contract NutzEnabled is Pausable, StorageEnabled { using SafeMath for uint; // satelite contract addresses address public nutzAddr; modifier onlyNutz() { require(msg.sender == nutzAddr); _; } function NutzEnabled(address _nutzAddr, address _storageAddr) StorageEnabled(_storageAddr) { nutzAddr = _nutzAddr; } // ############################################ // ########### NUTZ FUNCTIONS  ################ // ############################################ // total supply(modified for etherscan display) function totalSupply() constant returns (uint256) { return activeSupply(); } // total supply(for internal calculations) function completeSupply() constant returns (uint256) { return activeSupply().add(powerPool()).add(burnPool()); } // allowances according to ERC20 // not written to storage, as not very critical mapping (address => mapping (address => uint)) internal allowed; function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; } function approve(address _owner, address _spender, uint256 _amountBabz) public onlyNutz whenNotPaused { require(_owner != _spender); allowed[_owner][_spender] = _amountBabz; } function _transfer(address _from, address _to, uint256 _amountBabz, bytes _data) internal { require(_to != address(this)); require(_to != address(0)); require(_amountBabz > 0); require(_from != _to); _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz)); _setBabzBalanceOf(_to, babzBalanceOf(_to).add(_amountBabz)); } function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused { _transfer(_from, _to, _amountBabz, _data); } function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public onlyNutz whenNotPaused { allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz); _transfer(_from, _to, _amountBabz, _data); } } /* * Contract that is working with ERC223 tokens */ contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data); } contract ControllerInterface { // State Variables bool public paused; address public nutzAddr; // Nutz functions function babzBalanceOf(address _owner) constant returns (uint256); function activeSupply() constant returns (uint256); function burnPool() constant returns (uint256); function powerPool() constant returns (uint256); function totalSupply() constant returns (uint256); function completeSupply() constant returns (uint256); function allowance(address _owner, address _spender) constant returns (uint256); function approve(address _owner, address _spender, uint256 _amountBabz) public; function transfer(address _from, address _to, uint256 _amountBabz, bytes _data) public; function transferFrom(address _sender, address _from, address _to, uint256 _amountBabz, bytes _data) public; // Market functions function floor() constant returns (uint256); function ceiling() constant returns (uint256); function purchase(address _sender, uint256 _value, uint256 _price) public returns (uint256); function sell(address _from, uint256 _price, uint256 _amountBabz); // Power functions function powerBalanceOf(address _owner) constant returns (uint256); function outstandingPower() constant returns (uint256); function authorizedPower() constant returns (uint256); function powerTotalSupply() constant returns (uint256); function powerUp(address _sender, address _from, uint256 _amountBabz) public; function downTick(address _owner, uint256 _now) public; function createDownRequest(address _owner, uint256 _amountPower) public; function downs(address _owner) constant public returns(uint256, uint256, uint256); function downtime() constant returns (uint256); } /** * @title PullPayment * @dev Base contract supporting async send for pull payments. */ contract PullPayment is Ownable { using SafeMath for uint256; uint public dailyLimit = 1000000000000000000000;  // 1 ETH uint public lastDay; uint public spentToday; // 8bytes date, 24 bytes value mapping(address => uint256) internal payments; modifier onlyNutz() { require(msg.sender == ControllerInterface(owner).nutzAddr()); _; } modifier whenNotPaused () { require(!ControllerInterface(owner).paused()); _; } function balanceOf(address _owner) constant returns (uint256 value) { return uint192(payments[_owner]); } function paymentOf(address _owner) constant returns (uint256 value, uint256 date) { value = uint192(payments[_owner]); date = (payments[_owner] >> 192); return; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyOwner { dailyLimit = _dailyLimit; } function changeWithdrawalDate(address _owner, uint256 _newDate)  public onlyOwner { // allow to withdraw immediately // move witdrawal date more days into future payments[_owner] = (_newDate << 192) + uint192(payments[_owner]); } function asyncSend(address _dest) public payable onlyNutz { require(msg.value > 0); uint256 newValue = msg.value.add(uint192(payments[_dest])); uint256 newDate; if (isUnderLimit(msg.value)) { uint256 date = payments[_dest] >> 192; newDate = (date > now) ? date : now; } else { newDate = now.add(3 days); } spentToday = spentToday.add(msg.value); payments[_dest] = (newDate << 192) + uint192(newValue); } function withdraw() public whenNotPaused { address untrustedRecipient = msg.sender; uint256 amountWei = uint192(payments[untrustedRecipient]); require(amountWei != 0); require(now >= (payments[untrustedRecipient] >> 192)); require(this.balance >= amountWei); payments[untrustedRecipient] = 0; assert(untrustedRecipient.call.gas(1000).value(amountWei)()); } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay.add(24 hours)) { lastDay = now; spentToday = 0; } // not using safe math because we don't want to throw; if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) { return false; } return true; } } /** * Nutz implements a price floor and a price ceiling on the token being * sold. It is based of the zeppelin token contract. */ contract Nutz is Ownable, ERC20 { event Sell(address indexed seller, uint256 value); string public name = \"Acebusters Nutz\"; // acebusters units: // 10^12 - Nutz   (NTZ) // 10^9 - Jonyz // 10^6 - Helcz // 10^3 - Pascalz // 10^0 - Babz string public symbol = \"NTZ\"; uint256 public decimals = 12; // returns balances of active holders function balanceOf(address _owner) constant returns (uint) { return ControllerInterface(owner).babzBalanceOf(_owner); } function totalSupply() constant returns (uint256) { return ControllerInterface(owner).totalSupply(); } function activeSupply() constant returns (uint256) { return ControllerInterface(owner).activeSupply(); } // return remaining allowance // if calling return allowed[address(this)][_spender]; // returns balance of ether parked to be withdrawn function allowance(address _owner, address _spender) constant returns (uint256) { return ControllerInterface(owner).allowance(_owner, _spender); } // returns either the salePrice, or if reserve does not suffice // for active supply, returns maxFloor function floor() constant returns (uint256) { return ControllerInterface(owner).floor(); } // returns either the salePrice, or if reserve does not suffice // for active supply, returns maxFloor function ceiling() constant returns (uint256) { return ControllerInterface(owner).ceiling(); } function powerPool() constant returns (uint256) { return ControllerInterface(owner).powerPool(); } function _checkDestination(address _from, address _to, uint256 _value, bytes _data) internal { // erc223: Retrieve the size of the code on target address, this needs assembly . uint256 codeLength; assembly { codeLength := extcodesize(_to) } if(codeLength>0) { ERC223ReceivingContract untrustedReceiver = ERC223ReceivingContract(_to); // untrusted contract call untrustedReceiver.tokenFallback(_from, _value, _data); } } // ############################################ // ########### ADMIN FUNCTIONS ################ // ############################################ function powerDown(address powerAddr, address _holder, uint256 _amountBabz) public onlyOwner { bytes memory empty; _checkDestination(powerAddr, _holder, _amountBabz, empty); // NTZ transfered from power pool to user's balance Transfer(powerAddr, _holder, _amountBabz); } function asyncSend(address _pullAddr, address _dest, uint256 _amountWei) public onlyOwner { assert(_amountWei <= this.balance); PullPayInterface(_pullAddr).asyncSend.value(_amountWei)(_dest); } // ############################################ // ########### PUBLIC FUNCTIONS ############### // ############################################ function approve(address _spender, uint256 _amountBabz) public { ControllerInterface(owner).approve(msg.sender, _spender, _amountBabz); Approval(msg.sender, _spender, _amountBabz); } function transfer(address _to, uint256 _amountBabz, bytes _data) public returns (bool) { ControllerInterface(owner).transfer(msg.sender, _to, _amountBabz, _data); Transfer(msg.sender, _to, _amountBabz); _checkDestination(msg.sender, _to, _amountBabz, _data); return true; } function transfer(address _to, uint256 _amountBabz) public returns (bool) { bytes memory empty; return transfer(_to, _amountBabz, empty); } function transData(address _to, uint256 _amountBabz, bytes _data) public returns (bool) { return transfer(_to, _amountBabz, _data); } function transferFrom(address _from, address _to, uint256 _amountBabz, bytes _data) public returns (bool) { ControllerInterface(owner).transferFrom(msg.sender, _from, _to, _amountBabz, _data); Transfer(_from, _to, _amountBabz); _checkDestination(_from, _to, _amountBabz, _data); return true; } function transferFrom(address _from, address _to, uint256 _amountBabz) public returns (bool) { bytes memory empty; return transferFrom(_from, _to, _amountBabz, empty); } function () public payable { uint256 price = ControllerInterface(owner).ceiling(); purchase(price); require(msg.value > 0); } function purchase(uint256 _price) public payable { require(msg.value > 0); uint256 amountBabz = ControllerInterface(owner).purchase(msg.sender, msg.value, _price); Transfer(owner, msg.sender, amountBabz); bytes memory empty; _checkDestination(address(this), msg.sender, amountBabz, empty); } function sell(uint256 _price, uint256 _amountBabz) public { require(_amountBabz != 0); ControllerInterface(owner).sell(msg.sender, _price, _amountBabz); Sell(msg.sender, _amountBabz); } function powerUp(uint256 _amountBabz) public { Transfer(msg.sender, owner, _amountBabz); ControllerInterface(owner).powerUp(msg.sender, msg.sender, _amountBabz); } } contract MarketEnabled is NutzEnabled { uint256 constant INFINITY = 0xffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff; // address of the pull payemnt satelite address public pullAddr; // the Token sale mechanism parameters: // purchasePrice is the number of NTZ received for purchase with 1 ETH uint256 internal purchasePrice; // floor is the number of NTZ needed, to receive 1 ETH in sell uint256 internal salePrice; function MarketEnabled(address _pullAddr, address _storageAddr, address _nutzAddr) NutzEnabled(_nutzAddr, _storageAddr) { pullAddr = _pullAddr; } function ceiling() constant returns (uint256) { return purchasePrice; } // returns either the salePrice, or if reserve does not suffice // for active supply, returns maxFloor function floor() constant returns (uint256) { if (nutzAddr.balance == 0) { return INFINITY; } uint256 maxFloor = activeSupply().mul(1000000).div(nutzAddr.balance); // 1,000,000 WEI, used as price factor // return max of maxFloor or salePrice return maxFloor >= salePrice ? maxFloor : salePrice; } function moveCeiling(uint256 _newPurchasePrice) public onlyAdmins { require(_newPurchasePrice <= salePrice); purchasePrice = _newPurchasePrice; } function moveFloor(uint256 _newSalePrice) public onlyAdmins { require(_newSalePrice >= purchasePrice); // moveFloor fails if the administrator tries to push the floor so low // that the sale mechanism is no longer able to buy back all tokens at // the floor price if those funds were to be withdrawn. if (_newSalePrice < INFINITY) { require(nutzAddr.balance >= activeSupply().mul(1000000).div(_newSalePrice)); // 1,000,000 WEI, used as price factor } salePrice = _newSalePrice; } function purchase(address _sender, uint256 _value, uint256 _price) public onlyNutz whenNotPaused returns (uint256) { // disable purchases if purchasePrice set to 0 require(purchasePrice > 0); require(_price == purchasePrice); uint256 amountBabz = purchasePrice.mul(_value).div(1000000); // 1,000,000 WEI, used as price factor // avoid deposits that issue nothing // might happen with very high purchase price require(amountBabz > 0); // make sure power pool grows proportional to economy uint256 activeSup = activeSupply(); uint256 powPool = powerPool(); if (powPool > 0) { uint256 powerShare = powPool.mul(amountBabz).div(activeSup.add(burnPool())); _setPowerPool(powPool.add(powerShare)); } _setActiveSupply(activeSup.add(amountBabz)); _setBabzBalanceOf(_sender, babzBalanceOf(_sender).add(amountBabz)); return amountBabz; } function sell(address _from, uint256 _price, uint256 _amountBabz) public onlyNutz whenNotPaused { uint256 effectiveFloor = floor(); require(_amountBabz != 0); require(effectiveFloor != INFINITY); require(_price == effectiveFloor); uint256 amountWei = _amountBabz.mul(1000000).div(effectiveFloor);  // 1,000,000 WEI, used as price factor require(amountWei > 0); // make sure power pool shrinks proportional to economy uint256 powPool = powerPool(); uint256 activeSup = activeSupply(); if (powPool > 0) { uint256 powerShare = powPool.mul(_amountBabz).div(activeSup.add(burnPool())); _setPowerPool(powPool.sub(powerShare)); } _setActiveSupply(activeSup.sub(_amountBabz)); _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz)); Nutz(nutzAddr).asyncSend(pullAddr, _from, amountWei); } // withdraw excessive reserve - i.e. milestones function allocateEther(uint256 _amountWei, address _beneficiary) public onlyAdmins { require(_amountWei > 0); // allocateEther fails if allocating those funds would mean that the // sale mechanism is no longer able to buy back all tokens at the floor // price if those funds were to be withdrawn. require(nutzAddr.balance.sub(_amountWei) >= activeSupply().mul(1000000).div(salePrice)); // 1,000,000 WEI, used as price factor Nutz(nutzAddr).asyncSend(pullAddr, _beneficiary, _amountWei); } } contract PowerEnabled is MarketEnabled { // satelite contract addresses address public powerAddr; // maxPower is a limit of total power that can be outstanding // maxPower has a valid value between outstandingPower and authorizedPow/2 uint256 public maxPower = 0; // time it should take to power down uint256 public downtime; uint public constant MIN_SHARE_OF_POWER = 100000; modifier onlyPower() { require(msg.sender == powerAddr); _; } function PowerEnabled(address _powerAddr, address _pullAddr, address _storageAddr, address _nutzAddr) MarketEnabled(_pullAddr, _nutzAddr, _storageAddr) { powerAddr = _powerAddr; } function setMaxPower(uint256 _maxPower) public onlyAdmins { require(outstandingPower() <= _maxPower && _maxPower < authorizedPower()); maxPower = _maxPower; } function setDowntime(uint256 _downtime) public onlyAdmins { downtime = _downtime; } function minimumPowerUpSizeBabz() public constant returns (uint256) { uint256 completeSupplyBabz = completeSupply(); if (completeSupplyBabz == 0) { return INFINITY; } return completeSupplyBabz.div(MIN_SHARE_OF_POWER); } // this is called when NTZ are deposited into the burn pool function dilutePower(uint256 _amountBabz, uint256 _amountPower) public onlyAdmins { uint256 authorizedPow = authorizedPower(); uint256 totalBabz = completeSupply(); if (authorizedPow == 0) { // during the first capital increase, set value directly as authorized shares _setAuthorizedPower((_amountPower > 0) ? _amountPower : _amountBabz.add(totalBabz)); } else { // in later increases, expand authorized shares at same rate like economy _setAuthorizedPower(authorizedPow.mul(totalBabz.add(_amountBabz)).div(totalBabz)); } _setBurnPool(burnPool().add(_amountBabz)); } function _slashPower(address _holder, uint256 _value, bytes32 _data) internal { uint256 previouslyOutstanding = outstandingPower(); _setOutstandingPower(previouslyOutstanding.sub(_value)); // adjust size of power pool uint256 powPool = powerPool(); uint256 slashingBabz = _value.mul(powPool).div(previouslyOutstanding); _setPowerPool(powPool.sub(slashingBabz)); // put event into satelite contract Power(powerAddr).slashPower(_holder, _value, _data); } function slashPower(address _holder, uint256 _value, bytes32 _data) public onlyAdmins { _setPowerBalanceOf(_holder, powerBalanceOf(_holder).sub(_value)); _slashPower(_holder, _value, _data); } function slashDownRequest(uint256 _pos, address _holder, uint256 _value, bytes32 _data) public onlyAdmins { var (total, left, start) = downs(_holder); left = left.sub(_value); _setDownRequest(_holder, total, left, start); _slashPower(_holder, _value, _data); } // this is called when NTZ are deposited into the power pool function powerUp(address _sender, address _from, uint256 _amountBabz) public onlyNutz whenNotPaused { uint256 authorizedPow = authorizedPower(); require(authorizedPow != 0); require(_amountBabz != 0); uint256 totalBabz = completeSupply(); require(totalBabz != 0); uint256 amountPow = _amountBabz.mul(authorizedPow).div(totalBabz); // check pow limits uint256 outstandingPow = outstandingPower(); require(outstandingPow.add(amountPow) <= maxPower); uint256 powBal = powerBalanceOf(_from).add(amountPow); require(powBal >= authorizedPow.div(MIN_SHARE_OF_POWER)); if (_sender != _from) { allowed[_from][_sender] = allowed[_from][_sender].sub(_amountBabz); } _setOutstandingPower(outstandingPow.add(amountPow)); _setPowerBalanceOf(_from, powBal); _setActiveSupply(activeSupply().sub(_amountBabz)); _setBabzBalanceOf(_from, babzBalanceOf(_from).sub(_amountBabz)); _setPowerPool(powerPool().add(_amountBabz)); Power(powerAddr).powerUp(_from, amountPow); } function powerTotalSupply() constant returns (uint256) { uint256 issuedPower = authorizedPower().div(2); // return max of maxPower or issuedPower return maxPower >= issuedPower ? maxPower : issuedPower; } function _vestedDown(uint256 _total, uint256 _left, uint256 _start, uint256 _now) internal constant returns (uint256) { if (_now <= _start) { return 0; } // calculate amountVested // amountVested is amount that can be withdrawn according to time passed uint256 timePassed = _now.sub(_start); if (timePassed > downtime) { timePassed = downtime; } uint256 amountVested = _total.mul(timePassed).div(downtime); uint256 amountFrozen = _total.sub(amountVested); if (_left <= amountFrozen) { return 0; } return _left.sub(amountFrozen); } function createDownRequest(address _owner, uint256 _amountPower) public onlyPower whenNotPaused { // prevent powering down tiny amounts // when powering down, at least completeSupply/minShare Power should be claimed require(_amountPower >= authorizedPower().div(MIN_SHARE_OF_POWER)); _setPowerBalanceOf(_owner, powerBalanceOf(_owner).sub(_amountPower)); var (, left, ) = downs(_owner); uint256 total = _amountPower.add(left); _setDownRequest(_owner, total, total, now); } // executes a powerdown request function downTick(address _holder, uint256 _now) public onlyPower whenNotPaused { var (total, left, start) = downs(_holder); uint256 amountPow = _vestedDown(total, left, start, _now); // prevent power down in tiny steps uint256 minStep = total.div(10); require(left <= minStep || minStep <= amountPow); // calculate token amount representing share of power uint256 amountBabz = amountPow.mul(completeSupply()).div(authorizedPower()); // transfer power and tokens _setOutstandingPower(outstandingPower().sub(amountPow)); left = left.sub(amountPow); _setPowerPool(powerPool().sub(amountBabz)); _setActiveSupply(activeSupply().add(amountBabz)); _setBabzBalanceOf(_holder, babzBalanceOf(_holder).add(amountBabz)); // down request completed if (left == 0) { start = 0; total = 0; } // TODO _setDownRequest(_holder, total, left, start); Nutz(nutzAddr).powerDown(powerAddr, _holder, amountBabz); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Controller is PowerEnabled { function Controller(address _powerAddr, address _pullAddr, address _nutzAddr, address _storageAddr) PowerEnabled(_powerAddr, _pullAddr, _nutzAddr, _storageAddr) { } function setContracts(address _storageAddr, address _nutzAddr, address _powerAddr, address _pullAddr) public onlyAdmins whenPaused { storageAddr = _storageAddr; nutzAddr = _nutzAddr; powerAddr = _powerAddr; pullAddr = _pullAddr; } function changeDailyLimit(uint256 _dailyLimit) public onlyAdmins { PullPayment(pullAddr).changeDailyLimit(_dailyLimit); } function kill(address _newController) public onlyAdmins whenPaused { if (powerAddr != address(0)) { Ownable(powerAddr).transferOwnership(msg.sender); } if (pullAddr != address(0)) { Ownable(pullAddr).transferOwnership(msg.sender); } if (nutzAddr != address(0)) { Ownable(nutzAddr).transferOwnership(msg.sender); } if (storageAddr != address(0)) { Ownable(storageAddr).transferOwnership(msg.sender); } selfdestruct(_newController); } } contract UpgradeEventCompact { using SafeMath for uint; // states //  - verifying, initial state //  - controlling, after verifying, before complete //  - complete, after controlling enum EventState { Verifying, Complete } EventState public state; // Terms address public nextController; address public oldController; address public council; // Params address nextPullPayment; address storageAddr; address nutzAddr; address powerAddr; uint256 maxPower; uint256 downtime; uint256 purchasePrice; uint256 salePrice; function UpgradeEventCompact(address _oldController, address _nextController, address _nextPullPayment) { state = EventState.Verifying; nextController = _nextController; oldController = _oldController; nextPullPayment = _nextPullPayment; //the ownership of this satellite should be with oldController council = msg.sender; } modifier isState(EventState _state) { require(state == _state); _; } function upgrade() isState(EventState.Verifying) { // check old controller var old = Controller(oldController); old.pause(); require(old.admins(1) == address(this)); require(old.paused() == true); // check next controller var next = Controller(nextController); require(next.admins(1) == address(this)); require(next.paused() == true); // kill old one, and transfer ownership // transfer ownership of payments and storage to here storageAddr = old.storageAddr(); nutzAddr = old.nutzAddr(); powerAddr = old.powerAddr(); maxPower = old.maxPower(); downtime = old.downtime(); purchasePrice = old.ceiling(); salePrice = old.floor(); uint newPowerPool = (old.outstandingPower()).mul(old.activeSupply().add(old.burnPool())).div(old.authorizedPower().sub(old.outstandingPower())); //set pull payment contract in old controller old.setContracts(powerAddr, nextPullPayment, nutzAddr, storageAddr); // kill old controller, sending all ETH to new controller old.kill(nextController); // transfer ownership of Nutz/Power contracts to next controller Ownable(nutzAddr).transferOwnership(nextController); Ownable(powerAddr).transferOwnership(nextController); // transfer ownership of storage to next controller Storage(storageAddr).setUInt('Nutz', 'powerPool', newPowerPool); Ownable(storageAddr).transferOwnership(nextController); // if intended, transfer ownership of pull payment account Ownable(nextPullPayment).transferOwnership(nextController); // resume next controller if (maxPower > 0) { next.setMaxPower(maxPower); } next.setDowntime(downtime); next.moveFloor(salePrice); next.moveCeiling(purchasePrice); next.unpause(); // remove access next.removeAdmin(address(this)); // set state state = EventState.Complete; } } "}
{"sol name": "38957.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "32484.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract Vaponymous is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function Vaponymous( ) { balances[msg.sender] = 6200000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 6200000000000000;                        // Update total supply (100000 for example) name = \"Vaponymous\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"VAPO\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "31827.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000;                        // Update total supply (100000 for example) name = \"GoldCoin\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"GDC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "21241.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(a <= c); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(a >= b); return a - b; } function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } } contract ContractReceiver { function tokenFallback(address from, uint256 value, bytes data) public; } contract AuctusToken { function transfer(address to, uint256 value) public returns (bool); function transfer(address to, uint256 value, bytes data) public returns (bool); function burn(uint256 value) public returns (bool); function setTokenSaleFinished() public; } contract AuctusWhitelist { function getAllowedAmountToContribute(address addr) view public returns(uint256); } contract AuctusTokenSale is ContractReceiver { using SafeMath for uint256; address public auctusTokenAddress = 0xfD89de68b246eB3e21B06e9B65450AC28D222488; address public auctusWhiteListAddress = 0xA6e728E524c1D7A65fE5193cA1636265DE9Bc982; uint256 public startTime = 1522159200; //2018-03-27 2 PM UTC uint256 public endTime; uint256 public basicPricePerEth = 2000; address public owner; uint256 public softCap; uint256 public remainingTokens; uint256 public weiRaised; mapping(address => uint256) public invested; bool public saleWasSet; bool public tokenSaleHalted; event Buy(address indexed buyer, uint256 tokenAmount); event Revoke(address indexed buyer, uint256 investedAmount); function AuctusTokenSale(uint256 minimumCap, uint256 endSaleTime) public { owner = msg.sender; softCap = minimumCap; endTime = endSaleTime; saleWasSet = false; tokenSaleHalted = false; } modifier onlyOwner() { require(owner == msg.sender); _; } modifier openSale() { require(saleWasSet && !tokenSaleHalted && now >= startTime && now <= endTime && remainingTokens > 0); _; } modifier saleCompletedSuccessfully() { require(weiRaised >= softCap && (now > endTime || remainingTokens == 0)); _; } modifier saleFailed() { require(weiRaised < softCap && now > endTime); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); owner = newOwner; } function setTokenSaleHalt(bool halted) onlyOwner public { tokenSaleHalted = halted; } function setSoftCap(uint256 minimumCap) onlyOwner public { require(now < startTime); softCap = minimumCap; } function setEndSaleTime(uint256 endSaleTime) onlyOwner public { require(now < endTime); endTime = endSaleTime; } function tokenFallback(address, uint256 value, bytes) public { require(msg.sender == auctusTokenAddress); require(!saleWasSet); setTokenSaleDistribution(value); } function() payable openSale public { uint256 weiToInvest; uint256 weiRemaining; (weiToInvest, weiRemaining) = getValueToInvest(); require(weiToInvest > 0); uint256 tokensToReceive = weiToInvest.mul(basicPricePerEth); remainingTokens = remainingTokens.sub(tokensToReceive); weiRaised = weiRaised.add(weiToInvest); invested[msg.sender] = invested[msg.sender].add(weiToInvest); if (weiRemaining > 0) { msg.sender.transfer(weiRemaining); } assert(AuctusToken(auctusTokenAddress).transfer(msg.sender, tokensToReceive)); emit Buy(msg.sender, tokensToReceive); } function revoke() saleFailed public { uint256 investedValue = invested[msg.sender]; require(investedValue > 0); invested[msg.sender] = 0; msg.sender.transfer(investedValue); emit Revoke(msg.sender, investedValue); } function finish() onlyOwner saleCompletedSuccessfully public { //40% of the ethers are unvested uint256 freeEthers = address(this).balance * 40 / 100; uint256 vestedEthers = address(this).balance - freeEthers; address(0xd1B10607921C78D9a00529294C4b99f1bd250E1c).transfer(freeEthers); //Owner assert(address(0x0285d35508e1A1f833142EB5211adb858Bd3323A).call.value(vestedEthers)()); //AuctusEtherVesting SC AuctusToken token = AuctusToken(auctusTokenAddress); token.setTokenSaleFinished(); if (remainingTokens > 0) { token.burn(remainingTokens); remainingTokens = 0; } } function getValueToInvest() view private returns (uint256, uint256) { uint256 allowedValue = AuctusWhitelist(auctusWhiteListAddress).getAllowedAmountToContribute(msg.sender); uint256 weiToInvest; if (allowedValue == 0) { weiToInvest = 0; } else if (allowedValue >= invested[msg.sender].add(msg.value)) { weiToInvest = getAllowedAmount(msg.value); } else { weiToInvest = getAllowedAmount(allowedValue.sub(invested[msg.sender])); } return (weiToInvest, msg.value.sub(weiToInvest)); } function getAllowedAmount(uint256 value) view private returns (uint256) { uint256 maximumValue = remainingTokens / basicPricePerEth; if (value > maximumValue) { return maximumValue; } else { return value; } } function setTokenSaleDistribution(uint256 totalAmount) private { //Auctus core team 20% uint256 auctusCoreTeam = totalAmount * 20 / 100; //Bounty 2% uint256 bounty = totalAmount * 2 / 100; //Reserve for Future 18% uint256 reserveForFuture = totalAmount * 18 / 100; //Partnerships and Advisory free amount 1.8% uint256 partnershipsAdvisoryFree = totalAmount * 18 / 1000; //Partnerships and Advisory vested amount 7.2% uint256 partnershipsAdvisoryVested = totalAmount * 72 / 1000; uint256 privateSales = 2970000000000000000000000; uint256 preSale = 2397307557007329968290000; transferTokens(auctusCoreTeam, bounty, reserveForFuture, preSale, partnershipsAdvisoryVested, partnershipsAdvisoryFree, privateSales); remainingTokens = totalAmount - auctusCoreTeam - bounty - reserveForFuture - preSale - partnershipsAdvisoryVested - partnershipsAdvisoryFree - privateSales; saleWasSet = true; } function transferTokens( uint256 auctusCoreTeam, uint256 bounty, uint256 reserveForFuture, uint256 preSale, uint256 partnershipsAdvisoryVested, uint256 partnershipsAdvisoryFree, uint256 privateSales ) private { AuctusToken token = AuctusToken(auctusTokenAddress); bytes memory empty; assert(token.transfer(0x6bc58c572d0973cF0EfA1Fe1D7D6c9d7Eea2cd23, auctusCoreTeam, empty)); //AuctusTokenVesting SC assert(token.transfer(0x936Cf3e904B83B1D939C41475DC5F7c470419A3E, bounty, empty)); //AuctusBountyDistribution SC assert(token.transfer(0xF5ad5fF703D0AD0df3bAb3A1194FbCC5c152bf3b, reserveForFuture, empty)); //AuctusTokenVesting SC assert(token.transfer(0x2cE4FAb9F313F1df0978869C5d302768F1bB471d, preSale, empty)); //AuctusPreSaleDistribution SC assert(token.transfer(0x03f6278E5c359a5E8947a62E87D85AC394580d13, partnershipsAdvisoryVested, empty)); //AuctusTokenVesting SC assert(token.transfer(0x6c89Cc03036193d52e9b8386413b545184BDAb99, partnershipsAdvisoryFree)); assert(token.transfer(0xd1B10607921C78D9a00529294C4b99f1bd250E1c, privateSales)); } } "}
{"sol name": "32662.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract BWCOINToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function BWCOINToken() { balances[msg.sender] = 25 * 1000000 * 10000;               // Give the creator all initial tokens (100000 for example) totalSupply = 25 * 1000000 * 10000;                        // Update total supply (100000 for example) name = \"BWCOIN\";                                   // Set the name for display purposes decimals = 4;                            // Amount of decimals for display purposes symbol = \"BWC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36729.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "36329.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; // EROSCOIN Alpha contract based on the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 // Symbol: ERO // Status: ERC20 Verified contract EROSToken { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * EROSToken Math operations with safety checks to avoid unnecessary conflicts */ library EROMaths { // Saftey Checks for Multiplication Tasks function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } // Saftey Checks for Divison Tasks function div(uint256 a, uint256 b) internal constant returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } // Saftey Checks for Subtraction Tasks function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } // Saftey Checks for Addition Tasks function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract Ownable { address public owner; address public newOwner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } // validates an address - currently only checks that it isn't null modifier validAddress(address _address) { require(_address != 0x0); _; } function transferOwnership(address _newOwner) onlyOwner { if (_newOwner != address(0)) { owner = _newOwner; } } function acceptOwnership() { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; } event OwnershipTransferred(address indexed _from, address indexed _to); } contract EroStandardToken is EROSToken, Ownable { using EROMaths for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function freezeAccount(address target, bool freeze) onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) returns (bool success) { if (frozenAccount[msg.sender]) return false; require( (balances[msg.sender] >= _value) && (_value > 0) && (_to != address(0)) && (balances[_to].add(_value) >= balances[_to]) && (msg.data.length >= (2 * 32) + 4)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (frozenAccount[msg.sender]) return false; require( (allowed[_from][msg.sender] >= _value) && (balances[_from] >= _value) && (_value > 0) && (_to != address(0)) && (balances[_to].add(_value) >= balances[_to]) && (msg.data.length >= (2 * 32) + 4) ); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { /* To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 */ require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; // Notify anyone listening that this approval done Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract EROSCOIN is EroStandardToken { /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ uint256 constant public decimals = 8; //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 TTC = 980 base units. It's like comparing 1 wei to 1 ether. uint256 public totalSupply = 240 * (10**7) * 10**8 ; // 2.4 billion tokens, 8 decimal places string constant public name = \"EROSCOIN\"; //fancy name: eg EROSCOIN Alpha string constant public symbol = \"ERO\"; //An identifier: eg ERO string constant public version = \"v1.1.3\";       //Version 0.1.6 standard. Just an arbitrary versioning scheme. function EROSCOIN(){ balances[msg.sender] = totalSupply;               // Give the creator all initial tokens } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "36935.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; /* Aventus Buyer ======================== credit to /u/Cintix THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract Buyer { // Store the amount of ETH deposited by each account. mapping (address => uint256) public balances; // Bounty for executing buy. uint256 public buy_bounty; // Bounty for executing withdrawals. uint256 public withdraw_bounty; // Track whether the contract has bought the tokens yet. bool public bought_tokens; // Record ETH value of tokens currently held by contract. uint256 public contract_eth_value; // Emergency kill switch in case a critical bug is found. bool public kill_switch; // SHA3 hash of kill switch password. bytes32 password_hash = 0xbeb7247422d4e22a0cf0085c07b37aca88a1958e4da1ca1947e53a5adf5c0499; // Earliest time contract is allowed to buy into the crowdsale. uint256 public earliest_buy_time = 1505304000; // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure. uint256 public eth_cap = 5000 ether; // The developer address. address public developer = 0x53b1606bc4540f90daad2b05110f6cc0b42daefa; // The crowdsale address.  Settable by the developer. address public sale = 0x8b7B6C61238088593BF75eEC8FBF58D0a615d30c; // The token address.  Settable by the developer. ERC20 public token = ERC20(0x0d88eD6E74bbFD96B831231638b66C05571e824F); // Allows the developer to set the crowdsale and token addresses. // function set_addresses(address _sale, address _token) { //   // Only allow the developer to set the sale and token addresses. //   require(msg.sender == developer); //   // Only allow setting the addresses once. //   require(sale == 0x0); //   // Set the crowdsale and token addresses. //   sale = _sale; //   token = ERC20(_token); // } // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. function activate_kill_switch(string password) { // Only activate the kill switch if the sender is the developer or the password is correct. require(msg.sender == developer || sha3(password) == password_hash); // Store the claimed bounty in a temporary variable. // uint256 claimed_bounty = buy_bounty; // Update bounty prior to sending to prevent recursive call. // buy_bounty = 0; // Irreversibly activate the kill switch. kill_switch = true; // Send the caller their bounty for activating the kill switch. // msg.sender.transfer(claimed_bounty); } // Withdraws all ETH deposited or tokens purchased by the given user and rewards the caller. function withdraw(address user){ // Only allow withdrawals after the contract has had a chance to buy in. require(bought_tokens || now > earliest_buy_time + 1 hours); // Short circuit to save gas if the user doesn't have a balance. if (balances[user] == 0) return; // If the contract failed to buy into the sale, withdraw the user's ETH. if (!bought_tokens) { // Store the user's balance prior to withdrawal in a temporary variable. uint256 eth_to_withdraw = balances[user]; // Update the user's balance prior to sending ETH to prevent recursive call. balances[user] = 0; // Return the user's funds.  Throws on failure to prevent loss of funds. user.transfer(eth_to_withdraw); } // Withdraw the user's tokens if the contract has purchased them. else { // Retrieve current token balance of contract. uint256 contract_token_balance = token.balanceOf(address(this)); // Disallow token withdrawals if there are no tokens to withdraw. require(contract_token_balance != 0); // Store the user's token balance in a temporary variable. uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; // Update the value of tokens currently held by the contract. contract_eth_value -= balances[user]; // Update the user's balance prior to sending to prevent recursive call. balances[user] = 0; // 1% fee if contract successfully bought tokens. uint256 fee = tokens_to_withdraw / 200; // Send the fee to the developer. require(token.transfer(developer, fee)); // Send the funds.  Throws on failure to prevent loss of funds. require(token.transfer(user, tokens_to_withdraw - fee)); } // Each withdraw call earns 1% of the current withdraw bounty. // uint256 claimed_bounty = withdraw_bounty / 100; // Update the withdraw bounty prior to sending to prevent recursive call. // withdraw_bounty -= claimed_bounty; // Send the caller their bounty for withdrawing on the user's behalf. // msg.sender.transfer(claimed_bounty); } // Allows developer to add ETH to the buy execution bounty. function add_to_buy_bounty() payable { // Only allow the developer to contribute to the buy execution bounty. require(msg.sender == developer); // Update bounty to include received amount. buy_bounty += msg.value; } // Allows developer to add ETH to the withdraw execution bounty. // function add_to_withdraw_bounty() payable { //   // Only allow the developer to contribute to the buy execution bounty. //   require(msg.sender == developer); //   // Update bounty to include received amount. //   withdraw_bounty += msg.value; // } // Buys tokens in the crowdsale and rewards the caller, callable by anyone. function claim_bounty(){ // Short circuit to save gas if the contract has already bought tokens. if (bought_tokens) return; // Short circuit to save gas if the earliest buy time hasn't been reached. if (now < earliest_buy_time) return; // Short circuit to save gas if kill switch is active. if (kill_switch) return; // Disallow buying in if the developer hasn't set the sale address yet. require(sale != 0x0); // Record that the contract has bought the tokens. bought_tokens = true; // Store the claimed bounty in a temporary variable. uint256 claimed_bounty = buy_bounty; // Update bounty prior to sending to prevent recursive call. buy_bounty = 0; // Record the amount of ETH sent as the contract's current value. contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); // Transfer all the funds (less the bounties) to the crowdsale address // to buy tokens.  Throws if the crowdsale hasn't started yet or has // already completed, preventing loss of funds. require(sale.call.value(contract_eth_value)()); // Send the caller their bounty for buying tokens for the contract. msg.sender.transfer(claimed_bounty); } // Default function.  Called when a user sends ETH to the contract. function () payable { // Disallow deposits if kill switch is active. require(!kill_switch); // Only allow deposits if the contract hasn't already purchased the tokens. require(!bought_tokens); // Only allow deposits that won't exceed the contract's ETH cap. require(this.balance < eth_cap); // Update records of deposited ETH to include the received amount. balances[msg.sender] += msg.value; } } "}
{"sol name": "38787.sol", "label": 0, "sol content": "/* A contract to store goods with escrowed funds. */ /* Deployment: Contract: Owner: seller Last address: dynamic ABI: [{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"escrows\",\"outputs\":[{\"name\":\"buyer\",\"type\":\"address\"},{\"name\":\"lockedFunds\",\"type\":\"uint256\"},{\"name\":\"frozenFunds\",\"type\":\"uint256\"},{\"name\":\"frozenTime\",\"type\":\"uint64\"},{\"name\":\"count\",\"type\":\"uint16\"},{\"name\":\"buyerNo\",\"type\":\"bool\"},{\"name\":\"sellerNo\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"count\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"cancel\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"seller\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"freezePeriod\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"},{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint16\"}],\"name\":\"buy\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"status\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"rewardPromille\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"}],\"name\":\"getMoney\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"},{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"no\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"},{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"reject\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"},{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"accept\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"totalEscrows\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"},{\"name\":\"_who\",\"type\":\"address\"},{\"name\":\"_payment\",\"type\":\"uint256\"},{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"arbYes\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feeFunds\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_lockId\",\"type\":\"uint256\"},{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"yes\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"address\"}],\"name\":\"buyers\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"availableCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"price\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"contentCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"logsCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"unbuy\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"getFees\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"feePromille\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"pendingCount\",\"outputs\":[{\"name\":\"\",\"type\":\"uint16\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_dataInfo\",\"type\":\"string\"},{\"name\":\"_version\",\"type\":\"uint256\"}],\"name\":\"addDescription\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"arbiter\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_arbiter\",\"type\":\"address\"},{\"name\":\"_freezePeriod\",\"type\":\"uint256\"},{\"name\":\"_feePromille\",\"type\":\"uint256\"},{\"name\":\"_rewardPromille\",\"type\":\"uint256\"},{\"name\":\"_count\",\"type\":\"uint16\"},{\"name\":\"_price\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"LogDebug\",\"type\":\"event\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":true,\"name\":\"lockId\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"dataInfo\",\"type\":\"string\"},{\"indexed\":true,\"name\":\"version\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"eventType\",\"type\":\"uint16\"},{\"indexed\":true,\"name\":\"sender\",\"type\":\"address\"},{\"indexed\":false,\"name\":\"count\",\"type\":\"uint256\"},{\"indexed\":false,\"name\":\"payment\",\"type\":\"uint256\"}],\"name\":\"LogEvent\",\"type\":\"event\"}] Optimized: yes Solidity version: v0.4.4 */ pragma solidity ^0.4.0; contract EscrowGoods { struct EscrowInfo { address buyer; uint lockedFunds; uint frozenFunds; uint64 frozenTime; uint16 count; bool buyerNo; bool sellerNo; } //enum GoodsStatus uint16 constant internal None = 0; uint16 constant internal Available = 1; uint16 constant internal Canceled = 2; //enum EventTypes uint16 constant internal Buy = 1; uint16 constant internal Accept = 2; uint16 constant internal Reject = 3; uint16 constant internal Cancel = 4; uint16 constant internal Description = 10; uint16 constant internal Unlock = 11; uint16 constant internal Freeze = 12; uint16 constant internal Resolved = 13; //data uint constant arbitrationPeriod = 30 days; uint constant safeGas = 25000; //seller/owner of the goods address public seller; //event counters uint public contentCount = 0; uint public logsCount = 0; //escrow related address public arbiter; uint public freezePeriod; //each lock fee in promilles. uint public feePromille; //reward in promilles. promille = percent * 10, eg 1,5% reward = 15 rewardPromille uint public rewardPromille; uint public feeFunds; uint public totalEscrows; mapping (uint => EscrowInfo) public escrows; //goods related //status of the goods: see GoodsStatus enum uint16 public status; //how many for sale uint16 public count; uint16 public availableCount; uint16 public pendingCount; //price per item uint public price; mapping (address => bool) public buyers; bool private atomicLock; //events event LogDebug(string message); event LogEvent(uint indexed lockId, string dataInfo, uint indexed version, uint16 eventType, address indexed sender, uint count, uint payment); modifier onlyOwner { if (msg.sender != seller) throw; _; } modifier onlyArbiter { if (msg.sender != arbiter) throw; _; } //modules function EscrowGoods(address _arbiter, uint _freezePeriod, uint _feePromille, uint _rewardPromille, uint16 _count, uint _price) { seller = msg.sender; // all variables are always initialized to 0, save gas //escrow related arbiter = _arbiter; freezePeriod = _freezePeriod; feePromille = _feePromille; rewardPromille = _rewardPromille; //goods related status = Available; count = _count; price = _price; availableCount = count; } //helpers for events with counter function logDebug(string message) internal { logsCount++; LogDebug(message); } function logEvent(uint lockId, string dataInfo, uint version, uint16 eventType, address sender, uint count, uint payment) internal { contentCount++; LogEvent(lockId, dataInfo, version, eventType, sender, count, payment); } function kill() onlyOwner { //do not allow killing contract with active escrows if(totalEscrows > 0) { logDebug(\"totalEscrows > 0\"); return; } //do not allow killing contract with unclaimed escrow fees if(feeFunds > 0) { logDebug(\"feeFunds > 0\"); return; } suicide(msg.sender); } function safeSend(address addr, uint value) internal { if(atomicLock) throw; atomicLock = true; if (!(addr.call.gas(safeGas).value(value)())) { atomicLock = false; throw; } atomicLock = false; } //escrow API //vote YES - immediately sends funds to the peer function yes(uint _lockId, string _dataInfo, uint _version) { EscrowInfo info = escrows[_lockId]; if(info.lockedFunds == 0) { logDebug(\"info.lockedFunds == 0\"); return; } if(msg.sender != info.buyer && msg.sender != seller) { logDebug(\"msg.sender != info.buyer && msg.sender != seller\"); return; } uint payment = info.lockedFunds; if(payment > this.balance) { //HACK: should not get here - funds cannot be unlocked in this case logDebug(\"payment > this.balance\"); return; } if(msg.sender == info.buyer) { //send funds to seller safeSend(seller, payment); } else if(msg.sender == seller) { //send funds to buyer safeSend(info.buyer, payment); } else { //HACK: should not get here logDebug(\"unknown msg.sender\"); return; } //remove record from escrows if(totalEscrows > 0) totalEscrows -= 1; info.lockedFunds = 0; logEvent(_lockId, _dataInfo, _version, Unlock, msg.sender, info.count, payment); } //vote NO - freeze funds for arbitration function no(uint _lockId, string _dataInfo, uint _version) { EscrowInfo info = escrows[_lockId]; if(info.lockedFunds == 0) { logDebug(\"info.lockedFunds == 0\"); return; } if(msg.sender != info.buyer && msg.sender != seller) { logDebug(\"msg.sender != info.buyer && msg.sender != seller\"); return; } //freeze funds //only allow one time freeze if(info.frozenFunds == 0) { info.frozenFunds = info.lockedFunds; info.frozenTime = uint64(now); } if(msg.sender == info.buyer) { info.buyerNo = true; } else if(msg.sender == seller) { info.sellerNo = true; } else { //HACK: should not get here logDebug(\"unknown msg.sender\"); return; } logEvent(_lockId, _dataInfo, _version, Freeze, msg.sender, info.count, info.lockedFunds); } //arbiter's decision on the case. //arbiter can only decide when both buyer and seller voted NO //arbiter decides on his own reward but not bigger than announced percentage (rewardPromille) function arbYes(uint _lockId, address _who, uint _payment, string _dataInfo, uint _version) onlyArbiter { EscrowInfo info = escrows[_lockId]; if(info.lockedFunds == 0) { logDebug(\"info.lockedFunds == 0\"); return; } if(info.frozenFunds == 0) { logDebug(\"info.frozenFunds == 0\"); return; } if(_who != seller && _who != info.buyer) { logDebug(\"_who != seller && _who != info.buyer\"); return; } //requires both NO to arbitration if(!info.buyerNo || !info.sellerNo) { logDebug(\"!info.buyerNo || !info.sellerNo\"); return; } if(_payment > info.lockedFunds) { logDebug(\"_payment > info.lockedFunds\"); return; } if(_payment > this.balance) { //HACK: should not get here - funds cannot be unlocked in this case logDebug(\"_payment > this.balance\"); return; } //limit payment uint reward = (info.lockedFunds * rewardPromille) / 1000; if(reward > (info.lockedFunds - _payment)) { logDebug(\"reward > (info.lockedFunds - _payment)\"); return; } //send funds to the winner safeSend(_who, _payment); //send the rest as reward info.lockedFunds -= _payment; feeFunds += info.lockedFunds; info.lockedFunds = 0; logEvent(_lockId, _dataInfo, _version, Resolved, msg.sender, info.count, _payment); } //allow arbiter to get his collected fees function getFees() onlyArbiter { if(feeFunds > this.balance) { //HACK: should not get here - funds cannot be unlocked in this case logDebug(\"feeFunds > this.balance\"); return; } safeSend(arbiter, feeFunds); feeFunds = 0; } //allow buyer or seller to take timeouted funds. //buyer can get funds if seller is silent and seller can get funds if buyer is silent (after freezePeriod) //buyer can get back funds under arbitration if arbiter is silent (after arbitrationPeriod) function getMoney(uint _lockId) { EscrowInfo info = escrows[_lockId]; if(info.lockedFunds == 0) { logDebug(\"info.lockedFunds == 0\"); return; } //HACK: this check is necessary since frozenTime == 0 at escrow creation if(info.frozenFunds == 0) { logDebug(\"info.frozenFunds == 0\"); return; } //timout for voting not over yet if(now < (info.frozenTime + freezePeriod)) { logDebug(\"now < (info.frozenTime + freezePeriod)\"); return; } uint payment = info.lockedFunds; if(payment > this.balance) { //HACK: should not get here - funds cannot be unlocked in this case logDebug(\"payment > this.balance\"); return; } //both has voted - money is under arbitration if(info.buyerNo && info.sellerNo) { //arbitration timeout is not over yet if(now < (info.frozenTime + freezePeriod + arbitrationPeriod)) { logDebug(\"now < (info.frozenTime + freezePeriod + arbitrationPeriod)\"); return; } //arbiter was silent so redeem the funds to the buyer safeSend(info.buyer, payment); info.lockedFunds = 0; return; } if(info.buyerNo) { safeSend(info.buyer, payment); info.lockedFunds = 0; return; } if(info.sellerNo) { safeSend(seller, payment); info.lockedFunds = 0; return; } } //goods API //add new description to the goods function addDescription(string _dataInfo, uint _version) onlyOwner { //Accept order to event log logEvent(0, _dataInfo, _version, Description, msg.sender, 0, 0); } //buy with escrow. id - escrow info id function buy(uint _lockId, string _dataInfo, uint _version, uint16 _count) payable { //reject money transfers for bad item status if(status != Available) throw; if(msg.value < (price * _count)) throw; if(_count > availableCount) throw; if(_count == 0) throw; if(feePromille > 1000) throw; if(rewardPromille > 1000) throw; if((feePromille + rewardPromille) > 1000) throw; //create default EscrowInfo struct or access existing EscrowInfo info = escrows[_lockId]; //lock only once for a given id if(info.lockedFunds > 0) throw; //lock funds uint fee = (msg.value * feePromille) / 1000; //limit fees if(fee > msg.value) throw; uint funds = (msg.value - fee); feeFunds += fee; totalEscrows += 1; info.buyer = msg.sender; info.lockedFunds = funds; info.frozenFunds = 0; info.buyerNo = false; info.sellerNo = false; info.count = _count; pendingCount += _count; buyers[msg.sender] = true; //Buy order to event log logEvent(_lockId, _dataInfo, _version, Buy, msg.sender, _count, msg.value); } function accept(uint _lockId, string _dataInfo, uint _version) onlyOwner { EscrowInfo info = escrows[_lockId]; if(info.count > availableCount) { logDebug(\"info.count > availableCount\"); return; } if(info.count > pendingCount) { logDebug(\"info.count > pendingCount\"); return; } pendingCount -= info.count; availableCount -= info.count; //Accept order to event log logEvent(_lockId, _dataInfo, _version, Accept, msg.sender, info.count, info.lockedFunds); } function reject(uint _lockId, string _dataInfo, uint _version) onlyOwner { EscrowInfo info = escrows[_lockId]; if(info.count > pendingCount) { logDebug(\"info.count > pendingCount\"); return; } pendingCount -= info.count; //send money back yes(_lockId, _dataInfo, _version); //Reject order to event log //HACK: \"yes\" call above may fail and this event will be non-relevant. Do not rely on it. logEvent(_lockId, _dataInfo, _version, Reject, msg.sender, info.count, info.lockedFunds); } function cancel(string _dataInfo, uint _version) onlyOwner { //Canceled status status = Canceled; //Cancel order to event log logEvent(0, _dataInfo, _version, Cancel, msg.sender, availableCount, 0); } //remove buyer from the watchlist function unbuy() { buyers[msg.sender] = false; } function () { throw; } } "}
{"sol name": "33447.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * * Version: B * @author  <[email\u00a0protected]> * * Overview: * Divides all incoming funds among various `activity` accounts. The division cannot be changed * after the contract is locked. */ contract OrganizeFunds { struct ActivityAccount { uint credited;   // total funds credited to this account uint balance;    // current balance = credited - amount withdrawn uint pctx10;     // percent allocation times ten address addr;    // payout addr of this acct string name; } uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle event MessageEvent(string message); event MessageEventI(string message, uint val); bool public isLocked; string public name; address public owner;                                // deployer executor mapping (uint => ActivityAccount) activityAccounts;  // accounts by index uint public activityCount;                           // how many activity accounts uint public totalFundsReceived;                      // amount received since begin of time uint public totalFundsDistributed;                   // amount distributed since begin of time uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time uint public withdrawGas = 100000;                    // gas for withdrawals modifier ownerOnly { require(msg.sender == owner); _; } modifier unlockedOnly { require(!isLocked); _; } // // constructor // function OrganizeFunds() public { owner = msg.sender; } function lock() public ownerOnly { isLocked = true; } function setName(string _name) public ownerOnly { name = _name; } // // reset // reset all activity accounts // in case we have any funds that have not been withdrawn, they become  newly received and undistributed. // function reset() public ownerOnly unlockedOnly { totalFundsReceived = this.balance; totalFundsDistributed = 0; totalFundsWithdrawn = 0; activityCount = 0; MessageEvent(\"ok: all accts reset\"); } // // set withdrawal gas // nonstandard gas is necessary to support push-withdrawals to other contract // function setWitdrawGas(uint256 _withdrawGas) public ownerOnly unlockedOnly { withdrawGas = _withdrawGas; MessageEventI(\"ok: withdraw gas set\", withdrawGas); } // // add a new activity account // function addActivityAccount(address _addr, uint256 _pctx10, string _name) public ownerOnly unlockedOnly { if (activityCount >= MAX_ACCOUNTS) { MessageEvent(\"err: max accounts\"); return; } activityAccounts[activityCount].addr = _addr; activityAccounts[activityCount].pctx10 = _pctx10; activityAccounts[activityCount].credited = 0; activityAccounts[activityCount].balance = 0; activityAccounts[activityCount].name = _name; ++activityCount; MessageEvent(\"ok: acct added\"); } // ---------------------------- // get acct info // ---------------------------- function getActivityAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, string _name, uint _credited, uint _balance) { for (uint i = 0; i < activityCount; i++ ) { address addr = activityAccounts[i].addr; if (addr == _addr) { _idx = i; _pctx10 = activityAccounts[i].pctx10; _name = activityAccounts[i].name; _credited = activityAccounts[i].credited; _balance = activityAccounts[i].balance; return; } } } // // get total percentages x10 // function getTotalPctx10() public constant returns(uint _totalPctx10) { _totalPctx10 = 0; for (uint i = 0; i < activityCount; i++ ) { _totalPctx10 += activityAccounts[i].pctx10; } } // // default payable function. // call us with plenty of gas, or catastrophe will ensue // function () public payable { totalFundsReceived += msg.value; MessageEventI(\"ok: received\", msg.value); } // // distribute funds to all activities // function distribute() public { //only payout if we have more than 1000 wei if (this.balance < TENHUNDWEI) { return; } //each account gets their prescribed percentage of this holdover. uint i; uint pctx10; uint acctDist; for (i = 0; i < activityCount; i++ ) { pctx10 = activityAccounts[i].pctx10; acctDist = totalFundsReceived * pctx10 / TENHUNDWEI; //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct if (activityAccounts[i].credited >= acctDist) { acctDist = 0; } else { acctDist = acctDist - activityAccounts[i].credited; } activityAccounts[i].credited += acctDist; activityAccounts[i].balance += acctDist; totalFundsDistributed += acctDist; } MessageEvent(\"ok: distributed funds\"); } // // withdraw actvity balance // can be called by owner to push funds to another contract // function withdraw() public { for (uint i = 0; i < activityCount; i++ ) { address addr = activityAccounts[i].addr; if (addr == msg.sender || msg.sender == owner) { uint amount = activityAccounts[i].balance; if (amount > 0) { activityAccounts[i].balance = 0; totalFundsWithdrawn += amount; if (!addr.call.gas(withdrawGas).value(amount)()) { //put back funds in case of err activityAccounts[i].balance = amount; totalFundsWithdrawn -= amount; MessageEvent(\"err: error sending funds\"); return; } } } } } // // suicide // function hariKari() public ownerOnly unlockedOnly { selfdestruct(owner); } } "}
{"sol name": "33877.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale. * Crowdsales have a start and end timestamps, where investors can make * token purchases and the crowdsale will assign them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. */ contract Crowdsale { using SafeMath for uint256; // The token being sold //  MintableToken public token; address public tokenAddr; TestTokenA public testTokenA; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // address where funds are collected address public wallet; // how many token units a buyer gets per wei uint256 public rate; // amount of raised money in wei uint256 public weiRaised; /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(address _tokenAddress, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_tokenAddress != 0x0); //    createTokenContract(_tokenAddress); //    createTokenContract(); tokenAddr = _tokenAddress; startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } // creates the token to be sold. // override this method to have crowdsale of a specific mintable token. //  function createTokenContract() internal returns (MintableToken) { //      return new TestTokenA(); ////    return MintableToken(_tokenAddress); //  } // fallback function can be used to buy tokens function () payable { buyTokens(msg.sender); } // low level token purchase function function buyTokens(address beneficiary) public payable { require(beneficiary != 0x0); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = weiAmount.mul(rate); // update state weiRaised = weiRaised.add(weiAmount); //    token.mint(beneficiary, tokens); //    bytes4 methodId = bytes4(keccak256(\"mint(address,uint256)\")); //    tokenAddr.call(methodId, beneficiary, tokens); testTokenA = TestTokenA(tokenAddr); testTokenA.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } // send ether to the fund collection wallet // override to create custom fund forwarding mechanisms function forwardFunds() internal { wallet.transfer(msg.value); } // @return true if the transaction can buy tokens function validPurchase() internal constant returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } // @return true if crowdsale event has ended function hasEnded() public constant returns (bool) { return now > endTime; } } /** * @title CappedCrowdsale * @dev Extension of Crowdsale with a max amount of funds raised */ contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) { require(_cap > 0); cap = _cap; } // overriding Crowdsale#validPurchase to add extra cap logic // @return true if investors can buy at the moment function validPurchase() internal constant returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } // overriding Crowdsale#hasEnded to add cap logic // @return true if crowdsale event has ended function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal { } } /** * @title RefundVault * @dev This contract is used for storing funds while a crowdsale * is in progress. Supports refunding the money if crowdsale fails, * and forwarding it if crowdsale is successful. */ contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) { require(_wallet != 0x0); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } /** * @title RefundableCrowdsale * @dev Extension of Crowdsale contract that adds a funding goal, and * the possibility of users getting a refund if goal is not met. * Uses a RefundVault as the crowdsale's vault. */ contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; // minimum amount of funds to be raised in weis uint256 public goal; // refund vault used to hold funds while crowdsale is running RefundVault public vault; function RefundableCrowdsale(uint256 _goal) { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; } // We're overriding the fund forwarding from Crowdsale. // In addition to sending the funds, we want to call // the RefundVault deposit function function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } // if crowdsale is unsuccessful, investors can claim refunds here function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } //  // if crowdsale is unsuccessful, investors can claim refunds here //  function claimRefund() notPaused public returns (bool) { //    require(!goalReached); //    require(hasEnded()); //    uint contributedAmt = weiContributed[msg.sender]; //    require(contributedAmt > 0); //    weiContributed[msg.sender] = 0; //    msg.sender.transfer(contributedAmt); //    LogClaimRefund(msg.sender, contributedAmt); //    return true; //  } // vault finalization task, called when owner calls finalize() function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public constant returns (bool) { return weiRaised >= goal; } } /** * @title Destructible * @dev Base contract that can be destroyed by owner. All funds in contract will be sent to the owner. */ contract Destructible is Ownable { function Destructible() payable { } /** * @dev Transfers the current balance to the owner and terminates the contract. */ function destroy() onlyOwner public { selfdestruct(owner); } function destroyAndSend(address _recipient) onlyOwner public { selfdestruct(_recipient); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ //  function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { function mint(address _to, uint256 _amount) public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(0x0, _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract TestTokenA is MintableToken { string public constant name = \"TestTokenA\"; string public constant symbol = \"ZNX\"; uint8 public constant decimals = 18; uint256 public constant initialSupply = 65000000 * (10 ** uint256(decimals));    // number of tokens in reserve /* * gives msg.sender all of existing tokens. */ function TestTokenA() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; } } contract TestTokenAPreICO is CappedCrowdsale, RefundableCrowdsale, Destructible, Pausable { function TestTokenAPreICO(address _tokenAddress, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _goal, uint256 _cap, address _wallet) CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) Crowdsale(_tokenAddress, _startTime, _endTime, _rate, _wallet) { //As goal needs to be met for a successful crowdsale //the value needs to less or equal than a cap which is limit for accepted funds require(_goal <= _cap); } } "}
{"sol name": "36732.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /* Enjin $1M Group Buyer ======================== Moves $1M worth of ETH into the Enjin presale multisig wallet Enjin multisig wallet: 0xc4740f71323129669424d1Ae06c42AEE99da30e2 Modified version of /u/Cintix Monetha ICOBuyer Modified by @ezra242 Fixes suggested by @icoscammer and @adevabhaktuni Please be aware users must possess the know-how to execute a function in Parity or Ethereum Mist Wallet to withdraw their tokens from this contract User must specify the token address manually to withdraw tokens */ // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract EnjinBuyer { // The minimum amount of eth required before the contract will buy in // Enjin requires $1000000 @ 306.22 for 50% bonus uint256 public eth_minimum = 3270 ether; // Store the amount of ETH deposited by each account. mapping (address => uint256) public balances; // Bounty for executing buy. uint256 public buy_bounty; // Bounty for executing withdrawals. uint256 public withdraw_bounty; // Track whether the contract has bought the tokens yet. bool public bought_tokens; // Record ETH value of tokens currently held by contract. uint256 public contract_eth_value; // Emergency kill switch in case a critical bug is found. bool public kill_switch; // SHA3 hash of kill switch password. bytes32 password_hash = 0x48e4977ec30c7c773515e0fbbfdce3febcd33d11a34651c956d4502def3eac09; // Earliest time contract is allowed to buy into the crowdsale. // This time constant is in the past, not important for Enjin buyer, we will only purchase once uint256 public earliest_buy_time = 1504188000; // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure. uint256 public eth_cap = 5000 ether; // The developer address. address public developer = 0xA4f8506E30991434204BC43975079aD93C8C5651; // The crowdsale address.  Settable by the developer. address public sale; // The token address.  Settable by the developer. ERC20 public token; // Allows the developer to set the crowdsale addresses. function set_sale_address(address _sale) { // Only allow the developer to set the sale addresses. require(msg.sender == developer); // Only allow setting the addresses once. require(sale == 0x0); // Set the crowdsale and token addresses. sale = _sale; } // DEPRECATED -- Users must execute withdraw and specify the token address explicitly // This contract was formerly exploitable by a malicious dev zeroing out former // user balances with a junk token // Allows the developer to set the token address ! // Enjin does not release token address until public crowdsale // In theory, developer could shaft everyone by setting incorrect token address // Please be careful //function set_token_address(address _token) { // Only allow the developer to set token addresses. //  require(msg.sender == developer); // Set the token addresses. //  token = ERC20(_token); //} // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. function activate_kill_switch(string password) { // Only activate the kill switch if the sender is the developer or the password is correct. require(msg.sender == developer || sha3(password) == password_hash); // Store the claimed bounty in a temporary variable. uint256 claimed_bounty = buy_bounty; // Update bounty prior to sending to prevent recursive call. buy_bounty = 0; // Irreversibly activate the kill switch. kill_switch = true; // Send the caller their bounty for activating the kill switch. msg.sender.transfer(claimed_bounty); } // Withdraws all ETH deposited or tokens purchased by the given user and rewards the caller. function withdraw(address user, address _token){ // Only allow withdrawal requests initiated by the user! // This means every user of this contract must be versed in how to // execute a function on a contract. Every user must also supply // the correct token address for Enjin. This address will not be known until // October 3 2017 require(msg.sender == user); // Only allow withdrawals after the contract has had a chance to buy in. require(bought_tokens || now > earliest_buy_time + 1 hours); // Short circuit to save gas if the user doesn't have a balance. if (balances[user] == 0) return; // If the contract failed to buy into the sale, withdraw the user's ETH. if (!bought_tokens) { // Store the user's balance prior to withdrawal in a temporary variable. uint256 eth_to_withdraw = balances[user]; // Update the user's balance prior to sending ETH to prevent recursive call. balances[user] = 0; // Return the user's funds.  Throws on failure to prevent loss of funds. user.transfer(eth_to_withdraw); } // Withdraw the user's tokens if the contract has purchased them. else { // Set token to the token specified by the user // Should work in cases where the user specifies a token not held by the contract // Should also work in cases where the user specifies a worthless token held by the contract // In aforementioned case, the user will zero out their balance // and receive their worthless token, but affect no one else token = ERC20(_token); // Retrieve current token balance of contract. uint256 contract_token_balance = token.balanceOf(address(this)); // Disallow token withdrawals if there are no tokens to withdraw. require(contract_token_balance != 0); // Store the user's token balance in a temporary variable. uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; // Update the value of tokens currently held by the contract. contract_eth_value -= balances[user]; // Update the user's balance prior to sending to prevent recursive call. balances[user] = 0; // 1% fee if contract successfully bought tokens. //uint256 fee = tokens_to_withdraw / 100; // Send the fee to the developer. //require(token.transfer(developer, fee)); // Send the funds.  Throws on failure to prevent loss of funds. require(token.transfer(user, tokens_to_withdraw)); } // Each withdraw call earns 1% of the current withdraw bounty. uint256 claimed_bounty = withdraw_bounty / 100; // Update the withdraw bounty prior to sending to prevent recursive call. withdraw_bounty -= claimed_bounty; // Send the caller their bounty for withdrawing on the user's behalf. msg.sender.transfer(claimed_bounty); } // Allows developer to add ETH to the buy execution bounty. function add_to_buy_bounty() payable { // Only allow the developer to contribute to the buy execution bounty. require(msg.sender == developer); // Update bounty to include received amount. buy_bounty += msg.value; } // Allows developer to add ETH to the withdraw execution bounty. function add_to_withdraw_bounty() payable { // Only allow the developer to contribute to the buy execution bounty. require(msg.sender == developer); // Update bounty to include received amount. withdraw_bounty += msg.value; } // Buys tokens in the crowdsale and rewards the caller, callable by anyone. function claim_bounty(){ // If we don't have eth_minimum eth in contract, don't buy in // Enjin requires $1M minimum for 50% bonus if (this.balance < eth_minimum) return; // Short circuit to save gas if the contract has already bought tokens. if (bought_tokens) return; // Short circuit to save gas if the earliest buy time hasn't been reached. if (now < earliest_buy_time) return; // Short circuit to save gas if kill switch is active. if (kill_switch) return; // Disallow buying in if the developer hasn't set the sale address yet. require(sale != 0x0); // Record that the contract has bought the tokens. bought_tokens = true; // Store the claimed bounty in a temporary variable. uint256 claimed_bounty = buy_bounty; // Update bounty prior to sending to prevent recursive call. buy_bounty = 0; // Record the amount of ETH sent as the contract's current value. contract_eth_value = this.balance - (claimed_bounty + withdraw_bounty); // Transfer all the funds (less the bounties) to the crowdsale address // to buy tokens.  Throws if the crowdsale hasn't started yet or has // already completed, preventing loss of funds. require(sale.call.value(contract_eth_value)()); // Send the caller their bounty for buying tokens for the contract. msg.sender.transfer(claimed_bounty); } // Default function.  Called when a user sends ETH to the contract. function () payable { // Disallow deposits if kill switch is active. require(!kill_switch); // Only allow deposits if the contract hasn't already purchased the tokens. require(!bought_tokens); // Only allow deposits that won't exceed the contract's ETH cap. require(this.balance < eth_cap); // Update records of deposited ETH to include the received amount. balances[msg.sender] += msg.value; } } "}
{"sol name": "39905.sol", "label": 0, "sol content": "pragma solidity ^0.4.0; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0 contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if(address(OAR)==0) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1); return true; } if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } } // </ORACLIZE_API> contract Dice is usingOraclize { uint constant pwin = 9000; //probability of winning (10000 = 100%) uint constant edge = 190; //edge percentage (10000 = 100%) uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint constant minBet = 200 finney; uint constant maxInvestors = 10; //maximum number of investors uint constant houseEdge = 90; //edge percentage (10000 = 100%) uint constant divestFee = 50; //divest fee percentage (10000 = 100%) uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%) uint safeGas = 2300; uint constant ORACLIZE_GAS_LIMIT = 175000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 3 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBet; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) public investorIDs; mapping(uint => Investor) public investors; uint public numInvestors = 0; uint public invested = 0; address public owner; address public houseAddress; bool public isStopped; WithdrawalProposal public proposedWithdrawal; mapping (bytes32 => Bet) public bets; bytes32[] public betsKeys; uint public investorsProfit = 0; uint public investorsLosses = 0; bool profitDistributed; event LOG_NewBet(address playerAddress, uint amount); event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon); event LOG_BetLost(address playerAddress, uint numberRolled); event LOG_EmergencyWithdrawalProposed(); event LOG_EmergencyWithdrawalFailed(address withdrawalAddress); event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event LOG_FailedSend(address receiver, uint amount); event LOG_ZeroSend(); event LOG_InvestorEntrance(address investor, uint amount); event LOG_InvestorCapitalUpdate(address investor, int amount); event LOG_InvestorExit(address investor, uint amount); event LOG_ContractStopped(); event LOG_ContractResumed(); event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress); event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress); event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit); event LOG_EmergencyAutoStop(); event LOG_EmergencyWithdrawalVote(address investor, bool vote); event LOG_ValueIsTooBig(); event LOG_SuccessfulSend(address addr, uint amount); function Dice() { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _; } modifier onlyIfStopped { if (!isStopped) throw; _; } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _; } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _; } modifier onlyOwner { if (owner != msg.sender) throw; _; } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _; } modifier onlyMoreThanZero { if (msg.value == 0) throw; _; } modifier onlyIfBetExist(bytes32 myid) { if(bets[myid].playerAddress == address(0x0)) throw; _; } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) { _; } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } _; } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _; } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _; } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _; } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _; } } modifier onlyIfValidGas(uint newGasLimit) { if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw; if (newGasLimit < 25000) throw; _; } modifier onlyIfNotProcessed(bytes32 myid) { if (bets[myid].numberRolled > 0) throw; _; } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _; } modifier investorsInvariant { _; if (numInvestors > maxInvestors) throw; } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { if ((invested < investorsProfit) || (invested + investorsProfit < invested) || (invested + investorsProfit < investorsLosses)) { return 0; } else { return invested + investorsProfit - investorsLosses; } } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLossesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { uint invested = investors[investorIDs[currentInvestor]].amountInvested; uint profit = getProfitShare(currentInvestor); uint losses = getLossesShare(currentInvestor); if ((invested + profit < profit) || (invested + profit < invested) || (invested + profit < losses)) return 0; else return invested + profit - losses; } function searchSmallestInvestor() constant returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function changeOraclizeProofType(byte _proofType) onlyOwner { if (_proofType == 0x00) throw; oraclize_setProof( _proofType |  proofStorage_IPFS ); } function changeOraclizeConfig(bytes32 _config) onlyOwner { oraclize_setConfig(_config); } // PRIVATE HELPERS FUNCTION function safeSend(address addr, uint value) private { if (value == 0) { LOG_ZeroSend(); return; } if (this.balance < value) { LOG_ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { LOG_FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value); } } LOG_SuccessfulSend(addr,value); } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; LOG_InvestorEntrance(msg.sender, msg.value); } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint lossesOfInvestor = getLossesShare(currentInvestor); //Check for overflow and underflow if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) && (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  { investors[i].amountInvested += profitOfInvestor - lossesOfInvestor; LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor)); } else { isStopped = true; LOG_EmergencyAutoStop(); } if (copyInvested + investors[i].amountInvested >= copyInvested) copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLosses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() payable { bet(); } function bet() payable onlyIfNotStopped { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); if (oraclizeFee >= msg.value) throw; uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { LOG_NewBet(msg.sender, betValue); bytes32 myid = oraclize_query( \"nested\", \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BIYkzb1GQzRZFNsTzF7fh+n8VmT8GEyW3mHYlrU8It5O6/bam6/LVVxqkury8YZDJPjm0mWQeqQGebGAVSFrFw16/VHJ65QMFBfIHN2frhav/d10ARqECjoOvse5v4/DIT3LQUHPEx0Z/5UdtqYTQydW/pbC5BM=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\", ORACLIZE_GAS_LIMIT + safeGas ); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback(bytes32 myid, string result, bytes proof) onlyOraclize onlyIfBetExist(myid) onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(bets[myid], numberRolled); isLosingBet(bets[myid], numberRolled); delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin; LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); //Check for overflow and underflow if ((investorsLosses + winAmount < investorsLosses) || (investorsLosses + winAmount < thisBet.amountBet)) { throw; } investorsLosses += winAmount - thisBet.amountBet; } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { LOG_BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); //Check for overflow and underflow if ((investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)) { throw; } uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000; uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() payable onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() payable onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment investorsInvariant { profitDistribution(); if (numInvestors == maxInvestors) { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); } numInvestors++; addInvestorAtID(numInvestors); } function divest() onlyInvestors { divest(msg.sender); } function divest(address currentInvestor) private investorsInvariant { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); if ((invested >= investors[currentID].amountInvested)) { invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; delete investors[currentID]; delete investorIDs[currentInvestor]; //Reorder investors if (currentID != numInvestors) { // Get last investor Investor lastInvestor = investors[numInvestors]; //Set last investor ID to investorID of divesting account investorIDs[lastInvestor.investorAddress] = currentID; //Copy investor at the new position in the mapping investors[currentID] = lastInvestor; //Delete old position in the mappping delete investors[numInvestors]; } numInvestors--; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); LOG_InvestorExit(currentInvestor, amountToReturn); } else { isStopped = true; LOG_EmergencyAutoStop(); } } function forceDivestOfAllInvestors() onlyOwner { uint copyNumInvestors = numInvestors; for (uint i = 1; i <= copyNumInvestors; i++) { divest(investors[1].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner { isStopped = true; LOG_ContractStopped(); } function resumeContract() onlyOwner { isStopped = false; LOG_ContractResumed(); } function changeHouseAddress(address newHouse) onlyOwner { if (newHouse == address(0x0)) throw; //changed based on audit feedback houseAddress = newHouse; LOG_HouseAddressChanged(houseAddress, newHouse); } function changeOwnerAddress(address newOwner) onlyOwner { if (newOwner == address(0x0)) throw; owner = newOwner; LOG_OwnerAddressChanged(owner, newOwner); } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) { safeGas = newGasLimit; LOG_GasLimitChanged(safeGas, newGasLimit); } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; LOG_EmergencyWithdrawalVote(msg.sender, vote); } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); LOG_EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed { uint numOfVotesInFavour; uint amountToWithdraw = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) { LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw); } } else { throw; } } } "}
{"sol name": "37991.sol", "label": 0, "sol content": "contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* This implements ONLY the standard functions and NOTHING else. For a token like you would want to deploy in something like Mist, see HumanStandardToken.sol. If you deploy this, you won't have anything useful. Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 .*/ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } /* This Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans. In other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans. Imagine coins, currencies, shares, voting weight, etc. Machine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners. 1) Initial Finite Supply (upon creation one specifies how much is minted). 2) In the absence of a token registry: Optional Decimal, Symbol & Name. 3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred. .*/ contract HumanStandardToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "44317.sol", "label": 0, "sol content": "/* * Credit to: gustavoguimaraes * Orginal source: https://github.com/gustavoguimaraes/honeyPotReentranceAttack */ pragma solidity ^0.4.8; contract HoneyPot { mapping (address => uint) public balances; function HoneyPot() payable { put(); } function put() payable { balances[msg.sender] = msg.value; } function get() { if (!msg.sender.call.value(balances[msg.sender])()) { throw; } balances[msg.sender] = 0; } function() { throw; } } "}
{"sol name": "32608.sol", "label": 0, "sol content": "pragma solidity 0.4.15; contract Owned { address public owner; modifier onlyOwner() { require(isOwner(msg.sender)); _; } function Owned() { owner = msg.sender; } function isOwner(address addr) public returns(bool) { return addr == owner; } function transfer(address newOwner) public onlyOwner { if (newOwner != address(this)) { owner = newOwner; } } } contract Proxy is Owned { event Forwarded (address indexed destination, uint value, bytes data); event Received (address indexed sender, uint value); function () payable { Received(msg.sender, msg.value); } function forward(address destination, uint value, bytes data) public onlyOwner { require(destination.call.value(value)(data)); Forwarded(destination, value, data); } } contract IdentityManager { uint adminTimeLock; uint userTimeLock; uint adminRate; event LogIdentityCreated( address indexed identity, address indexed creator, address owner, address indexed recoveryKey); event LogOwnerAdded( address indexed identity, address indexed owner, address instigator); event LogOwnerRemoved( address indexed identity, address indexed owner, address instigator); event LogRecoveryChanged( address indexed identity, address indexed recoveryKey, address instigator); event LogMigrationInitiated( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationCanceled( address indexed identity, address indexed newIdManager, address instigator); event LogMigrationFinalized( address indexed identity, address indexed newIdManager, address instigator); mapping(address => mapping(address => uint)) owners; mapping(address => address) recoveryKeys; mapping(address => mapping(address => uint)) limiter; mapping(address => uint) public migrationInitiated; mapping(address => address) public migrationNewAddress; modifier onlyOwner(address identity) { require(isOwner(identity, msg.sender)); _; } modifier onlyOlderOwner(address identity) { require(isOlderOwner(identity, msg.sender)); _; } modifier onlyRecovery(address identity) { require(recoveryKeys[identity] == msg.sender); _; } modifier rateLimited(address identity) { require(limiter[identity][msg.sender] < (now - adminRate)); limiter[identity][msg.sender] = now; _; } modifier validAddress(address addr) { //protects against some weird attacks require(addr != address(0)); _; } /// @dev Contract constructor sets initial timelock limits /// @param _userTimeLock Time before new owner added by recovery can control proxy /// @param _adminTimeLock Time before new owner can add/remove owners /// @param _adminRate Time period used for rate limiting a given key for admin functionality function IdentityManager(uint _userTimeLock, uint _adminTimeLock, uint _adminRate) { require(_adminTimeLock >= _userTimeLock); adminTimeLock = _adminTimeLock; userTimeLock = _userTimeLock; adminRate = _adminRate; } /// @dev Creates a new proxy contract for an owner and recovery /// @param owner Key who can use this contract to control proxy. Given full power /// @param recoveryKey Key of recovery network or address from seed to recovery proxy /// Gas cost of 289,311 function createIdentity(address owner, address recoveryKey) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; // This is to ensure original owner has full power from day one recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); } /// @dev Creates a new proxy contract for an owner and recovery and allows an initial forward call which would be to set the registry in our case /// @param owner Key who can use this contract to control proxy. Given full power /// @param recoveryKey Key of recovery network or address from seed to recovery proxy /// @param destination Address of contract to be called after proxy is created /// @param data of function to be called at the destination contract function createIdentityWithCall(address owner, address recoveryKey, address destination, bytes data) public validAddress(recoveryKey) { Proxy identity = new Proxy(); owners[identity][owner] = now - adminTimeLock; // This is to ensure original owner has full power from day one recoveryKeys[identity] = recoveryKey; LogIdentityCreated(identity, msg.sender, owner,  recoveryKey); identity.forward(destination, 0, data); } /// @dev Allows a user to transfer control of existing proxy to this contract. Must come through proxy /// @param owner Key who can use this contract to control proxy. Given full power /// @param recoveryKey Key of recovery network or address from seed to recovery proxy /// Note: User must change owner of proxy to this contract after calling this function registerIdentity(address owner, address recoveryKey) public validAddress(recoveryKey) { require(recoveryKeys[msg.sender] == 0); // Deny any funny business owners[msg.sender][owner] = now - adminTimeLock; // This is to ensure original owner has full power from day one recoveryKeys[msg.sender] = recoveryKey; LogIdentityCreated(msg.sender, msg.sender, owner, recoveryKey); } /// @dev Allows a user to forward a call through their proxy. function forwardTo(Proxy identity, address destination, uint value, bytes data) public onlyOwner(identity) { identity.forward(destination, value, data); } /// @dev Allows an olderOwner to add a new owner instantly function addOwner(Proxy identity, address newOwner) public onlyOlderOwner(identity) rateLimited(identity) { require(!isOwner(identity, newOwner)); owners[identity][newOwner] = now - userTimeLock; LogOwnerAdded(identity, newOwner, msg.sender); } /// @dev Allows a recoveryKey to add a new owner with userTimeLock waiting time function addOwnerFromRecovery(Proxy identity, address newOwner) public onlyRecovery(identity) rateLimited(identity) { require(!isOwner(identity, newOwner)); owners[identity][newOwner] = now; LogOwnerAdded(identity, newOwner, msg.sender); } /// @dev Allows an owner to remove another owner instantly function removeOwner(Proxy identity, address owner) public onlyOlderOwner(identity) rateLimited(identity) { // an owner should not be allowed to remove itself require(msg.sender != owner); delete owners[identity][owner]; LogOwnerRemoved(identity, owner, msg.sender); } /// @dev Allows an owner to change the recoveryKey instantly function changeRecovery(Proxy identity, address recoveryKey) public onlyOlderOwner(identity) rateLimited(identity) validAddress(recoveryKey) { recoveryKeys[identity] = recoveryKey; LogRecoveryChanged(identity, recoveryKey, msg.sender); } /// @dev Allows an owner to begin process of transfering proxy to new IdentityManager function initiateMigration(Proxy identity, address newIdManager) public onlyOlderOwner(identity) validAddress(newIdManager) { migrationInitiated[identity] = now; migrationNewAddress[identity] = newIdManager; LogMigrationInitiated(identity, newIdManager, msg.sender); } /// @dev Allows an owner to cancel the process of transfering proxy to new IdentityManager function cancelMigration(Proxy identity) public onlyOwner(identity) { address canceledManager = migrationNewAddress[identity]; delete migrationInitiated[identity]; delete migrationNewAddress[identity]; LogMigrationCanceled(identity, canceledManager, msg.sender); } /// @dev Allows an owner to finalize migration once adminTimeLock time has passed /// WARNING: before transfering to a new address, make sure this address is \"ready to recieve\" the proxy. /// Not doing so risks the proxy becoming stuck. function finalizeMigration(Proxy identity) public onlyOlderOwner(identity) { require(migrationInitiated[identity] != 0 && migrationInitiated[identity] + adminTimeLock < now); address newIdManager = migrationNewAddress[identity]; delete migrationInitiated[identity]; delete migrationNewAddress[identity]; identity.transfer(newIdManager); delete recoveryKeys[identity]; // We can only delete the owner that we know of. All other owners // needs to be removed before a call to this method. delete owners[identity][msg.sender]; LogMigrationFinalized(identity, newIdManager, msg.sender); } function isOwner(address identity, address owner) public constant returns (bool) { return (owners[identity][owner] > 0 && (owners[identity][owner] + userTimeLock) <= now); } function isOlderOwner(address identity, address owner) public constant returns (bool) { return (owners[identity][owner] > 0 && (owners[identity][owner] + adminTimeLock) <= now); } function isRecovery(address identity, address recoveryKey) public constant returns (bool) { return recoveryKeys[identity] == recoveryKey; } } "}
{"sol name": "33161.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 6000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 6000000;                        // Update total supply (100000 for example) name = \"Metacube\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"MTC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "32216.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract SIGNAL is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; function SIGNAL( ) { balances[msg.sender] = 5000000000000000; totalSupply = 5000000000000000; name = \"SIGNAL\"; decimals = 8; symbol = \"SIG\"; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36334.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; // Original author: Cintix // Modified by: Moonlambos, yakois // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract RequestSale { // Store the amount of ETH deposited by each account. mapping (address => uint256) public balances; // Track whether the contract has bought the tokens yet. bool public bought_tokens; // Record ETH value of tokens currently held by contract. uint256 public contract_eth_value; // Maximum amount of user ETH contract will accept. uint256 public eth_cap = 500 ether; // The minimum amount of ETH that must be deposited before the buy-in can be performed. uint256 constant public min_required_amount = 60 ether; // The owner's address. address public owner; // The crowdsale address. Can be verified at: https://request.network/#/presale. address public sale = 0xa579E31b930796e3Df50A56829cF82Db98b6F4B3; //Constructor. Sets the sender as the owner of the contract. function RequestSale() { owner = msg.sender; } // Allows any user to withdraw his tokens. // Token's ERC20 address as argument as it is unknow at the time of deployement. function perform_withdrawal(address tokenAddress) { // Tokens must be bought require(bought_tokens); // Retrieve current token balance of contract ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); // Disallow token withdrawals if there are no tokens to withdraw. require(contract_token_balance != 0); // Store the user's token balance in a temporary variable. uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; // Update the value of tokens currently held by the contract. contract_eth_value -= balances[msg.sender]; // Update the user's balance prior to sending to prevent recursive call. balances[msg.sender] = 0; // Send the funds.  Throws on failure to prevent loss of funds. require(token.transfer(msg.sender, tokens_to_withdraw)); } // Allows any caller to get his eth refunded. function refund_me() { // Store the user's balance prior to withdrawal in a temporary variable. uint256 eth_to_withdraw = balances[msg.sender]; // Update the user's balance prior to sending ETH to prevent recursive call. balances[msg.sender] = 0; // Return the user's funds.  Throws on failure to prevent loss of funds. msg.sender.transfer(eth_to_withdraw); } // Buy the tokens. Sends ETH to the presale wallet and records the ETH amount held in the contract. function buy_the_tokens() { // Only allow the owner to perform the buy in. require(msg.sender == owner); // Short circuit to save gas if the contract has already bought tokens. require(!bought_tokens); // The pre-sale address has to be set. require(sale != 0x0); // Throw if the contract balance is less than the minimum required amount. require(this.balance >= min_required_amount); // Record that the contract has bought the tokens. bought_tokens = true; // Record the amount of ETH sent as the contract's current value. contract_eth_value = this.balance; // Transfer all the funds to the crowdsale address. require(sale.call.value(contract_eth_value)()); } function upgrade_cap() { // Only the owner can raise the cap. require(msg.sender == owner); // Raise the cap. eth_cap = 1000 ether; } // Default function.  Called when a user sends ETH to the contract. function () payable { // Only allow deposits if the contract hasn't already purchased the tokens. require(!bought_tokens); // Only allow deposits that won't exceed the contract's ETH cap. require(this.balance + msg.value < eth_cap); // Update records of deposited ETH to include the received amount. balances[msg.sender] += msg.value; } } "}
{"sol name": "44545.sol", "label": 0, "sol content": "pragma solidity ^0.6.0; import \"./ItemManager.sol\"; contract Item { uint public priceInWei; uint public paidWei; uint public index; ItemManager parentContract; constructor(ItemManager _parentContract, uint _priceInWei, uint _index) public { priceInWei = _priceInWei; index = _index; parentContract = _parentContract; } receive() external payable { require(msg.value == priceInWei, \"We don't support partial payments\"); require(paidWei == 0, \"Item is already paid!\"); paidWei += msg.value; (bool success, ) = address(parentContract).call{value:msg.value}(abi.encodeWithSign ature(\"triggerPayment(uint256)\", index)); require(success, \"Delivery did not work\"); } fallback () external { } } "}
{"sol name": "24822.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * Digital Fantasy Sports is a digital sports platform that brings this concept of playing fantasy sports * while using cryptocurrencies to extraordinary fantasy players. It has created an ER20 token called * DFS that provides a simple secure interface between the players and the league action that they * love featuring multiple gaming sport platforms that use DFS as in-game currency. * * Website: https://www.digitalfantasysports.com/ * Twitter: https://twitter.com/dfstoken * Reddit: https://www.reddit.com/r/dfstoken * Discord: https://discordapp.com/channels/397817936884269057/397817937731387403 * Bitcoin Talk: https://bitcointalk.org/index.php?topic=2223626.0 */ // ==== Open Zeppelin library === /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** @title ERC827 interface, an extension of ERC20 token standard Interface of a ERC827 token, following the ERC20 standard with extra methods to transfer value and data and execute calls in transfers and approvals. */ contract ERC827 is ERC20 { function approve( address _spender, uint256 _value, bytes _data ) public returns (bool); function transfer( address _to, uint256 _value, bytes _data ) public returns (bool); function transferFrom( address _from, address _to, uint256 _value, bytes _data ) public returns (bool); } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Contracts that should not own Ether * @author Remco Bloemen <[email\u00a0protected]\u03c0.com> * @dev This tries to block incoming ether to prevent accidental loss of Ether. Should Ether end up * in the contract, it will allow the owner to reclaim this ether. * @notice Ether can still be send to this contract by: * calling functions labeled `payable` * `selfdestruct(contract_address)` * mining directly to the contract address */ contract HasNoEther is Ownable { /** * @dev Constructor that rejects incoming Ether * @dev The `payable` flag is added so we can access `msg.value` without compiler warning. If we * leave out payable, then Solidity will allow inheriting contracts to implement a payable * constructor. By doing it this way we prevent a payable constructor from working. Alternatively * we could use assembly to access msg.value. */ function HasNoEther() public payable { require(msg.value == 0); } /** * @dev Disallows direct send by settings a default function without the `payable` flag. */ function() external { } /** * @dev Transfer all Ether held by the contract to the owner. */ function reclaimEther() external onlyOwner { assert(owner.send(this.balance)); } } /** * @title Contracts that should not own Contracts * @author Remco Bloemen <[email\u00a0protected]\u03c0.com> * @dev Should contracts (anything Ownable) end up being owned by this contract, it allows the owner * of this contract to reclaim ownership of the contracts. */ contract HasNoContracts is Ownable { /** * @dev Reclaim ownership of Ownable contracts * @param contractAddr The address of the Ownable to be reclaimed. */ function reclaimContract(address contractAddr) external onlyOwner { Ownable contractInst = Ownable(contractAddr); contractInst.transferOwnership(owner); } } /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } /** * @title Contracts that should not own Tokens * @author Remco Bloemen <[email\u00a0protected]\u03c0.com> * @dev This blocks incoming ERC23 tokens to prevent accidental loss of tokens. * Should tokens (any ERC20Basic compatible) end up in the contract, it allows the * owner to reclaim the tokens. */ contract HasNoTokens is CanReclaimToken { /** * @dev Reject all ERC23 compatible tokens * @param from_ address The address that is transferring the tokens * @param value_ uint256 the amount of the specified token * @param data_ Bytes The data passed from the caller. */ function tokenFallback(address from_, uint256 value_, bytes data_) pure external { from_; value_; data_; revert(); } } /** * @title Base contract for contracts that should not own things. * @author Remco Bloemen <[email\u00a0protected]\u03c0.com> * @dev Solves a class of errors where a contract accidentally becomes owner of Ether, Tokens or * Owned contracts. See respective base contracts for details. */ contract NoOwner is HasNoEther, HasNoTokens, HasNoContracts { } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } /** @title ERC827, an extension of ERC20 token standard Implementation the ERC827, following the ERC20 standard with extra methods to transfer value and data and execute calls in transfers and approvals. Uses OpenZeppelin StandardToken. */ contract ERC827Token is ERC827, StandardToken { /** @dev Addition to ERC20 token methods. It allows to approve the transfer of value and execute a call with the sent data. Beware that changing an allowance with this method brings the risk that someone may use both the old and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 @param _spender The address that will spend the funds. @param _value The amount of tokens to be spent. @param _data ABI-encoded contract call to call `_to` address. @return true if the call function was executed successfully */ function approve(address _spender, uint256 _value, bytes _data) public returns (bool) { require(_spender != address(this)); super.approve(_spender, _value); require(_spender.call(_data)); return true; } /** @dev Addition to ERC20 token methods. Transfer tokens to a specified address and execute a call with the sent data on the same transaction @param _to address The address which you want to transfer to @param _value uint256 the amout of tokens to be transfered @param _data ABI-encoded contract call to call `_to` address. @return true if the call function was executed successfully */ function transfer(address _to, uint256 _value, bytes _data) public returns (bool) { require(_to != address(this)); super.transfer(_to, _value); require(_to.call(_data)); return true; } /** @dev Addition to ERC20 token methods. Transfer tokens from one address to another and make a contract call on the same transaction @param _from The address which you want to send tokens from @param _to The address which you want to transfer to @param _value The amout of tokens to be transferred @param _data ABI-encoded contract call to call `_to` address. @return true if the call function was executed successfully */ function transferFrom(address _from, address _to, uint256 _value, bytes _data) public returns (bool) { require(_to != address(this)); super.transferFrom(_from, _to, _value); require(_to.call(_data)); return true; } /** * @dev Addition to StandardToken methods. Increase the amount of tokens that * an owner allowed to a spender and execute a call with the sent data. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. * @param _data ABI-encoded contract call to call `_spender` address. */ function increaseApproval(address _spender, uint _addedValue, bytes _data) public returns (bool) { require(_spender != address(this)); super.increaseApproval(_spender, _addedValue); require(_spender.call(_data)); return true; } /** * @dev Addition to StandardToken methods. Decrease the amount of tokens that * an owner allowed to a spender and execute a call with the sent data. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. * @param _data ABI-encoded contract call to call `_spender` address. */ function decreaseApproval(address _spender, uint _subtractedValue, bytes _data) public returns (bool) { require(_spender != address(this)); super.decreaseApproval(_spender, _subtractedValue); require(_spender.call(_data)); return true; } } // ==== DFS Contracts === contract DFSToken is MintableToken, ERC827Token, NoOwner { string public symbol = 'DFS'; string public name = 'Digital Fantasy Sports'; uint8 public constant decimals = 18; bool public transferEnabled;    //allows to dissable transfers while minting and in case of emergency function setTransferEnabled(bool enable) onlyOwner public { transferEnabled = enable; } modifier canTransfer() { require( transferEnabled || msg.sender == owner); _; } function transfer(address _to, uint256 _value) canTransfer public returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) canTransfer public returns (bool) { return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value, bytes _data) canTransfer public returns (bool) { return super.transfer(_to, _value, _data); } function transferFrom(address _from, address _to, uint256 _value, bytes _data) canTransfer public returns (bool) { return super.transferFrom(_from, _to, _value, _data); } } "}
{"sol name": "40054.sol", "label": 0, "sol content": "/* Deployment: Owner: 0xeb5fa6cbf2aca03a0df228f2df67229e2d3bd01e Last address: 0x401e28717a6a35a50938bc7f290f2678fc0a2816 ABI: [{\"constant\":true,\"inputs\":[],\"name\":\"gotParticipants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_signature\",\"type\":\"uint256[]\"},{\"name\":\"_x0\",\"type\":\"uint256\"},{\"name\":\"_Ix\",\"type\":\"uint256\"},{\"name\":\"_Iy\",\"type\":\"uint256\"}],\"name\":\"withdrawStart\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pubkeys2\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"payment\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"name\":\"pubkeys1\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"participants\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawStep\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"withdrawFinal\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_pubkey1\",\"type\":\"uint256\"},{\"name\":\"_pubkey2\",\"type\":\"uint256\"}],\"name\":\"deposit\",\"outputs\":[],\"payable\":true,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_participants\",\"type\":\"uint256\"},{\"name\":\"_payment\",\"type\":\"uint256\"}],\"type\":\"constructor\"},{\"payable\":false,\"type\":\"fallback\"},{\"anonymous\":false,\"inputs\":[{\"indexed\":false,\"name\":\"message\",\"type\":\"string\"}],\"name\":\"LogDebug\",\"type\":\"event\"}] Optimized: yes Solidity version: v0.4.4 */ pragma solidity ^0.4.0; contract ArithLib { function jdouble(uint _ax, uint _ay, uint _az) constant returns (uint, uint, uint); function jadd(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint); function jsub(uint _ax, uint _ay, uint _az, uint _bx, uint _by, uint _bz) constant returns (uint, uint, uint); function jmul(uint _bx, uint _by, uint _bz, uint _n) constant returns (uint, uint, uint); function jexp(uint _b, uint _e, uint _m) constant returns (uint); function jrecover_y(uint _x, uint _y_bit) constant returns (uint); function jdecompose(uint _q0, uint _q1, uint _q2) constant returns (uint, uint); function isbit(uint _data, uint _bit) constant returns (uint); function hash_pubkey_to_pubkey(uint _pub1, uint _pub2) constant returns (uint, uint); } contract Laundromat { struct WithdrawInfo { address sender; uint Ix; uint Iy; uint[] signature; uint[] ring1; uint[] ring2; uint step; uint prevStep; } uint constant internal safeGas = 25000; uint constant internal P = 115792089237316195423570985008687907853269984665640564039457584007908834671663; uint constant internal Gx = 55066263022277343669578718895168534326250603453777594175500187360389116729240; uint constant internal Gy = 32670510020758816978083085130507043184471273380659243275938904335757337482424; address private owner; bool private atomicLock; address internal constant arithAddress = 0x600ad7b57f3e6aeee53acb8704a5ed50b60cacd6; ArithLib private arithContract; mapping (uint => WithdrawInfo) private withdraws; mapping (uint => bool) private consumed; uint public participants = 0; uint public payment = 0; uint public gotParticipants = 0; uint[] public pubkeys1; uint[] public pubkeys2; event LogDebug(string message); //create new mixing contract with _participants amount of mixing participants, //_payment - expected payment from each participant. function Laundromat(uint _participants, uint _payment) { owner = msg.sender; arithContract = ArithLib(arithAddress); participants = _participants; payment = _payment; } function safeSend(address addr, uint value) internal { if(atomicLock) throw; atomicLock = true; if (!(addr.call.gas(safeGas).value(value)())) { atomicLock = false; throw; } atomicLock = false; } //add new participant to the mixing function deposit(uint _pubkey1, uint _pubkey2) payable { //if(msg.value != payment) throw; if(gotParticipants >= participants) throw; pubkeys1.push(_pubkey1); pubkeys2.push(_pubkey2); gotParticipants++; } //get funds from the mixer. Requires valid signature. function withdrawStart(uint[] _signature, uint _x0, uint _Ix, uint _Iy) { if(gotParticipants < participants) throw; if(consumed[uint(sha3([_Ix, _Iy]))]) throw; WithdrawInfo withdraw = withdraws[uint(msg.sender)]; withdraw.sender = msg.sender; withdraw.Ix = _Ix; withdraw.Iy = _Iy; withdraw.signature = _signature; withdraw.ring1.length = 0; withdraw.ring2.length = 0; withdraw.ring1.push(_x0); withdraw.ring2.push(uint(sha3(_x0))); withdraw.step = 1; withdraw.prevStep = 0; } function withdrawStep() { WithdrawInfo withdraw = withdraws[uint(msg.sender)]; //throw if existing witdhraw not started if(withdraw.step < 1) throw; if(withdraw.step > participants) throw; if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw; uint k1x; uint k1y; uint k1z; uint k2x; uint k2y; uint k2z; uint pub1x; uint pub1y; (k1x, k1y, k1z) = arithContract.jmul(Gx, Gy, 1, withdraw.signature[withdraw.prevStep % participants]); (k2x, k2y, k2z) = arithContract.jmul( pubkeys1[withdraw.step % participants], pubkeys2[withdraw.step % participants], 1, withdraw.ring2[withdraw.prevStep % participants]); //ksub1 (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z); (pub1x, pub1y) = arithContract.jdecompose(k1x, k1y, k1z); //k3 (k1x, k1y) = arithContract.hash_pubkey_to_pubkey( pubkeys1[withdraw.step % participants], pubkeys2[withdraw.step % participants]); //k4 = ecmul(k3, s[prev_i]) (k1x, k1y, k1z) = arithContract.jmul(k1x, k1y, 1, withdraw.signature[withdraw.prevStep % participants]); //k5 = ecmul(I, e[prev_i].right) (k2x, k2y, k2z) = arithContract.jmul(withdraw.Ix, withdraw.Iy, 1, withdraw.ring2[withdraw.prevStep % participants]); //ksub2 (k1x, k1y, k1z) = arithContract.jsub(k1x, k1y, k1z, k2x, k2y, k2z); //pub2x, pub2y (k1x, k1y) = arithContract.jdecompose(k1x, k1y, k1z); withdraw.ring1.push(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y]))); withdraw.ring2.push(uint(sha3(uint(sha3([uint(withdraw.sender), pub1x, pub1y, k1x, k1y]))))); withdraw.step++; withdraw.prevStep++; } function withdrawFinal() returns (bool) { WithdrawInfo withdraw = withdraws[uint(msg.sender)]; if(withdraw.step != (participants + 1)) throw; if(consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))]) throw; if(withdraw.ring1[participants] != withdraw.ring1[0]) { LogDebug(\"Wrong signature\"); return false; } if(withdraw.ring2[participants] != withdraw.ring2[0]) { LogDebug(\"Wrong signature\"); return false; } withdraw.step++; consumed[uint(sha3([withdraw.Ix, withdraw.Iy]))] = true; safeSend(withdraw.sender, payment); return true; } function () { throw; } } "}
{"sol name": "32077.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract TeamSharksToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract SHRK is TeamSharksToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called SharksToken, make sure the //contract name above is also SharksToken instead of ERC20Token function SHRK( ) { balances[msg.sender] = 100000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 100000000000000000000000000;                        // Update total supply (100000 for example) name = \"Shark Coin\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"SHRK\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "31691.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name of contract contract GhostGold is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ string public name;                   //fancy name uint8 public decimals;                //How many decimals to show string public symbol;                 //An identifier string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // //function name must match the contract name above function GhostGold( ) { balances[msg.sender] = 1000000;               // Give the creator all initial tokens totalSupply = 1000000;                        // Update total supply name = \"GhostGold\";                           // Set the name for display purposes decimals = 0;                                 // Amount of decimals for display purposes symbol = \"GXG\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "31857.sol", "label": 0, "sol content": "// Copyright (C) 2017 DappHub, LLC pragma solidity ^0.4.11; //import \"ds-exec/exec.sol\"; contract DSExec { function tryExec( address target, bytes calldata, uint value) internal returns (bool call_ret) { return target.call.value(value)(calldata); } function exec( address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; } } // Convenience aliases function exec( address t, bytes c ) internal { exec(t, c, 0); } function exec( address t, uint256 v ) internal { bytes memory c; exec(t, c, v); } function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); } function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); } } //import \"ds-auth/auth.sol\"; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) constant returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) auth { authority = authority_; LogSetAuthority(authority); } modifier auth { assert(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } function assert(bool x) internal { if (!x) throw; } } //import \"ds-note/note.sol\"; contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint        wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } //import \"ds-math/math.sol\"; contract DSMath { /* standard uint256 functions */ function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); } function sub(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x - y) <= x); } function mul(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x * y; assert(x == 0 || z / x == y); } function div(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x / y; } function min(uint256 x, uint256 y) constant internal returns (uint256 z) { return x <= y ? x : y; } function max(uint256 x, uint256 y) constant internal returns (uint256 z) { return x >= y ? x : y; } /* uint128 functions (h is for half) */ function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x + y) >= x); } function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x - y) <= x); } function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x * y; assert(x == 0 || z / x == y); } function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x / y; } function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) { return x <= y ? x : y; } function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) { return x >= y ? x : y; } /* int256 functions */ function imin(int256 x, int256 y) constant internal returns (int256 z) { return x <= y ? x : y; } function imax(int256 x, int256 y) constant internal returns (int256 z) { return x >= y ? x : y; } /* WAD math */ uint128 constant WAD = 10 ** 18; function wadd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function wsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + WAD / 2) / WAD); } function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * WAD + y / 2) / y); } function wmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function wmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } /* RAY math */ uint128 constant RAY = 10 ** 27; function radd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function rsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + RAY / 2) / RAY); } function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * RAY + y / 2) / y); } function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) { // This famous algorithm is called \"exponentiation by squaring\" // and calculates x^n with x as fixed-point and n as regular unsigned. // // It's O(log n), instead of O(n) for naive repeated multiplication. // // These facts are why it works: // //  If n is even, then x^n = (x^2)^(n/2). //  If n is odd,  then x^n = x * x^(n-1), //   and applying the equation for even x gives //    x^n = x * (x^2)^((n-1) / 2). // //  Also, EVM division is flooring and //    floor[(n-1) / 2] = floor[n / 2]. z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } function rmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function rmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } function cast(uint256 x) constant internal returns (uint128 z) { assert((z = uint128(x)) == x); } } //import \"erc20/erc20.sol\"; contract ERC20 { function totalSupply() constant returns (uint supply); function balanceOf( address who ) constant returns (uint value); function allowance( address owner, address spender ) constant returns (uint _allowance); function transfer( address to, uint value) returns (bool ok); function transferFrom( address from, address to, uint value) returns (bool ok); function approve( address spender, uint value ) returns (bool ok); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } //import \"ds-token/base.sol\"; contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() constant returns (uint256) { return _supply; } function balanceOf(address src) constant returns (uint256) { return _balances[src]; } function allowance(address src, address guy) constant returns (uint256) { return _approvals[src][guy]; } function transfer(address dst, uint wad) returns (bool) { assert(_balances[msg.sender] >= wad); _balances[msg.sender] = sub(_balances[msg.sender], wad); _balances[dst] = add(_balances[dst], wad); Transfer(msg.sender, dst, wad); return true; } function transferFrom(address src, address dst, uint wad) returns (bool) { assert(_balances[src] >= wad); assert(_approvals[src][msg.sender] >= wad); _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); _balances[src] = sub(_balances[src], wad); _balances[dst] = add(_balances[dst], wad); Transfer(src, dst, wad); return true; } function approve(address guy, uint256 wad) returns (bool) { _approvals[msg.sender][guy] = wad; Approval(msg.sender, guy, wad); return true; } } //import \"ds-stop/stop.sol\"; contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; } function stop() auth note { stopped = true; } function start() auth note { stopped = false; } } //import \"ds-token/token.sol\"; contract DSToken is DSTokenBase(0), DSStop { bytes32  public  symbol; uint256  public  decimals = 18; // standard token precision. override to customize address  public  generator; modifier onlyGenerator { if(msg.sender!=generator) throw; _; } function DSToken(bytes32 symbol_) { symbol = symbol_; generator=msg.sender; } function transfer(address dst, uint wad) stoppable note returns (bool) { return super.transfer(dst, wad); } function transferFrom( address src, address dst, uint wad ) stoppable note returns (bool) { return super.transferFrom(src, dst, wad); } function approve(address guy, uint wad) stoppable note returns (bool) { return super.approve(guy, wad); } function push(address dst, uint128 wad) returns (bool) { return transfer(dst, wad); } function pull(address src, uint128 wad) returns (bool) { return transferFrom(src, msg.sender, wad); } function mint(uint128 wad) auth stoppable note { _balances[msg.sender] = add(_balances[msg.sender], wad); _supply = add(_supply, wad); } function burn(uint128 wad) auth stoppable note { _balances[msg.sender] = sub(_balances[msg.sender], wad); _supply = sub(_supply, wad); } // owner can transfer token even stop, function generatorTransfer(address dst, uint wad) onlyGenerator note returns (bool) { return super.transfer(dst, wad); } // Optional token name bytes32   public  name = \"\"; function setName(bytes32 name_) auth { name = name_; } } contract WarmWalletEvents { event LogSetWithdrawer (address indexed withdrawer); event LogSetWithdrawLimit (address indexed sender, uint value); } contract WarmWallet is DSStop, WarmWalletEvents{ DSToken public key; address public hotWallet; address public coldWallet; //@note address public withdrawer; uint public withdrawLimit; uint256 public lastWithdrawTime; modifier onlyWithdrawer { require(msg.sender == withdrawer); _; } // overrideable for easy testing function time() public constant returns (uint) { return now; } function WarmWallet(DSToken _key, address _hot, address _cold, address _withdrawer, uint _limit){ require(_key != address(0) ); require(_hot != address(0) ); require(_cold != address(0) ); require(_withdrawer != address(0) ); require(_limit > 0); require(_key != _hot); require(_key != _cold); require(_key != _withdrawer); key = _key; hotWallet = _hot; coldWallet = _cold; withdrawer = _withdrawer; withdrawLimit = _limit; lastWithdrawTime = 0; } function forwardToHotWallet(uint _amount) stoppable onlyWithdrawer { require(_amount > 0); uint _time = time(); require(_time > (lastWithdrawTime + 24 hours)); uint amount = _amount; if (amount > withdrawLimit) { amount = withdrawLimit; } key.transfer(hotWallet, amount); lastWithdrawTime = _time; } function restoreToColdWallet(uint _amount) onlyWithdrawer { require(_amount > 0); key.transfer(coldWallet, _amount); } function setWithdrawer(address _withdrawer) auth { withdrawer = _withdrawer; LogSetWithdrawer(_withdrawer); } function setWithdrawLimit(uint _limit) auth { withdrawLimit = _limit; LogSetWithdrawLimit(msg.sender, _limit); } // @notice This method can be used by the controller to extract mistakenly //  sent tokens to this contract. // @param dst The address that will be receiving the tokens // @param wad The amount of tokens to transfer // @param _token The address of the token contract that you want to recover function transferTokens(address dst, uint wad, address _token) onlyWithdrawer { require(_token != address(key)); if (wad > 0) { ERC20 token = ERC20(_token); token.transfer(dst, wad); } } } "}
{"sol name": "185.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract GIC is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; address public fundsWallet; function GIC () { balances[msg.sender] = 1000000000000000000000000000; totalSupply = 1000000000000000000000000000; name = \"Giccoin\"; decimals = 18; symbol = \"GIC\"; fundsWallet = msg.sender; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "39269.sol", "label": 0, "sol content": "/******************************************************************************\\ file:   RegBase.sol ver:    0.2.1 updated:9-May-2017 author: Darryl Morris (o0ragman0o) email:  o0ragman0o AT gmail.com This file is part of the SandalStraps framework `RegBase` provides an inheriting contract the minimal API to be compliant with `Registrar`.  It includes a set-once, `bytes32 public regName` which is refered to by `Registrar` lookups. An owner updatable `address public owner` state variable is also provided and is required by `Factory.createNew()`. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See MIT Licence for further details. <https://opensource.org/licenses/MIT>. \\******************************************************************************/ pragma solidity ^0.4.10; contract RegBase { // // Constants // bytes32 constant public VERSION = \"RegBase v0.2.1\"; // // State Variables // /// @dev A static identifier, set in the constructor and used for registrar /// lookup /// @return Registrar name SandalStraps registrars bytes32 public regName; /// @dev An general purpose resource such as short text or a key to a /// string in a StringsMap /// @return resource bytes32 public resource; /// @dev An address permissioned to enact owner restricted functions /// @return owner address public owner; // // Events // // Triggered on change of owner address event ChangedOwner(address indexed oldOwner, address indexed newOwner); // Triggered on change of resource event ChangedResource(bytes32 indexed resource); // // Modifiers // // Permits only the owner modifier onlyOwner() { require(msg.sender == owner); _; } // // Functions // /// @param _creator The calling address passed through by a factory, /// typically msg.sender /// @param _regName A static name referenced by a Registrar /// @param _owner optional owner address if creator is not the intended /// owner /// @dev On 0x0 value for owner, ownership precedence is: /// `_owner` else `_creator` else msg.sender function RegBase(address _creator, bytes32 _regName, address _owner) { regName = _regName; owner = _owner != 0x0 ? _owner : _creator != 0x0 ? _creator : msg.sender; } /// @notice Will selfdestruct the contract function destroy() public onlyOwner { selfdestruct(msg.sender); } /// @notice Change the owner to `_owner` /// @param _owner The address to which ownership is transfered function changeOwner(address _owner) public onlyOwner returns (bool) { ChangedOwner(owner, _owner); owner = _owner; return true; } /// @notice Change the resource to `_resource` /// @param _resource A key or short text to be stored as the resource. function changeResource(bytes32 _resource) public onlyOwner returns (bool) { resource = _resource; ChangedResource(_resource); return true; } } /******************************************************************************\\ file:   Factory.sol ver:    0.2.1 updated:9-May-2017 author: Darryl Morris (o0ragman0o) email:  o0ragman0o AT gmail.com This file is part of the SandalStraps framework Factories are a core but independant concept of the SandalStraps framework and can be used to create SandalStraps compliant 'product' contracts from embed bytecode. The abstract Factory contract is to be used as a SandalStraps compliant base for product specific factories which must impliment the createNew() function. is itself compliant with `Registrar` by inhereting `RegBase` and compiant with `Factory` through the `createNew(bytes32 _name, address _owner)` API. An optional creation fee can be set and manually collected by the owner. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See MIT Licence for further details. <https://opensource.org/licenses/MIT>. \\******************************************************************************/ pragma solidity ^0.4.10; // import \"https://github.com/o0ragman0o/SandalStraps/contracts/RegBase.sol\"; contract Factory is RegBase { // // Constants // // Deriving factories should have `bytes32 constant public regName` being // the product's contract name, e.g for products \"Foo\": // bytes32 constant public regName = \"Foo\"; // Deriving factories should have `bytes32 constant public VERSION` being // the product's contract name appended with 'Factory` and the version // of the product, e.g for products \"Foo\": // bytes32 constant public VERSION \"FooFactory 0.0.1\"; // // State Variables // /// @return The payment in wei required to create the product contract. uint public value; // // Events // // Is triggered when a product is created event Created(address _creator, bytes32 _regName, address _address); // // Modifiers // // To check that the correct fee has bene paid modifier feePaid() { require(msg.value == value || msg.sender == owner); _; } // // Functions // /// @param _creator The calling address passed through by a factory, /// typically msg.sender /// @param _regName A static name referenced by a Registrar /// @param _owner optional owner address if creator is not the intended /// owner /// @dev On 0x0 value for _owner or _creator, ownership precedence is: /// `_owner` else `_creator` else msg.sender function Factory(address _creator, bytes32 _regName, address _owner) RegBase(_creator, _regName, _owner) { // nothing left to construct } /// @notice Set the product creation fee /// @param _fee The desired fee in wei function set(uint _fee) onlyOwner returns (bool) { value = _fee; return true; } /// @notice Send contract balance to `owner` function withdraw() public returns (bool) { owner.transfer(this.balance); return true; } /// @notice Create a new product contract /// @param _regName A unique name if the the product is to be registered in /// a SandalStraps registrar /// @param _owner An address of a third party owner.  Will default to /// msg.sender if 0x0 /// @return kAddr_ The address of the new product contract function createNew(bytes32 _regName, address _owner) payable returns(address kAddr_); } /* Example implimentation of `createNew()` for a deriving factory function createNew(bytes32 _regName, address _owner) payable feePaid returns (address kAddr_) { require(_regName != 0x0); address kAddr_ = address(new Foo(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr); } Example product contract with `Factory` compiant constructor and `Registrar` compliant `regName`. The owner will be the caller by default if the `_owner` value is `0x0`. If the contract requires initialization that would normally be done in a constructor, then a `init()` function can be used instead post deployment. contract Foo is RegBase { bytes32 constant public VERSION = \"Foo v0.0.1\"; uint val; uint8 public __initFuse = 1; function Foo(address _creator, bytes32 _regName, address _owner) RegBase(_creator, _regName, _owner) { // put non-parametric constructor code here. } function _init(uint _val) { require(__initFuse == 1); // put parametric constructor code here and call _init() post // deployment val = _val; delete __initFuse; } } */ /* file:   Bakt.sol ver:    0.3.4-beta updated:16-May-2017 author: Darryl Morris email:  o0ragman0o AT gmail.com Copyright is retained by the author.  Copying or running this software is only by express permission. This software is provided WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. The author cannot be held liable for damage or loss. Design Notes: This contract DOES NOT offer trust to its holders. Holders instead elect a Trustee from among the holders and the Trustee is responsible for funds. The Trustee has unilateral powers to: - remove funds - use the contract to execute code on another contract - pay dividends - add holders - issue a token offer to a holder - selfdestruct the contract, on condition of 0 supply and 0 ether balance - veto a transaction Holders have the power to: - vote for a preferred Trustee - veto a transaction if owned or owns > 10% of tokens - purchase tokens offer with ether. - redeem tokens for ether at the token price or a price proportional to the fund. - withdraw their balance of ether. - Cause a panic state in the contract if holds > 10% of tokens This contract uses integer tokens so ERC20 `decimalPlaces` is 0. Maximum number of holders is limited to 254 to prevent potential OOG loops during elections. Perpetual election of the `Trustee` runs in O(254) time to discover a winner. Release Notes v0.3.4-beta: -fixed magnitude bug introduced when using scientific notation (10**18 != 10e18) -using 10**18 notation rather than 1e18 as already using 2**256 notation -Intend to deploy factory to Ropsten, Rinkeby and Live Ropsten: 0.3.4-beta-test1 @ 0xc446575f7ed13f7b4b849f70ffa9f209a64db742 */ // import \"https://github.com/o0ragman0o/SandalStraps/contracts/Factory.sol\"; pragma solidity ^0.4.10; contract BaktInterface { /* Structs */ struct Holder { uint8 id; address votingFor; uint40 offerExpiry; uint lastClaimed; uint tokenBalance; uint etherBalance; uint votes; uint offerAmount; mapping (address => uint) allowances; } struct TX { bool blocked; uint40 timeLock; address from; address to; uint value; bytes data; } /* Constants */ // Constant max tokens and max ether to prevent potential multiplication // overflows in 10e17 fixed point uint constant MAXTOKENS = 2**128 - 10**18; uint constant MAXETHER = 2**128; uint constant BLOCKPCNT = 10; // 10% holding required to block TX's uint constant TOKENPRICE = 1000000000000000; uint8 public constant decimalPlaces = 15; /* State Valiables */ // A mutex used for reentry protection bool __reMutex; // Initialisation fuse. Blows on initialisation and used for entry check; bool __initFuse = true; // Allows the contract to accept or deny payments bool public acceptingPayments; // The period for which a panic will prevent functionality to the contract uint40 public PANICPERIOD; // The period for which a pending transaction must wait before being sent uint40 public TXDELAY; /// @return The Panic flag state. false == calm, true == panicked bool public panicked; /// @return The pending transaction queue head pointer uint8 public ptxHead; /// @return The pending transaction queue tail pointer uint8 public ptxTail; /// @return The `PANIC` timelock expiry date/time uint40 public timeToCalm; /// @return The Address of the current elected trustee address public trustee; /// @return Total count of tokens uint public totalSupply; /// @return The combined balance of ether committed to holder accounts, /// unclaimed dividends and values in pending transactions. uint public committedEther; /// @dev The running tally of dividends points accured by /// dividend/totalSupply at each dividend payment uint dividendPoints; /// @return The historic tally of paid dividends uint public totalDividends; /// @return A static identifier, set in the constructor and used by /// registrars bytes32 public regName; /// @return An informational resource. Can be a sha3 of a string to lookup /// in a StringsMap bytes32 public resource; /// @param address The address of a holder. /// @return Holder data cast from struct Holder to an array mapping (address => Holder) public holders; /// @param uint8 The index of a holder /// @return An address of a holder address[256] public holderIndex; /// @param uint8 The index of a pending transaction /// @return Transaction details cast from struct TX to array TX[256] public pendingTxs; /* Events */ // Triggered when the contract recieves a payment event Deposit(uint value); // Triggered when ether is sent from the contract event Withdrawal(address indexed sender, address indexed recipient, uint value); // Triggered when a transaction is ordered event TransactionPending(uint indexed pTX, address indexed sender, address indexed recipient, uint value, uint timeLock); // Triggered when a pending transaction is blocked event TransactionBlocked(address indexed by, uint indexed pTX); // Triggered when a transaction fails either by being blocked or failure of // reciept event TransactionFailed(address indexed sender, address indexed recipient, uint value); // Triggered when the trustee pays dividends event DividendPaid(uint value); // ERC20 transfer notification event Transfer(address indexed from, address indexed to, uint value); // ERC20 approval notification event Approval(address indexed owner, address indexed spender, uint value); // Triggered on change of trustee event Trustee(address indexed trustee); // Trigger when a new holder is added event NewHolder(address indexed holder); // Triggered when a holder vacates event HolderVacated(address indexed holder); // Triggered when a offer of tokens is created event IssueOffer(address indexed holder); // Triggered on token creation when an offer is accepted event TokensCreated(address indexed holder, uint amount); // Triggered when tokens are destroyed during a redeeming round event TokensDestroyed(address indexed holder, uint amount); // Triggered when a hold causes a panic event Panicked(address indexed by); // Triggered when a holder calms a panic event Calm(); // // Bakt Functions // /// @dev Accept payment to the default function function() payable; /// @notice This will set the panic and pending periods. /// This action is a one off and is irrevocable! /// @param _panicDelayInSeconds The panic delay period in seconds /// @param _pendingDelayInSeconds The pending period in seconds function _init(uint40 _panicDelayInSeconds, uint40 _pendingDelayInSeconds) returns (bool); /// @return The balance of uncommitted ether funds. function fundBalance() constant returns (uint); /// @return The constant TOKENPRICE. function tokenPrice() constant returns (uint); // // ERC20 API functions // /// @param _addr The address of a holder /// @return The ERC20 token balance of the holder function balanceOf(address _addr) constant returns (uint); /// @notice Transfer `_amount` of tokens to `_to` /// @param _to the recipient holder's address /// @param _amount the number of tokens to transfer /// @return success state /// @dev `_to` must be an existing holder function transfer(address _to, uint _amount) returns (bool); /// @notice Transfer `_amount` of tokens from `_from` to `_to` /// @param _from The holder address from which to take tokens /// @param _to the recipient holder's address /// @param _amount the number of tokens to transfer /// @return success state /// @dev `_from` and `_to` must be existing holders function transferFrom(address _from, address _to, uint256 _amount) returns (bool); /// @notice Approve `_spender` to transfer `_amount` of tokens /// @param _spender the approved spender address. Does not have to be an /// existing holder. /// @param _amount the number of tokens to transfer function approve(address _spender, uint256 _amount) returns (bool); /// @param _owner The adddress of the holder owning tokens /// @param _spender The address of the account allowed to transfer tokens /// @return Amount of remaining token that the _spender can transfer function allowance(address _owner, address _spender) constant returns (uint256); // // Security Functions // /// @notice Cause the contract to Panic. This will block most state changing /// functions for a set delay. /// Exceptions are `vote()`, `blockPendingTx(uint _txIdx)` and `PANIC()`. function PANIC() returns (bool); /// @notice Release the contract from a Panic after the panic period has /// expired. function calm() returns (bool); /// @notice Execute the first TX in the pendingTxs queue. Values will /// revert if the transaction is blocked or fails. function sendPending() returns (bool); /// @notice Block a pending transaction with id `_txIdx`. Pending /// transactions can be blocked by any holder at any time but must /// still be cleared from the pending transactions queue once the timelock /// is cleared. /// @param _txIdx Index of the transaction in the pending transactions /// table function blockPendingTx(uint _txIdx) returns (bool); // // Trustee functions // /// @notice Send a transaction to `_to` containing `_value` with RLP encoded ///     arguments of `_data` /// @param _to The recipient address /// @param _value value of ether to send /// @param _data RLP encoded data to send with the transaction /// @dev Allows the trustee to initiate a transaction as the Bakt. It must /// be followed by sendPending() after the timeLock expires. function execute(address _to, uint _value, bytes _data) returns (uint8); /// @notice Pay dividends of `_value` /// @param _value a value of ether upto the fund balance /// @dev Allows the trustee to commit a portion of `fundBalance` to dividends. function payDividends(uint _value) returns (bool); // // Holder Functions // /// @return Returns the array of holder addresses. function getHolders() constant returns(address[256]); /// @param _addr The address of a holder /// @return Returns the holder's withdrawable balance of ether function etherBalanceOf(address _addr) constant returns (uint); /// @notice Initiate a withdrawal of the holder's `etherBalance` /// Follow up with sendPending() once the timelock has expired function withdraw() returns(uint8); /// @notice Vacate holder `_addr` /// @param _addr The address of a holder with empty balances. function vacate(address _addr) returns (bool); // // Token Creation/Destruction Functions // /// @notice Create tokens to the value of `msg.value` + /// `holder.etherBalance` /// @return success state /// @dev The amount of tokens created is: ///     tokens = floor((`etherBalance` + `msg.value`)/`tokenPrice`) ///     Any remainder of ether is credited to the holder's `etherBalance` function purchase() payable returns (bool); /// @notice Redeem `_amount` tokens back to the contract /// @param _amount The amount of tokens to redeem /// @dev ether = `_amount` * `fundBalance()` / `totalSupply` /// @return success state function redeem(uint _amount) returns (bool); // // Ballot functions // /// @notice Vote for `_candidate` as preferred Trustee. /// @param _candidate The address of the preferred holder /// @return success state function vote(address _candidate) returns (bool); } contract Bakt is BaktInterface { bytes32 constant public VERSION = \"Bakt 0.3.4-beta\"; // // Bakt Functions // // SandalStraps compliant constructor function Bakt(address _creator, bytes32 _regName, address _trustee) { regName = _regName; trustee = _trustee != 0x0 ? _trustee : _creator != 0x0 ? _creator : msg.sender; join(trustee); } // Accept payment to the default function on the condition that // `acceptingPayments` is true function() payable { require(msg.value > 0 && msg.value + this.balance < MAXETHER && acceptingPayments); Deposit(msg.value); } // Destructor // Selfdestructs on the condition that `totalSupply` and `committedEther` // are 0 function destroy() public canEnter onlyTrustee { require(totalSupply == 0 && committedEther == 0); delete holders[trustee]; selfdestruct(msg.sender); } // One Time Programable shot to set the panic and pending periods. // 86400 == 1 day function _init(uint40 _panicPeriodInSeconds, uint40 _pendingPeriodInSeconds) onlyTrustee returns (bool) { require(__initFuse); PANICPERIOD = _panicPeriodInSeconds; TXDELAY = _pendingPeriodInSeconds; acceptingPayments = true; delete __initFuse; return true; } // Returns calculated fund balance function fundBalance() public constant returns (uint) { return this.balance - committedEther; } // Returns token price constant function tokenPrice() public constant returns (uint) { return TOKENPRICE; } // `RegBase` compliant `changeResource()` to restrict caller to // `trustee` rather than `owner` function changeResource(bytes32 _resource) public canEnter onlyTrustee returns (bool) { resource = _resource; return true; } // // ERC20 API functions // // Returns holder token balance function balanceOf(address _addr) public constant returns (uint) { return holders[_addr].tokenBalance; } // To transfer tokens function transfer(address _to, uint _amount) public canEnter isHolder(_to) returns (bool) { Holder from = holders[msg.sender]; Holder to = holders[_to]; Transfer(msg.sender, _to, _amount); return xfer(from, to, _amount); } // To transfer tokens by proxy function transferFrom(address _from, address _to, uint256 _amount) public canEnter isHolder(_to) returns (bool) { require(_amount <= holders[_from].allowances[msg.sender]); Holder from = holders[_from]; Holder to = holders[_to]; from.allowances[msg.sender] -= _amount; Transfer(_from, _to, _amount); return xfer(from, to, _amount); } // To approve a proxy for token transfers function approve(address _spender, uint256 _amount) public canEnter returns (bool) { holders[msg.sender].allowances[_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } // Return the alloance of a proxy function allowance(address _owner, address _spender) constant returns (uint256) { return holders[_owner].allowances[_spender]; } // Processes token transfers and subsequent change in voting power function xfer(Holder storage _from, Holder storage _to, uint _amount) internal returns (bool) { // Ensure dividends are up to date at current balances updateDividendsFor(_from); updateDividendsFor(_to); // Remove existing votes revoke(_from); revoke(_to); // Transfer tokens _from.tokenBalance -= _amount; _to.tokenBalance += _amount; // Revote accoring to changed token balances revote(_from); revote(_to); // Force election election(); return true; } // // Security Functions // // Cause the contract to Panic. This will block most state changing // functions for a set delay. function PANIC() public isHolder(msg.sender) returns (bool) { // A blocking holder requires at least 10% of tokens require(holders[msg.sender].tokenBalance >= totalSupply / 10); panicked = true; timeToCalm = uint40(now + PANICPERIOD); Panicked(msg.sender); return true; } // Release the contract from a Panic after the panic period has expired. function calm() public isHolder(msg.sender) returns (bool) { require(uint40(now) > timeToCalm && panicked); panicked = false; Calm(); return true; } // Queues a pending transaction function timeLockSend(address _from, address _to, uint _value, bytes _data) internal returns (uint8) { // Check that queue is not full require(ptxHead + 1 != ptxTail); TX memory tx = TX({ from: _from, to: _to, value: _value, data: _data, blocked: false, timeLock: uint40(now + TXDELAY) }); TransactionPending(ptxHead, _from, _to, _value, now + TXDELAY); pendingTxs[ptxHead++] = tx; return  ptxHead - 1; } // Execute the first TX in the pendingTxs queue. Values will // revert if the transaction is blocked or fails. function sendPending() public preventReentry isHolder(msg.sender) returns (bool) { if (ptxTail == ptxHead) return false; // TX queue is empty TX memory tx = pendingTxs[ptxTail]; if(now < tx.timeLock) return false; // Have memory cached the TX so deleting store now to prevent any chance // of double spends. delete pendingTxs[ptxTail++]; if(!tx.blocked) { if(tx.to.call.value(tx.value)(tx.data)) { // TX sent successfully committedEther -= tx.value; Withdrawal(tx.from, tx.to, tx.value); return true; } } // TX is blocked or failed so manually revert balances to pre-pending // state if (tx.from == address(this)) { // Was sent from fund balance committedEther -= tx.value; } else { // Was sent from holder ether balance holders[tx.from].etherBalance += tx.value; } TransactionFailed(tx.from, tx.to, tx.value); return false; } // To block a pending transaction function blockPendingTx(uint _txIdx) public returns (bool) { // Only prevent reentry not entry during panic require(!__reMutex); // A blocking holder requires at least 10% of tokens or is trustee or // is from own account require(holders[msg.sender].tokenBalance >= totalSupply / BLOCKPCNT || msg.sender == pendingTxs[ptxTail].from || msg.sender == trustee); pendingTxs[_txIdx].blocked = true; TransactionBlocked(msg.sender, _txIdx); return true; } // // Trustee functions // // For the trustee to send a transaction as the contract. Returns pending // TX queue index function execute(address _to, uint _value, bytes _data) public canEnter onlyTrustee returns (uint8) { require(_value <= fundBalance()); committedEther += _value; return timeLockSend(address(this), _to, _value, _data); } // For the trustee to commit an amount from the fund balance as a dividend function payDividends(uint _value) public canEnter onlyTrustee returns (bool) { require(_value <= fundBalance()); // Calculates dividend as percent of current `totalSupply` in 10e17 // fixed point math dividendPoints += 10**18 * _value / totalSupply; totalDividends += _value; committedEther += _value; return true; } // For the trustee to add an address as a holder function addHolder(address _addr) public canEnter onlyTrustee returns (bool) { return join(_addr); } // Creates holder accounts.  Called by addHolder() and issue() function join(address _addr) internal returns (bool) { if(0 != holders[_addr].id) return true; require(_addr != address(this)); uint8 id; // Search for the first available slot. while (holderIndex[++id] != 0) {} // if `id` is 0 then there has been a array full overflow. if(id == 0) revert(); Holder holder = holders[_addr]; holder.id = id; holder.lastClaimed = dividendPoints; holder.votingFor = trustee; holderIndex[id] = _addr; NewHolder(_addr); return true; } // For the trustee to allow or disallow payments made to the Bakt function acceptPayments(bool _accepting) public canEnter onlyTrustee returns (bool) { acceptingPayments = _accepting; return true; } // For the trustee to issue an offer of new tokens to a holder function issue(address _addr, uint _amount) public canEnter onlyTrustee returns (bool) { // prevent overflows in total supply assert(totalSupply + _amount < MAXTOKENS); join(_addr); Holder holder = holders[_addr]; holder.offerAmount = _amount; holder.offerExpiry = uint40(now + 7 days); IssueOffer(_addr); return true; } // For the trustee to revoke an earlier Issue Offer function revokeOffer(address _addr) public canEnter onlyTrustee returns (bool) { Holder holder = holders[_addr]; delete holder.offerAmount; delete holder.offerExpiry; return true; } // // Holder Functions // // Returns the array of holder addresses. function getHolders() public constant returns(address[256]) { return holderIndex; } // Returns the holder's withdrawable balance of ether function etherBalanceOf(address _addr) public constant returns (uint) { Holder holder = holders[_addr]; return holder.etherBalance + dividendsOwing(holder); } // For a holder to initiate a withdrawal of their ether balance function withdraw() public canEnter returns(uint8 pTxId_) { Holder holder = holders[msg.sender]; updateDividendsFor(holder); pTxId_ = timeLockSend(msg.sender, msg.sender, holder.etherBalance, \"\"); holder.etherBalance = 0; } // To close a holder account function vacate(address _addr) public canEnter isHolder(msg.sender) isHolder(_addr) returns (bool) { Holder holder = holders[_addr]; // Ensure holder account is empty, is not the trustee and there are no // pending transactions or dividends require(_addr != trustee); require(holder.tokenBalance == 0); require(holder.etherBalance == 0); require(holder.lastClaimed == dividendPoints); require(ptxHead == ptxTail); delete holderIndex[holder.id]; delete holders[_addr]; // NB can't garbage collect holder.allowances mapping return (true); } // // Token Creation/Destruction Functions // // For a holder to buy an offer of tokens function purchase() payable canEnter returns (bool) { Holder holder = holders[msg.sender]; // offer must exist require(holder.offerAmount > 0); // offer not expired require(holder.offerExpiry > now); // correct payment has been sent require(msg.value == holder.offerAmount * TOKENPRICE); updateDividendsFor(holder); revoke(holder); totalSupply += holder.offerAmount; holder.tokenBalance += holder.offerAmount; TokensCreated(msg.sender, holder.offerAmount); delete holder.offerAmount; delete holder.offerExpiry; revote(holder); election(); return true; } // For holders to destroy tokens in return for ether during a redeeming // round function redeem(uint _amount) public canEnter isHolder(msg.sender) returns (bool) { uint redeemPrice; uint eth; Holder holder = holders[msg.sender]; require(_amount <= holder.tokenBalance); updateDividendsFor(holder); revoke(holder); redeemPrice = fundBalance() / totalSupply; // prevent redeeming above token price which would allow an arbitrage // attack on the fund balance redeemPrice = redeemPrice < TOKENPRICE ? redeemPrice : TOKENPRICE; eth = _amount * redeemPrice; // will throw if either `amount` or `redeemPRice` are 0 require(eth > 0); totalSupply -= _amount; holder.tokenBalance -= _amount; holder.etherBalance += eth; committedEther += eth; TokensDestroyed(msg.sender, _amount); revote(holder); election(); return true; } // // Dividend Functions // function dividendsOwing(Holder storage _holder) internal constant returns (uint _value) { // Calculates owed dividends in 10e17 fixed point math return (dividendPoints - _holder.lastClaimed) * _holder.tokenBalance/ 10**18; } function updateDividendsFor(Holder storage _holder) internal { _holder.etherBalance += dividendsOwing(_holder); _holder.lastClaimed = dividendPoints; } // // Ballot functions // // To vote for a preferred Trustee. function vote(address _candidate) public isHolder(msg.sender) isHolder(_candidate) returns (bool) { // Only prevent reentry not entry during panic require(!__reMutex); Holder holder = holders[msg.sender]; revoke(holder); holder.votingFor = _candidate; revote(holder); election(); return true; } // Loops through holders to find the holder with most votes and declares // them to be the Executive; function election() internal { uint max; uint winner; uint votes; uint8 i; address addr; if (0 == totalSupply) return; while(++i != 0) { addr = holderIndex[i]; if (addr != 0x0) { votes = holders[addr].votes; if (votes > max) { max = votes; winner = i; } } } trustee = holderIndex[winner]; Trustee(trustee); } // Pulls votes from the preferred candidate // required before any adjustments to `tokenBalance` or vote preference. function revoke(Holder _holder) internal { holders[_holder.votingFor].votes -= _holder.tokenBalance; } // Places votes with preferred candidate // required after any adjustments to `tokenBalance` or vote preference. function revote(Holder _holder) internal { holders[_holder.votingFor].votes += _holder.tokenBalance; } // // Modifiers // // Blocks if reentry mutex or panicked is true or sets rentry mutex to true modifier preventReentry() { require(!(__reMutex || panicked || __initFuse)); __reMutex = true; _; __reMutex = false; return; } // Blocks if reentry mutex or panicked is true modifier canEnter() { require(!(__reMutex || panicked || __initFuse)); _; } // Blocks if '_addr' is not a holder modifier isHolder(address _addr) { require(0 != holders[_addr].id); _; } // Block non-trustee holders modifier onlyTrustee() { require(msg.sender == trustee); _; } } // SandalStraps compliant factory for Bakt contract BaktFactory is Factory { // Live: 0xc7c11eb6983787f7aa0c20abeeac8101cf621e47 // https://etherscan.io/address/0xc7c11eb6983787f7aa0c20abeeac8101cf621e47 // Ropsten: 0xda33129464688b7bd752ce64e9ed6bca65f44902 (could not verify), //          0x19124dbab3fcba78b8d240ed2f2eb87654e252d4 // Rinkeby: /* Constants */ bytes32 constant public regName = \"Bakt\"; bytes32 constant public VERSION = \"Bakt Factory v0.3.4-beta\"; /* Constructor Destructor*/ function BaktFactory(address _creator, bytes32 _regName, address _owner) Factory(_creator, _regName, _owner) { // nothing to construct } /* Public Functions */ function createNew(bytes32 _regName, address _owner) payable feePaid returns (address kAddr_) { require(_regName != 0x0); kAddr_ = new Bakt(owner, _regName, msg.sender); Created(msg.sender, _regName, kAddr_); } } "}
{"sol name": "32983.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract SAILER is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function SAILER( ) { balances[msg.sender] = 21000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 21000000000000000000000000;                       // Update total supply (100000 for example) name = \"SAILER\";                                              // Set the name for display purposes decimals = 18;                                                   // Amount of decimals for display purposes symbol = \"SAIL\";                                            // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "43473.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; contract Token{ // token\u603b\u91cf\uff0c\u9ed8\u8ba4\u4f1a\u4e3apublic\u53d8\u91cf\u751f\u6210\u4e00\u4e2agetter\u51fd\u6570\u63a5\u53e3\uff0c\u540d\u79f0\u4e3atotalSupply(). uint256 public totalSupply; /// \u83b7\u53d6\u8d26\u6237_owner\u62e5\u6709token\u7684\u6570\u91cf function balanceOf(address _owner) constant returns (uint256 balance); //\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u5f80_to\u8d26\u6237\u8f6c\u6570\u91cf\u4e3a_value\u7684token function transfer(address _to, uint256 _value) returns (bool success); //\u4ece\u8d26\u6237_from\u4e2d\u5f80\u8d26\u6237_to\u8f6c\u6570\u91cf\u4e3a_value\u7684token\uff0c\u4e0eapprove\u65b9\u6cd5\u914d\u5408\u4f7f\u7528 function transferFrom(address _from, address _to, uint256 _value) returns (bool success); //\u6d88\u606f\u53d1\u9001\u8d26\u6237\u8bbe\u7f6e\u8d26\u6237_spender\u80fd\u4ece\u53d1\u9001\u8d26\u6237\u4e2d\u8f6c\u51fa\u6570\u91cf\u4e3a_value\u7684token function approve(address _spender, uint256 _value) returns (bool success); //\u83b7\u53d6\u8d26\u6237_spender\u53ef\u4ee5\u4ece\u8d26\u6237_owner\u4e2d\u8f6c\u51fatoken\u7684\u6570\u91cf function allowance(address _owner, address _spender) constant returns (uint256 remaining); //\u53d1\u751f\u8f6c\u8d26\u65f6\u5fc5\u987b\u8981\u89e6\u53d1\u7684\u4e8b\u4ef6 event Transfer(address indexed _from, address indexed _to, uint256 _value); //\u5f53\u51fd\u6570approve(address _spender, uint256 _value)\u6210\u529f\u6267\u884c\u65f6\u5fc5\u987b\u89e6\u53d1\u7684\u4e8b\u4ef6 event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //\u9ed8\u8ba4totalSupply \u4e0d\u4f1a\u8d85\u8fc7\u6700\u5927\u503c (2^256 - 1). //\u5982\u679c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u5c06\u4f1a\u6709\u65b0\u7684token\u751f\u6210\uff0c\u5219\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u53e5\u907f\u514d\u6ea2\u51fa\u7684\u5f02\u5e38 //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value;//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[_to] += _value;//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value Transfer(msg.sender, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //require(balances[_from] >= _value && allowed[_from][msg.sender] >= // _value && balances[_to] + _value > balances[_to]); require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value;//\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value balances[_from] -= _value; //\u652f\u51fa\u8d26\u6237_from\u51cf\u53bbtoken\u6570\u91cf_value allowed[_from][msg.sender] -= _value;//\u6d88\u606f\u53d1\u9001\u8005\u53ef\u4ee5\u4ece\u8d26\u6237_from\u4e2d\u8f6c\u51fa\u7684\u6570\u91cf\u51cf\u5c11_value Transfer(_from, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender];//\u5141\u8bb8_spender\u4ece_owner\u4e2d\u8f6c\u51fa\u7684token\u6570 } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { /* Public variables of the token */ string public name;                   //\u540d\u79f0: eg Simon Bucks uint8 public decimals;               //\u6700\u591a\u7684\u5c0f\u6570\u4f4d\u6570\uff0cHow many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;               //token\u7b80\u79f0: eg SBX string public version = 'H0.1';    //\u7248\u672c function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; // \u521d\u59cbtoken\u6570\u91cf\u7ed9\u4e88\u6d88\u606f\u53d1\u9001\u8005 totalSupply = _initialAmount;         // \u8bbe\u7f6e\u521d\u59cb\u603b\u91cf name = _tokenName;                   // token\u540d\u79f0 decimals = _decimalUnits;           // \u5c0f\u6570\u4f4d\u6570 symbol = _tokenSymbol;             // token\u7b80\u79f0 } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "39959.sol", "label": 0, "sol content": "pragma solidity ^0.4.0; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0 contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if(address(OAR)==0) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1); return true; } if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } } // </ORACLIZE_API> contract Dice is usingOraclize { uint constant pwin = 9000; //probability of winning (10000 = 100%) uint constant edge = 190; //edge percentage (10000 = 100%) uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint constant minBet = 200 finney; uint constant maxInvestors = 10; //maximum number of investors uint constant houseEdge = 190; //edge percentage (10000 = 100%) uint constant divestFee = 50; //divest fee percentage (10000 = 100%) uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%) uint safeGas = 2300; uint constant ORACLIZE_GAS_LIMIT = 175000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 3 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBet; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) public investorIDs; mapping(uint => Investor) public investors; uint public numInvestors = 0; uint public invested = 0; address public owner; address public houseAddress; bool public isStopped; WithdrawalProposal public proposedWithdrawal; mapping (bytes32 => Bet) public bets; bytes32[] public betsKeys; uint public investorsProfit = 0; uint public investorsLosses = 0; bool profitDistributed; event LOG_NewBet(address playerAddress, uint amount); event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon); event LOG_BetLost(address playerAddress, uint numberRolled); event LOG_EmergencyWithdrawalProposed(); event LOG_EmergencyWithdrawalFailed(address withdrawalAddress); event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event LOG_FailedSend(address receiver, uint amount); event LOG_ZeroSend(); event LOG_InvestorEntrance(address investor, uint amount); event LOG_InvestorCapitalUpdate(address investor, int amount); event LOG_InvestorExit(address investor, uint amount); event LOG_ContractStopped(); event LOG_ContractResumed(); event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress); event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress); event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit); event LOG_EmergencyAutoStop(); event LOG_EmergencyWithdrawalVote(address investor, bool vote); event LOG_ValueIsTooBig(); event LOG_SuccessfulSend(address addr, uint amount); function Dice() { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _; } modifier onlyIfStopped { if (!isStopped) throw; _; } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _; } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _; } modifier onlyOwner { if (owner != msg.sender) throw; _; } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _; } modifier onlyMoreThanZero { if (msg.value == 0) throw; _; } modifier onlyIfBetExist(bytes32 myid) { if(bets[myid].playerAddress == address(0x0)) throw; _; } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) { _; } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } _; } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _; } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _; } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _; } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _; } } modifier onlyIfValidGas(uint newGasLimit) { if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw; if (newGasLimit < 25000) throw; _; } modifier onlyIfNotProcessed(bytes32 myid) { if (bets[myid].numberRolled > 0) throw; _; } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _; } modifier investorsInvariant { _; if (numInvestors > maxInvestors) throw; } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { if ((invested < investorsProfit) || (invested + investorsProfit < invested) || (invested + investorsProfit < investorsLosses)) { return 0; } else { return invested + investorsProfit - investorsLosses; } } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLossesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { uint invested = investors[investorIDs[currentInvestor]].amountInvested; uint profit = getProfitShare(currentInvestor); uint losses = getLossesShare(currentInvestor); if ((invested + profit < profit) || (invested + profit < invested) || (invested + profit < losses)) return 0; else return invested + profit - losses; } function searchSmallestInvestor() constant returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function changeOraclizeProofType(byte _proofType) onlyOwner { if (_proofType == 0x00) throw; oraclize_setProof( _proofType |  proofStorage_IPFS ); } function changeOraclizeConfig(bytes32 _config) onlyOwner { oraclize_setConfig(_config); } // PRIVATE HELPERS FUNCTION function safeSend(address addr, uint value) private { if (value == 0) { LOG_ZeroSend(); return; } if (this.balance < value) { LOG_ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { LOG_FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value); } } LOG_SuccessfulSend(addr,value); } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; LOG_InvestorEntrance(msg.sender, msg.value); } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint lossesOfInvestor = getLossesShare(currentInvestor); //Check for overflow and underflow if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) && (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  { investors[i].amountInvested += profitOfInvestor - lossesOfInvestor; LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor)); } else { isStopped = true; LOG_EmergencyAutoStop(); } if (copyInvested + investors[i].amountInvested >= copyInvested) copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLosses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() payable { bet(); } function bet() payable onlyIfNotStopped { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); if (oraclizeFee >= msg.value) throw; uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { LOG_NewBet(msg.sender, betValue); bytes32 myid = oraclize_query( \"nested\", \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BJA0SE2e6Z358/qbF5jVzI7vYmPdafKfYPwDWywjBxEoxnnJGnBl15CMqt1Wktc8i7Vmvf21dFxM9ECGWXfk+mY8CX7bOf3L7ewbvKNFfpQzV0R+VFaxk/cepdSZVI/v6wq5ahxIrRMgws/IHtHDLIOF3mKCa/4=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\", ORACLIZE_GAS_LIMIT + safeGas ); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback(bytes32 myid, string result, bytes proof) onlyOraclize onlyIfBetExist(myid) onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(bets[myid], numberRolled); isLosingBet(bets[myid], numberRolled); delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin; LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); //Check for overflow and underflow if ((investorsLosses + winAmount < investorsLosses) || (investorsLosses + winAmount < thisBet.amountBet)) { throw; } investorsLosses += winAmount - thisBet.amountBet; } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { LOG_BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); //Check for overflow and underflow if ((investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)) { throw; } uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000; uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() payable onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() payable onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment investorsInvariant { profitDistribution(); if (numInvestors == maxInvestors) { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); } numInvestors++; addInvestorAtID(numInvestors); } function divest() onlyInvestors { divest(msg.sender); } function divest(address currentInvestor) private investorsInvariant { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); if ((invested >= investors[currentID].amountInvested)) { invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; delete investors[currentID]; delete investorIDs[currentInvestor]; //Reorder investors if (currentID != numInvestors) { // Get last investor Investor lastInvestor = investors[numInvestors]; //Set last investor ID to investorID of divesting account investorIDs[lastInvestor.investorAddress] = currentID; //Copy investor at the new position in the mapping investors[currentID] = lastInvestor; //Delete old position in the mappping delete investors[numInvestors]; } numInvestors--; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); LOG_InvestorExit(currentInvestor, amountToReturn); } else { isStopped = true; LOG_EmergencyAutoStop(); } } function forceDivestOfAllInvestors() onlyOwner { uint copyNumInvestors = numInvestors; for (uint i = 1; i <= copyNumInvestors; i++) { divest(investors[1].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner { isStopped = true; LOG_ContractStopped(); } function resumeContract() onlyOwner { isStopped = false; LOG_ContractResumed(); } function changeHouseAddress(address newHouse) onlyOwner { if (newHouse == address(0x0)) throw; //changed based on audit feedback houseAddress = newHouse; LOG_HouseAddressChanged(houseAddress, newHouse); } function changeOwnerAddress(address newOwner) onlyOwner { if (newOwner == address(0x0)) throw; owner = newOwner; LOG_OwnerAddressChanged(owner, newOwner); } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) { safeGas = newGasLimit; LOG_GasLimitChanged(safeGas, newGasLimit); } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; LOG_EmergencyWithdrawalVote(msg.sender, vote); } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); LOG_EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed { uint numOfVotesInFavour; uint amountToWithdraw = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) { LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw); } } else { throw; } } } "}
{"sol name": "21397.sol", "label": 0, "sol content": "// // compiler: solcjs //  version: 0.4.19+commit.c4cbbb05.Emscripten.clang // pragma solidity ^0.4.19; contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) { revert(); } _; } function changeOwner( address newowner ) public onlyOwner { owner = newowner; } } // see https://www.ethereum.org/token interface tokenRecipient { function receiveApproval( address from, uint256 value, bytes data ) public; } // ERC223 interface ContractReceiver { function tokenFallback( address from, uint value, bytes data ) public; } // ERC223-compliant token with ERC20 back-compatibility // // Implements: // - https://theethereum.wiki/w/index.php/ERC20_Token_Standard // - https://www.ethereum.org/token (uncontrolled, non-standard) // - https://github.com/Dexaran/ERC23-tokens/blob/Recommended/ERC223_Token.sol contract HashBux is owned { string  public name;        // ERC20 string  public symbol;      // ERC20 uint8   public decimals;    // ERC20 uint256 public totalSupply; // ERC20 mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; // ERC20 event Approval( address indexed owner, address indexed spender, uint value ); // ERC223, ERC20 plus last parameter event Transfer( address indexed from, address indexed to, uint256 value, bytes   indexed data ); // Ethereum Token event Burn( address indexed from, uint256 value ); function HashBux() public { balances_[msg.sender] = uint256(80000000); totalSupply = uint256(80000000); name = \"HashBux\"; decimals = uint8(0); symbol = \"HASH\"; } // HashBux-specific function mine( uint256 newTokens ) public onlyOwner { if (newTokens + totalSupply > 4e9) revert(); totalSupply += newTokens; balances_[owner] += newTokens; bytes memory empty; Transfer( address(this), owner, newTokens, empty ); } function() public payable { revert(); } // does not accept money // ERC20 function balanceOf( address owner ) public constant returns (uint) { return balances_[owner]; } // ERC20 function approve( address spender, uint256 value ) public returns (bool success) { allowances_[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } // ERC20 function allowance( address owner, address spender ) public constant returns (uint256 remaining) { return allowances_[owner][spender]; } // ERC20 function transfer(address to, uint256 value) public { bytes memory empty; // null _transfer( msg.sender, to, value, empty ); } // ERC20 function transferFrom( address from, address to, uint256 value ) public returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; } // Ethereum Token function approveAndCall( address spender, uint256 value, bytes context ) public returns (bool success) { if ( approve(spender, value) ) { tokenRecipient recip = tokenRecipient( spender ); recip.receiveApproval( msg.sender, value, context ); return true; } return false; } // Ethereum Token function burn( uint256 value ) public returns (bool success) { require( balances_[msg.sender] >= value ); balances_[msg.sender] -= value; totalSupply -= value; Burn( msg.sender, value ); return true; } // Ethereum Token function burnFrom( address from, uint256 value ) public returns (bool success) { require( balances_[from] >= value ); require( value <= allowances_[from][msg.sender] ); balances_[from] -= value; allowances_[from][msg.sender] -= value; totalSupply -= value; Burn( from, value ); return true; } function _transfer( address from, address to, uint value, bytes data ) internal { require( to != 0x0 ); require( balances_[from] >= value ); require( balances_[to] + value > balances_[to] ); // catch overflow balances_[from] -= value; balances_[to] += value; Transfer( from, to, value, data ); } // ERC223 Transfer and invoke specified callback function transfer( address to, uint value, bytes data, string custom_fallback ) public returns (bool success) { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require( rx.call.value(0) (bytes4(keccak256(custom_fallback)), msg.sender, value, data) ); } return true; } // ERC223 Transfer to a contract or externally-owned account function transfer( address to, uint value, bytes data ) public returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); } _transfer( msg.sender, to, value, data ); return true; } // ERC223 Transfer to contract and invoke tokenFallback() method function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; } // ERC223 fetch contract size (must be nonzero to be a contract) function isContract( address _addr ) private constant returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } } "}
{"sol name": "33925.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract RepublicofthePhilippinesToken is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; // function RepublicofthePhilippinesToken( ) { balances[msg.sender] = 100000000000000000; totalSupply = 1000000000; name = \"RepublicofthePhilippinesToken\"; decimals = 8; symbol = \"RPT\"; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "1470.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract OxyCoin is StandardToken { // CHANGE THIS. Update the contract name. /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   // Token Name uint8 public decimals;                // How many decimals to show. To be standard complicant keep it 18 string public symbol;                 // An identifier: eg SBX, XPR etc.. string public version = 'H1.0'; uint256 public unitsOneEthCanBuy;     // How many units of your coin can be bought by 1 ETH? uint256 public totalEthInWei;         // WEI is the smallest unit of ETH (the equivalent of cent in USD or satoshi in BTC). We'll store the total ETH raised via our ICO here. address public fundsWallet;           // Where should the raised ETH go? // This is a constructor function // which means the following function name has to match the contract name declared above function OxyCoin() { balances[msg.sender] = 20000000000000000000000000000;               // Give the creator all initial tokens. This is set to 1000 for example. If you want your initial tokens to be X and your decimal is 5, set this value to X * 100000. (CHANGE THIS) totalSupply = 20000000000000000000000000000;                        // Update total supply (1000 for example) (CHANGE THIS) name = \"OxyCoin\";                                   // Set the name for display purposes (CHANGE THIS) decimals = 18;                                               // Amount of decimals for display purposes (CHANGE THIS) symbol = \"OXY\";                                             // Set the symbol for display purposes (CHANGE THIS) unitsOneEthCanBuy = 20000000;                                      // Set the price of your token for the ICO (CHANGE THIS) fundsWallet = msg.sender;                                    // The owner of the contract gets ETH } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; Transfer(fundsWallet, msg.sender, amount); // Broadcast a message to the blockchain //Transfer ether to fundsWallet fundsWallet.transfer(msg.value); } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33873.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Base { address newOwner; address owner = msg.sender; address creator = msg.sender; function isOwner() internal constant returns(bool) { return owner == msg.sender; } function changeOwner(address addr) public { if(isOwner()) { newOwner = addr; } } function confirmOwner() public { if(msg.sender==newOwner) { owner=newOwner; } } function canDrive() internal constant returns(bool) { return (owner == msg.sender)||(creator==msg.sender); } function WthdrawAllToCreator() public payable { if(msg.sender==creator) { creator.transfer(this.balance); } } function WthdrawToCreator(uint val) public payable { if(msg.sender==creator) { creator.transfer(val); } } function WthdrawTo(address addr,uint val) public payable { if(msg.sender==creator) { addr.transfer(val); } } function WithdrawToken(address token, uint256 amount) public { if(msg.sender==creator) { token.call(bytes4(sha3(\"transfer(address,uint256)\")),creator,amount); } } } contract DepositBank is Base { uint public SponsorsQty; uint public CharterCapital; uint public ClientQty; uint public PrcntRate = 1; uint public MinPayment; bool paymentsAllowed; struct Lender { uint LastLendTime; uint Amount; uint Reserved; } mapping (address => uint) public Sponsors; mapping (address => Lender) public Lenders; event StartOfPayments(address indexed calledFrom, uint time); event EndOfPayments(address indexed calledFrom, uint time); function() payable { ToSponsor(); } ///Constructor function init() Public { owner = msg.sender; PrcntRate = 5; MinPayment = 1 ether; } // investors================================================================ function Deposit() payable { FixProfit();//fix time inside Lenders[msg.sender].Amount += msg.value; } function CheckProfit(address addr) constant returns(uint) { return ((Lenders[addr].Amount/100)*PrcntRate)*((now-Lenders[addr].LastLendTime)/1 days); } function FixProfit() { if(Lenders[msg.sender].Amount>0) { Lenders[msg.sender].Reserved += CheckProfit(msg.sender); } Lenders[msg.sender].LastLendTime=now; } function WitdrawLenderProfit() payable { if(paymentsAllowed) { FixProfit(); uint profit = Lenders[msg.sender].Reserved; Lenders[msg.sender].Reserved = 0; msg.sender.transfer(profit); } } //========================================================================== // sponsors ================================================================ function ToSponsor() payable { if(msg.value>= MinPayment) { if(Sponsors[msg.sender]==0)SponsorsQty++; Sponsors[msg.sender]+=msg.value; CharterCapital+=msg.value; } } //========================================================================== function AuthorizePayments(bool val) { if(isOwner()) { paymentsAllowed = val; } } function StartPaymens() { if(isOwner()) { AuthorizePayments(true); StartOfPayments(msg.sender, now); } } function StopPaymens() { if(isOwner()) { AuthorizePayments(false); EndOfPayments(msg.sender, now); } } function WithdrawToSponsor(address _addr, uint _wei) payable { if(Sponsors[_addr]>0) { if(isOwner()) { if(_addr.send(_wei)) { if(CharterCapital>=_wei)CharterCapital-=_wei; else CharterCapital=0; } } } } modifier Public{if(!finalized)_;} bool finalized; function Fin(){if(isOwner()){finalized = true;}} } "}
{"sol name": "32969.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract DNERO is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; function DNERO( ) { balances[msg.sender] = 1000000000000000000000000000; totalSupply = 1000000000000000000000000000; name = \"dNero\"; decimals = 18; symbol = \"DNR\"; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "24802.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // File: contracts/InkMediator.sol interface InkMediator { function mediationExpiry() external returns (uint32); function requestMediator(uint256 _transactionId, uint256 _transactionAmount, address _transactionOwner) external returns (bool); function confirmTransactionFee(uint256 _transactionAmount) external returns (uint256); function confirmTransactionAfterExpiryFee(uint256 _transactionAmount) external returns (uint256); function confirmTransactionAfterDisputeFee(uint256 _transactionAmount) external returns (uint256); function confirmTransactionByMediatorFee(uint256 _transactionAmount) external returns (uint256); function refundTransactionFee(uint256 _transactionAmount) external returns (uint256); function refundTransactionAfterExpiryFee(uint256 _transactionAmount) external returns (uint256); function refundTransactionAfterDisputeFee(uint256 _transactionAmount) external returns (uint256); function refundTransactionByMediatorFee(uint256 _transactionAmount) external returns (uint256); function settleTransactionByMediatorFee(uint256 _buyerAmount, uint256 _sellerAmount) external returns (uint256, uint256); } // File: contracts/InkOwner.sol interface InkOwner { function authorizeTransaction(uint256 _id, address _buyer) external returns (bool); } // File: contracts/InkProtocolInterface.sol interface InkProtocolInterface { // Event emitted when a transaction is initiated. event TransactionInitiated( uint256 indexed id, address owner, address indexed buyer, address indexed seller, address policy, address mediator, uint256 amount, // A hash string representing the metadata for the transaction. This is // somewhat arbitrary for the transaction. Only the transaction owner // will really know the original contents of the metadata and may choose // to share it at their discretion. bytes32 metadata ); // Event emitted when a transaction has been accepted by the seller. event TransactionAccepted( uint256 indexed id ); // Event emitted when a transaction has been disputed by the buyer. event TransactionDisputed( uint256 indexed id ); // Event emitted when a transaction is escalated to the mediator by the // seller. event TransactionEscalated( uint256 indexed id ); // Event emitted when a transaction is revoked by the seller. event TransactionRevoked( uint256 indexed id ); // Event emitted when a transaction is revoked by the seller. event TransactionRefundedByMediator( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is settled by the mediator. event TransactionSettledByMediator( uint256 indexed id, uint256 buyerAmount, uint256 sellerAmount, uint256 buyerMediatorFee, uint256 sellerMediatorFee ); // Event emitted when a transaction is confirmed by the mediator. event TransactionConfirmedByMediator( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is confirmed by the buyer. event TransactionConfirmed( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is refunded by the seller. event TransactionRefunded( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is confirmed by the seller after the // transaction expiry. event TransactionConfirmedAfterExpiry( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is confirmed by the buyer after it was // disputed. event TransactionConfirmedAfterDispute( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is refunded by the seller after it was // disputed. event TransactionRefundedAfterDispute( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is refunded by the buyer after the // escalation expiry. event TransactionRefundedAfterExpiry( uint256 indexed id, uint256 mediatorFee ); // Event emitted when a transaction is confirmed by the buyer after the // mediation expiry. event TransactionConfirmedAfterEscalation( uint256 indexed id ); // Event emitted when a transaction is refunded by the seller after the // mediation expiry. event TransactionRefundedAfterEscalation( uint256 indexed id ); // Event emitted when a transaction is settled by either the buyer or the // seller after the mediation expiry. event TransactionSettled( uint256 indexed id, uint256 buyerAmount, uint256 sellerAmount ); // Event emitted when a transaction's feedback is updated by the buyer. event FeedbackUpdated( uint256 indexed transactionId, uint8 rating, bytes32 comment ); // Event emitted an account is (unidirectionally) linked to another account. // For two accounts to be acknowledged as linked, the linkage must be // bidirectional. event AccountLinked( address indexed from, address indexed to ); /* Protocol */ function link(address _to) external; function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator) external returns (uint256); function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator, address _owner) external returns (uint256); function revokeTransaction(uint256 _id) external; function acceptTransaction(uint256 _id) external; function confirmTransaction(uint256 _id) external; function confirmTransactionAfterExpiry(uint256 _id) external; function refundTransaction(uint256 _id) external; function refundTransactionAfterExpiry(uint256 _id) external; function disputeTransaction(uint256 _id) external; function escalateDisputeToMediator(uint256 _id) external; function settleTransaction(uint256 _id) external; function refundTransactionByMediator(uint256 _id) external; function confirmTransactionByMediator(uint256 _id) external; function settleTransactionByMediator(uint256 _id, uint256 _buyerAmount, uint256 _sellerAmount) external; function provideTransactionFeedback(uint256 _id, uint8 _rating, bytes32 _comment) external; /* ERC20 */ function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function increaseApproval(address spender, uint addedValue) public returns (bool); function decreaseApproval(address spender, uint subtractedValue) public returns (bool); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/InkProtocolCore.sol /// @title Ink Protocol: Decentralized reputation and payments for peer-to-peer marketplaces. contract InkProtocolCore is InkProtocolInterface, StandardToken { string public constant name = \"Ink Protocol\"; string public constant symbol = \"XNK\"; uint8 public constant decimals = 18; uint256 private constant gasLimitForExpiryCall = 1000000; uint256 private constant gasLimitForMediatorCall = 4000000; enum Expiry { Transaction, // 0 Fulfillment, // 1 Escalation,  // 2 Mediation    // 3 } enum TransactionState { // This is an internal state to represent an uninitialized transaction. Null,                     // 0 Initiated,                // 1 Accepted,                 // 2 Disputed,                 // 3 Escalated,                // 4 Revoked,                  // 5 RefundedByMediator,       // 6 SettledByMediator,        // 7 ConfirmedByMediator,      // 8 Confirmed,                // 9 Refunded,                 // 10 ConfirmedAfterExpiry,     // 11 ConfirmedAfterDispute,    // 12 RefundedAfterDispute,     // 13 RefundedAfterExpiry,      // 14 ConfirmedAfterEscalation, // 15 RefundedAfterEscalation,  // 16 Settled                   // 17 } // The running ID counter for all Ink Transactions. uint256 private globalTransactionId = 0; // Mapping of all transactions by ID (globalTransactionId). mapping(uint256 => Transaction) internal transactions; // The struct definition for an Ink Transaction. struct Transaction { // The address of the buyer on the transaction. address buyer; // The address of the seller on the transaction. address seller; // The address of the policy contract for the transaction. address policy; // The address of the mediator contract for the transaction. address mediator; // The state of the transaction. TransactionState state; // The (block) time that the transaction transitioned to its current state. // This value is only set for the states that need it to be set (states // with an expiry involved). uint256 stateTime; // The XNK amount of the transaction. uint256 amount; } /* Constructor */ function InkProtocolCore() internal { // Start with a total supply of 500,000,000 Ink Tokens (XNK). totalSupply_ = 500000000000000000000000000; } /* ERC20 override functions */ function transfer(address _to, uint256 _value) public returns (bool) { // Don't allow token transfers to the Ink contract. require(_to != address(this)); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { // Don't allow token transfers to the Ink contract. require(_to != address(this)); return super.transferFrom(_from, _to, _value); } /* Account linking functions Functions used by users and agents to declare a unidirectionally account linking. */ // Called by a user who wishes to link with another _account. function link(address _to) external { require(_to != address(0)); require(_to != msg.sender); AccountLinked({ from: msg.sender, to: _to }); } /* Transaction functions */ function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator) external returns (uint256) { return _createTransaction(_seller, _amount, _metadata, _policy, _mediator, address(0)); } function createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator, address _owner) external returns (uint256) { return _createTransaction(_seller, _amount, _metadata, _policy, _mediator, _owner); } function revokeTransaction(uint256 _id) external { _revokeTransaction(_id, _findTransactionForBuyer(_id)); } function acceptTransaction(uint256 _id) external { _acceptTransaction(_id, _findTransactionForSeller(_id)); } function confirmTransaction(uint256 _id) external { _confirmTransaction(_id, _findTransactionForBuyer(_id)); } function confirmTransactionAfterExpiry(uint256 _id) external { _confirmTransactionAfterExpiry(_id, _findTransactionForSeller(_id)); } function refundTransaction(uint256 _id) external { _refundTransaction(_id, _findTransactionForSeller(_id)); } function refundTransactionAfterExpiry(uint256 _id) external { _refundTransactionAfterExpiry(_id, _findTransactionForBuyer(_id)); } function disputeTransaction(uint256 _id) external { _disputeTransaction(_id, _findTransactionForBuyer(_id)); } function escalateDisputeToMediator(uint256 _id) external { _escalateDisputeToMediator(_id, _findTransactionForSeller(_id)); } function settleTransaction(uint256 _id) external { _settleTransaction(_id, _findTransactionForParty(_id)); } function refundTransactionByMediator(uint256 _id) external { _refundTransactionByMediator(_id, _findTransactionForMediator(_id)); } function confirmTransactionByMediator(uint256 _id) external { _confirmTransactionByMediator(_id, _findTransactionForMediator(_id)); } function settleTransactionByMediator(uint256 _id, uint256 _buyerAmount, uint256 _sellerAmount) external { _settleTransactionByMediator(_id, _findTransactionForMediator(_id), _buyerAmount, _sellerAmount); } function provideTransactionFeedback(uint256 _id, uint8 _rating, bytes32 _comment) external { _provideTransactionFeedback(_id, _findTransactionForBuyer(_id), _rating, _comment); } /* Private functions */ function _createTransaction(address _seller, uint256 _amount, bytes32 _metadata, address _policy, address _mediator, address _owner) private returns (uint256) { require(_seller != address(0) && _seller != msg.sender); require(_owner != msg.sender && _owner != _seller); require(_amount > 0); // Per specifications, if a mediator is involved then a policy is required. // Otherwise, policy must be a zero address. if (_mediator == address(0)) { require(_policy == address(0)); } else { require(_policy != address(0)); } // Increment the transaction. uint256 id = globalTransactionId++; // Create the transaction. Transaction storage transaction = transactions[id]; transaction.buyer = msg.sender; transaction.seller = _seller; transaction.state = TransactionState.Initiated; transaction.amount = _amount; transaction.policy = _policy; _resolveMediator(id, transaction, _mediator, _owner); _resolveOwner(id, _owner); // Emit the event. TransactionInitiated({ id: id, owner: _owner, buyer: msg.sender, seller: _seller, policy: _policy, mediator: _mediator, amount: _amount, metadata: _metadata }); // Place the buyer's tokens in escrow (ie. this contract). _transferFrom(msg.sender, this, _amount); // Return the newly created transaction's id. return id; } function _revokeTransaction(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Initiated); TransactionRevoked({ id: _id }); _transferFromEscrow(_transaction.buyer, _transaction.amount); _cleanupTransaction(_id, _transaction, false); } function _acceptTransaction(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Initiated); if (_transaction.mediator != address(0)) { _updateTransactionState(_transaction, TransactionState.Accepted); } TransactionAccepted({ id: _id }); if (_transaction.mediator == address(0)) { // If there is no mediator involved, the transaction is immediately confirmed. _completeTransaction(_id, _transaction, TransactionState.Confirmed, _transaction.seller); } } function _confirmTransaction(uint256 _id, Transaction storage _transaction) private { TransactionState finalState; if (_transaction.state == TransactionState.Accepted) { finalState = TransactionState.Confirmed; } else if (_transaction.state == TransactionState.Disputed) { finalState = TransactionState.ConfirmedAfterDispute; } else if (_transaction.state == TransactionState.Escalated) { require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Mediation))); finalState = TransactionState.ConfirmedAfterEscalation; } else { revert(); } _completeTransaction(_id, _transaction, finalState, _transaction.seller); } function _confirmTransactionAfterExpiry(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Accepted); require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Transaction))); _completeTransaction(_id, _transaction, TransactionState.ConfirmedAfterExpiry, _transaction.seller); } function _refundTransaction(uint256 _id, Transaction storage _transaction) private { TransactionState finalState; if (_transaction.state == TransactionState.Accepted) { finalState = TransactionState.Refunded; } else if (_transaction.state == TransactionState.Disputed) { finalState = TransactionState.RefundedAfterDispute; } else if (_transaction.state == TransactionState.Escalated) { require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Mediation))); finalState = TransactionState.RefundedAfterEscalation; } else { revert(); } _completeTransaction(_id, _transaction, finalState, _transaction.buyer); } function _refundTransactionAfterExpiry(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Disputed); require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Escalation))); _completeTransaction(_id, _transaction, TransactionState.RefundedAfterExpiry, _transaction.buyer); } function _disputeTransaction(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Accepted); require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Fulfillment))); _updateTransactionState(_transaction, TransactionState.Disputed); TransactionDisputed({ id: _id }); } function _escalateDisputeToMediator(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Disputed); _updateTransactionState(_transaction, TransactionState.Escalated); TransactionEscalated({ id: _id }); } function _settleTransaction(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Escalated); require(_afterExpiry(_transaction, _fetchExpiry(_transaction, Expiry.Mediation))); // Divide the escrow amount in half and give it to the buyer. There's // a possibility that one account will get slightly more than the other. // We have decided to give the lesser amount to the buyer (arbitrarily). uint256 buyerAmount = _transaction.amount.div(2); // The remaining amount is given to the seller. uint256 sellerAmount = _transaction.amount.sub(buyerAmount); TransactionSettled({ id: _id, buyerAmount: buyerAmount, sellerAmount: sellerAmount }); _transferFromEscrow(_transaction.buyer, buyerAmount); _transferFromEscrow(_transaction.seller, sellerAmount); _cleanupTransaction(_id, _transaction, true); } function _refundTransactionByMediator(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Escalated); _completeTransaction(_id, _transaction, TransactionState.RefundedByMediator, _transaction.buyer); } function _confirmTransactionByMediator(uint256 _id, Transaction storage _transaction) private { require(_transaction.state == TransactionState.Escalated); _completeTransaction(_id, _transaction, TransactionState.ConfirmedByMediator, _transaction.seller); } function _settleTransactionByMediator(uint256 _id, Transaction storage _transaction, uint256 _buyerAmount, uint256 _sellerAmount) private { require(_transaction.state == TransactionState.Escalated); require(_buyerAmount.add(_sellerAmount) == _transaction.amount); uint256 buyerMediatorFee; uint256 sellerMediatorFee; (buyerMediatorFee, sellerMediatorFee) = InkMediator(_transaction.mediator).settleTransactionByMediatorFee(_buyerAmount, _sellerAmount); // Require that the sum of the fees be no more than the transaction's amount. require(buyerMediatorFee <= _buyerAmount && sellerMediatorFee <= _sellerAmount); TransactionSettledByMediator({ id: _id, buyerAmount: _buyerAmount, sellerAmount: _sellerAmount, buyerMediatorFee: buyerMediatorFee, sellerMediatorFee: sellerMediatorFee }); _transferFromEscrow(_transaction.buyer, _buyerAmount.sub(buyerMediatorFee)); _transferFromEscrow(_transaction.seller, _sellerAmount.sub(sellerMediatorFee)); _transferFromEscrow(_transaction.mediator, buyerMediatorFee.add(sellerMediatorFee)); _cleanupTransaction(_id, _transaction, true); } function _provideTransactionFeedback(uint256 _id, Transaction storage _transaction, uint8 _rating, bytes32 _comment) private { // The transaction must be completed (Null state with a buyer) to allow // feedback. require(_transaction.state == TransactionState.Null); // As per functional specifications, ratings must be an integer between // 1 and 5, inclusive. require(_rating >= 1 && _rating <= 5); FeedbackUpdated({ transactionId: _id, rating: _rating, comment: _comment }); } function _completeTransaction(uint256 _id, Transaction storage _transaction, TransactionState _finalState, address _transferTo) private { uint256 mediatorFee = _fetchMediatorFee(_transaction, _finalState); if (_finalState == TransactionState.Confirmed) { TransactionConfirmed({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.ConfirmedAfterDispute) { TransactionConfirmedAfterDispute({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.ConfirmedAfterEscalation) { TransactionConfirmedAfterEscalation({ id: _id }); } else if (_finalState == TransactionState.ConfirmedAfterExpiry) { TransactionConfirmedAfterExpiry({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.Refunded) { TransactionRefunded({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.RefundedAfterDispute) { TransactionRefundedAfterDispute({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.RefundedAfterEscalation) { TransactionRefundedAfterEscalation({ id: _id }); } else if (_finalState == TransactionState.RefundedAfterExpiry) { TransactionRefundedAfterExpiry({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.RefundedByMediator) { TransactionRefundedByMediator({ id: _id, mediatorFee: mediatorFee }); } else if (_finalState == TransactionState.ConfirmedByMediator) { TransactionConfirmedByMediator({ id: _id, mediatorFee: mediatorFee }); } _transferFromEscrow(_transferTo, _transaction.amount.sub(mediatorFee)); _transferFromEscrow(_transaction.mediator, mediatorFee); _cleanupTransaction(_id, _transaction, true); } function _fetchExpiry(Transaction storage _transaction, Expiry _expiryType) private returns (uint32) { uint32 expiry; bool success; if (_expiryType == Expiry.Transaction) { success = _transaction.policy.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"transactionExpiry()\"))); } else if (_expiryType == Expiry.Fulfillment) { success = _transaction.policy.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"fulfillmentExpiry()\"))); } else if (_expiryType == Expiry.Escalation) { success = _transaction.policy.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"escalationExpiry()\"))); } else if (_expiryType == Expiry.Mediation) { success = _transaction.mediator.call.gas(gasLimitForExpiryCall)(bytes4(keccak256(\"mediationExpiry()\"))); } if (success) { assembly { if eq(returndatasize(), 0x20) { let _freeMemPointer := mload(0x40) returndatacopy(_freeMemPointer, 0, 0x20) expiry := mload(_freeMemPointer) } } } return expiry; } function _fetchMediatorFee(Transaction storage _transaction, TransactionState _finalState) private returns (uint256) { if (_transaction.mediator == address(0)) { return 0; } uint256 mediatorFee; bool success; if (_finalState == TransactionState.Confirmed) { success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"confirmTransactionFee(uint256)\")), _transaction.amount); } else if (_finalState == TransactionState.ConfirmedAfterExpiry) { success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"confirmTransactionAfterExpiryFee(uint256)\")), _transaction.amount); } else if (_finalState == TransactionState.ConfirmedAfterDispute) { success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"confirmTransactionAfterDisputeFee(uint256)\")), _transaction.amount); } else if (_finalState == TransactionState.ConfirmedByMediator) { mediatorFee = InkMediator(_transaction.mediator).confirmTransactionByMediatorFee(_transaction.amount); } else if (_finalState == TransactionState.Refunded) { success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"refundTransactionFee(uint256)\")), _transaction.amount); } else if (_finalState == TransactionState.RefundedAfterExpiry) { success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"refundTransactionAfterExpiryFee(uint256)\")), _transaction.amount); } else if (_finalState == TransactionState.RefundedAfterDispute) { success = _transaction.mediator.call.gas(gasLimitForMediatorCall)(bytes4(keccak256(\"refundTransactionAfterDisputeFee(uint256)\")), _transaction.amount); } else if (_finalState == TransactionState.RefundedByMediator) { mediatorFee = InkMediator(_transaction.mediator).refundTransactionByMediatorFee(_transaction.amount); } if (success) { assembly { if eq(returndatasize(), 0x20) { let _freeMemPointer := mload(0x40) returndatacopy(_freeMemPointer, 0, 0x20) mediatorFee := mload(_freeMemPointer) } } // The mediator's fee cannot be more than transaction's amount. if (mediatorFee > _transaction.amount) { mediatorFee = 0; } } else { require(mediatorFee <= _transaction.amount); } return mediatorFee; } function _resolveOwner(uint256 _transactionId, address _owner) private { if (_owner != address(0)) { // If an owner is specified, it must authorize the transaction. require(InkOwner(_owner).authorizeTransaction( _transactionId, msg.sender )); } } function _resolveMediator(uint256 _transactionId, Transaction storage _transaction, address _mediator, address _owner) private { if (_mediator != address(0)) { // The mediator must accept the transaction otherwise we abort. require(InkMediator(_mediator).requestMediator(_transactionId, _transaction.amount, _owner)); // Assign the mediator to the transaction. _transaction.mediator = _mediator; } } function _afterExpiry(Transaction storage _transaction, uint32 _expiry) private view returns (bool) { return now.sub(_transaction.stateTime) >= _expiry; } function _findTransactionForBuyer(uint256 _id) private view returns (Transaction storage transaction) { transaction = _findTransaction(_id); require(msg.sender == transaction.buyer); } function _findTransactionForSeller(uint256 _id) private view returns (Transaction storage transaction) { transaction = _findTransaction(_id); require(msg.sender == transaction.seller); } function _findTransactionForParty(uint256 _id) private view returns (Transaction storage transaction) { transaction = _findTransaction(_id); require(msg.sender == transaction.buyer || msg.sender == transaction.seller); } function _findTransactionForMediator(uint256 _id) private view returns (Transaction storage transaction) { transaction = _findTransaction(_id); require(msg.sender == transaction.mediator); } function _findTransaction(uint256 _id) private view returns (Transaction storage transaction) { transaction = transactions[_id]; require(_id < globalTransactionId); } function _transferFrom(address _from, address _to, uint256 _value) private returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(_from, _to, _value); return true; } function _transferFromEscrow(address _to, uint256 _value) private returns (bool) { if (_value > 0) { return _transferFrom(this, _to, _value); } return true; } function _updateTransactionState(Transaction storage _transaction, TransactionState _state) private { _transaction.state = _state; _transaction.stateTime = now; } function _cleanupTransaction(uint256 _id, Transaction storage _transaction, bool _completed) private { // Remove data that is no longer needed on the contract. if (_completed) { delete _transaction.state; delete _transaction.seller; delete _transaction.policy; delete _transaction.mediator; delete _transaction.stateTime; delete _transaction.amount; } else { delete transactions[_id]; } } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } // File: zeppelin-solidity/contracts/token/ERC20/TokenVesting.sol /** * @title TokenVesting * @dev A token holder contract that can release its token balance gradually like a * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the * owner. */ contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); // beneficiary of tokens after they are released address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; mapping (address => uint256) public released; mapping (address => bool) public revoked; /** * @dev Creates a vesting contract that vests its balance of any ERC20 token to the * _beneficiary, gradually in a linear fashion until _start + _duration. By then all * of the balance will have vested. * @param _beneficiary address of the beneficiary to whom vested tokens are transferred * @param _cliff duration in seconds of the cliff in which tokens will begin to vest * @param _duration duration in seconds of the period in which the tokens will vest * @param _revocable whether the vesting is revocable or not */ function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public { require(_beneficiary != address(0)); require(_cliff <= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; } /** * @notice Transfers vested tokens to beneficiary. * @param token ERC20 token which is being vested */ function release(ERC20Basic token) public { uint256 unreleased = releasableAmount(token); require(unreleased > 0); released[token] = released[token].add(unreleased); token.safeTransfer(beneficiary, unreleased); Released(unreleased); } /** * @notice Allows the owner to revoke the vesting. Tokens already vested * remain in the contract, the rest are returned to the owner. * @param token ERC20 token which is being vested */ function revoke(ERC20Basic token) public onlyOwner { require(revocable); require(!revoked[token]); uint256 balance = token.balanceOf(this); uint256 unreleased = releasableAmount(token); uint256 refund = balance.sub(unreleased); revoked[token] = true; token.safeTransfer(owner, refund); Revoked(); } /** * @dev Calculates the amount that has already vested but hasn't been released yet. * @param token ERC20 token which is being vested */ function releasableAmount(ERC20Basic token) public view returns (uint256) { return vestedAmount(token).sub(released[token]); } /** * @dev Calculates the amount that has already vested. * @param token ERC20 token which is being vested */ function vestedAmount(ERC20Basic token) public view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); if (now < cliff) { return 0; } else if (now >= start.add(duration) || revoked[token]) { return totalBalance; } else { return totalBalance.mul(now.sub(start)).div(duration); } } } // File: contracts/InkProtocol.sol /// @title Ink Protocol: Decentralized reputation and payments for peer-to-peer marketplaces. contract InkProtocol is InkProtocolCore { // Allocation addresses. address public constant __address0__ = 0xA13febeEde2B2924Ce8b27c1512874D3576fEC16; address public constant __address1__ = 0xc5bA7157b5B69B0fAe9332F30719Eecd79649486; address public constant __address2__ = 0x29a4b44364A8Bcb6e4d9dd60c222cCaca286ebf2; address public constant __address3__ = 0xc1DC1e5C3970E22201C5DAB0841abB2DD6499D3F; address public constant __address4__ = 0x0746d0b67BED258d94D06b15859df8dbd990eC3D; /* Constructor for Mainnet. */ function InkProtocol() public { // Unsold tokens due to token sale hard cap. balances[__address0__] = 19625973697895500000000000; Transfer(address(0), __address0__, balanceOf(__address0__)); // Allocate 32% to contract for distribution. // Vesting starts Feb 28, 2018 @ 00:00:00 GMT TokenVesting vesting1 = new TokenVesting(__address1__, 1519776000, 0, 3 years, false); balances[vesting1] = 160000000000000000000000000; Transfer(address(0), vesting1, balanceOf(vesting1)); // Allocate 32% to contract for Listia Inc. // Vesting starts Feb 28, 2018 @ 00:00:00 GMT TokenVesting vesting2 = new TokenVesting(__address2__, 1519776000, 0, 3 years, false); balances[vesting2] = 160000000000000000000000000; Transfer(address(0), vesting2, balanceOf(vesting2)); // Allocate 6% to wallet for Listia Marketplace credit conversion. balances[__address3__] = 30000000000000000000000000; Transfer(address(0), __address3__, balanceOf(__address3__)); // Allocate to wallet for token sale distribution. balances[__address4__] = 130374026302104500000000000; Transfer(address(0), __address4__, balanceOf(__address4__)); } } "}
{"sol name": "35513.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; /* * Contract that is working with ERC223 tokens */ /* New ERC23 contract interface */ contract ERC223 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data){ TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); /* tkn variable is analogue of msg variable of Ether transaction *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender) *  tkn.value the number of tokens that were sent   (analogue of msg.value) *  tkn.data is data of token transaction   (analogue of msg.data) *  tkn.sig is 4 bytes signature of function *  if data of token transaction is a function execution */ } } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x > MAX_UINT256 - y) throw; return x + y; } function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x < y) throw; return x - y; } function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) { if (y == 0) return 0; if (x > MAX_UINT256 / y) throw; return x * y; } } contract TokenStorage{ function name() constant returns (string _name) {} function symbol() constant returns (string _symbol) {} function decimals() constant returns (uint8 _decimals) {} function totalSupply() constant returns (uint48 _totalSupply)  {} function transfer(address _to, uint48 _value, bytes _data, string _custom_fallback) returns (bool success) {} function transfer(address _to, uint48 _value, bytes _data) returns (bool success) {} function transfer(address _to, uint48 _value) returns (bool success) {} function isContract(address _addr) private returns (bool is_contract) {} function transferToAddress(address _to, uint48 _value, bytes _data) private returns (bool success)  {} function transferToContract(address _to, uint48 _value, bytes _data) private returns (bool success)  {} function balanceOf(address _owner) constant returns (uint48 balance) {} } contract GameCoin is ERC223, SafeMath { TokenStorage _s; mapping(address => uint) balances; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; // Function to access name of token . function name() constant returns (string _name) { return name; } // Function to access symbol of token . function symbol() constant returns (string _symbol) { return symbol; } // Function to access decimals of token . function decimals() constant returns (uint8 _decimals) { return decimals; } // Function to access total supply of tokens . function totalSupply() constant returns (uint256 _totalSupply) { return totalSupply; } function GameCoin() { _s = TokenStorage(0x9ff62629aec4436d03a84665acfb2a3195ca784b); name = \"GameCoin\"; symbol = \"GMC\"; decimals = 2; totalSupply = 25907002099; } // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint _value, bytes _data, string _custom_fallback) returns (bool success) { if(isContract(_to)) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.call.value(0)(bytes4(sha3(_custom_fallback)), msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint _value, bytes _data) returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . function transfer(address _to, uint _value) returns (bool success) { //standard function transfer similar to ERC20 transfer with no _data //added due to backwards compatibility reasons bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } //assemble the given address bytecode. If bytecode exists then the _addr is a contract. function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } //function that is called when transaction target is an address function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } //function that is called when transaction target is a contract function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } function balanceOf(address _owner) constant returns (uint balance) { if(balances[_owner] == 0){ return uint(_s.balanceOf(_owner)); } else { return uint(balances[_owner]); } } } "}
{"sol name": "44533.sol", "label": 0, "sol content": "pragma solidity 0.4.18; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <stefan.george@consensys.net> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <stefan.george@consensys.net> contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; /* * Public functions */ /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis. function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit) public MultiSigWallet(_owners, _required) { dailyLimit = _dailyLimit; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool confirmed = isConfirmed(transactionId); if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!confirmed) spentToday -= tx.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "31694.sol", "label": 0, "sol content": "/** *   Based on ConsenSys HumanStandardToken: *   Licensed under the MIT: https://github.com/ConsenSys/Tokens/blob/master/LICENSE */ pragma solidity 0.4.19; contract Token { /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public view returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) public returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]); uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) view public returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view public returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "34140.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 100000000000000;               // Give the creator all initial tokens (100000000000000 for example) totalSupply = 100000000000000;                        // Update total supply (100000000000000 for example) name = \"Crypt0\";                                   // Set decimals = 8;                            // Amount of decimals for display purposes symbol = \"CRYPT0\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35757.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; /* ICO Syndicate Contract ======================== Buys ICO Tokens for a given ICO known contract address Author: Bogdan */ // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) public returns (bool success); function balanceOf(address _owner) public constant returns (uint256 balance); } contract ICOSyndicate { // Store the amount of ETH deposited by each account. mapping (address => uint256) public balances; // Track whether the contract has bought the tokens yet. bool public bought_tokens; // Record ETH value of tokens currently held by contract. uint256 public contract_eth_value; // Emergency kill switch in case a critical bug is found. bool public kill_switch; // Maximum amount of user ETH contract will accept.  Reduces risk of hard cap related failure. uint256 public eth_cap = 30000 ether; // The developer address. address public developer = 0x91d97da49d3cD71B475F46d719241BD8bb6Af18f; // The crowdsale address.  Settable by the developer. address public sale; // The token address.  Settable by the developer. ERC20 public token; // Allows the developer to set the crowdsale and token addresses. function set_addresses(address _sale, address _token) public { // Only allow the developer to set the sale and token addresses. require(msg.sender == developer); // Only allow setting the addresses once. require(sale == 0x0); // Set the crowdsale and token addresses. sale = _sale; token = ERC20(_token); } // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. function activate_kill_switch() public { // Only activate the kill switch if the sender is the developer or the password is correct. require(msg.sender == developer); // Irreversibly activate the kill switch. kill_switch = true; } // Withdraws all ETH deposited or tokens purchased by the given user and rewards the caller. function withdraw(address user) public { // Only allow withdrawals after the contract has had a chance to buy in. require(bought_tokens); // Short circuit to save gas if the user doesn't have a balance. if (balances[user] == 0) return; // If the contract failed to buy into the sale, withdraw the user's ETH. if (!bought_tokens) { // Store the user's balance prior to withdrawal in a temporary variable. uint256 eth_to_withdraw = balances[user]; // Update the user's balance prior to sending ETH to prevent recursive call. balances[user] = 0; // Return the user's funds.  Throws on failure to prevent loss of funds. user.transfer(eth_to_withdraw); } // Withdraw the user's tokens if the contract has purchased them. else { // Retrieve current token balance of contract. uint256 contract_token_balance = token.balanceOf(address(this)); // Disallow token withdrawals if there are no tokens to withdraw. require(contract_token_balance != 0); // Store the user's token balance in a temporary variable. uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; // Update the value of tokens currently held by the contract. contract_eth_value -= balances[user]; // Update the user's balance prior to sending to prevent recursive call. balances[user] = 0; // Send the funds.  Throws on failure to prevent loss of funds. require(token.transfer(user, tokens_to_withdraw)); } } // Buys tokens in the crowdsale and rewards the caller, callable by anyone. function buy() public { // Short circuit to save gas if the contract has already bought tokens. if (bought_tokens) return; // Short circuit to save gas if kill switch is active. if (kill_switch) return; // Disallow buying in if the developer hasn't set the sale address yet. require(sale != 0x0); // Record that the contract has bought the tokens. bought_tokens = true; // Record the amount of ETH sent as the contract's current value. contract_eth_value = this.balance; // Transfer all the funds to the crowdsale address to buy tokens. // Throws if the crowdsale hasn't started yet or has already completed, preventing loss of funds. require(sale.call.value(contract_eth_value)()); } // Default function.  Called when a user sends ETH to the contract. function () public payable { // Disallow deposits if kill switch is active. require(!kill_switch); // Only allow deposits if the contract hasn't already purchased the tokens. require(!bought_tokens); // Only allow deposits that won't exceed the contract's ETH cap. require(this.balance < eth_cap); // Update records of deposited ETH to include the received amount. balances[msg.sender] += msg.value; } } "}
{"sol name": "36496.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract CentraSale { using SafeMath for uint; address public contract_address = 0x96a65609a7b84e8842732deb08f56c3e21ac6f8a; address public owner; uint public cap; uint public constant cap_max = 170000*10**18; uint public constant min_value = 10**18*1/10; uint public operation; mapping(uint => address) public operation_address; mapping(uint => uint) public operation_amount; uint256 public constant token_price = 1481481481481481; uint256 public tokens_total; uint public constant contract_start = 1505844000; uint public constant contract_finish = 1507269600; uint public constant card_titanium_minamount = 500*10**18; uint public constant card_titanium_first = 200000; mapping(address => uint) cards_titanium_check; address[] public cards_titanium; uint public constant card_black_minamount = 100*10**18; uint public constant card_black_first = 500000; mapping(address => uint) public cards_black_check; address[] public cards_black; uint public constant card_metal_minamount = 40*10**18; uint public constant card_metal_first = 750000; mapping(address => uint) cards_metal_check; address[] public cards_metal; uint public constant card_gold_minamount = 30*10**18; uint public constant card_gold_first = 1000000; mapping(address => uint) cards_gold_check; address[] public cards_gold; uint public constant card_blue_minamount = 5/10*10**18; uint public constant card_blue_first = 100000000; mapping(address => uint) cards_blue_check; address[] public cards_blue; uint public constant card_start_minamount = 1/10*10**18; uint public constant card_start_first = 100000000; mapping(address => uint) cards_start_check; address[] public cards_start; // Functions with this modifier can only be executed by the owner modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } // Constructor function CentraSale() { owner = msg.sender; operation = 0; cap = 0; } //default function for crowdfunding function() payable { if(!(msg.value >= min_value)) throw; if(now < contract_start) throw; if(now > contract_finish) throw; //if(cap + msg.value > cap_max) throw; tokens_total = msg.value*10**18/token_price; if(!(tokens_total > 0)) throw; if(!contract_transfer(tokens_total)) throw; cap = cap.add(msg.value); operations(); get_card(); owner.send(this.balance); } //Contract execute function contract_transfer(uint _amount) private returns (bool) { if(!contract_address.call(bytes4(sha3(\"transfer(address,uint256)\")),msg.sender,_amount)) { return false; } return true; } //Update operations function operations() private returns (bool) { operation_address[operation] = msg.sender; operation_amount[operation] = msg.value; operation = operation.add(1); return true; } //Withdraw money from contract balance to owner function withdraw() onlyOwner returns (bool result) { owner.send(this.balance); return true; } //get total titanium cards function cards_titanium_total() constant returns (uint) { return cards_titanium.length; } //get total black cards function cards_black_total() constant returns (uint) { return cards_black.length; } //get total metal cards function cards_metal_total() constant returns (uint) { return cards_metal.length; } //get total gold cards function cards_gold_total() constant returns (uint) { return cards_gold.length; } //get total blue cards function cards_blue_total() constant returns (uint) { return cards_blue.length; } //get total start cards function cards_start_total() constant returns (uint) { return cards_start.length; } /* * User get card(titanium, black, gold metal, gold and other), if amount eth sufficient for this. */ function get_card() private returns (bool) { if((msg.value >= card_titanium_minamount) &&(cards_titanium.length < card_titanium_first) &&(cards_titanium_check[msg.sender] != 1) ) { cards_titanium.push(msg.sender); cards_titanium_check[msg.sender] = 1; } if((msg.value >= card_black_minamount) &&(msg.value < card_titanium_minamount) &&(cards_black.length < card_black_first) &&(cards_black_check[msg.sender] != 1) ) { cards_black.push(msg.sender); cards_black_check[msg.sender] = 1; } if((msg.value >= card_metal_minamount) &&(msg.value < card_black_minamount) &&(cards_metal.length < card_metal_first) &&(cards_metal_check[msg.sender] != 1) ) { cards_metal.push(msg.sender); cards_metal_check[msg.sender] = 1; } if((msg.value >= card_gold_minamount) &&(msg.value < card_metal_minamount) &&(cards_gold.length < card_gold_first) &&(cards_gold_check[msg.sender] != 1) ) { cards_gold.push(msg.sender); cards_gold_check[msg.sender] = 1; } if((msg.value >= card_blue_minamount) &&(msg.value < card_gold_minamount) &&(cards_blue.length < card_blue_first) &&(cards_blue_check[msg.sender] != 1) ) { cards_blue.push(msg.sender); cards_blue_check[msg.sender] = 1; } if((msg.value >= card_start_minamount) &&(msg.value < card_blue_minamount) &&(cards_start.length < card_start_first) &&(cards_start_check[msg.sender] != 1) ) { cards_start.push(msg.sender); cards_start_check[msg.sender] = 1; } return true; } } /** * Math operations with safety checks */ library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } } } "}
{"sol name": "37109.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will recieve the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract TGEToken is MintableToken { string public name; uint8 public decimals = 18; string public symbol; string public version = \"H0.1\"; function TGEToken( string _tokenName, string _tokenSymbol ) { name = _tokenName; symbol = _tokenSymbol; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. assert(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } function burn(uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; totalSupply -= _value; Transfer(msg.sender, 0x0, _value); return true; } else { return false; } } } "}
{"sol name": "34041.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "36175.sol", "label": 0, "sol content": "/** * Edgeless Casino Proxy Contract. Serves as a proxy for game functionality. * Allows the players to deposit and withdraw funds. * Allows authorized addresses to make game transactions. * author: Julia Altenried **/ pragma solidity ^ 0.4 .17; contract token { function transferFrom(address sender, address receiver, uint amount) public returns(bool success) {} function transfer(address receiver, uint amount) public returns(bool success) {} function balanceOf(address holder) public constant returns(uint) {} } contract owned { address public owner; modifier onlyOwner { require(msg.sender == owner); _; } function owned() public { owner = msg.sender; } function changeOwner(address newOwner) onlyOwner public { owner = newOwner; } } contract safeMath { //internals function safeSub(uint a, uint b) constant internal returns(uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) constant internal returns(uint) { uint c = a + b; assert(c >= a && c >= b); return c; } function safeMul(uint a, uint b) constant internal returns(uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } } contract casinoBank is owned, safeMath { /** the total balance of all players with 4 virtual decimals **/ uint public playerBalance; /** the balance per player in edgeless tokens with 4 virtual decimals */ mapping(address => uint) public balanceOf; /** in case the user wants/needs to call the withdraw function from his own wallet, he first needs to request a withdrawal */ mapping(address => uint) public withdrawAfter; /** the price per kgas in tokens (4 decimals) */ uint public gasPrice = 20; /** the edgeless token contract */ token edg; /** owner should be able to close the contract is nobody has been using it for at least 30 days */ uint public closeAt; /** informs listeners how many tokens were deposited for a player */ event Deposit(address _player, uint _numTokens, bool _chargeGas); /** informs listeners how many tokens were withdrawn from the player to the receiver address */ event Withdrawal(address _player, address _receiver, uint _numTokens); function casinoBank(address tokenContract) public { edg = token(tokenContract); } /** * accepts deposits for an arbitrary address. * retrieves tokens from the message sender and adds them to the balance of the specified address. * edgeless tokens do not have any decimals, but are represented on this contract with 4 decimals. * @param receiver  address of the receiver *        numTokens number of tokens to deposit (0 decimals) *\t\t\t\t chargeGas indicates if the gas cost is subtracted from the user's edgeless token balance **/ function deposit(address receiver, uint numTokens, bool chargeGas) public isAlive { require(numTokens > 0); uint value = safeMul(numTokens, 10000); if (chargeGas) value = safeSub(value, msg.gas / 1000 * gasPrice); assert(edg.transferFrom(msg.sender, address(this), numTokens)); balanceOf[receiver] = safeAdd(balanceOf[receiver], value); playerBalance = safeAdd(playerBalance, value); Deposit(receiver, numTokens, chargeGas); } /** * If the user wants/needs to withdraw his funds himself, he needs to request the withdrawal first. * This method sets the earliest possible withdrawal date to 7 minutes from now. * Reason: The user should not be able to withdraw his funds, while the the last game methods have not yet been mined. **/ function requestWithdrawal() public { withdrawAfter[msg.sender] = now + 7 minutes; } /** * In case the user requested a withdrawal and changes his mind. * Necessary to be able to continue playing. **/ function cancelWithdrawalRequest() public { withdrawAfter[msg.sender] = 0; } /** * withdraws an amount from the user balance if 7 minutes passed since the request. * @param amount the amount of tokens to withdraw **/ function withdraw(uint amount) public keepAlive { require(withdrawAfter[msg.sender] > 0 && now > withdrawAfter[msg.sender]); withdrawAfter[msg.sender] = 0; uint value = safeMul(amount, 10000); balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], value); playerBalance = safeSub(playerBalance, value); assert(edg.transfer(msg.sender, amount)); Withdrawal(msg.sender, msg.sender, amount); } /** * lets the owner withdraw from the bankroll * @param numTokens the number of tokens to withdraw (0 decimals) **/ function withdrawBankroll(uint numTokens) public onlyOwner { require(numTokens <= bankroll()); assert(edg.transfer(owner, numTokens)); } /** * returns the current bankroll in tokens with 0 decimals **/ function bankroll() constant public returns(uint) { return safeSub(edg.balanceOf(address(this)), playerBalance / 10000); } /** * lets the owner close the contract if there are no player funds on it or if nobody has been using it for at least 30 days */ function close() onlyOwner public { if (playerBalance == 0) selfdestruct(owner); if (closeAt == 0) closeAt = now + 30 days; else if (closeAt < now) selfdestruct(owner); } /** * in case close has been called accidentally. **/ function open() onlyOwner public { closeAt = 0; } /** * make sure the contract is not in process of being closed. **/ modifier isAlive { require(closeAt == 0); _; } /** * delays the time of closing. **/ modifier keepAlive { if (closeAt > 0) closeAt = now + 30 days; _; } } contract casinoProxy is casinoBank { /** indicates if an address is authorized to call game functions  */ mapping(address => bool) public authorized; /** list of casino game contract addresses */ address[] public casinoGames; /** a number to count withdrawal signatures to ensure each signature is different even if withdrawing the same amount to the same address */ mapping(address => uint) public count; modifier onlyAuthorized { require(authorized[msg.sender]); _; } modifier onlyCasinoGames { bool isCasino; for (uint i = 0; i < casinoGames.length; i++) { if (msg.sender == casinoGames[i]) { isCasino = true; break; } } require(isCasino); _; } /** * creates a new casino wallet. * @param authorizedAddress the address which may send transactions to the Edgeless Casino *        blackjackAddress  the address of the Edgeless blackjack contract *\t\t\t\t tokenContract     the address of the Edgeless token contract **/ function casinoProxy(address authorizedAddress, address blackjackAddress, address tokenContract) casinoBank(tokenContract) public { authorized[authorizedAddress] = true; casinoGames.push(blackjackAddress); } /** * shifts tokens from the contract balance to the receiver. * only callable from an edgeless casino contract. * @param receiver the address of the receiver *        numTokens the amount of tokens to shift with 4 decimals **/ function shift(address receiver, uint numTokens) public onlyCasinoGames { balanceOf[receiver] = safeAdd(balanceOf[receiver], numTokens); playerBalance = safeAdd(playerBalance, numTokens); } /** * transfers an amount from the contract balance to the owner's wallet. * @param receiver the receiver address *\t\t\t\t amount   the amount of tokens to withdraw (0 decimals) *\t\t\t\t v,r,s \t\tthe signature of the player **/ function withdrawFor(address receiver, uint amount, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized keepAlive { uint gasCost = msg.gas / 1000 * gasPrice; var player = ecrecover(keccak256(receiver, amount, count[receiver]), v, r, s); count[receiver]++; uint value = safeAdd(safeMul(amount, 10000), gasCost); balanceOf[player] = safeSub(balanceOf[player], value); playerBalance = safeSub(playerBalance, value); assert(edg.transfer(receiver, amount)); Withdrawal(player, receiver, amount); } /** * update a casino game address in case of a new contract or a new casino game * @param game       the index of the game *        newAddress the new address of the game **/ function setGameAddress(uint8 game, address newAddress) public onlyOwner { if (game < casinoGames.length) casinoGames[game] = newAddress; else casinoGames.push(newAddress); } /** * authorize a address to call game functions. * @param addr the address to be authorized **/ function authorize(address addr) public onlyOwner { authorized[addr] = true; } /** * deauthorize a address to call game functions. * @param addr the address to be deauthorized **/ function deauthorize(address addr) public onlyOwner { authorized[addr] = false; } /** * updates the price per 1000 gas in EDG. * @param price the new gas price (4 decimals, max 0.0256 EDG) **/ function setGasPrice(uint8 price) public onlyOwner { gasPrice = price; } /** * Forwards a move to the corresponding game contract if the data has been signed by the client. * The casino contract ensures it is no duplicate move. * @param game  specifies which game contract to call *        value the value to send to the contract in tokens with 4 decimals *        data  the function call *        v,r,s the player's signature of the data **/ function move(uint8 game, uint value, bytes data, uint8 v, bytes32 r, bytes32 s) public onlyAuthorized isAlive { require(game < casinoGames.length); require(safeMul(bankroll(), 10000) > value * 8); //make sure, the casino can always pay out the player var player = ecrecover(keccak256(data), v, r, s); require(withdrawAfter[player] == 0 || now < withdrawAfter[player]); value = safeAdd(value, msg.gas / 1000 * gasPrice); balanceOf[player] = safeSub(balanceOf[player], value); playerBalance = safeSub(playerBalance, value); assert(casinoGames[game].call(data)); } } "}
{"sol name": "40028.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract EtherTreasuryInterface { function withdraw(address _to, uint _value) returns(bool); function withdrawWithReference(address _to, uint _value, string _reference) returns(bool); } contract SafeMin { modifier onlyHuman { if (_isHuman()) { _; } } modifier immutable(address _address) { if (_address == 0) { _; } } function _safeFalse() internal returns(bool) { _safeSend(msg.sender, msg.value); return false; } function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; } } function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); } function _isContract() constant internal returns(bool) { return msg.sender != tx.origin; } function _isHuman() constant internal returns(bool) { return !_isContract(); } } contract MultiAsset { function isCreated(bytes32 _symbol) constant returns(bool); function baseUnit(bytes32 _symbol) constant returns(uint8); function name(bytes32 _symbol) constant returns(string); function description(bytes32 _symbol) constant returns(string); function isReissuable(bytes32 _symbol) constant returns(bool); function owner(bytes32 _symbol) constant returns(address); function isOwner(address _owner, bytes32 _symbol) constant returns(bool); function totalSupply(bytes32 _symbol) constant returns(uint); function balanceOf(address _holder, bytes32 _symbol) constant returns(uint); function transfer(address _to, uint _value, bytes32 _symbol) returns(bool); function transferToICAP(bytes32 _icap, uint _value) returns(bool); function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function transferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function approve(address _spender, uint _value, bytes32 _symbol) returns(bool); function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool); function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint); function transferFrom(address _from, address _to, uint _value, bytes32 _symbol) returns(bool); function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool); function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function setCosignerAddress(address _address, bytes32 _symbol) returns(bool); function setCosignerAddressForUser(address _address) returns(bool); function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool); } contract AssetMin is SafeMin { event Transfer(address indexed from, address indexed to, uint value); event Approve(address indexed from, address indexed spender, uint value); MultiAsset public multiAsset; bytes32 public symbol; string public name; function init(address _multiAsset, bytes32 _symbol) immutable(address(multiAsset)) returns(bool) { MultiAsset ma = MultiAsset(_multiAsset); if (!ma.isCreated(_symbol)) { return false; } multiAsset = ma; symbol = _symbol; return true; } function setName(string _name) returns(bool) { if (bytes(name).length != 0) { return false; } name = _name; return true; } modifier onlyMultiAsset() { if (msg.sender == address(multiAsset)) { _; } } function totalSupply() constant returns(uint) { return multiAsset.totalSupply(symbol); } function balanceOf(address _owner) constant returns(uint) { return multiAsset.balanceOf(_owner, symbol); } function allowance(address _from, address _spender) constant returns(uint) { return multiAsset.allowance(_from, _spender, symbol); } function transfer(address _to, uint _value) returns(bool) { return __transferWithReference(_to, _value, \"\"); } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { return __transferWithReference(_to, _value, _reference); } function __transferWithReference(address _to, uint _value, string _reference) private returns(bool) { return _isHuman() ? multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) : multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference); } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { return __transferToICAPWithReference(_icap, _value, \"\"); } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { return __transferToICAPWithReference(_icap, _value, _reference); } function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private returns(bool) { return _isHuman() ? multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) : multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference); } function approve(address _spender, uint _value) onlyHuman() returns(bool) { return multiAsset.proxyApprove(_spender, _value, symbol); } function setCosignerAddress(address _cosigner) onlyHuman() returns(bool) { return multiAsset.proxySetCosignerAddress(_cosigner, symbol); } function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() { Transfer(_from, _to, _value); } function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() { Approve(_from, _spender, _value); } function sendToOwner() returns(bool) { address owner = multiAsset.owner(symbol); return multiAsset.transfer(owner, balanceOf(owner), symbol); } function decimals() constant returns(uint8) { return multiAsset.baseUnit(symbol); } } contract Owned { address public contractOwner; function Owned() { contractOwner = msg.sender; } modifier onlyContractOwner() { if (contractOwner == msg.sender) { _; } } } contract GMT is AssetMin, Owned { uint public txGasPriceLimit = 21000000000; uint public refundGas = 40000; uint public transferCallGas = 21000; uint public transferWithReferenceCallGas = 21000; uint public transferToICAPCallGas = 21000; uint public transferToICAPWithReferenceCallGas = 21000; uint public approveCallGas = 21000; uint public forwardCallGas = 21000; uint public setCosignerCallGas = 21000; EtherTreasuryInterface public treasury; mapping(bytes32 => address) public allowedForwards; function updateRefundGas() onlyContractOwner() returns(uint) { uint startGas = msg.gas; // just to simulate calculations, dunno if optimizer will remove this. uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; if (tx.gasprice > txGasPriceLimit) { return 0; } // end. if (!_refund(1)) { return 0; } refundGas = startGas - msg.gas; return refundGas; } function setOperationsCallGas( uint _transfer, uint _transferToICAP, uint _transferWithReference, uint _transferToICAPWithReference, uint _approve, uint _forward, uint _setCosigner ) onlyContractOwner() returns(bool) { transferCallGas = _transfer; transferToICAPCallGas = _transferToICAP; transferWithReferenceCallGas = _transferWithReference; transferToICAPWithReferenceCallGas = _transferToICAPWithReference; approveCallGas = _approve; forwardCallGas = _forward; setCosignerCallGas = _setCosigner; return true; } function setupTreasury(address _treasury, uint _txGasPriceLimit) payable onlyContractOwner() returns(bool) { if (_txGasPriceLimit == 0) { return _safeFalse(); } treasury = EtherTreasuryInterface(_treasury); txGasPriceLimit = _txGasPriceLimit; if (msg.value > 0) { _safeSend(_treasury, msg.value); } return true; } function setForward(bytes4 _msgSig, address _forward) onlyContractOwner() returns(bool) { allowedForwards[sha3(_msgSig)] = _forward; return true; } function _stringGas(string _string) constant internal returns(uint) { return bytes(_string).length * 75; // ~75 gas per byte, empirical shown 68-72. } function _applyRefund(uint _startGas) internal returns(bool) { if (tx.gasprice > txGasPriceLimit) { return false; } uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice; return _refund(refund); } function _refund(uint _value) internal returns(bool) { return address(treasury) != 0 && treasury.withdraw(tx.origin, _value); } function _transfer(address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferCallGas; if (!super.transfer(_to, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPCallGas; if (!super.transferToICAP(_icap, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferWithReferenceCallGas + _stringGas(_reference); if (!super.transferWithReference(_to, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPWithReferenceCallGas + _stringGas(_reference); if (!super.transferToICAPWithReference(_icap, _value, _reference)) { return (false, false); } return (true, _applyRefund(startGas)); } function _approve(address _spender, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + approveCallGas; if (!super.approve(_spender, _value)) { return (false, false); } return (true, _applyRefund(startGas)); } function _setCosignerAddress(address _cosigner) internal returns(bool, bool) { uint startGas = msg.gas + setCosignerCallGas; if (!super.setCosignerAddress(_cosigner)) { return (false, false); } return (true, _applyRefund(startGas)); } function transfer(address _to, uint _value) returns(bool) { bool success; (success,) = _transfer(_to, _value); return success; } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferToICAP(_icap, _value); return success; } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferWithReference(_to, _value, _reference); return success; } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferToICAPWithReference(_icap, _value, _reference); return success; } function approve(address _spender, uint _value) returns(bool) { bool success; (success,) = _approve(_spender, _value); return success; } function setCosignerAddress(address _cosigner) returns(bool) { bool success; (success,) = _setCosignerAddress(_cosigner); return success; } function checkTransfer(address _to, uint _value) constant returns(bool, bool) { return _transfer(_to, _value); } function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferToICAP(_icap, _value); } function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferWithReference(_to, _value, _reference); } function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferToICAPWithReference(_icap, _value, _reference); } function checkApprove(address _spender, uint _value) constant returns(bool, bool) { return _approve(_spender, _value); } function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) { return _setCosignerAddress(_cosigner); } function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); } function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas + (_data.length * 50); // 50 gas per byte; if (_to == 0x0) { return (false, _safeFalse()); } if (!_to.call.value(msg.value)(_data)) { return (false, _safeFalse()); } return (true, _applyRefund(startGas)); } function () payable { _forward(allowedForwards[sha3(msg.sig)], msg.data); } } "}
{"sol name": "44156.sol", "label": 0, "sol content": "/** * Copyright 2017-2021, bZeroX, LLC. All Rights Reserved. * Licensed under the Apache License, Version 2.0. */ pragma solidity 0.5.17; pragma experimental ABIEncoderV2; import \"./AdvancedTokenStorage.sol\"; import \"./interfaces/ProtocolSettingsLike.sol\"; contract LoanTokenSettings is AdvancedTokenStorage { using SafeMath for uint256; modifier onlyAdmin() { require(msg.sender == address(this) || msg.sender == owner(), \"unauthorized\"); _; } bytes32 internal constant iToken_LowerAdminAddress = 0x7ad06df6a0af6bd602d90db766e0d5f253b45187c3717a0f9026ea8b10ff0d4b;    // keccak256(\"iToken_LowerAdminAddress\") bytes32 internal constant iToken_LowerAdminContract = 0x34b31cff1dbd8374124bd4505521fc29cab0f9554a5386ba7d784a4e611c7e31;   // keccak256(\"iToken_LowerAdminContract\") function() external { revert(\"fallback not allowed\"); } function setLowerAdminValues( address _lowerAdmin, address _lowerAdminContract) public onlyAdmin { assembly { sstore(iToken_LowerAdminAddress, _lowerAdmin) sstore(iToken_LowerAdminContract, _lowerAdminContract) } } function setDisplayParams( string memory _name, string memory _symbol) public onlyAdmin { name = _name; symbol = _symbol; } function recoverEther( address receiver, uint256 amount) public onlyAdmin { uint256 balance = address(this).balance; if (balance < amount) amount = balance; (bool success,) = receiver.call.value(amount)(\"\"); require(success, \"transfer failed\" ); } function recoverToken( address tokenAddress, address receiver, uint256 amount) public onlyAdmin { require(tokenAddress != loanTokenAddress, \"invalid token\"); IERC20 token = IERC20(tokenAddress); uint256 balance = token.balanceOf(address(this)); if (balance < amount) amount = balance; require(token.transfer( receiver, amount), \"transfer failed\" ); } function transfer( address _to, uint256 _value) public returns (bool) { require(_to != address(0), \"invalid transfer\"); balances[msg.sender] = balances[msg.sender].sub(_value, \"insufficient balance\"); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function initialize( address _loanTokenAddress, string memory _name, string memory _symbol) public onlyAdmin { loanTokenAddress = _loanTokenAddress; name = _name; symbol = _symbol; decimals = IERC20(loanTokenAddress).decimals(); initialPrice = WEI_PRECISION; // starting price of 1 } } "}
{"sol name": "31528.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract JLSCoin is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'J1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function JLSCoin( ) { balances[msg.sender] = 50000000*10**8;               // Give the creator all initial tokens (100000 for example) totalSupply = 50000000*10**8;                        // Update total supply (100000 for example) name = \"Jules Coin\";                                  // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"JLS\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "32557.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract useContractWeb { ContractWeb internal web = ContractWeb(0xA2a7F4bf61b5bf07611739941F62Dec30541840A); } contract Owned { address public owner = msg.sender; function transferOwner(address _newOwner) onlyOwner public returns (bool) { owner = _newOwner; return true; } modifier onlyOwner { require(msg.sender == owner); _; } } contract CheckPayloadSize { modifier onlyPayloadSize(uint256 _size) { require(msg.data.length >= _size + 4); _; } } contract CanTransferTokens is CheckPayloadSize, Owned { function transferCustomToken(address _token, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyOwner public returns (bool) { Token tkn = Token(_token); return tkn.transfer(_to, _value); } } contract SafeMath { function add(uint256 x, uint256 y) pure internal returns (uint256) { require(x <= x + y); return x + y; } function sub(uint256 x, uint256 y) pure internal returns (uint256) { require(x >= y); return x - y; } } contract CheckIfContract { function isContract(address _addr) view internal returns (bool) { uint256 length; if (_addr == address(0x0)) return false; assembly { length := extcodesize(_addr) } if(length > 0) { return true; } else { return false; } } } contract ContractReceiver { TKN internal fallback; struct TKN { address sender; uint256 value; bytes data; bytes4 sig; } function getFallback() view public returns (TKN) { return fallback; } function tokenFallback(address _from, uint256 _value, bytes _data) public returns (bool) { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); fallback = tkn; return true; } } contract Token1st { address public currentTradingSystem; address public currentExchangeSystem; mapping(address => uint) public balanceOf; mapping(address => mapping (address => uint)) public allowance; mapping(address => mapping (address => uint)) public tradingBalanceOf; mapping(address => mapping (address => uint)) public exchangeBalanceOf; /* @notice get balance of a specific address */ function getBalanceOf(address _address) view public returns (uint amount){ return balanceOf[_address]; } event Transfer (address _to, address _from, uint _decimalAmount); /* A contract or user attempts to get the coins */ function transferDecimalAmountFrom(address _from, address _to, uint _value) public returns (bool success) { require(balanceOf[_from] - tradingBalanceOf[_from][currentTradingSystem] - exchangeBalanceOf[_from][currentExchangeSystem] >= _value);                 // Check if the sender has enough require(balanceOf[_to] + (_value) >= balanceOf[_to]);  // Check for overflows require(_value <= allowance[_from][msg.sender]);   // Check allowance balanceOf[_from] -= _value;                          // Subtract from the sender balanceOf[_to] += _value;                            // Add the same to the recipient allowance[_from][msg.sender] -= _value; Transfer(_to, _from, _value); return true; } /* Allow another contract or user to spend some tokens in your behalf */ function approveSpenderDecimalAmount(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } } contract ContractWeb is CanTransferTokens, CheckIfContract { //contract name | contract info mapping(string => contractInfo) internal contracts; event ContractAdded(string _name, address _referredTo); event ContractEdited(string _name, address _referredTo); event ContractMadePermanent(string _name); struct contractInfo { address contractAddress; bool isPermanent; } function getContractAddress(string _name) view public returns (address) { return contracts[_name].contractAddress; } function isContractPermanent(string _name) view public returns (bool) { return contracts[_name].isPermanent; } function setContract(string _name, address _address) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(isContract(_address)); require(this != _address); require(contracts[_name].contractAddress != _address); require(contracts[_name].isPermanent == false); address oldAddress = contracts[_name].contractAddress; contracts[_name].contractAddress = _address; if(oldAddress == address(0x0)) { ContractAdded(_name, _address); } else { ContractEdited(_name, _address); } return true; } function makeContractPermanent(string _name) onlyOwner public returns (bool) { require(contracts[_name].contractAddress != address(0x0)); require(contracts[_name].isPermanent == false); contracts[_name].isPermanent = true; ContractMadePermanent(_name); return true; } function tokenSetup(address _Tokens1st, address _Balancecs, address _Token, address _Conversion, address _Distribution) onlyPayloadSize(5 * 32) onlyOwner public returns (bool) { setContract(\"Token1st\", _Tokens1st); setContract(\"Balances\", _Balancecs); setContract(\"Token\", _Token); setContract(\"Conversion\", _Conversion); setContract(\"Distribution\", _Distribution); return true; } } contract Balances is CanTransferTokens, SafeMath, useContractWeb { mapping(address => uint256) internal _balances; function get(address _account) view public returns (uint256) { return _balances[_account]; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function Balances() public { _balances[msg.sender] = 190 * 1000000 * 1000000000000000000; } modifier onlyToken { require(msg.sender == tokenContract()); _; } function transfer(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) onlyToken public returns (bool success) { _balances[_from] = sub(_balances[_from], _value); _balances[_to] = add(_balances[_to], _value); return true; } } contract Token is CanTransferTokens, SafeMath, CheckIfContract, useContractWeb { string public symbol = \"SHC\"; string public name = \"ShineCoin\"; uint8 public decimals = 18; uint256 public totalSupply = 190 * 1000000 * 1000000000000000000; mapping (address => mapping (address => uint256)) internal _allowance; // ERC20 Events event Approval(address indexed from, address indexed to, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); // ERC223 Event event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data); function balanceOf(address _account) view public returns (uint256) { return Balances(balancesContract()).get(_account); } function allowance(address _from, address _to) view public returns (uint256 remaining) { return _allowance[_from][_to]; } function balancesContract() view public returns (address) { return web.getContractAddress(\"Balances\"); } function Token() public { bytes memory empty; Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000); Transfer(this, msg.sender, 190 * 1000000 * 1000000000000000000, empty); } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) onlyPayloadSize(4 * 32) public returns (bool success) { if(isContract(_to)) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); require(receiver.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value, bytes _data) onlyPayloadSize(3 * 32) public returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function transferToAddress(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint256 _value, bytes _data) internal returns (bool success) { require(Balances(balancesContract()).get(msg.sender) >= _value); Balances(balancesContract()).transfer(msg.sender, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) public returns (bool) { bytes memory empty; require(_value > 0 && _allowance[_from][msg.sender] >= _value && Balances(balancesContract()).get(_from) >= _value); _allowance[_from][msg.sender] = sub(_allowance[_from][msg.sender], _value); if(msg.sender != _to && isContract(_to)) { Balances(balancesContract()).transfer(_from, _to, _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(_from, _value, empty); } else { Balances(balancesContract()).transfer(_from, _to, _value); } Transfer(_from, _to, _value); Transfer(_from, _to, _value, empty); return true; } function approve(address _to, uint256 _value) onlyPayloadSize(2 * 32) public returns (bool) { _allowance[msg.sender][_to] = add(_allowance[msg.sender][_to], _value); Approval(msg.sender, _to, _value); return true; } } contract Conversion is CanTransferTokens, useContractWeb { function token1stContract() view public returns (address) { return web.getContractAddress(\"Token1st\"); } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function convert() public returns (bool) { uint256 senderBalance = Token1st(token1stContract()).getBalanceOf(msg.sender); require(Token1st(token1stContract()).allowance(msg.sender, this) >= senderBalance); Token1st(token1stContract()).transferDecimalAmountFrom(msg.sender, owner, senderBalance); return Token(tokenContract()).transfer(msg.sender, senderBalance * 10000000000); } } contract Distribution is CanTransferTokens, SafeMath, useContractWeb { uint256 public liveSince; uint256 public withdrawn; function withdrawnReadable() view public returns (uint256) { return withdrawn / 1000000000000000000; } function secondsLive() view public returns (uint256) { if(liveSince != 0) { return now - liveSince; } } function allowedSince() view public returns (uint256) { return secondsLive() * 380265185769276972; } function allowedSinceReadable() view public returns (uint256) { return secondsLive() * 380265185769276972 / 1000000000000000000; } function stillAllowed() view public returns (uint256) { return allowedSince() - withdrawn; } function stillAllowedReadable() view public returns (uint256) { uint256 _1 = allowedSince() - withdrawn; return _1 / 1000000000000000000; } function tokenContract() view public returns (address) { return web.getContractAddress(\"Token\"); } function makeLive() onlyOwner public returns (bool) { require(liveSince == 0); liveSince = now; return true; } function deposit() onlyOwner public returns (bool) { require(Token(tokenContract()).allowance(owner, this) > 0); return Token(tokenContract()).transferFrom(owner, this, Token(tokenContract()).allowance(owner, this)); } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value && _value > 0 && liveSince != 0); withdrawn = add(withdrawn, _value); return Token(tokenContract()).transfer(_to, _value); } function transferReadable(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { require(stillAllowed() >= _value * 1000000000000000000 && stillAllowed() != 0 && liveSince != 0); withdrawn = add(withdrawn, _value * 1000000000000000000); return Token(tokenContract()).transfer(_to, _value * 1000000000000000000); } } "}
{"sol name": "44099.sol", "label": 0, "sol content": "pragma solidity ^0.6.0; pragma experimental ABIEncoderV2; import \"../../utils/SafeERC20.sol\"; import \"../../DS/DSMath.sol\"; import \"../../auth/AdminAuth.sol\"; import \"../DFSExchangeHelper.sol\"; import \"../../interfaces/OffchainWrapperInterface.sol\"; import \"../../interfaces/TokenInterface.sol\"; contract ZeroxWrapper is OffchainWrapperInterface, DFSExchangeHelper, AdminAuth, DSMath { string public constant ERR_SRC_AMOUNT = \"Not enough funds\"; string public constant ERR_PROTOCOL_FEE = \"Not enough eth for protcol fee\"; string public constant ERR_TOKENS_SWAPED_ZERO = \"Order success but amount 0\"; using SafeERC20 for ERC20; /// @notice Takes order from 0x and returns bool indicating if it is successful /// @param _exData Exchange data /// @param _type Action type (buy or sell) function takeOrder( ExchangeData memory _exData, ActionType _type ) override public payable returns (bool success, uint256) { // check that contract have enough balance for exchange and protocol fee require(getBalance(_exData.srcAddr) >= _exData.srcAmount, ERR_SRC_AMOUNT); require(getBalance(KYBER_ETH_ADDRESS) >= _exData.offchainData.protocolFee, ERR_PROTOCOL_FEE); /// @dev 0x always uses max approve in v1, so we approve the exact amount we want to sell /// @dev safeApprove is modified to always first set approval to 0, then to exact amount if (_type == ActionType.SELL) { ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, _exData.srcAmount); } else { uint srcAmount = wdiv(_exData.destAmount, _exData.offchainData.price) + 1; // + 1 so we round up ERC20(_exData.srcAddr).safeApprove(_exData.offchainData.allowanceTarget, srcAmount); } // we know that it will be eth if dest addr is either weth or eth address destAddr = _exData.destAddr == KYBER_ETH_ADDRESS ? EXCHANGE_WETH_ADDRESS : _exData.destAddr; uint256 tokensBefore = getBalance(destAddr); (success, ) = _exData.offchainData.exchangeAddr.call{value: _exData.offchainData.protocolFee}(_exData.offchainData.callData); uint256 tokensSwaped = 0; if (success) { // get the current balance of the swaped tokens tokensSwaped = getBalance(destAddr) - tokensBefore; require(tokensSwaped > 0, ERR_TOKENS_SWAPED_ZERO); } // returns all funds from src addr, dest addr and eth funds (protocol fee leftovers) sendLeftover(_exData.srcAddr, destAddr, msg.sender); return (success, tokensSwaped); } // solhint-disable-next-line no-empty-blocks receive() external virtual payable {} } "}
{"sol name": "36380.sol", "label": 0, "sol content": "pragma solidity 0.4.16; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "39473.sol", "label": 0, "sol content": "pragma solidity 0.4.4; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; /* * Public functions */ /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis. function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit) public MultiSigWallet(_owners, _required) { dailyLimit = _dailyLimit; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool confirmed = isConfirmed(transactionId); if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!confirmed) spentToday -= tx.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "33234.sol", "label": 0, "sol content": "pragma solidity 0.4.15; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { require (msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require (!isOwner[owner]); _; } modifier ownerExists(address owner) { require (isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require (transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require (confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require (!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require (!transactions[transactionId].executed); _; } modifier notNull(address _address) { require (_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require (ownerCount <= MAX_OWNER_COUNT); require (_required <= ownerCount); require (_required != 0); require (ownerCount != 0); _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { require ( !isOwner[_owners[i]]); require (_owners[i] != 0); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; /* * Public functions */ /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis. function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit) public MultiSigWallet(_owners, _required) { dailyLimit = _dailyLimit; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { Transaction storage txn = transactions[transactionId]; bool confirmed = isConfirmed(transactionId); if (confirmed || txn.data.length == 0 && isUnderLimit(txn.value)) { txn.executed = true; if (!confirmed) spentToday += txn.value; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; if (!confirmed) spentToday -= txn.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "38050.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "969.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: contracts/interface/DiviesInterface.sol interface DiviesInterface { function deposit() external payable; } // File: contracts/interface/F3DexternalSettingsInterface.sol interface F3DexternalSettingsInterface { function getFastGap() external returns(uint256); function getLongGap() external returns(uint256); function getFastExtra() external returns(uint256); function getLongExtra() external returns(uint256); } // File: contracts/interface/HourglassInterface.sol interface HourglassInterface { function() payable external; function buy(address _playerAddress) payable external returns(uint256); function sell(uint256 _amountOfTokens) external; function reinvest() external; function withdraw() external; function exit() external; function dividendsOf(address _playerAddress) external view returns(uint256); function balanceOf(address _playerAddress) external view returns(uint256); function transfer(address _toAddress, uint256 _amountOfTokens) external returns(bool); function stakingRequirement() external view returns(uint256); } // File: contracts/interface/JIincForwarderInterface.sol interface JIincForwarderInterface { function deposit() external payable returns(bool); function status() external view returns(address, address, bool); function startMigration(address _newCorpBank) external returns(bool); function cancelMigration() external returns(bool); function finishMigration() external returns(bool); function setup(address _firstCorpBank) external; } // File: contracts/interface/PlayerBookInterface.sol interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } // File: contracts/interface/otherFoMo3D.sol interface otherFoMo3D { function potSwap() external payable; } // File: contracts/library/SafeMath.sol /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } // File: contracts/library/F3DKeysCalcLong.sol //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== library F3DKeysCalcLong { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } // File: contracts/library/F3Ddatasets.sol //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library F3Ddatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys \u5c0f\u7f8a uint256 mask;   // player mask uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead\uff0c lead\u9886\u5bfc\u5417\uff1f uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran  \u8fd9\u4e2a\u5f00\u5173\u503c\u5f97\u7814\u7a76\u4e0b uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 p3d;    // % of buy in thats paid to p3d holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 p3d;    // % of pot thats paid to p3d holders } } // File: contracts/library/NameFilter.sol /** * @title -Name Filter- v0.1.9 * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510   \u2566\u2566 \u2566\u2554\u2550\u2557\u2554\u2566\u2557  \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u250c\u2500\u2510 *  \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502   \u2551\u2551 \u2551\u255a\u2550\u2557 \u2551   \u251c\u2500\u2518\u251c\u252c\u2518\u251c\u2524 \u2514\u2500\u2510\u251c\u2524 \u2502\u2502\u2502 \u2502 \u2514\u2500\u2510 *  \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534  \u255a\u255d\u255a\u2550\u255d\u255a\u2550\u255d \u2569   \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2514\u2500\u2518 *                                  _____                      _____ *                                 (, /     /)       /) /)    (, /      /)          /) *          \u250c\u2500\u2510                      /   _ (/_      // //       /  _   // _   __  _(/ *          \u251c\u2500\u2524                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_ *          \u2534 \u2534                /   /          .-/ _____   (__ / *                            (__ /          (_/ (, /                                      /)\u2122 *                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/ * \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510\u252c \u252c\u250c\u2500\u2510\u250c\u252c\u2510                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_ * \u251c\u2500\u2518\u251c\u252c\u2518\u2502 \u2502 \u2502\u2502\u2502 \u2502\u2502   \u2502                      (__ /              .-/  \u00a9 Jekyll Island Inc. 2018 * \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534                                        (_/ *              _       __    _      ____      ____  _   _    _____  ____  ___ *=============| |\\ |  / /\\  | |\\/| | |_ =====| |_  | | | |    | |  | |_  | |_)==============* *=============|_| \\| /_/--\\ |_|  | |_|__=====|_|   |_| |_|__  |_|  |_|__ |_| \\==============* * * \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510  \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u252c\u2510\u250c\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 * \u2551  \u2502 \u2502\u2502\u2502\u2502 \u2502 \u251c\u252c\u2518\u251c\u2500\u2524\u2502   \u2502   \u2551  \u2502 \u2502 \u2502\u2502\u251c\u2524  \u2502 Inventor \u2502 * \u255a\u2550\u255d\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2534\u2514\u2500\u2534 \u2534\u2514\u2500\u2518 \u2534   \u255a\u2550\u255d\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 */ library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } // File: contracts/library/UintCompressor.sol /** * @title -UintCompressor- v0.1.9 * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510   \u2566\u2566 \u2566\u2554\u2550\u2557\u2554\u2566\u2557  \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u250c\u2500\u2510 *  \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502   \u2551\u2551 \u2551\u255a\u2550\u2557 \u2551   \u251c\u2500\u2518\u251c\u252c\u2518\u251c\u2524 \u2514\u2500\u2510\u251c\u2524 \u2502\u2502\u2502 \u2502 \u2514\u2500\u2510 *  \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534  \u255a\u255d\u255a\u2550\u255d\u255a\u2550\u255d \u2569   \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2514\u2500\u2518 *                                  _____                      _____ *                                 (, /     /)       /) /)    (, /      /)          /) *          \u250c\u2500\u2510                      /   _ (/_      // //       /  _   // _   __  _(/ *          \u251c\u2500\u2524                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_ *          \u2534 \u2534                /   /          .-/ _____   (__ / *                            (__ /          (_/ (, /                                      /)\u2122 *                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/ * \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510\u252c \u252c\u250c\u2500\u2510\u250c\u252c\u2510                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_ * \u251c\u2500\u2518\u251c\u252c\u2518\u2502 \u2502 \u2502\u2502\u2502 \u2502\u2502   \u2502                      (__ /              .-/  \u00a9 Jekyll Island Inc. 2018 * \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534                                        (_/ *    _  _   __   __ _  ____     ___   __   _  _  ____  ____  ____  ____  ____   __   ____ *===/ )( \\ (  ) (  ( \\(_  _)===/ __) /  \\ ( \\/ )(  _ \\(  _ \\(  __)/ ___)/ ___) /  \\ (  _ \\===* *   ) \\/ (  )(  /    /  )(    ( (__ (  O )/ \\/ \\ ) __/ )   / ) _) \\___ \\\\___ \\(  O ) )   / *===\\____/ (__) \\_)__) (__)====\\___) \\__/ \\_)(_/(__)  (__\\_)(____)(____/(____/ \\__/ (__\\_)===* * * \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510  \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u252c\u2510\u250c\u2500\u2510 \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 * \u2551  \u2502 \u2502\u2502\u2502\u2502 \u2502 \u251c\u252c\u2518\u251c\u2500\u2524\u2502   \u2502   \u2551  \u2502 \u2502 \u2502\u2502\u251c\u2524  \u2502 Inventor \u2502 * \u255a\u2550\u255d\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2534\u2514\u2500\u2534 \u2534\u2514\u2500\u2518 \u2534   \u255a\u2550\u255d\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518 \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 */ library UintCompressor { using SafeMath for *; function insert(uint256 _var, uint256 _include, uint256 _start, uint256 _end) internal pure returns(uint256) { // check conditions require(_end < 77 && _start < 77, \"start/end must be less than 77\"); require(_end >= _start, \"end must be >= start\"); // format our start/end points _end = exponent(_end).mul(10); _start = exponent(_start); // check that the include data fits into its segment require(_include < (_end / _start)); // build middle if (_include > 0) _include = _include.mul(_start); return((_var.sub((_var / _start).mul(_start))).add(_include).add((_var / _end).mul(_end))); } function extract(uint256 _input, uint256 _start, uint256 _end) internal pure returns(uint256) { // check conditions require(_end < 77 && _start < 77, \"start/end must be less than 77\"); require(_end >= _start, \"end must be >= start\"); // format our start/end points _end = exponent(_end).mul(10); _start = exponent(_start); // return requested section return((((_input / _start).mul(_start)).sub((_input / _end).mul(_end))) / _start); } function exponent(uint256 _position) private pure returns(uint256) { return((10).pwr(_position)); } } // File: contracts/F3Devents.sol contract F3Devents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } // File: contracts/modularLong.sol contract modularLong is F3Devents {} // File: contracts/FoMo3Dlong.sol contract FoMo3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using F3DKeysCalcLong for uint256; otherFoMo3D private otherF3D_; //TODO: DiviesInterface constant private Divies = DiviesInterface(0x6e6d9770e44f57db3bb94d18e3e7cc5ba7855f6d); JIincForwarderInterface constant private Jekyll_Island_Inc = JIincForwarderInterface(0xca255f23ba3fd322fb634d3783db90659a7a48ba); PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x8727455a941d4f95e20a4c76ec3aef019fe73811); F3DexternalSettingsInterface constant private extSettings = F3DexternalSettingsInterface(0x35d3f1c98d9fd8087e312e953f32233ace1996b6); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== string constant public name = \"FoMoKiller long\"; string constant public symbol = \"FoMoKiller\"; uint256 private rndExtra_ = 15 seconds;     // length of the very first ICO uint256 private rndGap_ = 1 hours;         // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 24 hours;                // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => F3Ddatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => F3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => F3Ddatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA , Team\u7684\u8d39\u7528\u5206\u914d\u6570\u636e //**************** mapping (uint256 => F3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => F3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team address public ourTEAM = 0xf1E32a3EaA5D6c360AF6AA2c45a97e377Be183BD; mapping (address => bool) public myFounder_; mapping (address => uint256) public myFounder_PID; //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { // Team allocation structures // 0 = \u9884\u8a00\u5bb6 // 1 = \u5b88\u536b // 2 = \u4e18\u6bd4\u7279 // 3 = \u957f\u8001 // Team allocation percentages // (F3D, P3D) + (Pot , Referrals, Community) // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot. fees_[0] = F3Ddatasets.TeamFee(70,0); fees_[1] = F3Ddatasets.TeamFee(60,0); fees_[2] = F3Ddatasets.TeamFee(50,0); fees_[3] = F3Ddatasets.TeamFee(40,0); // how to split up the final pot based on which team was picked // (F3D, P3D) potSplit_[0] = F3Ddatasets.PotSplit(20,0); potSplit_[1] = F3Ddatasets.PotSplit(30,0); potSplit_[2] = F3Ddatasets.PotSplit(40,0); potSplit_[3] = F3Ddatasets.PotSplit(50,0); myFounder_[0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93] = true; myFounder_[0xfB31eb7B96e413BEbEe61F5E3880938b937c2Ef0] = true; myFounder_[0xEa8A4f09C45967DFCFda180fA80ad44eefAb52bE] = true; myFounder_[0xf1E32a3EaA5D6c360AF6AA2c45a97e377Be183BD] = true; } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } /** * @dev prevents contracts from interacting with fomo3d */ modifier isHuman() { address _addr = msg.sender; // require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } /** * */ modifier onlyDevs() { //TODO: require( msg.sender == 0xa78cd12e5f2daf88023f0bfe119eac8b3f3dbc93 || msg.sender == 0xfB31eb7B96e413BEbEe61F5E3880938b937c2Ef0 || msg.sender == 0xEa8A4f09C45967DFCFda180fA80ad44eefAb52bE || msg.sender == 0xf1E32a3EaA5D6c360AF6AA2c45a97e377Be183BD, \"only team just can activate\" ); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // set up our tx event data F3Ddatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit F3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(40)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, _team, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit F3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core(_rID, _pID, _eth, _affID, _team, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit F3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000) { uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // manage airdrops if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { // gib muni uint256 _prize; if (_eth >= 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 2 prize was won _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { // calculate prize and give it to winner _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); // adjust airDropPot airDropPot_ = (airDropPot_).sub(_prize); // let event know a tier 3 prize was won _eventData_.compressedData += 300000000000000000000000000000000; } // set airdrop happened bool to true _eventData_.compressedData += 10000000000000000000000000000000; // let event know how much was won _eventData_.compressedData += _prize * 1000000000000000000000000000000000; // reset air drop tracker // \u4e0d\u5728\u8fd9\u91ccreset\uff0c\u4e00\u8f6e\u6e38\u620f\u7ed3\u675f\u7684\u65f6\u5019\u518dreset // airDropTracker_ = 0; } } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); if (myFounder_PID[plyr_[_pID].addr] > 0) { plyrRnds_[_pID][_rID].keys = myFounder_PID[plyr_[_pID].addr].add(plyrRnds_[_pID][_rID].keys); round_[_rID].keys = myFounder_PID[plyr_[_pID].addr].add(round_[_rID].keys); myFounder_PID[plyr_[_pID].addr] = 0; } // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // distribute eth  \u5206\u94b1 _eth = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _team, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of fomo3d if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev checks to make sure user picked a valid team.  if not sets team * to default (sneks) */ function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(40)) / 100;    //\u8d62\u5f97\u5956\u91d1\u6c60\u91cc40%\u7684\u5956\u91d1 uint256 _com = (_pot / 10);             // _com\u83b7\u5f9710%\u7684\u6536\u76ca uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; //20%\u300130%\u300140%\u300150% uint256 _p3d = 0; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); //\u7ed3\u7b97\u6536\u76ca ourTEAM.transfer(_com); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // // community rewards // if (!address(Jekyll_Island_Inc).call.value(_com)(bytes4(keccak256(\"deposit()\")))) // { //     // This ensures Team Just cannot influence the outcome of FoMo3D with //     // bank migrations by breaking outgoing transactions. //     // Something we would never do. But that's not the point. //     // We spent 2000$ in eth re-deploying just to patch this, we hold the //     // highest belief that everything we create should be trustless. //     // Team JUST, The name you shouldn't have to trust. //     _p3d = _p3d.add(_com); //     _com = 0; // } // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; airDropTracker_ = 0; //\u4e0b\u4e00\u8f6e\uff0c\u7a7a\u6295\u6570\u4ece0\u8ba1\u6570 return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev generates a random number between 0-99 and checks to see if thats * resulted in an airdrop win * @return do we have a winner? */ function airdrop() private view returns(bool) { //\u8d2d\u4e70\u7b2c1w\u300110w\u3001100w\u30011000w\u300110000w\u53ea\u5c0f\u7f8a\u7684\u65f6\u5019\u6709\u5956\u52b1 if(airDropTracker_ == 10000 || airDropTracker_ == 100000 || airDropTracker_ == 1000000 || airDropTracker_ == 10000000 || airDropTracker_ == 100000000  || airDropTracker_ == 1000000000  ) return(true); else return(false); } /** * @dev distributes eth based on fees to com, aff, and p3d  mark by 33 */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(uint256) { // pay 3% out to community rewards uint256 _com = (_eth.mul(3) / 100); ourTEAM.transfer(_com); uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { //\u4fee\u6539\u5206\u7ea2\u6bd4\u4f8b\uff0c\u521b\u4e16\u519c\u6c11\u5206\u7ea2\u6bd4\u4f8b\u4e3a20% if(myFounder_[plyr_[_affID].addr]) { _aff = _eth / 5; } plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } return (_eth.sub(_com)).sub(_aff); } function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F3Devents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; //70%\u300160%\u300150%\u300140% // toss 1% into airdrop pot uint256 _air = (_eth / 100); airDropPot_ = airDropPot_.add(_air); uint256 _pot = _eth.sub(_gen).sub(_air); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() onlyDevs() public { // make sure that its been linked. require(address(otherF3D_) != address(0), \"must link to other FoMo3D first\"); // can only be ran once require(activated_ == false, \"fomo3d already activated\"); // activate the contract activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } function setOtherFomo(address _otherF3D) onlyDevs() public { // make sure that it HASNT yet been linked. require(address(otherF3D_) == address(0), \"silly dev, you already did that\"); // set up other fomo3d (fast or long) for pot swap otherF3D_ = otherFoMo3D(_otherF3D); } function setOtherFounder(address _otherF3D, uint256 _values) onlyDevs() public { myFounder_[_otherF3D] = true; myFounder_PID[_otherF3D] = _values.mul(1000000000000000000); } } "}
{"sol name": "35719.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 90000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 90000000000000;                        // Update total supply (100000 for example) name = \"Dollarydoos\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"DDoos\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "39618.sol", "label": 0, "sol content": "pragma solidity ^0.4.6; // -------------------------- //  R Split Contract // -------------------------- contract RSPLT_E { event StatEvent(string msg); event StatEventI(string msg, uint val); enum SettingStateValue  {debug, locked} struct partnerAccount { uint credited;  // total funds credited to this account uint balance;   // current balance = credited - amount withdrawn uint pctx10;     // percent allocation times ten address addr;   // payout addr of this acct bool evenStart; // even split up to evenDistThresh } // ----------------------------- //  data storage // ---------------------------------------- address public owner;                                // deployer executor mapping (uint => partnerAccount) partnerAccounts;    // accounts by index uint public numAccounts;                             // how many accounts exist uint public holdoverBalance;                         // amount yet to be distributed uint public totalFundsReceived;                      // amount received since begin of time uint public totalFundsDistributed;                   // amount distributed since begin of time uint public evenDistThresh;                          // distribute evenly until this amount (total) uint public withdrawGas = 35000;                     // gas for withdrawals uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to do payout SettingStateValue public settingsState = SettingStateValue.debug; // -------------------- // contract constructor // -------------------- function RSPLT_E() { owner = msg.sender; } // ----------------------------------- // lock // lock the contract. after calling this you will not be able to modify accounts: // ----------------------------------- function lock() { if (msg.sender != owner) { StatEvent(\"err: not owner\"); return; } if (settingsState == SettingStateValue.locked) { StatEvent(\"err: locked\"); return; } settingsState == SettingStateValue.locked; StatEvent(\"ok: contract locked\"); } // ----------------------------------- // reset // reset all accounts // ----------------------------------- function reset() { if (msg.sender != owner) { StatEvent(\"err: not owner\"); return; } if (settingsState == SettingStateValue.locked) { StatEvent(\"err: locked\"); return; } numAccounts = 0; holdoverBalance = 0; totalFundsReceived = 0; totalFundsDistributed = 0; StatEvent(\"ok: all accts reset\"); } // ----------------------------------- // set even distribution threshold // ----------------------------------- function setEvenDistThresh(uint256 _thresh) { if (msg.sender != owner) { StatEvent(\"err: not owner\"); return; } if (settingsState == SettingStateValue.locked) { StatEvent(\"err: locked\"); return; } evenDistThresh = (_thresh / TENHUNDWEI) * TENHUNDWEI; StatEventI(\"ok: threshold set\", evenDistThresh); } // ----------------------------------- // set even distribution threshold // ----------------------------------- function setWitdrawGas(uint256 _withdrawGas) { if (msg.sender != owner) { StatEvent(\"err: not owner\"); return; } withdrawGas = _withdrawGas; StatEventI(\"ok: withdraw gas set\", withdrawGas); } // --------------------------------------------------- // add a new account // --------------------------------------------------- function addAccount(address _addr, uint256 _pctx10, bool _evenStart) { if (msg.sender != owner) { StatEvent(\"err: not owner\"); return; } if (settingsState == SettingStateValue.locked) { StatEvent(\"err: locked\"); return; } partnerAccounts[numAccounts].addr = _addr; partnerAccounts[numAccounts].pctx10 = _pctx10; partnerAccounts[numAccounts].evenStart = _evenStart; partnerAccounts[numAccounts].credited = 0; partnerAccounts[numAccounts].balance = 0; ++numAccounts; StatEvent(\"ok: acct added\"); } // ---------------------------- // get acct info // ---------------------------- function getAccountInfo(address _addr) constant returns(uint _idx, uint _pctx10, bool _evenStart, uint _credited, uint _balance) { for (uint i = 0; i < numAccounts; i++ ) { address addr = partnerAccounts[i].addr; if (addr == _addr) { _idx = i; _pctx10 = partnerAccounts[i].pctx10; _evenStart = partnerAccounts[i].evenStart; _credited = partnerAccounts[i].credited; _balance = partnerAccounts[i].balance; StatEvent(\"ok: found acct\"); return; } } StatEvent(\"err: acct not found\"); } // ---------------------------- // get total percentages x2 // ---------------------------- function getTotalPctx10() constant returns(uint _totalPctx10) { _totalPctx10 = 0; for (uint i = 0; i < numAccounts; i++ ) { _totalPctx10 += partnerAccounts[i].pctx10; } StatEventI(\"ok: total pctx10\", _totalPctx10); } // ------------------------------------------- // default payable function. // call us with plenty of gas, or catastrophe will ensue // note: you can call this fcn with amount of zero to force distribution // ------------------------------------------- function () payable { totalFundsReceived += msg.value; holdoverBalance += msg.value; } // ---------------------------- // distribute funds to all partners // ---------------------------- function distribute() { //only payout if we have more than 1000 wei if (holdoverBalance < TENHUNDWEI) { return; } //first pay accounts that are not constrained by even distribution //each account gets their prescribed percentage of this holdover. uint i; uint pctx10; uint acctDist; uint maxAcctDist; uint numEvenSplits = 0; for (i = 0; i < numAccounts; i++ ) { if (partnerAccounts[i].evenStart) { ++numEvenSplits; } else { pctx10 = partnerAccounts[i].pctx10; acctDist = holdoverBalance * pctx10 / TENHUNDWEI; //we also double check to ensure that the amount awarded cannot exceed the //total amount due to this acct. note: this check is necessary, cuz here we //might not distribute the full holdover amount during each pass. maxAcctDist = totalFundsReceived * pctx10 / TENHUNDWEI; if (partnerAccounts[i].credited >= maxAcctDist) { acctDist = 0; } else if (partnerAccounts[i].credited + acctDist > maxAcctDist) { acctDist = maxAcctDist - partnerAccounts[i].credited; } partnerAccounts[i].credited += acctDist; partnerAccounts[i].balance += acctDist; totalFundsDistributed += acctDist; holdoverBalance -= acctDist; } } //now pay accounts that are constrained by even distribution. we split whatever is //left of the holdover evenly. uint distAmount = holdoverBalance; if (totalFundsDistributed < evenDistThresh) { for (i = 0; i < numAccounts; i++ ) { if (partnerAccounts[i].evenStart) { acctDist = distAmount / numEvenSplits; //we also double check to ensure that the amount awarded cannot exceed the //total amount due to this acct. note: this check is necessary, cuz here we //might not distribute the full holdover amount during each pass. uint fundLimit = totalFundsReceived; if (fundLimit > evenDistThresh) fundLimit = evenDistThresh; maxAcctDist = fundLimit / numEvenSplits; if (partnerAccounts[i].credited >= maxAcctDist) { acctDist = 0; } else if (partnerAccounts[i].credited + acctDist > maxAcctDist) { acctDist = maxAcctDist - partnerAccounts[i].credited; } partnerAccounts[i].credited += acctDist; partnerAccounts[i].balance += acctDist; totalFundsDistributed += acctDist; holdoverBalance -= acctDist; } } } //now, if there are any funds left (because of a remainder in the even split), then distribute them //according to percentages. note that this must be done here, even if we haven't passed the even distribution //threshold, to ensure that we don't get stuck with a remainder amount that cannot be distributed. distAmount = holdoverBalance; if (distAmount > 0) { for (i = 0; i < numAccounts; i++ ) { if (partnerAccounts[i].evenStart) { pctx10 = partnerAccounts[i].pctx10; acctDist = distAmount * pctx10 / TENHUNDWEI; //we also double check to ensure that the amount awarded cannot exceed the //total amount due to this acct. note: this check is necessary, cuz here we //might not distribute the full holdover amount during each pass. maxAcctDist = totalFundsReceived * pctx10 / TENHUNDWEI; if (partnerAccounts[i].credited >= maxAcctDist) { acctDist = 0; } else if (partnerAccounts[i].credited + acctDist > maxAcctDist) { acctDist = maxAcctDist - partnerAccounts[i].credited; } partnerAccounts[i].credited += acctDist; partnerAccounts[i].balance += acctDist; totalFundsDistributed += acctDist; holdoverBalance -= acctDist; } } } StatEvent(\"ok: distributed funds\"); } // ---------------------------- // withdraw account balance // ---------------------------- function withdraw() { for (uint i = 0; i < numAccounts; i++ ) { address addr = partnerAccounts[i].addr; if (addr == msg.sender) { uint amount = partnerAccounts[i].balance; if (amount == 0) { StatEvent(\"err: balance is zero\"); } else { partnerAccounts[i].balance = 0; if (!msg.sender.call.gas(withdrawGas).value(amount)()) throw; StatEventI(\"ok: rewards paid\", amount); } } } } // ---------------------------- // suicide // ---------------------------- function hariKari() { if (msg.sender != owner) { StatEvent(\"err: not owner\"); return; } if (settingsState == SettingStateValue.locked) { StatEvent(\"err: locked\"); return; } suicide(owner); } } "}
{"sol name": "40204.sol", "label": 0, "sol content": "contract MultiAsset { function isCreated(bytes32 _symbol) constant returns(bool); function owner(bytes32 _symbol) constant returns(address); function totalSupply(bytes32 _symbol) constant returns(uint); function balanceOf(address _holder, bytes32 _symbol) constant returns(uint); function transfer(address _to, uint _value, bytes32 _symbol) returns(bool); function proxyTransferWithReference(address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool); function proxyApprove(address _spender, uint _value, bytes32 _symbol) returns(bool); function allowance(address _from, address _spender, bytes32 _symbol) constant returns(uint); function transferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function proxyTransferFromWithReference(address _from, address _to, uint _value, bytes32 _symbol, string _reference) returns(bool); function proxyTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool); function proxySetCosignerAddress(address _address, bytes32 _symbol) returns(bool); } contract Ambi { function getNodeAddress(bytes32 _name) constant returns (address); function addNode(bytes32 _name, address _addr) external returns (bool); function hasRelation(bytes32 _from, bytes32 _role, address _to) constant returns (bool); } contract EtherTreasuryInterface { function withdraw(address _to, uint _value) returns(bool); } contract Safe { // Should always be placed as first modifier! modifier noValue { if (msg.value > 0) { // Internal Out Of Gas/Throw: revert this transaction too; // Call Stack Depth Limit reached: revert this transaction too; // Recursive Call: safe, no any changes applied yet, we are inside of modifier. _safeSend(msg.sender, msg.value); } _ } modifier onlyHuman { if (_isHuman()) { _ } } modifier noCallback { if (!isCall) { _ } } modifier immutable(address _address) { if (_address == 0) { _ } } address stackDepthLib; function setupStackDepthLib(address _stackDepthLib) immutable(address(stackDepthLib)) returns(bool) { stackDepthLib = _stackDepthLib; return true; } modifier requireStackDepth(uint16 _depth) { if (stackDepthLib == 0x0) { throw; } if (_depth > 1023) { throw; } if (!stackDepthLib.delegatecall(0x32921690, stackDepthLib, _depth)) { throw; } _ } // Must not be used inside the functions that have noValue() modifier! function _safeFalse() internal noValue() returns(bool) { return false; } function _safeSend(address _to, uint _value) internal { if (!_unsafeSend(_to, _value)) { throw; } } function _unsafeSend(address _to, uint _value) internal returns(bool) { return _to.call.value(_value)(); } function _isContract() constant internal returns(bool) { return msg.sender != tx.origin; } function _isHuman() constant internal returns(bool) { return !_isContract(); } bool private isCall = false; function _setupNoCallback() internal { isCall = true; } function _finishNoCallback() internal { isCall = false; } } contract Asset is Safe { event Transfer(address indexed from, address indexed to, uint value); event Approve(address indexed from, address indexed spender, uint value); MultiAsset public multiAsset; bytes32 public symbol; function init(address _multiAsset, bytes32 _symbol) noValue() immutable(address(multiAsset)) returns(bool) { MultiAsset ma = MultiAsset(_multiAsset); if (!ma.isCreated(_symbol)) { return false; } multiAsset = ma; symbol = _symbol; return true; } modifier onlyMultiAsset() { if (msg.sender == address(multiAsset)) { _ } } function totalSupply() constant returns(uint) { return multiAsset.totalSupply(symbol); } function balanceOf(address _owner) constant returns(uint) { return multiAsset.balanceOf(_owner, symbol); } function allowance(address _from, address _spender) constant returns(uint) { return multiAsset.allowance(_from, _spender, symbol); } function transfer(address _to, uint _value) returns(bool) { return __transferWithReference(_to, _value, \"\"); } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { return __transferWithReference(_to, _value, _reference); } function __transferWithReference(address _to, uint _value, string _reference) private noValue() returns(bool) { return _isHuman() ? multiAsset.proxyTransferWithReference(_to, _value, symbol, _reference) : multiAsset.transferFromWithReference(msg.sender, _to, _value, symbol, _reference); } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { return __transferToICAPWithReference(_icap, _value, \"\"); } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { return __transferToICAPWithReference(_icap, _value, _reference); } function __transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) private noValue() returns(bool) { return _isHuman() ? multiAsset.proxyTransferToICAPWithReference(_icap, _value, _reference) : multiAsset.transferFromToICAPWithReference(msg.sender, _icap, _value, _reference); } function transferFrom(address _from, address _to, uint _value) returns(bool) { return __transferFromWithReference(_from, _to, _value, \"\"); } function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) { return __transferFromWithReference(_from, _to, _value, _reference); } function __transferFromWithReference(address _from, address _to, uint _value, string _reference) private noValue() onlyHuman() returns(bool) { return multiAsset.proxyTransferFromWithReference(_from, _to, _value, symbol, _reference); } function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) { return __transferFromToICAPWithReference(_from, _icap, _value, \"\"); } function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) { return __transferFromToICAPWithReference(_from, _icap, _value, _reference); } function __transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) private noValue() onlyHuman() returns(bool) { return multiAsset.proxyTransferFromToICAPWithReference(_from, _icap, _value, _reference); } function approve(address _spender, uint _value) noValue() onlyHuman() returns(bool) { return multiAsset.proxyApprove(_spender, _value, symbol); } function setCosignerAddress(address _cosigner) noValue() onlyHuman() returns(bool) { return multiAsset.proxySetCosignerAddress(_cosigner, symbol); } function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() { Transfer(_from, _to, _value); } function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() { Approve(_from, _spender, _value); } function sendToOwner() noValue() returns(bool) { address owner = multiAsset.owner(symbol); uint balance = this.balance; bool success = true; if (balance > 0) { success = _unsafeSend(owner, balance); } return multiAsset.transfer(owner, balanceOf(owner), symbol) && success; } } contract AmbiEnabled { Ambi public ambiC; bool public isImmortal; bytes32 public name; modifier checkAccess(bytes32 _role) { if(address(ambiC) != 0x0 && ambiC.hasRelation(name, _role, msg.sender)){ _ } } function getAddress(bytes32 _name) constant returns (address) { return ambiC.getNodeAddress(_name); } function setAmbiAddress(address _ambi, bytes32 _name) returns (bool){ if(address(ambiC) != 0x0){ return false; } Ambi ambiContract = Ambi(_ambi); if(ambiContract.getNodeAddress(_name)!=address(this)) { if (!ambiContract.addNode(_name, address(this))){ return false; } } name = _name; ambiC = ambiContract; return true; } function immortality() checkAccess(\"owner\") returns(bool) { isImmortal = true; return true; } function remove() checkAccess(\"owner\") returns(bool) { if (isImmortal) { return false; } selfdestruct(msg.sender); return true; } } contract CryptoCarbon is Asset, AmbiEnabled { uint public txGasPriceLimit = 21000000000; uint public refundGas = 40000; uint public transferCallGas = 21000; uint public transferWithReferenceCallGas = 21000; uint public transferFromCallGas = 21000; uint public transferFromWithReferenceCallGas = 21000; uint public transferToICAPCallGas = 21000; uint public transferToICAPWithReferenceCallGas = 21000; uint public transferFromToICAPCallGas = 21000; uint public transferFromToICAPWithReferenceCallGas = 21000; uint public approveCallGas = 21000; uint public forwardCallGas = 21000; uint public setCosignerCallGas = 21000; uint public absMinFee; uint public feePercent; // set up in 1/100 of percent, 10 is 0.1% uint public absMaxFee; EtherTreasuryInterface public treasury; address public feeAddress; bool private __isAllowed; mapping(bytes32 => address) public allowedForwards; function setFeeStructure(uint _absMinFee, uint _feePercent, uint _absMaxFee) noValue() checkAccess(\"cron\") returns (bool) { if(_feePercent > 10000 || _absMaxFee < _absMinFee) { return false; } absMinFee = _absMinFee; feePercent = _feePercent; absMaxFee = _absMaxFee; return true; } function setupFee(address _feeAddress) noValue() checkAccess(\"admin\") returns(bool) { feeAddress = _feeAddress; return true; } function updateRefundGas() noValue() checkAccess(\"setup\") returns(uint) { uint startGas = msg.gas; // just to simulate calculations uint refund = (startGas - msg.gas + refundGas) * tx.gasprice; if (tx.gasprice > txGasPriceLimit) { return 0; } // end if (!_refund(5000000000000000)) { return 0; } refundGas = startGas - msg.gas; return refundGas; } function setOperationsCallGas( uint _transfer, uint _transferFrom, uint _transferToICAP, uint _transferFromToICAP, uint _transferWithReference, uint _transferFromWithReference, uint _transferToICAPWithReference, uint _transferFromToICAPWithReference, uint _approve, uint _forward, uint _setCosigner ) noValue() checkAccess(\"setup\") returns(bool) { transferCallGas = _transfer; transferFromCallGas = _transferFrom; transferToICAPCallGas = _transferToICAP; transferFromToICAPCallGas = _transferFromToICAP; transferWithReferenceCallGas = _transferWithReference; transferFromWithReferenceCallGas = _transferFromWithReference; transferToICAPWithReferenceCallGas = _transferToICAPWithReference; transferFromToICAPWithReferenceCallGas = _transferFromToICAPWithReference; approveCallGas = _approve; forwardCallGas = _forward; setCosignerCallGas = _setCosigner; return true; } function setupTreasury(address _treasury, uint _txGasPriceLimit) checkAccess(\"admin\") returns(bool) { if (_txGasPriceLimit == 0) { return _safeFalse(); } treasury = EtherTreasuryInterface(_treasury); txGasPriceLimit = _txGasPriceLimit; if (msg.value > 0) { _safeSend(_treasury, msg.value); } return true; } function setForward(bytes4 _msgSig, address _forward) noValue() checkAccess(\"admin\") returns(bool) { allowedForwards[sha3(_msgSig)] = _forward; return true; } function _stringGas(string _string) constant internal returns(uint) { return bytes(_string).length * 75; // ~75 gas per byte, empirical shown 68-72. } function _transferFee(address _feeFrom, uint _value, string _reference) internal returns(bool) { if (feeAddress == 0x0 || feeAddress == _feeFrom || _value == 0) { return true; } return multiAsset.transferFromWithReference(_feeFrom, feeAddress, _value, symbol, _reference); } function _returnFee(address _to, uint _value) internal returns(bool, bool) { if (feeAddress == 0x0 || feeAddress == _to || _value == 0) { return (false, true); } if (!multiAsset.transferFromWithReference(feeAddress, _to, _value, symbol, \"Fee return\")) { throw; } return (false, true); } function _applyRefund(uint _startGas) internal returns(bool) { uint refund = (_startGas - msg.gas + refundGas) * tx.gasprice; return _refund(refund); } function _refund(uint _value) internal returns(bool) { if (tx.gasprice > txGasPriceLimit) { return false; } return treasury.withdraw(tx.origin, _value); } function _allow() internal { __isAllowed = true; } function _disallow() internal { __isAllowed = false; } function calculateFee(uint _value) constant returns(uint) { uint fee = (_value * feePercent) / 10000; if (fee < absMinFee) { return absMinFee; } if (fee > absMaxFee) { return absMaxFee; } return fee; } function calculateFeeDynamic(uint _value, uint _additionalGas) constant returns(uint) { uint fee = calculateFee(_value); if (_additionalGas <= 7500) { return fee; } // Assuming that absMinFee covers at least 100000 gas refund, let's add another absMinFee // for every other 100000 additional gas. uint additionalFee = ((_additionalGas / 100000) + 1) * absMinFee; return fee + additionalFee; } function takeFee(address _feeFrom, uint _value, string _reference) noValue() checkAccess(\"fee\") returns(bool) { return _transferFee(_feeFrom, _value, _reference); } function _transfer(address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferCallGas; uint fee = calculateFee(_value); if (!_transferFee(msg.sender, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transfer(_to, _value); _disallow(); if (!success) { return _returnFee(msg.sender, fee); } return (true, _applyRefund(startGas)); } function _transferFrom(address _from, address _to, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferFromCallGas; _allow(); uint fee = calculateFee(_value); if (!_transferFee(_from, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferFrom(_from, _to, _value); _disallow(); if (!success) { return _returnFee(_from, fee); } return (true, _applyRefund(startGas)); } function _transferToICAP(bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPCallGas; uint fee = calculateFee(_value); if (!_transferFee(msg.sender, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferToICAP(_icap, _value); _disallow(); if (!success) { return _returnFee(msg.sender, fee); } return (true, _applyRefund(startGas)); } function _transferFromToICAP(address _from, bytes32 _icap, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + transferFromToICAPCallGas; uint fee = calculateFee(_value); if (!_transferFee(_from, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferFromToICAP(_from, _icap, _value); _disallow(); if (!success) { return _returnFee(_from, fee); } return (true, _applyRefund(startGas)); } function _transferWithReference(address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferWithReferenceCallGas; uint additionalGas = _stringGas(_reference); uint fee = calculateFeeDynamic(_value, additionalGas); if (!_transferFee(msg.sender, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferWithReference(_to, _value, _reference); _disallow(); if (!success) { return _returnFee(msg.sender, fee); } return (true, _applyRefund(startGas + additionalGas)); } function _transferFromWithReference(address _from, address _to, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferFromWithReferenceCallGas; uint additionalGas = _stringGas(_reference); uint fee = calculateFeeDynamic(_value, additionalGas); if (!_transferFee(_from, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferFromWithReference(_from, _to, _value, _reference); _disallow(); if (!success) { return _returnFee(_from, fee); } return (true, _applyRefund(startGas + additionalGas)); } function _transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferToICAPWithReferenceCallGas; uint additionalGas = _stringGas(_reference); uint fee = calculateFeeDynamic(_value, additionalGas); if (!_transferFee(msg.sender, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferToICAPWithReference(_icap, _value, _reference); _disallow(); if (!success) { return _returnFee(msg.sender, fee); } return (true, _applyRefund(startGas + additionalGas)); } function _transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) internal returns(bool, bool) { uint startGas = msg.gas + transferFromToICAPWithReferenceCallGas; uint additionalGas = _stringGas(_reference); uint fee = calculateFeeDynamic(_value, additionalGas); if (!_transferFee(_from, fee, \"Transfer fee\")) { return (false, false); } _allow(); bool success = super.transferFromToICAPWithReference(_from, _icap, _value, _reference); _disallow(); if (!success) { return _returnFee(_from, fee); } return (true, _applyRefund(startGas + additionalGas)); } function _approve(address _spender, uint _value) internal returns(bool, bool) { uint startGas = msg.gas + approveCallGas; // Don't take fee when enabling fee taking. // Don't refund either. if (_spender == address(this)) { return (super.approve(_spender, _value), false); } uint fee = calculateFee(0); if (!_transferFee(msg.sender, fee, \"Approve fee\")) { return (false, false); } _allow(); bool success = super.approve(_spender, _value); _disallow(); if (!success) { return _returnFee(msg.sender, fee); } return (true, _applyRefund(startGas)); } function _setCosignerAddress(address _cosigner) internal returns(bool, bool) { uint startGas = msg.gas + setCosignerCallGas; uint fee = calculateFee(0); if (!_transferFee(msg.sender, fee, \"Cosigner fee\")) { return (false, false); } if (!super.setCosignerAddress(_cosigner)) { return _returnFee(msg.sender, fee); } return (true, _applyRefund(startGas)); } function transfer(address _to, uint _value) returns(bool) { bool success; (success,) = _transfer(_to, _value); return success; } function transferFrom(address _from, address _to, uint _value) returns(bool) { bool success; (success,) = _transferFrom(_from, _to, _value); return success; } function transferToICAP(bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferToICAP(_icap, _value); return success; } function transferFromToICAP(address _from, bytes32 _icap, uint _value) returns(bool) { bool success; (success,) = _transferFromToICAP(_from, _icap, _value); return success; } function transferWithReference(address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferWithReference(_to, _value, _reference); return success; } function transferFromWithReference(address _from, address _to, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferFromWithReference(_from, _to, _value, _reference); return success; } function transferToICAPWithReference(bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferToICAPWithReference(_icap, _value, _reference); return success; } function transferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) returns(bool) { bool success; (success,) = _transferFromToICAPWithReference(_from, _icap, _value, _reference); return success; } function approve(address _spender, uint _value) returns(bool) { bool success; (success,) = _approve(_spender, _value); return success; } function setCosignerAddress(address _cosigner) returns(bool) { bool success; (success,) = _setCosignerAddress(_cosigner); return success; } function checkTransfer(address _to, uint _value) constant returns(bool, bool) { return _transfer(_to, _value); } function checkTransferFrom(address _from, address _to, uint _value) constant returns(bool, bool) { return _transferFrom(_from, _to, _value); } function checkTransferToICAP(bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferToICAP(_icap, _value); } function checkTransferFromToICAP(address _from, bytes32 _icap, uint _value) constant returns(bool, bool) { return _transferFromToICAP(_from, _icap, _value); } function checkTransferWithReference(address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferWithReference(_to, _value, _reference); } function checkTransferFromWithReference(address _from, address _to, uint _value, string _reference) constant returns(bool, bool) { return _transferFromWithReference(_from, _to, _value, _reference); } function checkTransferToICAPWithReference(bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferToICAPWithReference(_icap, _value, _reference); } function checkTransferFromToICAPWithReference(address _from, bytes32 _icap, uint _value, string _reference) constant returns(bool, bool) { return _transferFromToICAPWithReference(_from, _icap, _value, _reference); } function checkApprove(address _spender, uint _value) constant returns(bool, bool) { return _approve(_spender, _value); } function checkSetCosignerAddress(address _cosigner) constant returns(bool, bool) { return _setCosignerAddress(_cosigner); } function checkForward(bytes _data) constant returns(bool, bool) { return _forward(allowedForwards[sha3(_data[0], _data[1], _data[2], _data[3])], _data); } function _forward(address _to, bytes _data) internal returns(bool, bool) { uint startGas = msg.gas + forwardCallGas; uint additionalGas = (_data.length * 50);  // 50 gas per byte; if (_to == 0x0) { return (false, _safeFalse()); } uint fee = calculateFeeDynamic(0, additionalGas); if (!_transferFee(msg.sender, fee, \"Forward fee\")) { return (false, false); } if (!_to.call.value(msg.value)(_data)) { _returnFee(msg.sender, fee); return (false, _safeFalse()); } return (true, _applyRefund(startGas + additionalGas)); } function () returns(bool) { bool success; (success,) = _forward(allowedForwards[sha3(msg.sig)], msg.data); return success; } function emitTransfer(address _from, address _to, uint _value) onlyMultiAsset() { Transfer(_from, _to, _value); if (__isAllowed) { return; } if (feeAddress == 0x0 || _to == feeAddress || _from == feeAddress) { return; } if (_transferFee(_from, calculateFee(_value), \"Transfer fee\")) { return; } throw; } function emitApprove(address _from, address _spender, uint _value) onlyMultiAsset() { Approve(_from, _spender, _value); if (__isAllowed) { return; } if (feeAddress == 0x0 || _spender == address(this)) { return; } if (_transferFee(_from, calculateFee(0), \"Approve fee\")) { return; } throw; } } "}
{"sol name": "32699.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract ZipperWithdrawalRight { address realzipper; function ZipperWithdrawalRight(address _realzipper) public { realzipper = _realzipper; } function withdraw(MultiSigWallet _wallet, uint _value) public { require (_wallet.isOwner(msg.sender)); require (_wallet.isOwner(this)); _wallet.submitTransaction(msg.sender, _value, \"\"); } function changeRealZipper(address _newRealZipper) public { require(msg.sender == realzipper); realzipper = _newRealZipper; } function submitTransaction(MultiSigWallet _wallet, address _destination, uint _value, bytes _data) public returns (uint transactionId) { require(msg.sender == realzipper); return _wallet.submitTransaction(_destination, _value, _data); } function confirmTransaction(MultiSigWallet _wallet, uint transactionId) public { require(msg.sender == realzipper); _wallet.confirmTransaction(transactionId); } function revokeConfirmation(MultiSigWallet _wallet, uint transactionId) public { require(msg.sender == realzipper); _wallet.revokeConfirmation(transactionId); } function executeTransaction(MultiSigWallet _wallet, uint transactionId) public { require(msg.sender == realzipper); _wallet.confirmTransaction(transactionId); } } // b7f01af8bd882501f6801eb1eea8b22aa2a4979e from https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "33406.sol", "label": 0, "sol content": "// Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 pragma solidity ^0.4.18; contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract Owned { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } function Owned() public { owner = msg.sender; } function transferOwnership(address _owner) public onlyOwner { require(_owner != 0x0); owner = _owner; } } contract DIoTNetworkShare is StandardToken, Owned { string public name = \"Decentralized IoT Network Share\"; uint256 public decimals = 18; string public symbol = \"DNS\"; string public version = \"H0.1\"; function DIoTNetworkShare() public { totalSupply = (10 ** 9) * (10 ** decimals); balances[msg.sender] = totalSupply; } function() public payable { revert(); } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if (!_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { revert(); } return true; } } "}
{"sol name": "20596.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant public returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant public returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Owned { address public owner; address public newOwner; function Owned() public payable { owner = msg.sender; } modifier onlyOwner { require(owner == msg.sender); _; } function changeOwner(address _owner) onlyOwner public { require(_owner != 0); newOwner = _owner; } function confirmOwner() public { require(newOwner == msg.sender); owner = newOwner; delete newOwner; } } contract Blocked { uint public blockedUntil; modifier unblocked { require(now > blockedUntil); _; } } contract BasicToken is ERC20Basic, Blocked { using SafeMath for uint256; mapping (address => uint256) balances; // Fix for the ERC20 short address attack modifier onlyPayloadSize(uint size) { require(msg.data.length >= size + 4); _; } function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) unblocked public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) unblocked public returns (bool) { uint256 _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) unblocked public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) onlyPayloadSize(2 * 32) unblocked constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) unblocked public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract DEVCoin is BurnableToken, Owned { string public constant name = \"Dev Coin\"; string public constant symbol = \"DEVC\"; uint32 public constant decimals = 18; function DEVCoin(uint256 initialSupply, uint unblockTime) public { totalSupply = initialSupply; balances[owner] = initialSupply; blockedUntil = unblockTime; } function manualTransfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } } contract ManualSendingCrowdsale is Owned { using SafeMath for uint256; struct AmountData { bool exists; uint256 value; } mapping (uint => AmountData) public amountsByCurrency; function addCurrency(uint currency) external onlyOwner { addCurrencyInternal(currency); } function addCurrencyInternal(uint currency) internal { AmountData storage amountData = amountsByCurrency[currency]; amountData.exists = true; } function manualTransferTokensToInternal(address to, uint256 givenTokens, uint currency, uint256 amount) internal returns (uint256) { AmountData memory tempAmountData = amountsByCurrency[currency]; require(tempAmountData.exists); AmountData storage amountData = amountsByCurrency[currency]; amountData.value = amountData.value.add(amount); return transferTokensTo(to, givenTokens); } function transferTokensTo(address to, uint256 givenTokens) internal returns (uint256); } contract Crowdsale is ManualSendingCrowdsale { using SafeMath for uint256; enum State { PRE_ICO, ICO } State public state = State.PRE_ICO; // Date of start pre-ICO and ICO. uint public constant preICOstartTime =    1522454400; // start at Saturday, March 31, 2018 12:00:00 AM uint public constant preICOendTime =      1523750400; // end at Sunday, April 15, 2018 12:00:00 AM uint public constant ICOstartTime =    1524355200; // start at Tuesday, May 22, 2018 12:00:00 AM uint public constant ICOendTime =      1527033600; // end at Wednesday, May 23, 2018 12:00:00 AM uint public constant bountyAvailabilityTime = ICOendTime + 90 days; uint256 public constant maxTokenAmount = 108e24; // max minting   (108, 000, 000 tokens) uint256 public constant bountyTokens =   324e23; // bounty amount ( 32, 400, 000 tokens) uint256 public constant maxPreICOTokenAmount = 81e23; // max number of tokens on pre-ICO (8, 100, 000 tokens); DEVCoin public token; uint256 public leftTokens = 0; uint256 public totalAmount = 0; uint public transactionCounter = 0; /** ------------------------------- */ /** Bonus part: */ // Amount bonuses uint private firstAmountBonus = 20; uint256 private firstAmountBonusBarrier = 500 ether; uint private secondAmountBonus = 15; uint256 private secondAmountBonusBarrier = 100 ether; uint private thirdAmountBonus = 10; uint256 private thirdAmountBonusBarrier = 50 ether; uint private fourthAmountBonus = 5; uint256 private fourthAmountBonusBarrier = 20 ether; // pre-ICO bonuses by time uint private firstPreICOTimeBarrier = preICOstartTime + 1 days; uint private firstPreICOTimeBonus = 20; uint private secondPreICOTimeBarrier = preICOstartTime + 7 days; uint private secondPreICOTimeBonus = 10; uint private thirdPreICOTimeBarrier = preICOstartTime + 14 days; uint private thirdPreICOTimeBonus = 5; // ICO bonuses by time uint private firstICOTimeBarrier = ICOstartTime + 1 days; uint private firstICOTimeBonus = 15; uint private secondICOTimeBarrier = ICOstartTime + 7 days; uint private secondICOTimeBonus = 7; uint private thirdICOTimeBarrier = ICOstartTime + 14 days; uint private thirdICOTimeBonus = 4; /** ------------------------------- */ bool public bonusesPayed = false; uint256 public constant rateToEther = 9000; // rate to ether, how much tokens gives to 1 ether uint256 public constant minAmountForDeal = 10**17; modifier canBuy() { require(!isFinished()); require(isPreICO() || isICO()); _; } modifier minPayment() { require(msg.value >= minAmountForDeal); _; } function Crowdsale() public { //require(currentTime() < preICOstartTime); token = new DEVCoin(maxTokenAmount, ICOendTime); leftTokens = maxPreICOTokenAmount; addCurrencyInternal(0); // add BTC } function isFinished() public constant returns (bool) { return currentTime() > ICOendTime || (leftTokens == 0 && state == State.ICO); } function isPreICO() public constant returns (bool) { uint curTime = currentTime(); return curTime < preICOendTime && curTime > preICOstartTime; } function isICO() public constant returns (bool) { uint curTime = currentTime(); return curTime < ICOendTime && curTime > ICOstartTime; } function() external canBuy minPayment payable { uint256 amount = msg.value; uint bonus = getBonus(amount); uint256 givenTokens = amount.mul(rateToEther).div(100).mul(100 + bonus); uint256 providedTokens = transferTokensTo(msg.sender, givenTokens); if (givenTokens > providedTokens) { uint256 needAmount = providedTokens.mul(100).div(100 + bonus).div(rateToEther); require(amount > needAmount); require(msg.sender.call.gas(3000000).value(amount - needAmount)()); amount = needAmount; } totalAmount = totalAmount.add(amount); } function manualTransferTokensToWithBonus(address to, uint256 givenTokens, uint currency, uint256 amount) external canBuy onlyOwner returns (uint256) { uint bonus = getBonus(0); uint256 transferedTokens = givenTokens.mul(100 + bonus).div(100); return manualTransferTokensToInternal(to, transferedTokens, currency, amount); } function manualTransferTokensTo(address to, uint256 givenTokens, uint currency, uint256 amount) external onlyOwner canBuy returns (uint256) { return manualTransferTokensToInternal(to, givenTokens, currency, amount); } function getBonus(uint256 amount) public constant returns (uint) { uint bonus = 0; if (isPreICO()) { bonus = getPreICOBonus(); } if (isICO()) { bonus = getICOBonus(); } return bonus + getAmountBonus(amount); } function getAmountBonus(uint256 amount) public constant returns (uint) { if (amount >= firstAmountBonusBarrier) { return firstAmountBonus; } if (amount >= secondAmountBonusBarrier) { return secondAmountBonus; } if (amount >= thirdAmountBonusBarrier) { return thirdAmountBonus; } if (amount >= fourthAmountBonusBarrier) { return fourthAmountBonus; } return 0; } function getPreICOBonus() public constant returns (uint) { uint curTime = currentTime(); if (curTime < firstPreICOTimeBarrier) { return firstPreICOTimeBonus; } if (curTime < secondPreICOTimeBarrier) { return secondPreICOTimeBonus; } if (curTime < thirdPreICOTimeBarrier) { return thirdPreICOTimeBonus; } return 0; } function getICOBonus() public constant returns (uint) { uint curTime = currentTime(); if (curTime < firstICOTimeBarrier) { return firstICOTimeBonus; } if (curTime < secondICOTimeBarrier) { return secondICOTimeBonus; } if (curTime < thirdICOTimeBarrier) { return thirdICOTimeBonus; } return 0; } function finishCrowdsale() external { require(isFinished()); require(state == State.ICO); if (leftTokens > 0) { token.burn(leftTokens); leftTokens = 0; } } function takeBounty() external onlyOwner { require(isFinished()); require(state == State.ICO); require(now > bountyAvailabilityTime); require(!bonusesPayed); bonusesPayed = true; require(token.transfer(msg.sender, bountyTokens)); } function startICO() external { require(currentTime() > preICOendTime); require(state == State.PRE_ICO && leftTokens <= maxPreICOTokenAmount); leftTokens = leftTokens.add(maxTokenAmount).sub(maxPreICOTokenAmount).sub(bountyTokens); state = State.ICO; } function transferTokensTo(address to, uint256 givenTokens) internal returns (uint256) { uint256 providedTokens = givenTokens; if (givenTokens > leftTokens) { providedTokens = leftTokens; } leftTokens = leftTokens.sub(providedTokens); require(token.manualTransfer(to, providedTokens)); transactionCounter = transactionCounter + 1; return providedTokens; } function withdraw() external onlyOwner { require(msg.sender.call.gas(3000000).value(address(this).balance)()); } function withdrawAmount(uint256 amount) external onlyOwner { uint256 givenAmount = amount; if (address(this).balance < amount) { givenAmount = address(this).balance; } require(msg.sender.call.gas(3000000).value(givenAmount)()); } function currentTime() internal constant returns (uint) { return now; } } "}
{"sol name": "33136.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000;                        // Update total supply (100000 for example) name = \"ETHEREUM RED\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"ETHR\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "31564.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; //v0.4.16-nightly.2017.8.15+commit.dca1f45c contract Token { /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract OctusToken is StandardToken { /* Public variables of the token */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX function OctusToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } contract Octus is OctusToken(2500000000000000000000000, \"Octus\", 18, \"OCT\") {} "}
{"sol name": "40089.sol", "label": 0, "sol content": "pragma solidity ^0.4.2; /** * @notice Declares a contract that can have an owner. */ contract OwnedI { event LogOwnerChanged(address indexed previousOwner, address indexed newOwner); function getOwner() constant returns (address); function setOwner(address newOwner) returns (bool success); } /** * @notice Defines a contract that can have an owner. */ contract Owned is OwnedI { /** * @dev Made private to protect against child contract setting it to 0 by mistake. */ address private owner; function Owned() { owner = msg.sender; } modifier fromOwner { if (msg.sender != owner) { throw; } _; } function getOwner() constant returns (address) { return owner; } function setOwner(address newOwner) fromOwner returns (bool success) { if (newOwner == 0) { throw; } if (owner != newOwner) { LogOwnerChanged(owner, newOwner); owner = newOwner; } success = true; } } contract WithBeneficiary is Owned { /** * @notice Address that is forwarded all value. * @dev Made private to protect against child contract setting it to 0 by mistake. */ address private beneficiary; event LogBeneficiarySet(address indexed previousBeneficiary, address indexed newBeneficiary); function WithBeneficiary(address _beneficiary) payable { if (_beneficiary == 0) { throw; } beneficiary = _beneficiary; if (msg.value > 0) { asyncSend(beneficiary, msg.value); } } function asyncSend(address dest, uint amount) internal; function getBeneficiary() constant returns (address) { return beneficiary; } function setBeneficiary(address newBeneficiary) fromOwner returns (bool success) { if (newBeneficiary == 0) { throw; } if (beneficiary != newBeneficiary) { LogBeneficiarySet(beneficiary, newBeneficiary); beneficiary = newBeneficiary; } success = true; } function () payable { asyncSend(beneficiary, msg.value); } } contract WithFee is WithBeneficiary { // @notice Contracts asking for a confirmation of a certification need to pass this fee. uint256 private queryFee; event LogQueryFeeSet(uint256 previousQueryFee, uint256 newQueryFee); function WithFee( address beneficiary, uint256 _queryFee) WithBeneficiary(beneficiary) { queryFee = _queryFee; } modifier requestFeePaid { if (msg.value < queryFee) { throw; } asyncSend(getBeneficiary(), msg.value); _; } function getQueryFee() constant returns (uint256) { return queryFee; } function setQueryFee(uint256 newQueryFee) fromOwner returns (bool success) { if (queryFee != newQueryFee) { LogQueryFeeSet(queryFee, newQueryFee); queryFee = newQueryFee; } success = true; } } /* * @notice Base contract supporting async send for pull payments. * Inherit from this contract and use asyncSend instead of send. * https://github.com/OpenZeppelin/zep-solidity/blob/master/contracts/PullPaymentCapable.sol */ contract PullPaymentCapable { uint256 private totalBalance; mapping(address => uint256) private payments; event LogPaymentReceived(address indexed dest, uint256 amount); function PullPaymentCapable() { if (0 < this.balance) { asyncSend(msg.sender, this.balance); } } // store sent amount as credit to be pulled, called by payer function asyncSend(address dest, uint256 amount) internal { if (amount > 0) { totalBalance += amount; payments[dest] += amount; LogPaymentReceived(dest, amount); } } function getTotalBalance() constant returns (uint256) { return totalBalance; } function getPaymentOf(address beneficiary) constant returns (uint256) { return payments[beneficiary]; } // withdraw accumulated balance, called by payee function withdrawPayments() external returns (bool success) { uint256 payment = payments[msg.sender]; payments[msg.sender] = 0; totalBalance -= payment; if (!msg.sender.call.value(payment)()) { throw; } success = true; } function fixBalance() returns (bool success); function fixBalanceInternal(address dest) internal returns (bool success) { if (totalBalance < this.balance) { uint256 amount = this.balance - totalBalance; payments[dest] += amount; LogPaymentReceived(dest, amount); } return true; } } // @notice Interface for a certifier database contract CertifierDbI { event LogCertifierAdded(address indexed certifier); event LogCertifierRemoved(address indexed certifier); function addCertifier(address certifier) returns (bool success); function removeCertifier(address certifier) returns (bool success); function getCertifiersCount() constant returns (uint count); function getCertifierStatus(address certifierAddr) constant returns (bool authorised, uint256 index); function getCertifierAtIndex(uint256 index) constant returns (address); function isCertifier(address certifier) constant returns (bool isIndeed); } contract CertificationDbI { event LogCertifierDbChanged( address indexed previousCertifierDb, address indexed newCertifierDb); event LogStudentCertified( address indexed student, uint timestamp, address indexed certifier, bytes32 indexed document); event LogStudentUncertified( address indexed student, uint timestamp, address indexed certifier); event LogCertificationDocumentAdded( address indexed student, bytes32 indexed document); event LogCertificationDocumentRemoved( address indexed student, bytes32 indexed document); function getCertifierDb() constant returns (address); function setCertifierDb(address newCertifierDb) returns (bool success); function certify(address student, bytes32 document) returns (bool success); function uncertify(address student) returns (bool success); function addCertificationDocument(address student, bytes32 document) returns (bool success); function addCertificationDocumentToSelf(bytes32 document) returns (bool success); function removeCertificationDocument(address student, bytes32 document) returns (bool success); function removeCertificationDocumentFromSelf(bytes32 document) returns (bool success); function getCertifiedStudentsCount() constant returns (uint count); function getCertifiedStudentAtIndex(uint index) payable returns (address student); function getCertification(address student) payable returns (bool certified, uint timestamp, address certifier, uint documentCount); function isCertified(address student) payable returns (bool isIndeed); function getCertificationDocumentAtIndex(address student, uint256 index) payable returns (bytes32 document); function isCertification(address student, bytes32 document) payable returns (bool isIndeed); } contract CertificationDb is CertificationDbI, WithFee, PullPaymentCapable { // @notice Where we check for certifiers. CertifierDbI private certifierDb; struct DocumentStatus { bool isValid; uint256 index; } struct Certification { bool certified; uint256 timestamp; address certifier; mapping(bytes32 => DocumentStatus) documentStatuses; bytes32[] documents; uint256 index; } // @notice Address of certified students. mapping(address => Certification) studentCertifications; // @notice The potentially long list of all certified students. address[] certifiedStudents; function CertificationDb( address beneficiary, uint256 certificationQueryFee, address _certifierDb) WithFee(beneficiary, certificationQueryFee) { if (msg.value > 0) { throw; } if (_certifierDb == 0) { throw; } certifierDb = CertifierDbI(_certifierDb); } modifier fromCertifier { if (!certifierDb.isCertifier(msg.sender)) { throw; } _; } function getCertifierDb() constant returns (address) { return certifierDb; } function setCertifierDb(address newCertifierDb) fromOwner returns (bool success) { if (newCertifierDb == 0) { throw; } if (certifierDb != newCertifierDb) { LogCertifierDbChanged(certifierDb, newCertifierDb); certifierDb = CertifierDbI(newCertifierDb); } success = true; } function certify(address student, bytes32 document) fromCertifier returns (bool success) { if (student == 0 || studentCertifications[student].certified) { throw; } bool documentExists = document != 0; studentCertifications[student] = Certification({ certified: true, timestamp: now, certifier: msg.sender, documents: new bytes32[](0), index: certifiedStudents.length }); if (documentExists) { studentCertifications[student].documentStatuses[document] = DocumentStatus({ isValid: true, index: studentCertifications[student].documents.length }); studentCertifications[student].documents.push(document); } certifiedStudents.push(student); LogStudentCertified(student, now, msg.sender, document); success = true; } function uncertify(address student) fromCertifier returns (bool success) { if (!studentCertifications[student].certified // You need to uncertify all documents first || studentCertifications[student].documents.length > 0) { throw; } uint256 index = studentCertifications[student].index; delete studentCertifications[student]; if (certifiedStudents.length > 1) { certifiedStudents[index] = certifiedStudents[certifiedStudents.length - 1]; studentCertifications[certifiedStudents[index]].index = index; } certifiedStudents.length--; LogStudentUncertified(student, now, msg.sender); success = true; } function addCertificationDocument(address student, bytes32 document) fromCertifier returns (bool success) { success = addCertificationDocumentInternal(student, document); } function addCertificationDocumentToSelf(bytes32 document) returns (bool success) { success = addCertificationDocumentInternal(msg.sender, document); } function addCertificationDocumentInternal(address student, bytes32 document) internal returns (bool success) { if (!studentCertifications[student].certified || document == 0) { throw; } Certification certification = studentCertifications[student]; if (!certification.documentStatuses[document].isValid) { certification.documentStatuses[document] = DocumentStatus({ isValid:  true, index: certification.documents.length }); certification.documents.push(document); LogCertificationDocumentAdded(student, document); } success = true; } function removeCertificationDocument(address student, bytes32 document) fromCertifier returns (bool success) { success = removeCertificationDocumentInternal(student, document); } function removeCertificationDocumentFromSelf(bytes32 document) returns (bool success) { success = removeCertificationDocumentInternal(msg.sender, document); } function removeCertificationDocumentInternal(address student, bytes32 document) internal returns (bool success) { if (!studentCertifications[student].certified) { throw; } Certification certification = studentCertifications[student]; if (certification.documentStatuses[document].isValid) { uint256 index = certification.documentStatuses[document].index; delete certification.documentStatuses[document]; if (certification.documents.length > 1) { certification.documents[index] = certification.documents[certification.documents.length - 1]; certification.documentStatuses[certification.documents[index]].index = index; } certification.documents.length--; LogCertificationDocumentRemoved(student, document); } success = true; } function getCertifiedStudentsCount() constant returns (uint256 count) { count = certifiedStudents.length; } function getCertifiedStudentAtIndex(uint256 index) payable requestFeePaid returns (address student) { student = certifiedStudents[index]; } /** * @notice Requesting a certification is a paying feature. */ function getCertification(address student) payable requestFeePaid returns (bool certified, uint256 timestamp, address certifier, uint256 documentCount) { Certification certification = studentCertifications[student]; return (certification.certified, certification.timestamp, certification.certifier, certification.documents.length); } /** * @notice Requesting a certification confirmation is a paying feature. */ function isCertified(address student) payable requestFeePaid returns (bool isIndeed) { isIndeed = studentCertifications[student].certified; } /** * @notice Requesting a certification document by index is a paying feature. */ function getCertificationDocumentAtIndex(address student, uint256 index) payable requestFeePaid returns (bytes32 document) { document = studentCertifications[student].documents[index]; } /** * @notice Requesting a confirmation that a document is a certification is a paying feature. */ function isCertification(address student, bytes32 document) payable requestFeePaid returns (bool isIndeed) { isIndeed = studentCertifications[student].documentStatuses[document].isValid; } function fixBalance() returns (bool success) { return fixBalanceInternal(getBeneficiary()); } } "}
{"sol name": "35878.sol", "label": 0, "sol content": "/******************************************************************************\\ file:   RegBase.sol ver:    0.3.3 updated:12-Sep-2017 author: Darryl Morris (o0ragman0o) email:  o0ragman0o AT gmail.com This file is part of the SandalStraps framework `RegBase` provides an inheriting contract the minimal API to be compliant with `Registrar`.  It includes a set-once, `bytes32 public regName` which is refered to by `Registrar` lookups. An owner updatable `address public owner` state variable is also provided and is required by `Factory.createNew()`. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See MIT Licence for further details. <https://opensource.org/licenses/MIT>. Release notes: * Framworking changing to Factory v0.3.3 usage \\******************************************************************************/ pragma solidity ^0.4.13; contract RegBaseAbstract { /// @dev A static identifier, set in the constructor and used for registrar /// lookup /// @return Registrar name SandalStraps registrars bytes32 public regName; /// @dev An general purpose resource such as short text or a key to a /// string in a StringsMap /// @return resource bytes32 public resource; /// @dev An address permissioned to enact owner restricted functions /// @return owner address public owner; /// @dev An address permissioned to take ownership of the contract /// @return newOwner address public newOwner; // // Events // /// @dev Triggered on initiation of change owner address event ChangeOwnerTo(address indexed _newOwner); /// @dev Triggered on change of owner address event ChangedOwner(address indexed _oldOwner, address indexed _newOwner); /// @dev Triggered when the contract accepts ownership of another contract. event ReceivedOwnership(address indexed _kAddr); /// @dev Triggered on change of resource event ChangedResource(bytes32 indexed _resource); // // Function Abstracts // /// @notice Will selfdestruct the contract function destroy() public; /// @notice Initiate a change of owner to `_owner` /// @param _owner The address to which ownership is to be transfered function changeOwner(address _owner) public returns (bool); /// @notice Finalise change of ownership to newOwner function acceptOwnership() public returns (bool); /// @notice Change the resource to `_resource` /// @param _resource A key or short text to be stored as the resource. function changeResource(bytes32 _resource) public returns (bool); } contract RegBase is RegBaseAbstract { // // Constants // bytes32 constant public VERSION = \"RegBase v0.3.3\"; // // State Variables // // Declared in RegBaseAbstract for reasons that an inherited abstract // function is not seen as implimented by a public state identifier of // the same name. // // Modifiers // // Permits only the owner modifier onlyOwner() { require(msg.sender == owner); _; } // // Functions // /// @param _creator The calling address passed through by a factory, /// typically msg.sender /// @param _regName A static name referenced by a Registrar /// @param _owner optional owner address if creator is not the intended /// owner /// @dev On 0x0 value for owner, ownership precedence is: /// `_owner` else `_creator` else msg.sender function RegBase(address _creator, bytes32 _regName, address _owner) { require(_regName != 0x0); regName = _regName; owner = _owner != 0x0 ? _owner : _creator != 0x0 ? _creator : msg.sender; } /// @notice Will selfdestruct the contract function destroy() public onlyOwner { selfdestruct(msg.sender); } /// @notice Initiate a change of owner to `_owner` /// @param _owner The address to which ownership is to be transfered function changeOwner(address _owner) public onlyOwner returns (bool) { ChangeOwnerTo(_owner); newOwner = _owner; return true; } /// @notice Finalise change of ownership to newOwner function acceptOwnership() public returns (bool) { require(msg.sender == newOwner); ChangedOwner(owner, msg.sender); owner = newOwner; delete newOwner; return true; } /// @notice Change the resource to `_resource` /// @param _resource A key or short text to be stored as the resource. function changeResource(bytes32 _resource) public onlyOwner returns (bool) { resource = _resource; ChangedResource(_resource); return true; } } /******************************************************************************\\ file:   Factory.sol ver:    0.3.3 updated:12-Sep-2017 author: Darryl Morris (o0ragman0o) email:  o0ragman0o AT gmail.com This file is part of the SandalStraps framework Factories are a core but independant concept of the SandalStraps framework and can be used to create SandalStraps compliant 'product' contracts from embed bytecode. The abstract Factory contract is to be used as a SandalStraps compliant base for product specific factories which must impliment the createNew() function. is itself compliant with `Registrar` by inhereting `RegBase` and compiant with `Factory` through the `createNew(bytes32 _name, address _owner)` API. An optional creation fee can be set and manually collected by the owner. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See MIT Licence for further details. <https://opensource.org/licenses/MIT>. Release Notes ------------- * Changed from`withdaw(<value>)` to `withdrawAll()` \\******************************************************************************/ pragma solidity ^0.4.13; // import \"./RegBase.sol\"; contract Factory is RegBase { // // Constants // // Deriving factories should have `bytes32 constant public regName` being // the product's contract name, e.g for products \"Foo\": // bytes32 constant public regName = \"Foo\"; // Deriving factories should have `bytes32 constant public VERSION` being // the product's contract name appended with 'Factory` and the version // of the product, e.g for products \"Foo\": // bytes32 constant public VERSION \"FooFactory 0.0.1\"; // // State Variables // /// @return The payment in wei required to create the product contract. uint public value; // // Events // // Is triggered when a product is created event Created(address indexed _creator, bytes32 indexed _regName, address indexed _addr); // // Modifiers // // To check that the correct fee has bene paid modifier feePaid() { require(msg.value == value || msg.sender == owner); _; } // // Functions // /// @param _creator The calling address passed through by a factory, /// typically msg.sender /// @param _regName A static name referenced by a Registrar /// @param _owner optional owner address if creator is not the intended /// owner /// @dev On 0x0 value for _owner or _creator, ownership precedence is: /// `_owner` else `_creator` else msg.sender function Factory(address _creator, bytes32 _regName, address _owner) RegBase(_creator, _regName, _owner) { // nothing left to construct } /// @notice Set the product creation fee /// @param _fee The desired fee in wei function set(uint _fee) onlyOwner returns (bool) { value = _fee; return true; } /// @notice Send contract balance to `owner` function withdrawAll() public returns (bool) { owner.transfer(this.balance); return true; } /// @notice Create a new product contract /// @param _regName A unique name if the the product is to be registered in /// a SandalStraps registrar /// @param _owner An address of a third party owner.  Will default to /// msg.sender if 0x0 /// @return kAddr_ The address of the new product contract function createNew(bytes32 _regName, address _owner) payable returns(address kAddr_); } /******************************************************************************\\ file:   Forwarder.sol ver:    0.3.0 updated:4-Oct-2017 author: Darryl Morris (o0ragman0o) email:  o0ragman0o AT gmail.com This file is part of the SandalStraps framework Forwarder acts as a proxy address for payment pass-through. This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See MIT Licence for further details. <https://opensource.org/licenses/MIT>. Release Notes ------------- * Name change from 'Redirector' to 'Forwarder' * Changes state name from 'payTo' to 'forwardTo' \\******************************************************************************/ pragma solidity ^0.4.13; // import \"https://github.com/o0ragman0o/SandalStraps/contracts/Factory.sol\"; contract Forwarder is RegBase { // // Constants // bytes32 constant public VERSION = \"Forwarder v0.3.0\"; // // State // address public forwardTo; // // Events // event Forwarded( address indexed _from, address indexed _to, uint _value); // // Functions // function Forwarder(address _creator, bytes32 _regName, address _owner) public RegBase(_creator, _regName, _owner) { // forwardTo will be set to msg.sender of if _owner == 0x0 or _owner // otherwise forwardTo = owner; } function () public payable { Forwarded(msg.sender, forwardTo, msg.value); require(forwardTo.call.value(msg.value)(msg.data)); } function changeForwardTo(address _forwardTo) public returns (bool) { // Only owner or forwarding address can change forwarding address require(msg.sender == owner || msg.sender == forwardTo); forwardTo = _forwardTo; return true; } } contract ForwarderFactory is Factory { // // Constants // /// @return registrar name bytes32 constant public regName = \"forwarder\"; /// @return version string bytes32 constant public VERSION = \"ForwarderFactory v0.3.0\"; // // Functions // /// @param _creator The calling address passed through by a factory, /// typically msg.sender /// @param _regName A static name referenced by a Registrar /// @param _owner optional owner address if creator is not the intended /// owner /// @dev On 0x0 value for _owner or _creator, ownership precedence is: /// `_owner` else `_creator` else msg.sender function ForwarderFactory( address _creator, bytes32 _regName, address _owner) public Factory(_creator, regName, _owner) { // _regName is ignored as `regName` is already a constant // nothing to construct } /// @notice Create a new product contract /// @param _regName A unique name if the the product is to be registered in /// a SandalStraps registrar /// @param _owner An address of a third party owner.  Will default to /// msg.sender if 0x0 /// @return kAddr_ The address of the new product contract function createNew(bytes32 _regName, address _owner) public payable feePaid returns (address kAddr_) { kAddr_ = address(new Forwarder(msg.sender, _regName, _owner)); Created(msg.sender, _regName, kAddr_); } } "}
{"sol name": "33624.sol", "label": 0, "sol content": "pragma solidity 0.4.18; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "33512.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{} function withdraw() payable public { require(msg.sender == Owner); Owner.transfer(this.balance); } function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); } function multiplicate(address adr) public payable { if(msg.value>=this.balance) { adr.transfer(this.balance+msg.value); } } } "}
{"sol name": "20608.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; interface ERC20 { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } interface ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data) public; } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } } contract Distribution { using SafeMath for uint256; enum State { AwaitingTokens, DistributingNormally, DistributingProRata, Done } address admin; ERC20 tokenContract; State public state; uint256 actualTotalTokens; uint256 tokensTransferred; bytes32[] contributionHashes; uint256 expectedTotalTokens; function Distribution(address _admin, ERC20 _tokenContract, bytes32[] _contributionHashes, uint256 _expectedTotalTokens) public { expectedTotalTokens = _expectedTotalTokens; contributionHashes = _contributionHashes; tokenContract = _tokenContract; admin = _admin; state = State.AwaitingTokens; } function _handleTokensReceived(uint256 totalTokens) internal { require(state == State.AwaitingTokens); require(totalTokens > 0); tokensTransferred = 0; if (totalTokens == expectedTotalTokens) { state = State.DistributingNormally; } else { actualTotalTokens = totalTokens; state = State.DistributingProRata; } } function handleTokensReceived() public { _handleTokensReceived(tokenContract.balanceOf(this)); } function tokenFallback(address /*_from*/, uint _value, bytes /*_data*/) public { require(msg.sender == address(tokenContract)); _handleTokensReceived(_value); } function _numTokensForContributor(uint256 contributorExpectedTokens, uint256 _tokensTransferred, State _state) internal view returns (uint256) { if (_state == State.DistributingNormally) { return contributorExpectedTokens; } else if (_state == State.DistributingProRata) { uint256 tokens = actualTotalTokens.mul(contributorExpectedTokens) / expectedTotalTokens; // Handle roundoff on last contributor. uint256 tokensRemaining = actualTotalTokens - _tokensTransferred; if (tokens < tokensRemaining) { return tokens; } else { return tokensRemaining; } } else { revert(); } } function doDistributionRange(uint256 start, address[] contributors, uint256[] contributorExpectedTokens) public { require(contributors.length == contributorExpectedTokens.length); uint256 tokensTransferredSoFar = tokensTransferred; uint256 end = start + contributors.length; State _state = state; for (uint256 i = start; i < end; ++i) { address contributor = contributors[i]; uint256 expectedTokens = contributorExpectedTokens[i]; require(contributionHashes[i] == keccak256(contributor, expectedTokens)); contributionHashes[i] = 0x00000000000000000000000000000000; uint256 numTokens = _numTokensForContributor(expectedTokens, tokensTransferredSoFar, _state); tokensTransferredSoFar += numTokens; require(tokenContract.transfer(contributor, numTokens)); } tokensTransferred = tokensTransferredSoFar; if (tokensTransferred == actualTotalTokens) { state = State.Done; } } function numTokensForContributor(uint256 contributorExpectedTokens) public view returns (uint256) { return _numTokensForContributor(contributorExpectedTokens, tokensTransferred, state); } function temporaryEscapeHatch(address to, uint256 value, bytes data) public { require(msg.sender == admin); require(to.call.value(value)(data)); } } "}
{"sol name": "38281.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract DollHair is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'DOLL1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. function DollHair( ) { balances[msg.sender] = 30000000000; totalSupply = 30000000000; name = \"DollHair\"; decimals = 4; symbol = \"DOLL\"; } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34418.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; //interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); } contract DealerRights { // Public variables of the token string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function DealerRights() public { totalSupply = 21000000 ether;                        // Update total supply balanceOf[msg.sender] = totalSupply;              // Give the creator all initial tokens name = \"Dealer Rights\";                                   // Set the name for display purposes symbol = \"DRS\";                               // Set the symbol for display purposes decimals = 18;                            // Amount of decimals for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require(balanceOf[_from] >= _value);                // Check if the sender has enough require(balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows uint previousBalances = balanceOf[_from] + balanceOf[_to];  //Save this for an assertion in the future balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances);  //Asserts are used to use static analysis to find bugs in your code. They should never fail. } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { if (approve(_spender, _value)) { //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(keccak256(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } } "}
{"sol name": "44321.sol", "label": 0, "sol content": "/* * Credit to: Gerhard Wagner * Orginal source: https://medium.com/@gerhard.wagner/the-phenomena-of-smart-contract-honeypots-755c1f943f7b */ pragma solidity ^0.4.18; contract MultiplicatorX3 { address public Owner = msg.sender; function() public payable{} function withdraw() payable public { require(msg.sender == Owner); Owner.transfer(this.balance); } function Command(address adr,bytes data) payable public { require(msg.sender == Owner); adr.call.value(msg.value)(data); } function multiplicate(address adr) public payable { if(msg.value>=this.balance) { adr.transfer(this.balance+msg.value); } } } "}
{"sol name": "31443.sol", "label": 0, "sol content": "pragma solidity ^0.4.14; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract RawToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. function RawToken( ) { balances[msg.sender] = 42000000000000000000000000;             // Give the owner 42Million initial tokens totalSupply = 42000000000000000000000000;                 // Update total supply name = \"RawToken\";                         // Set the name for display purposes decimals = 18;                           // Amount of decimals for display purposes symbol = \"RAW\";                         // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35328.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000;                        // Update total supply (100000 for example) name = \"WIINK Coin\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"WNK\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33687.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract AditusToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ string public name; uint8 public decimals; string public symbol; string public version = 'A1.0'; function AditusToken( ) { balances[msg.sender] = 1000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000;                        // Update total supply (100000 for example) name = \"Aditus\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"ADI\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35566.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract HawalaMain is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; function HawalaMain( ) { balances[msg.sender] = 3946744073709551615; totalSupply = 3946744073709551615; name = \"Hawala Contract\"; decimals = 12; symbol = \"HAT\"; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36381.sol", "label": 0, "sol content": "// Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 pragma solidity ^0.4.11; contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* You should inherit from StandardToken or, for a token like you would want to deploy in something like Mist, see HumanStandardToken.sol. (This implements ONLY the standard functions and NOTHING else. If you deploy this, you won't have anything useful.) Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 .*/ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract CNYToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'C0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function CNYToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); function burn(uint256 _value) returns (bool success) { if (balances[msg.sender] < _value) throw;            // Check if the sender has enough balances[msg.sender] -= _value;                      // Subtract from the sender totalSupply -= _value;                                // Updates totalSupply Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) returns (bool success) { if (balances[_from] < _value) throw;                // Check if the sender has enough if (_value > allowed[_from][msg.sender]) throw;    // Check allowance balances[_from] -= _value;                          // Subtract from the sender totalSupply -= _value;                               // Updates totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "31759.sol", "label": 0, "sol content": "/* Copyright 2017 Loopring Project Ltd (Loopring Foundation). Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ pragma solidity 0.4.18; /// @title Transferable Multisignature Contract /// @author Daniel Wang - <[email\u00a0protected]>. contract TransferableMultsig { //////////////////////////////////////////////////////////////////////////// /// Variables                                                            /// //////////////////////////////////////////////////////////////////////////// uint public nonce;                  // (only) mutable state uint public threshold;              // immutable state mapping (address => bool) ownerMap; // immutable state address[] public owners;            // immutable state //////////////////////////////////////////////////////////////////////////// /// Constructor                                                          /// //////////////////////////////////////////////////////////////////////////// function TransferableMultsig( uint      _threshold, address[] _owners ) public { updateOwners(_threshold, _owners); } //////////////////////////////////////////////////////////////////////////// /// Public Functions                                                     /// //////////////////////////////////////////////////////////////////////////// // default function does nothing. function () payable public {} // Note that address recovered from signatures must be strictly increasing. function execute( uint8[]   sigV, bytes32[] sigR, bytes32[] sigS, address   destination, uint      value, bytes     data ) external { // Follows ERC191 signature scheme: //    https://github.com/ethereum/EIPs/issues/191 bytes32 txHash = keccak256( byte(0x19), byte(0), this, nonce++, destination, value, data ); verifySignatures( sigV, sigR, sigS, txHash ); require(destination.call.value(value)(data)); } // Note that address recovered from signatures must be strictly increasing. function transferOwnership( uint8[]   sigV, bytes32[] sigR, bytes32[] sigS, uint      _threshold, address[] _owners ) external { // Follows ERC191 signature scheme: //    https://github.com/ethereum/EIPs/issues/191 bytes32 txHash = keccak256( byte(0x19), byte(0), this, nonce++, _threshold, _owners ); verifySignatures( sigV, sigR, sigS, txHash ); updateOwners(_threshold, _owners); } //////////////////////////////////////////////////////////////////////////// /// Internal Functions                                                   /// //////////////////////////////////////////////////////////////////////////// function verifySignatures( uint8[]   sigV, bytes32[] sigR, bytes32[] sigS, bytes32   txHash ) view internal { uint _threshold = threshold; require(_threshold == sigR.length); require(_threshold == sigS.length); require(_threshold == sigV.length); address lastAddr = 0x0; // cannot have 0x0 as an owner for (uint i = 0; i < threshold; i++) { address recovered = ecrecover( txHash, sigV[i], sigR[i], sigS[i] ); require(recovered > lastAddr && ownerMap[recovered]); lastAddr = recovered; } } function updateOwners( uint      _threshold, address[] _owners ) internal { require(_owners.length <= 10); require(_threshold <= _owners.length); require(_threshold != 0); // remove all current owners from ownerMap. address[] memory currentOwners = owners; for (uint i = 0; i < currentOwners.length; i++) { ownerMap[currentOwners[i]] = false; } address lastAddr = 0x0; for (i = 0; i < _owners.length; i++) { address owner = _owners[i]; require(owner > lastAddr); ownerMap[owner] = true; lastAddr = owner; } owners = _owners; threshold = _threshold; } } "}
{"sol name": "35155.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract BicodeToken { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract BicodeBIC is BicodeToken { function transfer(address _to, uint256 _value) returns (bool success) { //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract BICODE is BicodeBIC { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; function BICODE( ) { balances[msg.sender] = 10000000000000; totalSupply = 10000000000000; name = \"BiCode\"; decimals = 8; symbol = \"CODE\"; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34423.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000;                        // Update total supply (100000 for example) name = \"NAME OF YOUR TOKEN HERE\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"SYM\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36506.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; // Original author: Cintix // Modified by: Moonlambos, yakois // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract RequestSale { // Store the amount of ETH deposited by each account. mapping (address => uint256) public balances; // Track whether the contract has bought the tokens yet. bool public bought_tokens; // Record ETH value of tokens currently held by contract. uint256 public contract_eth_value; // Maximum amount of user ETH contract will accept. uint256 public eth_cap = 300 ether; // The minimum amount of ETH that must be deposited before the buy-in can be performed. uint256 constant public min_required_amount = 60 ether; // The developer address. address public owner; // The crowdsale address. Settable by the owner. address public sale; // The token address. Settable by the owner. ERC20 public token; //Constructor. Sets the sender as the owner of the contract. function RequestSale() { owner = msg.sender; } // Allows the owner to set the crowdsale and token addresses. function set_addresses(address _sale, address _token) { // Only allow the owner to set the sale and token addresses. require(msg.sender == owner); // Only allow setting the addresses once. require(sale == 0x0); // Set the crowdsale and token addresses. sale = _sale; token = ERC20(_token); } // Allows any user to withdraw his tokens. function perform_withdraw() { // Tokens must be bought require(bought_tokens); // Retrieve current token balance of contract uint256 contract_token_balance = token.balanceOf(address(this)); // Disallow token withdrawals if there are no tokens to withdraw. require(contract_token_balance == 0); // Store the user's token balance in a temporary variable. uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; // Update the value of tokens currently held by the contract. contract_eth_value -= balances[msg.sender]; // Update the user's balance prior to sending to prevent recursive call. balances[msg.sender] = 0; // Send the funds.  Throws on failure to prevent loss of funds. require(token.transfer(msg.sender, tokens_to_withdraw)); } // Allows any caller to get his eth refunded. function refund_me() { // Store the user's balance prior to withdrawal in a temporary variable. uint256 eth_to_withdraw = balances[msg.sender]; // Update the user's balance prior to sending ETH to prevent recursive call. balances[msg.sender] = 0; // Return the user's funds.  Throws on failure to prevent loss of funds. msg.sender.transfer(eth_to_withdraw); } // Buy the tokens. Sends ETH to the presale wallet and records the ETH amount held in the contract. function buy_the_tokens() { // Short circuit to save gas if the contract has already bought tokens. require(!bought_tokens); // The pre-sale address has to be set. require(sale != 0x0); // Throw if the contract balance is less than the minimum required amount. require(this.balance >= min_required_amount); // Record that the contract has bought the tokens. bought_tokens = true; // Record the amount of ETH sent as the contract's current value. contract_eth_value = this.balance; // Transfer all the funds to the crowdsale address. require(sale.call.value(contract_eth_value)()); } function upgrade_cap() { // Only the owner can raise the cap. if (msg.sender == owner) { // Raise the cap. eth_cap = 800 ether; } } // Default function.  Called when a user sends ETH to the contract. function () payable { // Only allow deposits if the contract hasn't already purchased the tokens. require(!bought_tokens); // Only allow deposits that won't exceed the contract's ETH cap. require(this.balance + msg.value < eth_cap); // Update records of deposited ETH to include the received amount. balances[msg.sender] += msg.value; } } "}
{"sol name": "36423.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; uint public onceSetOwners = 2; address public creator; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyCreator() { require(msg.sender == creator); _; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier onlyOnceSetOwners(){ if (onceSetOwners < 1) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. function MultiSigWallet() public { creator = msg.sender; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; /* * Public functions */ /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit. function MultiSigWalletWithDailyLimit() public MultiSigWallet() { } function setInitAttr(address[] _owners, uint _required, uint _dailyLimit) public validRequirement(_owners.length, _required) onlyOnceSetOwners onlyCreator { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } dailyLimit = _dailyLimit; owners = _owners; required = _required; onceSetOwners = onceSetOwners - 1; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool confirmed = isConfirmed(transactionId); if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!confirmed) spentToday -= tx.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "33739.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000000000000;                        // Update total supply (100000 for example) name = \"StakeIt\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"STAKE\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33979.sol", "label": 0, "sol content": "pragma solidity 0.4.15; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "37051.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; /** * * @author  David Rosen <[email\u00a0protected]> * * Version A * * Overview: * This divides all incoming funds among various `activity` accounts. The division cannot be changed * after the contract is locked. */ // -------------------------- //  R Split Contract // -------------------------- contract OrganizeFunds { struct ActivityAccount { uint credited;   // total funds credited to this account uint balance;    // current balance = credited - amount withdrawn uint pctx10;     // percent allocation times ten address addr;    // payout addr of this acct } uint constant TENHUNDWEI = 1000;                     // need gt. 1000 wei to distribute uint constant MAX_ACCOUNTS = 10;                     // max accounts this contract can handle event MessageEvent(string message); event MessageEventI(string message, uint val); bool public isLocked; address public owner;                                // deployer executor mapping (uint => ActivityAccount) activityAccounts;  // accounts by index uint public activityCount;                           // how many activity accounts uint public totalFundsReceived;                      // amount received since begin of time uint public totalFundsDistributed;                   // amount distributed since begin of time uint public totalFundsWithdrawn;                     // amount withdrawn since begin of time uint public withdrawGas = 100000;                    // gas for withdrawals modifier ownerOnly { require(msg.sender == owner); _; } modifier unlockedOnly { require(!isLocked); _; } // // constructor // function OrganizeFunds() { owner = msg.sender; } function lock() public ownerOnly { isLocked = true; } // // reset // reset all accounts // in case we have any funds that have not been withdrawn, they become  newly received and undistributed. // function reset() public ownerOnly unlockedOnly { totalFundsReceived = this.balance; totalFundsDistributed = 0; totalFundsWithdrawn = 0; activityCount = 0; MessageEvent(\"ok: all accts reset\"); } // // set withdrawal gas // nonstandard gas is necessary to support push-withdrawals to other contract // function setWitdrawGas(uint256 _withdrawGas) public ownerOnly unlockedOnly { withdrawGas = _withdrawGas; MessageEventI(\"ok: withdraw gas set\", withdrawGas); } // // add a new account // function addAccount(address _addr, uint256 _pctx10) public ownerOnly unlockedOnly { if (activityCount >= MAX_ACCOUNTS) { MessageEvent(\"err: max accounts\"); return; } activityAccounts[activityCount].addr = _addr; activityAccounts[activityCount].pctx10 = _pctx10; activityAccounts[activityCount].credited = 0; activityAccounts[activityCount].balance = 0; ++activityCount; MessageEvent(\"ok: acct added\"); } // ---------------------------- // get acct info // ---------------------------- function getAccountInfo(address _addr) public constant returns(uint _idx, uint _pctx10, uint _credited, uint _balance) { for (uint i = 0; i < activityCount; i++ ) { address addr = activityAccounts[i].addr; if (addr == _addr) { _idx = i; _pctx10 = activityAccounts[i].pctx10; _credited = activityAccounts[i].credited; _balance = activityAccounts[i].balance; return; } } } // // get total percentages x10 // function getTotalPctx10() public constant returns(uint _totalPctx10) { _totalPctx10 = 0; for (uint i = 0; i < activityCount; i++ ) { _totalPctx10 += activityAccounts[i].pctx10; } } // // default payable function. // call us with plenty of gas, or catastrophe will ensue // function () payable { totalFundsReceived += msg.value; MessageEventI(\"ok: received\", msg.value); } // // distribute funds to all activities // function distribute() public { //only payout if we have more than 1000 wei if (this.balance < TENHUNDWEI) { return; } //each account gets their prescribed percentage of this holdover. uint i; uint pctx10; uint acctDist; for (i = 0; i < activityCount; i++ ) { pctx10 = activityAccounts[i].pctx10; acctDist = totalFundsReceived * pctx10 / TENHUNDWEI; //we also double check to ensure that the amount credited cannot exceed the total amount due to this acct if (activityAccounts[i].credited >= acctDist) { acctDist = 0; } else { acctDist = acctDist - activityAccounts[i].credited; } activityAccounts[i].credited += acctDist; activityAccounts[i].balance += acctDist; totalFundsDistributed += acctDist; } MessageEvent(\"ok: distributed funds\"); } // // withdraw actvity balance // can be called by owner to push funds to another contract // function withdraw() public { for (uint i = 0; i < activityCount; i++ ) { address addr = activityAccounts[i].addr; if (addr == msg.sender || msg.sender == owner) { uint amount = activityAccounts[i].balance; if (amount > 0) { activityAccounts[i].balance = 0; totalFundsWithdrawn += amount; if (!addr.call.gas(withdrawGas).value(amount)()) { //put back funds in case of err activityAccounts[i].balance = amount; totalFundsWithdrawn -= amount; MessageEvent(\"err: error sending funds\"); return; } } } } } // // suicide // function hariKari() public ownerOnly unlockedOnly { selfdestruct(owner); } } "}
{"sol name": "33206.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract ZipperMultisigFactory { address zipper; function ZipperMultisigFactory(address _zipper) public { zipper = _zipper; } function createMultisig() public returns (address _multisig) { address[] memory addys = new address[](2); addys[0] = zipper; addys[1] = msg.sender; MultiSigWallet a = new MultiSigWallet(addys, 2); MultisigCreated(a, msg.sender, zipper); return a; } function changeZipper(address _newZipper) public { require(msg.sender == zipper); zipper = _newZipper; } event MultisigCreated(address _multisig, address indexed _sender, address indexed _zipper); } // b7f01af8bd882501f6801eb1eea8b22aa2a4979e from https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "31356.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; /** * HauroPay Presale. More info www.hauropay.com. * Designed by www.coincrowd.it. */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() internal { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Authorizable * @dev The Authorizable contract has authorized addresses, and provides basic authorization control * functions, this simplifies the implementation of \"multiple user permissions\". */ contract Authorizable is Ownable { mapping(address => bool) public authorized; event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization); /** * @dev The Authorizable constructor sets the first `authorized` of the contract to the sender * account. */ function Authorizable() public { authorized[msg.sender] = true; } /** * @dev Throws if called by any account other than the authorized. */ modifier onlyAuthorized() { require(authorized[msg.sender]); _; } /** * @dev Allows the current owner to set an authorization. * @param addressAuthorized The address to change authorization. */ function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public { AuthorizationSet(addressAuthorized, authorization); authorized[addressAuthorized] = authorization; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token from an address to another specified address * @param _sender The address to transfer from. * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[_sender]); // SafeMath.sub will throw if there is not enough balance. balances[_sender] = balances[_sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(_sender, _to, _value); return true; } /** * @dev transfer token for a specified address (BasicToken transfer method) */ function transfer(address _to, uint256 _value) public returns (bool) { return transferFunction(msg.sender, _to, _value); } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC223TokenCompatible is BasicToken { using SafeMath for uint256; event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data); // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if( isContract(_to) ) { _to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); return true; } // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) { return transfer( _to, _value, _data, \"tokenFallback(address,uint256,bytes)\"); } //assemble the given address bytecode. If bytecode exists then the _addr is a contract. function isContract(address _addr) private view returns (bool is_contract) { uint256 length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Startable * @dev Base contract which allows owner to implement an start mechanism without ever being stopped more. */ contract Startable is Ownable, Authorizable { event Start(); bool public started = false; /** * @dev Modifier to make a function callable only when the contract is started. */ modifier whenStarted() { require( started || authorized[msg.sender] ); _; } /** * @dev called by the owner to start, go to normal state */ function start() onlyOwner public { started = true; Start(); } } /** * @title Startable token * * @dev StandardToken modified with startable transfers. **/ contract StartToken is Startable, ERC223TokenCompatible, StandardToken { function transfer(address _to, uint256 _value) public whenStarted returns (bool) { return super.transfer(_to, _value); } function transfer(address _to, uint256 _value, bytes _data) public whenStarted returns (bool) { return super.transfer(_to, _value, _data); } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenStarted returns (bool) { return super.transfer(_to, _value, _data, _custom_fallback); } function transferFrom(address _from, address _to, uint256 _value) public whenStarted returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenStarted returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenStarted returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract HumanStandardToken is StandardToken, StartToken { /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { approve(_spender, _value); require(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData)); return true; } } contract BurnToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Function to burn tokens. * @param _burner The address of token holder. * @param _value The amount of token to be burned. */ function burnFunction(address _burner, uint256 _value) internal returns (bool) { require(_value > 0); require(_value <= balances[_burner]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_burner] = balances[_burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_burner, _value); return true; } /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public returns(bool) { return burnFunction(msg.sender, _value); } /** * @dev Burns tokens from one address * @param _from address The address which you want to burn tokens from * @param _value uint256 the amount of tokens to be burned */ function burnFrom(address _from, uint256 _value) public returns (bool) { require(_value <= allowed[_from][msg.sender]); // check if it has the budget allowed burnFunction(_from, _value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); return true; } } contract OriginToken is Authorizable, BasicToken, BurnToken { /** * @dev transfer token from tx.orgin to a specified address (onlyAuthorized contract) */ function originTransfer(address _to, uint256 _value) onlyAuthorized public returns (bool) { return transferFunction(tx.origin, _to, _value); } /** * @dev Burns a specific amount of tokens from tx.orgin. (onlyAuthorized contract) * @param _value The amount of token to be burned. */ function originBurn(uint256 _value) onlyAuthorized public returns(bool) { return burnFunction(tx.origin, _value); } } contract Token is ERC223TokenCompatible, StandardToken, StartToken, HumanStandardToken, BurnToken, OriginToken { uint256 public totalSupply; uint256 public initialSupply; uint8 public decimals; string public name; string public symbol; function Token(uint256 _totalSupply, uint8 _decimals, string _name, string _symbol) public { decimals = _decimals; totalSupply = _totalSupply * 10 ** uint(decimals); initialSupply = totalSupply; name = _name; symbol = _symbol; balances[msg.sender] = totalSupply; Transfer(0, msg.sender, totalSupply); } } contract Presale is Ownable { using SafeMath for uint256; Token public tokenContract; uint8 public decimals; uint256 public tokenValue;  // 1 Token in wei uint256 public centToken; // euro cents value of 1 token uint256 public endTime;  // seconds from 1970-01-01T00:00:00Z uint256 public startTime;  // seconds from 1970-01-01T00:00:00Z function Presale() public { //Configuration centToken = 25; // Euro cents value of 1 token tokenValue = 402693728269933; // centToken in wei of ether 04/12/2017 startTime = 1513625400; // 18/12/2017 20:30 UTC+1 endTime = 1516476600; // 20/01/2018 20:30 UTC+1 uint256 totalSupply = 12000000; // 12.000.000 * 0.25\u20ac = 3.000.000\u20ac CAPPED decimals = 18; string memory name = \"MethaVoucher\"; string memory symbol = \"MTV\"; //End Configuration tokenContract = new Token(totalSupply, decimals, name, symbol); //tokenContract.setAuthorized(this, true); // Authorizable constructor set msg.sender to true tokenContract.transferOwnership(msg.sender); } address public updater;  // account in charge of updating the token value event UpdateValue(uint256 newValue); function updateValue(uint256 newValue) public { require(msg.sender == updater || msg.sender == owner); tokenValue = newValue; UpdateValue(newValue); } function updateUpdater(address newUpdater) public onlyOwner { updater = newUpdater; } function updateTime(uint256 _newStart, uint256 _newEnd) public onlyOwner { if ( _newStart != 0 ) startTime = _newStart; if ( _newEnd != 0 ) endTime = _newEnd; } event Buy(address buyer, uint256 value); function buy(address _buyer) public payable returns(uint256) { require(now > startTime); // check if started require(now < endTime); // check if ended require(msg.value > 0); uint256 remainingTokens = tokenContract.balanceOf(this); require( remainingTokens > 0 ); // Check if there are any remaining tokens uint256 oneToken = 10 ** uint256(decimals); uint256 tokenAmount = msg.value.mul(oneToken).div(tokenValue); if ( remainingTokens < tokenAmount ) { uint256 refund = (tokenAmount - remainingTokens).mul(tokenValue).div(oneToken); tokenAmount = remainingTokens; owner.transfer(msg.value-refund); remainingTokens = 0; // set remaining token to 0 _buyer.transfer(refund); } else { remainingTokens = remainingTokens.sub(tokenAmount); // update remaining token without bonus owner.transfer(msg.value); } tokenContract.transfer(_buyer, tokenAmount); Buy(_buyer, tokenAmount); return tokenAmount; } function withdraw(address to, uint256 value) public onlyOwner { to.transfer(value); } function updateTokenContract(address _tokenContract) public onlyOwner { tokenContract = Token(_tokenContract); } function withdrawTokens(address to, uint256 value) public onlyOwner returns (bool) { return tokenContract.transfer(to, value); } function () public payable { buy(msg.sender); } } "}
{"sol name": "32072.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract GBIT is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function GBIT( ) { balances[msg.sender] = 500000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 500000000;                        // Update total supply (100000 for example) name = \"GBIT\";                                   // Set the name for display purposes decimals = 2;                            // Amount of decimals for display purposes symbol = \"GBT\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "38751.sol", "label": 0, "sol content": "pragma solidity ^0.4.2; /* The token is used as a voting shares */ contract token { mapping (address => uint256) public balanceOf;  } /* define 'owned' */ contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) throw; _; } function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract tokenRecipient { event receivedEther(address sender, uint amount); event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData); function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData){ Token t = Token(_token); if (!t.transferFrom(_from, this, _value)) throw; receivedTokens(_from, _value, _token, _extraData); } function () payable { receivedEther(msg.sender, msg.value); } } contract Token { function transferFrom(address _from, address _to, uint256 _value) returns (bool success); } /* The democracy contract itself */ contract Association is owned, tokenRecipient { /* Contract Variables and events */ uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; token public sharesTokenAddress; event ProposalAdded(uint proposalID, address recipient, uint amount, string description); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint result, uint quorum, bool active); event ChangeOfRules(uint minimumQuorum, uint debatingPeriodInMinutes, address sharesTokenAddress); struct Proposal { address recipient; uint amount; string description; uint votingDeadline; bool executed; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; } struct Vote { bool inSupport; address voter; } /* modifier that allows only shareholders to vote and create new proposals */ modifier onlyShareholders { if (sharesTokenAddress.balanceOf(msg.sender) == 0) throw; _; } /* First time setup */ function Association(token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) payable { changeVotingRules(sharesAddress, minimumSharesToPassAVote, minutesForDebate); } /*change rules*/ function changeVotingRules(token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) onlyOwner { sharesTokenAddress = token(sharesAddress); if (minimumSharesToPassAVote == 0 ) minimumSharesToPassAVote = 1; minimumQuorum = minimumSharesToPassAVote; debatingPeriodInMinutes = minutesForDebate; ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, sharesTokenAddress); } /* Function to create a new proposal */ function newProposal( address beneficiary, uint etherAmount, string JobDescription, bytes transactionBytecode ) onlyShareholders returns (uint proposalID) { proposalID = proposals.length++; Proposal p = proposals[proposalID]; p.recipient = beneficiary; p.amount = etherAmount; p.description = JobDescription; p.proposalHash = sha3(beneficiary, etherAmount, transactionBytecode); p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes; p.executed = false; p.proposalPassed = false; p.numberOfVotes = 0; ProposalAdded(proposalID, beneficiary, etherAmount, JobDescription); numProposals = proposalID+1; return proposalID; } /* function to check if a proposal code matches */ function checkProposalCode( uint proposalNumber, address beneficiary, uint etherAmount, bytes transactionBytecode ) constant returns (bool codeChecksOut) { Proposal p = proposals[proposalNumber]; return p.proposalHash == sha3(beneficiary, etherAmount, transactionBytecode); } /* */ function vote(uint proposalNumber, bool supportsProposal) onlyShareholders returns (uint voteID) { Proposal p = proposals[proposalNumber]; if (p.voted[msg.sender] == true) throw; voteID = p.votes.length++; p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender}); p.voted[msg.sender] = true; p.numberOfVotes = voteID +1; Voted(proposalNumber,  supportsProposal, msg.sender); return voteID; } function executeProposal(uint proposalNumber, bytes transactionBytecode) { Proposal p = proposals[proposalNumber]; /* Check if the proposal can be executed */ if (now < p.votingDeadline  /* has the voting deadline arrived? */ ||  p.executed        /* has it been already executed? */ ||  p.proposalHash != sha3(p.recipient, p.amount, transactionBytecode)) /* Does the transaction code match the proposal? */ throw; /* tally the votes */ uint quorum = 0; uint yea = 0; uint nay = 0; for (uint i = 0; i <  p.votes.length; ++i) { Vote v = p.votes[i]; uint voteWeight = sharesTokenAddress.balanceOf(v.voter); quorum += voteWeight; if (v.inSupport) { yea += voteWeight; } else { nay += voteWeight; } } /* execute result */ if (quorum <= minimumQuorum) { /* Not enough significant voters */ throw; } else if (yea > nay ) { /* has quorum and was approved */ p.executed = true; if (!p.recipient.call.value(p.amount * 1 ether)(transactionBytecode)) { throw; } p.proposalPassed = true; } else { p.proposalPassed = false; } // Fire Events ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed); } } "}
{"sol name": "34222.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract SISIPI is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function SISIPI( ) { balances[msg.sender] = 1000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000;                        // Update total supply (100000 for example) name = \"SISIPI\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"SISI\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "40460.sol", "label": 0, "sol content": "// <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize srl, Thomas Bertani Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { address oraclizeAddr = OAR.getAddress(); if (oraclizeAddr == 0){ oraclize_setNetwork(networkID_auto); oraclizeAddr = OAR.getAddress(); } oraclize = OraclizeI(oraclizeAddr); _ } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _ } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){ OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd); return true; } if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } return mint; } } // </ORACLIZE_API> contract Dice is usingOraclize { uint public pwin = 5000; //probability of winning (10000 = 100%) uint public edge = 200; //edge percentage (10000 = 100%) uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint public minBet = 1 finney; uint public maxInvestors = 5; //maximum number of investors uint public ownerEdge = 50; //edge percentage (10000 = 100%) uint public divestFee = 50; //divest fee percentage (10000 = 100%) uint constant safeGas = 25000; uint constant oraclizeGasLimit = 150000; struct Investor { address user; uint capital; } mapping(uint => Investor) investors; //starts at 1 uint public numInvestors = 0; mapping(address => uint) investorIDs; uint public invested = 0; address owner; bool public isStopped; struct Bet { address user; uint bet; // amount uint roll; // result uint fee; } mapping (bytes32 => Bet) bets; bytes32[] betsKeys; uint public amountWagered = 0; int public profit = 0; int public takenProfit = 0; int public ownerProfit = 0; function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); pwin = pwinInitial; edge = edgeInitial; maxWin = maxWinInitial; minBet = minBetInitial; maxInvestors = maxInvestorsInitial; ownerEdge = ownerEdgeInitial; divestFee = divestFeeInitial; owner = msg.sender; } function() { bet(); } function bet() { if (isStopped) throw; uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit); if (msg.value < oraclizeFee) throw; uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\", 'BDXJhrVpBJ53o2CxlJRlQtZJKZqLYt5IQe+73YDS4HtNjS5HodbIB3tvfow7UquyAk085VkLnL9EpKgwqWQz7ZLdGvsQlRd2sKxIolNg9DbnfPspGqLhLbbYSVnN8CwvsjpAXcSSo3c+4cNwC90yF4oNibkvD3ytapoZ7goTSyoUYTfwSjnw3ti+HJVH7N3+c0iwOCqZjDdsGQUcX3m3S/IHWbOOQQ5osO4Lbj3Gg0x1UdNtfUzYCFY79nzYgWIQEFCuRBI0n6NBvBQW727+OsDRY0J/9/gjt8ucibHWic0=', oraclizeGasLimit); // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}' bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee); betsKeys.push(myid); } else { throw; // invalid bet size } } function numBets() constant returns(uint) { return betsKeys.length; } function minBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit); return oraclizeFee+minBet; } function safeSend(address addr, uint value) internal { if (!(addr.call.gas(safeGas).value(value)())){ ownerProfit += int(value); } } function __callback(bytes32 myid, string result, bytes proof) { if (msg.sender != oraclize_cbAddress()) throw; Bet thisBet = bets[myid]; if (thisBet.bet>0) { if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) { uint roll = parseInt(result); if (roll<1 || roll>10000){ safeSend(thisBet.user, thisBet.bet); return; } bets[myid].roll = roll; int profitDiff; if (roll-1 < pwin) { //win uint winAmount = (thisBet.bet * (10000 - edge)) / pwin; safeSend(thisBet.user, winAmount); profitDiff = int(thisBet.bet - winAmount); } else { //lose safeSend(thisBet.user, 1); profitDiff = int(thisBet.bet) - 1; } ownerProfit += (profitDiff*int(ownerEdge))/10000; profit += profitDiff-(profitDiff*int(ownerEdge))/10000; amountWagered += thisBet.bet; } else { //bet is too big (bankroll may have changed since the bet was made) safeSend(thisBet.user, thisBet.bet); } } } function getBet(uint id) constant returns(address, uint, uint, uint) { if(id<betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee); } } function invest() { if (isStopped) throw; if (investorIDs[msg.sender]>0) { rebalance(); investors[investorIDs[msg.sender]].capital += msg.value; invested += msg.value; } else { rebalance(); uint investorID = 0; if (numInvestors<maxInvestors) { investorID = ++numInvestors; } else { for (uint i=1; i<=numInvestors; i++) { if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) { investorID = i; } } } if (investorID>0) { if (investors[investorID].capital>0) { divest(investors[investorID].user, investors[investorID].capital); investorIDs[investors[investorID].user] = 0; } if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) { investors[investorID].user = msg.sender; investors[investorID].capital = msg.value; invested += msg.value; investorIDs[msg.sender] = investorID; } else { throw; } } else { throw; } } } function rebalance() private { if (takenProfit != profit) { uint newInvested = 0; uint initialBankroll = getBankroll(); for (uint i=1; i<=numInvestors; i++) { investors[i].capital = getBalance(investors[i].user); newInvested += investors[i].capital; } invested = newInvested; if (newInvested != initialBankroll && numInvestors>0) { ownerProfit += int(initialBankroll - newInvested); //give the rounding error to the first investor invested += (initialBankroll - newInvested); } takenProfit = profit; } } function divest(address user, uint amount) private { if (investorIDs[user]>0) { rebalance(); if (amount>getBalance(user)) { amount = getBalance(user); } investors[investorIDs[user]].capital -= amount; invested -= amount; uint newAmount = (amount*divestFee)/10000; // take a fee from the deinvest amount ownerProfit += int(newAmount); safeSend(user, (amount-newAmount)); } } function divest(uint amount) { if (msg.value>0) throw; divest(msg.sender, amount); } function divest() { if (msg.value>0) throw; divest(msg.sender, getBalance(msg.sender)); } function getBalance(address user) constant returns(uint) { if (investorIDs[user]>0 && invested>0) { return investors[investorIDs[user]].capital * getBankroll() / invested; } else { return 0; } } function getBankroll() constant returns(uint) { uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit); if (this.balance < bankroll){ log0(\"bankroll_mismatch\"); bankroll = this.balance; } return bankroll; } function getMinInvestment() constant returns(uint) { if (numInvestors<maxInvestors) { return 0; } else { uint investorID; for (uint i=1; i<=numInvestors; i++) { if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) { investorID = i; } } return getBalance(investors[investorID].user); } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) { return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length); } function stopContract() { if (owner != msg.sender) throw; isStopped = true; } function resumeContract() { if (owner != msg.sender) throw; isStopped = false; } function forceDivestAll() { forceDivestAll(false); } function forceDivestAll(bool ownerTakeChangeAndProfit) { if (owner != msg.sender) throw; for (uint investorID=1; investorID<=numInvestors; investorID++) { divest(investors[investorID].user, getBalance(investors[investorID].user)); } if (ownerTakeChangeAndProfit) owner.send(this.balance); } function ownerTakeProfit() { ownerTakeProfit(false); } function ownerTakeProfit(bool takeChange) { if (owner != msg.sender) throw; if (takeChange){ uint investorsCapital = 0; for (uint i=1; i<=numInvestors; i++) { investorsCapital += investors[i].capital; } if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){ owner.send(this.balance); ownerProfit = 0; } } else { owner.send(uint(ownerProfit)); ownerProfit = 0; } } } "}
{"sol name": "420.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "990.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "801.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "32700.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "22500.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "520.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "721.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "22480.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "31890.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "21750.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
