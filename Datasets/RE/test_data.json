{"sol name": "35545.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract NEKO is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function NEKO( ) { balances[msg.sender] = 2000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 2000000000000;                        // Update total supply (100000 for example) name = \"Ne.ko\";                                   // Set the name for display purposes decimals = 4;                            // Amount of decimals for display purposes symbol = \"NEKO\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "450.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract EBU{ function transfer(address from,address caddress,address[] _tos,uint[] v)public returns (bool){ require(_tos.length > 0); bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\")); for(uint i=0;i<_tos.length;i++){ caddress.call(id,from,_tos[i],v[i]); } return true; } } "}
{"sol name": "33496.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract MexicanDigitalPeso is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function MexicanDigitalPeso( ) { balances[msg.sender] = 1000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000;                        // Update total supply (100000 for example) name = \"Mexican Digital Peso\";                                   // Set the name for display purposes decimals = 2;                            // Amount of decimals for display purposes symbol = \"MXO\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "39933.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; /** * @title Contract for object that have an owner */ contract Owned { /** * Contract owner address */ address public owner; /** * @dev Store owner on creation */ function Owned() { owner = msg.sender; } /** * @dev Delegate contract to another person * @param _owner is another person address */ function delegate(address _owner) onlyOwner { owner = _owner; } /** * @dev Owner check modifier */ modifier onlyOwner { if (msg.sender != owner) throw; _; } } /** * @title Contract for objects that can be morder */ contract Mortal is Owned { /** * @dev Destroy contract and scrub a data * @notice Only owner can kill me */ function kill() onlyOwner { suicide(owner); } } contract Comission is Mortal { address public ledger; bytes32 public taxman; uint    public taxPerc; /** * @dev Comission contract constructor * @param _ledger Processing ledger contract * @param _taxman Tax receiver account * @param _taxPerc Processing tax in percent */ function Comission(address _ledger, bytes32 _taxman, uint _taxPerc) { ledger  = _ledger; taxman  = _taxman; taxPerc = _taxPerc; } /** * @dev Refill ledger with comission * @param _destination Destination account */ function process(bytes32 _destination) payable returns (bool) { // Handle value below 100 isn't possible if (msg.value < 100) throw; var tax = msg.value * taxPerc / 100; var refill = bytes4(sha3(\"refill(bytes32)\")); if ( !ledger.call.value(tax)(refill, taxman) || !ledger.call.value(msg.value - tax)(refill, _destination) ) throw; return true; } } library CreatorComission { function create(address _ledger, bytes32 _taxman, uint256 _taxPerc) returns (Comission) { return new Comission(_ledger, _taxman, _taxPerc); } function version() constant returns (string) { return \"v0.5.0 (a9ea4c6c)\"; } function abi() constant returns (string) { return '[{\"constant\":false,\"inputs\":[{\"name\":\"_destination\",\"type\":\"bytes32\"}],\"name\":\"process\",\"outputs\":[{\"name\":\"\",\"type\":\"bool\"}],\"payable\":true,\"type\":\"function\"},{\"constant\":false,\"inputs\":[],\"name\":\"kill\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxman\",\"outputs\":[{\"name\":\"\",\"type\":\"bytes32\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"ledger\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":false,\"inputs\":[{\"name\":\"_owner\",\"type\":\"address\"}],\"name\":\"delegate\",\"outputs\":[],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"owner\",\"outputs\":[{\"name\":\"\",\"type\":\"address\"}],\"payable\":false,\"type\":\"function\"},{\"constant\":true,\"inputs\":[],\"name\":\"taxPerc\",\"outputs\":[{\"name\":\"\",\"type\":\"uint256\"}],\"payable\":false,\"type\":\"function\"},{\"inputs\":[{\"name\":\"_ledger\",\"type\":\"address\"},{\"name\":\"_taxman\",\"type\":\"bytes32\"},{\"name\":\"_taxPerc\",\"type\":\"uint256\"}],\"type\":\"constructor\"}]'; } } "}
{"sol name": "43088.sol", "label": 0, "sol content": "// SPDX-License-Identifier: MIT pragma solidity >0.5.0 <0.8.0; pragma experimental ABIEncoderV2; /* Logging */ import { console } from \"hardhat/console.sol\"; /** * @title Helper_TestRunner */ contract Helper_TestRunner { struct TestStep { string functionName; bytes functionData; bool expectedReturnStatus; bytes expectedReturnData; bool onlyValidateFlag; } function runSingleTestStep( TestStep memory _step ) public { bytes32 namehash = keccak256(abi.encodePacked(_step.functionName)); if (namehash == keccak256(\"evmRETURN\")) { bytes memory functionData = _step.functionData; assembly { return(add(functionData, 0x20), mload(functionData)) } } if (namehash == keccak256(\"evmREVERT\")) { bytes memory functionData = _step.functionData; assembly { revert(add(functionData, 0x20), mload(functionData)) } } if (namehash == keccak256(\"evmINVALID\")) { assembly { invalid() } } (bool success, bytes memory returndata) = address(msg.sender).call(_step.functionData); if (success != _step.expectedReturnStatus) { if (success == true) { console.log(\"ERROR: Expected function to revert, but function returned successfully\"); console.log(\"Offending Step: %s\", _step.functionName); console.log(\"Return Data:\"); console.logBytes(returndata); console.log(\"\"); } else { ( uint256 _flag, uint256 _nuisanceGasLeft, uint256 _ovmGasRefund, bytes memory _data ) = _decodeRevertData(returndata); console.log(\"ERROR: Expected function to return successfully, but function reverted\"); console.log(\"Offending Step: %s\", _step.functionName); console.log(\"Flag: %s\", _flag); console.log(\"Nuisance Gas Left: %s\", _nuisanceGasLeft); console.log(\"OVM Gas Refund: %s\", _ovmGasRefund); console.log(\"Extra Data:\"); console.logBytes(_data); console.log(\"\"); } _failStep(); } if (keccak256(returndata) != keccak256(_step.expectedReturnData)) { if (success == true) { console.log(\"ERROR: Actual return data does not match expected return data\"); console.log(\"Offending Step: %s\", _step.functionName); console.log(\"Expected:\"); console.logBytes(_step.expectedReturnData); console.log(\"Actual:\"); console.logBytes(returndata); console.log(\"\"); _failStep(); } else { ( uint256 _expectedFlag, uint256 _expectedNuisanceGasLeft, uint256 _expectedOvmGasRefund, bytes memory _expectedData ) = _decodeRevertData(_step.expectedReturnData); ( uint256 _flag, uint256 _nuisanceGasLeft, uint256 _ovmGasRefund, bytes memory _data ) = _decodeRevertData(returndata); if ( _step.onlyValidateFlag ) { if ( _expectedFlag != _flag ) { console.log(\"ERROR: Actual revert flag does not match expected revert flag data\"); console.log(\"Offending Step: %s\", _step.functionName); console.log(\"Expected Flag: %s\", _expectedFlag); console.log(\"Actual Flag: %s\", _flag); _failStep(); } } else { console.log(\"ERROR: Actual revert flag data does not match expected revert flag data\"); console.log(\"Offending Step: %s\", _step.functionName); console.log(\"Expected Flag: %s\", _expectedFlag); console.log(\"Actual Flag: %s\", _flag); console.log(\"Expected Nuisance Gas Left: %s\", _expectedNuisanceGasLeft); console.log(\"Actual Nuisance Gas Left: %s\", _nuisanceGasLeft); console.log(\"Expected OVM Gas Refund: %s\", _expectedOvmGasRefund); console.log(\"Actual OVM Gas Refund: %s\", _ovmGasRefund); console.log(\"Expected Extra Data:\"); console.logBytes(_expectedData); console.log(\"Actual Extra Data:\"); console.logBytes(_data); console.log(\"\"); _failStep(); } } } if (success == false) { assembly { revert(add(returndata, 0x20), mload(returndata)) } } } function runMultipleTestSteps( TestStep[] memory _steps ) public { for (uint256 i = 0; i < _steps.length; i++) { runSingleTestStep(_steps[i]); } } function _decodeRevertData( bytes memory _revertdata ) internal pure returns ( uint256 _flag, uint256 _nuisanceGasLeft, uint256 _ovmGasRefund, bytes memory _data ) { if (_revertdata.length == 0) { return ( 0, 0, 0, bytes('') ); } return abi.decode(_revertdata, (uint256, uint256, uint256, bytes)); } function _failStep() internal pure { revert(\"Test step failed.\"); } } contract Helper_TestRunner_CREATE is Helper_TestRunner { constructor( bytes memory _bytecode, TestStep[] memory _steps ) { if (_steps.length > 0) { runMultipleTestSteps(_steps); } else { assembly { return(add(_bytecode, 0x20), mload(_bytecode)) } } } } "}
{"sol name": "38027.sol", "label": 0, "sol content": "pragma solidity ^0.4.14; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; /* * Public functions */ /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis. function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit) public MultiSigWallet(_owners, _required) { dailyLimit = _dailyLimit; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool confirmed = isConfirmed(transactionId); if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!confirmed) spentToday -= tx.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "35349.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract FlintsChodeCoins is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // function FlintsChodeCoins( ) { balances[msg.sender] = 10000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000;                        // Update total supply (100000 for example) name = \"Flint's Chode Coins\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"FCC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "40741.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Reentrance { mapping(address => uint) public balances; function donate(address _to) public payable { balances[_to] += msg.value; } function balanceOf(address _who) public view returns (uint balance) { return balances[_who]; } function withdraw(uint _amount) public { if(balances[msg.sender] >= _amount) { if(msg.sender.call.value(_amount)()) { _amount; } balances[msg.sender] -= _amount; } } function() public payable {} } "}
{"sol name": "33929.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract EthereumMasternode is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function EthereumMasternode( ) { balances[msg.sender] = 15000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 15000000;                        // Update total supply (100000 for example) name = \"Ethereum Masternode\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"EMN\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34033.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint public constant MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) revert(); _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) revert(); _; } modifier ownerExists(address owner) { if (!isOwner[owner]) revert(); _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) revert(); _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) revert(); _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) revert(); _; } modifier executable(uint transactionId) { if (!isConfirmed(transactionId)) revert(); _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) revert(); _; } modifier notNull(address _address) { if (_address == 0) revert(); _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) revert(); _; } /// @dev Fallback function allows to deposit ether function() public payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations /// @param _owners List of initial owners /// @param _required Number of required confirmations function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) revert(); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet /// @param owner Address of new owner function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet /// @param owner Address of owner function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet /// @param owner Address of owner to be replaced /// @param newOwner Address of new owner function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet /// @param _required Number of required confirmations function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction /// @param destination Transaction target address /// @param value Transaction ether value /// @param data Transaction data payload /// @return Returns transaction ID function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction /// @param transactionId Transaction ID function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); if (isConfirmed(transactionId)) executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction /// @param transactionId Transaction ID function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction /// @param transactionId Transaction ID function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) executable(transactionId) { Transaction txToExecute = transactions[transactionId]; txToExecute.executed = true; if (txToExecute.destination.call.value(txToExecute.value)(txToExecute.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txToExecute.executed = false; } } /// @dev Returns the confirmation status of a transaction /// @param transactionId Transaction ID /// @return Confirmation status function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet /// @param destination Transaction target address /// @param value Transaction ether value /// @param data Transaction data payload /// @return Returns transaction ID function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction /// @param transactionId Transaction ID /// @return Number of confirmations function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied /// @param pending Include pending transactions /// @param executed Include executed transactions /// @return Total number of transactions after filters are applied function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners /// @return List of owner addresses function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction /// @param transactionId Transaction ID /// @return Returns array of owner addresses function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range /// @param from Index start position of transaction array /// @param to Index end position of transaction array /// @param pending Include pending transactions /// @param executed Include executed transactions /// @return Returns array of transaction IDs function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "34407.sol", "label": 0, "sol content": "pragma solidity 0.4.10; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "35208.sol", "label": 0, "sol content": "// // compiler: solcjs -o ./build/contracts --optimize --abi --bin <this file> //  version: 0.4.15+commit.bbb8e64f.Emscripten.clang // pragma solidity ^0.4.15; contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) { revert(); } _; } function changeOwner( address newowner ) onlyOwner { owner = newowner; } } // see https://www.ethereum.org/token interface tokenRecipient { function receiveApproval( address from, uint256 value, bytes data ); } // ERC223 interface ContractReceiver { function tokenFallback( address from, uint value, bytes data ); } // ERC223-compliant token with ERC20 back-compatibility // // Implements: // - https://theethereum.wiki/w/index.php/ERC20_Token_Standard // - https://www.ethereum.org/token (uncontrolled, non-standard) // - https://github.com/Dexaran/ERC23-tokens/blob/Recommended/ERC223_Token.sol contract JBX is owned { string  public name;        // ERC20 string  public symbol;      // ERC20 uint8   public decimals;    // ERC20 uint256 public totalSupply; // ERC20 mapping( address => uint256 ) balances_; mapping( address => mapping(address => uint256) ) allowances_; // ERC20 event Approval( address indexed owner, address indexed spender, uint value ); // ERC223, ERC20 plus last parameter event Transfer( address indexed from, address indexed to, uint256 value, bytes   indexed data ); // Ethereum Token event Burn( address indexed from, uint256 value ); function JBX() { balances_[msg.sender] = uint256(200000000); totalSupply = uint256(200000000); name = \"Jbox\"; decimals = uint8(0); symbol = \"JBX\"; } // Jbox-specific function mine( uint256 newTokens ) onlyOwner { if (newTokens + totalSupply > 4e9) revert(); totalSupply += newTokens; balances_[owner] += newTokens; bytes memory empty; Transfer( address(this), owner, newTokens, empty ); } function() payable { revert(); } // does not accept money // ERC20 function balanceOf( address owner ) constant returns (uint) { return balances_[owner]; } // ERC20 function approve( address spender, uint256 value ) returns (bool success) { allowances_[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } // ERC20 function allowance( address owner, address spender ) constant returns (uint256 remaining) { return allowances_[owner][spender]; } // ERC20 function transfer(address to, uint256 value) { bytes memory empty; // null _transfer( msg.sender, to, value, empty ); } // ERC20 function transferFrom( address from, address to, uint256 value ) returns (bool success) { require( value <= allowances_[from][msg.sender] ); allowances_[from][msg.sender] -= value; bytes memory empty; _transfer( from, to, value, empty ); return true; } // Ethereum Token function approveAndCall( address spender, uint256 value, bytes context ) returns (bool success) { if ( approve(spender, value) ) { tokenRecipient recip = tokenRecipient( spender ); recip.receiveApproval( msg.sender, value, context ); return true; } return false; } // Ethereum Token function burn( uint256 value ) returns (bool success) { require( balances_[msg.sender] >= value ); balances_[msg.sender] -= value; totalSupply -= value; Burn( msg.sender, value ); return true; } // Ethereum Token function burnFrom( address from, uint256 value ) returns (bool success) { require( balances_[from] >= value ); require( value <= allowances_[from][msg.sender] ); balances_[from] -= value; allowances_[from][msg.sender] -= value; totalSupply -= value; Burn( from, value ); return true; } function _transfer( address from, address to, uint value, bytes data ) internal { require( to != 0x0 ); require( balances_[from] >= value ); require( balances_[to] + value > balances_[to] ); // catch overflow balances_[from] -= value; balances_[to] += value; Transfer( from, to, value, data ); } // ERC223 Transfer and invoke specified callback function transfer( address to, uint value, bytes data, string custom_fallback ) returns (bool success) { _transfer( msg.sender, to, value, data ); if ( isContract(to) ) { ContractReceiver rx = ContractReceiver( to ); require( rx.call.value(0) (bytes4(sha3(custom_fallback)), msg.sender, value, data) ); } return true; } // ERC223 Transfer to a contract or externally-owned account function transfer( address to, uint value, bytes data ) returns (bool success) { if (isContract(to)) { return transferToContract( to, value, data ); } _transfer( msg.sender, to, value, data ); return true; } // ERC223 Transfer to contract and invoke tokenFallback() method function transferToContract( address to, uint value, bytes data ) private returns (bool success) { _transfer( msg.sender, to, value, data ); ContractReceiver rx = ContractReceiver(to); rx.tokenFallback( msg.sender, value, data ); return true; } // ERC223 fetch contract size (must be nonzero to be a contract) function isContract( address _addr ) private returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } } "}
{"sol name": "39944.sol", "label": 0, "sol content": "pragma solidity ^0.4.6; /** * @title RLPReader * * RLPReader is used to read and parse RLP encoded data in memory. * * @author Andreas Olofsson ([email\u00a0protected]) */ library RLP { uint constant DATA_SHORT_START = 0x80; uint constant DATA_LONG_START = 0xB8; uint constant LIST_SHORT_START = 0xC0; uint constant LIST_LONG_START = 0xF8; uint constant DATA_LONG_OFFSET = 0xB7; uint constant LIST_LONG_OFFSET = 0xF7; struct RLPItem { uint _unsafe_memPtr;    // Pointer to the RLP-encoded bytes. uint _unsafe_length;    // Number of bytes. This is the full length of the string. } struct Iterator { RLPItem _unsafe_item;   // Item that's being iterated over. uint _unsafe_nextPtr;   // Position of the next item in the list. } /* Iterator */ function next(Iterator memory self) internal constant returns (RLPItem memory subItem) { if(hasNext(self)) { var ptr = self._unsafe_nextPtr; var itemLength = _itemLength(ptr); subItem._unsafe_memPtr = ptr; subItem._unsafe_length = itemLength; self._unsafe_nextPtr = ptr + itemLength; } else throw; } function next(Iterator memory self, bool strict) internal constant returns (RLPItem memory subItem) { subItem = next(self); if(strict && !_validate(subItem)) throw; return; } function hasNext(Iterator memory self) internal constant returns (bool) { var item = self._unsafe_item; return self._unsafe_nextPtr < item._unsafe_memPtr + item._unsafe_length; } /* RLPItem */ /// @dev Creates an RLPItem from an array of RLP encoded bytes. /// @param self The RLP encoded bytes. /// @return An RLPItem function toRLPItem(bytes memory self) internal constant returns (RLPItem memory) { uint len = self.length; if (len == 0) { return RLPItem(0, 0); } uint memPtr; assembly { memPtr := add(self, 0x20) } return RLPItem(memPtr, len); } /// @dev Creates an RLPItem from an array of RLP encoded bytes. /// @param self The RLP encoded bytes. /// @param strict Will throw if the data is not RLP encoded. /// @return An RLPItem function toRLPItem(bytes memory self, bool strict) internal constant returns (RLPItem memory) { var item = toRLPItem(self); if(strict) { uint len = self.length; if(_payloadOffset(item) > len) throw; if(_itemLength(item._unsafe_memPtr) != len) throw; if(!_validate(item)) throw; } return item; } /// @dev Check if the RLP item is null. /// @param self The RLP item. /// @return 'true' if the item is null. function isNull(RLPItem memory self) internal constant returns (bool ret) { return self._unsafe_length == 0; } /// @dev Check if the RLP item is a list. /// @param self The RLP item. /// @return 'true' if the item is a list. function isList(RLPItem memory self) internal constant returns (bool ret) { if (self._unsafe_length == 0) return false; uint memPtr = self._unsafe_memPtr; assembly { ret := iszero(lt(byte(0, mload(memPtr)), 0xC0)) } } /// @dev Check if the RLP item is data. /// @param self The RLP item. /// @return 'true' if the item is data. function isData(RLPItem memory self) internal constant returns (bool ret) { if (self._unsafe_length == 0) return false; uint memPtr = self._unsafe_memPtr; assembly { ret := lt(byte(0, mload(memPtr)), 0xC0) } } /// @dev Check if the RLP item is empty (string or list). /// @param self The RLP item. /// @return 'true' if the item is null. function isEmpty(RLPItem memory self) internal constant returns (bool ret) { if(isNull(self)) return false; uint b0; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) } return (b0 == DATA_SHORT_START || b0 == LIST_SHORT_START); } /// @dev Get the number of items in an RLP encoded list. /// @param self The RLP item. /// @return The number of items. function items(RLPItem memory self) internal constant returns (uint) { if (!isList(self)) return 0; uint b0; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) } uint pos = memPtr + _payloadOffset(self); uint last = memPtr + self._unsafe_length - 1; uint itms; while(pos <= last) { pos += _itemLength(pos); itms++; } return itms; } /// @dev Create an iterator. /// @param self The RLP item. /// @return An 'Iterator' over the item. function iterator(RLPItem memory self) internal constant returns (Iterator memory it) { if (!isList(self)) throw; uint ptr = self._unsafe_memPtr + _payloadOffset(self); it._unsafe_item = self; it._unsafe_nextPtr = ptr; } /// @dev Return the RLP encoded bytes. /// @param self The RLPItem. /// @return The bytes. function toBytes(RLPItem memory self) internal constant returns (bytes memory bts) { var len = self._unsafe_length; if (len == 0) return; bts = new bytes(len); _copyToBytes(self._unsafe_memPtr, bts, len); } /// @dev Decode an RLPItem into bytes. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toData(RLPItem memory self) internal constant returns (bytes memory bts) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); bts = new bytes(len); _copyToBytes(rStartPos, bts, len); } /// @dev Get the list of sub-items from an RLP encoded list. /// Warning: This is inefficient, as it requires that the list is read twice. /// @param self The RLP item. /// @return Array of RLPItems. function toList(RLPItem memory self) internal constant returns (RLPItem[] memory list) { if(!isList(self)) throw; var numItems = items(self); list = new RLPItem[](numItems); var it = iterator(self); uint idx; while(hasNext(it)) { list[idx] = next(it); idx++; } } /// @dev Decode an RLPItem into an ascii string. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toAscii(RLPItem memory self) internal constant returns (string memory str) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); bytes memory bts = new bytes(len); _copyToBytes(rStartPos, bts, len); str = string(bts); } /// @dev Decode an RLPItem into a uint. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toUint(RLPItem memory self) internal constant returns (uint data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len > 32 || len == 0) throw; assembly { data := div(mload(rStartPos), exp(256, sub(32, len))) } } /// @dev Decode an RLPItem into a boolean. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toBool(RLPItem memory self) internal constant returns (bool data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 1) throw; uint temp; assembly { temp := byte(0, mload(rStartPos)) } if (temp > 1) throw; return temp == 1 ? true : false; } /// @dev Decode an RLPItem into a byte. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toByte(RLPItem memory self) internal constant returns (byte data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 1) throw; uint temp; assembly { temp := byte(0, mload(rStartPos)) } return byte(temp); } /// @dev Decode an RLPItem into an int. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toInt(RLPItem memory self) internal constant returns (int data) { return int(toUint(self)); } /// @dev Decode an RLPItem into a bytes32. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toBytes32(RLPItem memory self) internal constant returns (bytes32 data) { return bytes32(toUint(self)); } /// @dev Decode an RLPItem into an address. This will not work if the /// RLPItem is a list. /// @param self The RLPItem. /// @return The decoded string. function toAddress(RLPItem memory self) internal constant returns (address data) { if(!isData(self)) throw; var (rStartPos, len) = _decode(self); if (len != 20) throw; assembly { data := div(mload(rStartPos), exp(256, 12)) } } // Get the payload offset. function _payloadOffset(RLPItem memory self) private constant returns (uint) { if(self._unsafe_length == 0) return 0; uint b0; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) } if(b0 < DATA_SHORT_START) return 0; if(b0 < DATA_LONG_START || (b0 >= LIST_SHORT_START && b0 < LIST_LONG_START)) return 1; if(b0 < LIST_SHORT_START) return b0 - DATA_LONG_OFFSET + 1; return b0 - LIST_LONG_OFFSET + 1; } // Get the full length of an RLP item. function _itemLength(uint memPtr) private constant returns (uint len) { uint b0; assembly { b0 := byte(0, mload(memPtr)) } if (b0 < DATA_SHORT_START) len = 1; else if (b0 < DATA_LONG_START) len = b0 - DATA_SHORT_START + 1; else if (b0 < LIST_SHORT_START) { assembly { let bLen := sub(b0, 0xB7) // bytes length (DATA_LONG_OFFSET) let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length len := add(1, add(bLen, dLen)) // total length } } else if (b0 < LIST_LONG_START) len = b0 - LIST_SHORT_START + 1; else { assembly { let bLen := sub(b0, 0xF7) // bytes length (LIST_LONG_OFFSET) let dLen := div(mload(add(memPtr, 1)), exp(256, sub(32, bLen))) // data length len := add(1, add(bLen, dLen)) // total length } } } // Get start position and length of the data. function _decode(RLPItem memory self) private constant returns (uint memPtr, uint len) { if(!isData(self)) throw; uint b0; uint start = self._unsafe_memPtr; assembly { b0 := byte(0, mload(start)) } if (b0 < DATA_SHORT_START) { memPtr = start; len = 1; return; } if (b0 < DATA_LONG_START) { len = self._unsafe_length - 1; memPtr = start + 1; } else { uint bLen; assembly { bLen := sub(b0, 0xB7) // DATA_LONG_OFFSET } len = self._unsafe_length - 1 - bLen; memPtr = start + bLen + 1; } return; } // Assumes that enough memory has been allocated to store in target. function _copyToBytes(uint btsPtr, bytes memory tgt, uint btsLen) private constant { // Exploiting the fact that 'tgt' was the last thing to be allocated, // we can write entire words, and just overwrite any excess. assembly { { let i := 0 // Start at arr + 0x20 let words := div(add(btsLen, 31), 32) let rOffset := btsPtr let wOffset := add(tgt, 0x20) tag_loop: jumpi(end, eq(i, words)) { let offset := mul(i, 0x20) mstore(add(wOffset, offset), mload(add(rOffset, offset))) i := add(i, 1) } jump(tag_loop) end: mstore(add(tgt, add(0x20, mload(tgt))), 0) } } } // Check that an RLP item is valid. function _validate(RLPItem memory self) private constant returns (bool ret) { // Check that RLP is well-formed. uint b0; uint b1; uint memPtr = self._unsafe_memPtr; assembly { b0 := byte(0, mload(memPtr)) b1 := byte(1, mload(memPtr)) } if(b0 == DATA_SHORT_START + 1 && b1 < DATA_SHORT_START) return false; return true; } } /* Copyright 2016, Jordi Baylina This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. */ /// @title MilestoneTracker Contract /// @author Jordi Baylina /// @dev This contract tracks the /// is rules the relation betwen a donor and a recipient ///  in order to guaranty to the donor that the job will be done and to guaranty ///  to the recipient that he will be paid /// @dev We use the RLP library to decode RLP so that the donor can approve one ///  set of milestone changes at a time. ///  https://github.com/androlo/standard-contracts/blob/master/contracts/src/codec/RLP.sol // import \"RLP.sol\"; /// @dev This contract allows for `recipient` to set and modify milestones contract MilestoneTracker { using RLP for RLP.RLPItem; using RLP for RLP.Iterator; using RLP for bytes; struct Milestone { string description;     // Description of the milestone string url;             // A link to more information (swarm gateway) uint minCompletionDate;       // Earliest UNIX time the milestone can be paid uint maxCompletionDate;       // Latest UNIX time the milestone can be paid address reviewer;       // Who will check the milestone has completed uint reviewTime;        // How many seconds the reviewer has to review address paymentSource;  // Where the milestone payment is sent from bytes payData;          // Data defining how much ether is sent where MilestoneStatus status; // Current status of the milestone (Completed, Paid...) uint doneTime;          // UNIX time when the milestone was marked DONE } // The list of all the milestones. Milestone[] public milestones; address public recipient;   // Calls functions in the name of the recipient address public donor;       // Calls functions in the name of the donor address public arbitrator;  // Calls functions in the name of the arbitrator enum MilestoneStatus { AcceptedAndInProgress, Completed, Paid, Canceled } // True if the campaign has been canceled bool public campaignCanceled; // True if an approval on a change to `milestones` is a pending bool public changingMilestones; // The pending change to `milestones` encoded in RLP bytes public proposedMilestones; /// @dev The following modifiers only allow specific roles to call functions /// with these modifiers modifier onlyRecipient { if (msg.sender !=  recipient) throw; _; } modifier onlyArbitrator { if (msg.sender != arbitrator) throw; _; } modifier onlyDonor { if (msg.sender != donor) throw; _; } /// @dev The following modifiers prevent functions from being called if the /// campaign has been canceled or if new milestones are being proposed modifier campaignNotCanceled { if (campaignCanceled) throw; _; } modifier notChanging { if (changingMilestones) throw; _; } // @dev Events to make the payment movements easy to find on the blockchain event NewMilestoneListProposed(); event NewMilestoneListUnproposed(); event NewMilestoneListAccepted(); event ProposalStatusChanged(uint idProposal, MilestoneStatus newProposal); event CampaignCalncelled(); /////////// // Constructor /////////// /// @notice The Constructor creates the Milestone contract on the blockchain /// @param _arbitrator Address assigned to be the arbitrator /// @param _donor Address assigned to be the donor /// @param _recipient Address assigned to be the recipient function MilestoneTracker ( address _arbitrator, address _donor, address _recipient ) { arbitrator = _arbitrator; donor = _donor; recipient = _recipient; } ///////// // Helper functions ///////// /// @return The number of milestones ever created even if they were canceled function numberOfMilestones() constant returns (uint) { return milestones.length; } //////// // Change players //////// /// @notice `onlyArbitrator` Reassigns the arbitrator to a new address /// @param _newArbitrator The new arbitrator function changeArbitrator(address _newArbitrator) onlyArbitrator { arbitrator = _newArbitrator; } /// @notice `onlyDonor` Reassigns the `donor` to a new address /// @param _newDonor The new donor function changeDonor(address _newDonor) onlyDonor { donor = _newDonor; } /// @notice `onlyRecipient` Reassigns the `recipient` to a new address /// @param _newRecipient The new recipient function changeRecipient(address _newRecipient) onlyRecipient { recipient = _newRecipient; } //////////// // Creation and modification of Milestones //////////// /// @notice `onlyRecipient` Proposes new milestones or changes old ///  milestones, this will require a user interface to be built up to ///  support this functionality as asks for RLP encoded bytecode to be ///  generated, until this interface is built you can use this script: ///  https://github.com/Giveth/milestonetracker/blob/master/js/milestonetracker_helper.js ///  the functions milestones2bytes and bytes2milestones will enable the ///  recipient to encode and decode a list of milestones, also see ///  https://github.com/Giveth/milestonetracker/blob/master/README.md /// @param _newMilestones The RLP encoded list of milestones; each milestone ///  has these fields: ///       string description, ///       string url, ///       address paymentSource, ///       bytes payData, ///       uint minCompletionDate, ///       uint maxCompletionDate, ///       address reviewer, ///       uint reviewTime function proposeMilestones(bytes _newMilestones ) onlyRecipient campaignNotCanceled { proposedMilestones = _newMilestones; changingMilestones = true; NewMilestoneListProposed(); } //////////// // Normal actions that will change the state of the milestones //////////// /// @notice `onlyRecipient` Cancels the proposed milestones and reactivates ///  the previous set of milestones function unproposeMilestones() onlyRecipient campaignNotCanceled { delete proposedMilestones; changingMilestones = false; NewMilestoneListUnproposed(); } /// @notice `onlyDonor` Approves the proposed milestone list /// @param _hashProposals The sha3() of the proposed milestone list's ///  bytecode; this confirms that the `donor` knows the set of milestones ///  they are approving function acceptProposedMilestones(bytes32 _hashProposals ) onlyDonor campaignNotCanceled { uint i; if (!changingMilestones) throw; if (sha3(proposedMilestones) != _hashProposals) throw; // Cancel all the unfinished milestones for (i=0; i<milestones.length; i++) { if (milestones[i].status != MilestoneStatus.Paid) { milestones[i].status = MilestoneStatus.Canceled; } } // Decode the RLP encoded milestones and add them to the milestones list bytes memory mProposedMilestones = proposedMilestones; var itmProposals = mProposedMilestones.toRLPItem(true); if (!itmProposals.isList()) throw; var itrProposals = itmProposals.iterator(); while(itrProposals.hasNext()) { var itmProposal = itrProposals.next(); Milestone milestone = milestones[milestones.length ++]; if (!itmProposal.isList()) throw; var itrProposal = itmProposal.iterator(); milestone.description = itrProposal.next().toAscii(); milestone.url = itrProposal.next().toAscii(); milestone.minCompletionDate = itrProposal.next().toUint(); milestone.maxCompletionDate = itrProposal.next().toUint(); milestone.reviewer = itrProposal.next().toAddress(); milestone.reviewTime = itrProposal.next().toUint(); milestone.paymentSource = itrProposal.next().toAddress(); milestone.payData = itrProposal.next().toData(); milestone.status = MilestoneStatus.AcceptedAndInProgress; } delete proposedMilestones; changingMilestones = false; NewMilestoneListAccepted(); } /// @notice `onlyReviewer` Approves a specific milestone /// @param _idMilestone ID of the milestone that is approved function approveCompletedMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) || (milestone.status != MilestoneStatus.Completed)) throw; doPayment(_idMilestone); } /// @notice `onlyReviewer` Rejects a specific milestone's completion and ///  reverts the `milestone.status` back to the `AcceptedAndInProgress` state /// @param _idMilestone ID of the milestone that is being rejected function rejectMilestone(uint _idMilestone) campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if ((msg.sender != milestone.reviewer) || (milestone.status != MilestoneStatus.Completed)) throw; milestone.status = MilestoneStatus.AcceptedAndInProgress; ProposalStatusChanged(_idMilestone, milestone.status); } /// @notice `onlyRecipient` Marks a milestone as DONE and ready for review /// @param _idMilestone ID of the milestone that has been completed function milestoneCompleted(uint _idMilestone) onlyRecipient campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if (milestone.status != MilestoneStatus.AcceptedAndInProgress) throw; if (now < milestone.minCompletionDate) throw; if (now > milestone.maxCompletionDate) throw; milestone.status = MilestoneStatus.Completed; milestone.doneTime = now; ProposalStatusChanged(_idMilestone, milestone.status); } /// @notice `onlyRecipient` Sends the milestone payment as specified in ///  `payData`; the recipient can only call this after the `reviewTime` has ///  elapsed /// @param _idMilestone ID of the milestone to be paid out function collectMilestonePayment(uint _idMilestone ) onlyRecipient campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if  ((milestone.status != MilestoneStatus.Completed) || (now < milestone.doneTime + milestone.reviewTime)) throw; doPayment(_idMilestone); } /// @notice `onlyRecipient` Cancels a previously accepted milestone /// @param _idMilestone ID of the milestone to be canceled function cancelMilestone(uint _idMilestone) onlyRecipient campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; milestone.status = MilestoneStatus.Canceled; ProposalStatusChanged(_idMilestone, milestone.status); } /// @notice `onlyArbitrator` Forces a milestone to be paid out as long as it /// has not been paid or canceled /// @param _idMilestone ID of the milestone to be paid out function arbitrateApproveMilestone(uint _idMilestone ) onlyArbitrator campaignNotCanceled notChanging { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; if  ((milestone.status != MilestoneStatus.AcceptedAndInProgress) && (milestone.status != MilestoneStatus.Completed)) throw; doPayment(_idMilestone); } /// @notice `onlyArbitrator` Cancels the entire campaign voiding all ///  milestones vo function arbitrateCancelCampaign() onlyArbitrator campaignNotCanceled { campaignCanceled = true; CampaignCalncelled(); } // @dev This internal function is executed when the milestone is paid out function doPayment(uint _idMilestone) internal { if (_idMilestone >= milestones.length) throw; Milestone milestone = milestones[_idMilestone]; // Recheck again to not pay twice if (milestone.status == MilestoneStatus.Paid) throw; milestone.status = MilestoneStatus.Paid; if (!milestone.paymentSource.call.value(0)(milestone.payData)) throw; ProposalStatusChanged(_idMilestone, milestone.status); } } "}
{"sol name": "37093.sol", "label": 0, "sol content": "// Copyright (C) 2017 DappHub, LLC // Copyright (C) 2017 DappHub, LLC pragma solidity ^0.4.11; //import \"ds-exec/exec.sol\"; contract DSExec { function tryExec( address target, bytes calldata, uint value) internal returns (bool call_ret) { return target.call.value(value)(calldata); } function exec( address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; } } // Convenience aliases function exec( address t, bytes c ) internal { exec(t, c, 0); } function exec( address t, uint256 v ) internal { bytes memory c; exec(t, c, v); } function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); } function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); } } //import \"ds-auth/auth.sol\"; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) constant returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) auth { authority = authority_; LogSetAuthority(authority); } modifier auth { assert(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } function assert(bool x) internal { if (!x) throw; } } //import \"ds-note/note.sol\"; contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint        wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } //import \"ds-math/math.sol\"; contract DSMath { /* standard uint256 functions */ function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); } function sub(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x - y) <= x); } function mul(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x * y; assert(x == 0 || z / x == y); } function div(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x / y; } function min(uint256 x, uint256 y) constant internal returns (uint256 z) { return x <= y ? x : y; } function max(uint256 x, uint256 y) constant internal returns (uint256 z) { return x >= y ? x : y; } /* uint128 functions (h is for half) */ function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x + y) >= x); } function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x - y) <= x); } function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x * y; assert(x == 0 || z / x == y); } function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x / y; } function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) { return x <= y ? x : y; } function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) { return x >= y ? x : y; } /* int256 functions */ function imin(int256 x, int256 y) constant internal returns (int256 z) { return x <= y ? x : y; } function imax(int256 x, int256 y) constant internal returns (int256 z) { return x >= y ? x : y; } /* WAD math */ uint128 constant WAD = 10 ** 18; function wadd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function wsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + WAD / 2) / WAD); } function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * WAD + y / 2) / y); } function wmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function wmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } /* RAY math */ uint128 constant RAY = 10 ** 27; function radd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function rsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + RAY / 2) / RAY); } function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * RAY + y / 2) / y); } function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) { // This famous algorithm is called \"exponentiation by squaring\" // and calculates x^n with x as fixed-point and n as regular unsigned. // // It's O(log n), instead of O(n) for naive repeated multiplication. // // These facts are why it works: // //  If n is even, then x^n = (x^2)^(n/2). //  If n is odd,  then x^n = x * x^(n-1), //   and applying the equation for even x gives //    x^n = x * (x^2)^((n-1) / 2). // //  Also, EVM division is flooring and //    floor[(n-1) / 2] = floor[n / 2]. z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } function rmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function rmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } function cast(uint256 x) constant internal returns (uint128 z) { assert((z = uint128(x)) == x); } } //import \"erc20/erc20.sol\"; contract ERC20 { function totalSupply() constant returns (uint supply); function balanceOf( address who ) constant returns (uint value); function allowance( address owner, address spender ) constant returns (uint _allowance); function transfer( address to, uint value) returns (bool ok); function transferFrom( address from, address to, uint value) returns (bool ok); function approve( address spender, uint value ) returns (bool ok); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } //import \"ds-token/base.sol\"; contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() constant returns (uint256) { return _supply; } function balanceOf(address src) constant returns (uint256) { return _balances[src]; } function allowance(address src, address guy) constant returns (uint256) { return _approvals[src][guy]; } function transfer(address dst, uint wad) returns (bool) { assert(_balances[msg.sender] >= wad); _balances[msg.sender] = sub(_balances[msg.sender], wad); _balances[dst] = add(_balances[dst], wad); Transfer(msg.sender, dst, wad); return true; } function transferFrom(address src, address dst, uint wad) returns (bool) { assert(_balances[src] >= wad); assert(_approvals[src][msg.sender] >= wad); _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); _balances[src] = sub(_balances[src], wad); _balances[dst] = add(_balances[dst], wad); Transfer(src, dst, wad); return true; } function approve(address guy, uint256 wad) returns (bool) { _approvals[msg.sender][guy] = wad; Approval(msg.sender, guy, wad); return true; } } //import \"ds-stop/stop.sol\"; contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; } function stop() auth note { stopped = true; } function start() auth note { stopped = false; } } //import \"ds-token/token.sol\"; contract DSToken is DSTokenBase(0), DSStop { bytes32  public  symbol; uint256  public  decimals = 18; // standard token precision. override to customize address  public  generator; modifier onlyGenerator { if(msg.sender!=generator) throw; _; } function DSToken(bytes32 symbol_) { symbol = symbol_; generator=msg.sender; } function transfer(address dst, uint wad) stoppable note returns (bool) { return super.transfer(dst, wad); } function transferFrom( address src, address dst, uint wad ) stoppable note returns (bool) { return super.transferFrom(src, dst, wad); } function approve(address guy, uint wad) stoppable note returns (bool) { return super.approve(guy, wad); } function push(address dst, uint128 wad) returns (bool) { return transfer(dst, wad); } function pull(address src, uint128 wad) returns (bool) { return transferFrom(src, msg.sender, wad); } function mint(uint128 wad) auth stoppable note { _balances[msg.sender] = add(_balances[msg.sender], wad); _supply = add(_supply, wad); } function burn(uint128 wad) auth stoppable note { _balances[msg.sender] = sub(_balances[msg.sender], wad); _supply = sub(_supply, wad); } // owner can transfer token even stop, function generatorTransfer(address dst, uint wad) onlyGenerator note returns (bool) { return super.transfer(dst, wad); } // Optional token name bytes32   public  name = \"\"; function setName(bytes32 name_) auth { name = name_; } } ////////////////////////////////////////////////// // //import \"ds-token/token.sol\"; // //    import \"ds-stop/stop.sol\"; //        import \"ds-auth/auth.sol\"; //        import \"ds-note/note.sol\"; // //    import \"ds-token/base.sol\"; //        import \"erc20/erc20.sol\"; //        import \"ds-math/math.sol\"; // //import \"ds-exec/exec.sol\"; //import \"ds-auth/auth.sol\"; //import \"ds-note/note.sol\"; //import \"ds-math/math.sol\"; contract KkkTokenSale is DSStop, DSMath, DSExec { DSToken public key; // KEY PRICES (ETH/KEY) uint128 public constant PUBLIC_SALE_PRICE = 200000 ether; uint128 public constant TOTAL_SUPPLY = 10 ** 11 * 1 ether;  // 100 billion KEY in total uint128 public constant SELL_SOFT_LIMIT = TOTAL_SUPPLY * 12 / 100; // soft limit is 12% , 60000 eth uint128 public constant SELL_HARD_LIMIT = TOTAL_SUPPLY * 16 / 100; // hard limit is 16% , 80000 eth uint128 public constant FUTURE_DISTRIBUTE_LIMIT = TOTAL_SUPPLY * 84 / 100; // 84% for future distribution uint128 public constant USER_BUY_LIMIT = 500 ether; // 500 ether limit uint128 public constant MAX_GAS_PRICE = 50000000000;  // 50GWei uint public startTime; uint public endTime; bool public moreThanSoftLimit; mapping (address => uint)  public  userBuys; // limit to 500 eth address public destFoundation; //multisig account , 4-of-6 uint128 public sold; uint128 public constant soldByChannels = 40000 * 200000 ether; // 2 ICO websites, each 20000 eth function KkkTokenSale(uint startTime_, address destFoundation_) { key = new DSToken(\"KKK\"); //        key = new DSToken(\"KEY\"); destFoundation = destFoundation_; startTime = startTime_; endTime = startTime + 14 days; sold = soldByChannels; // sold by 3rd party ICO websites; key.mint(TOTAL_SUPPLY); key.transfer(destFoundation, FUTURE_DISTRIBUTE_LIMIT); key.transfer(destFoundation, soldByChannels); //disable transfer key.stop(); } // overrideable for easy testing function time() constant returns (uint) { return now; } function isContract(address _addr) constant internal returns(bool) { uint size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size > 0; } function canBuy(uint total) returns (bool) { return total <= USER_BUY_LIMIT; } function() payable stoppable note { require(!isContract(msg.sender)); require(msg.value >= 0.01 ether); require(tx.gasprice <= MAX_GAS_PRICE); assert(time() >= startTime && time() < endTime); var toFund = cast(msg.value); var requested = wmul(toFund, PUBLIC_SALE_PRICE); // selling SELL_HARD_LIMIT tokens ends the sale if( add(sold, requested) >= SELL_HARD_LIMIT) { requested = SELL_HARD_LIMIT - sold; toFund = wdiv(requested, PUBLIC_SALE_PRICE); endTime = time(); } // User cannot buy more than USER_BUY_LIMIT var totalUserBuy = add(userBuys[msg.sender], toFund); assert(canBuy(totalUserBuy)); userBuys[msg.sender] = totalUserBuy; sold = hadd(sold, requested); // Soft limit triggers the sale to close in 24 hours if( !moreThanSoftLimit && sold >= SELL_SOFT_LIMIT ) { moreThanSoftLimit = true; endTime = time() + 24 hours; // last 24 hours after soft limit, } key.start(); key.transfer(msg.sender, requested); key.stop(); exec(destFoundation, toFund); // send collected ETH to multisig // return excess ETH to the user uint toReturn = sub(msg.value, toFund); if(toReturn > 0) { exec(msg.sender, toReturn); } } function setStartTime(uint startTime_) auth note { require(time() <= startTime && time() <= startTime_); startTime = startTime_; endTime = startTime + 14 days; } function finalize() auth note { require(time() >= endTime); // enable transfer key.start(); // transfer undistributed KEY key.transfer(destFoundation, key.balanceOf(this)); // owner -> destFoundation key.setOwner(destFoundation); } // @notice This method can be used by the controller to extract mistakenly //  sent tokens to this contract. // @param dst The address that will be receiving the tokens // @param wad The amount of tokens to transfer // @param _token The address of the token contract that you want to recover function transferTokens(address dst, uint wad, address _token) public auth note { ERC20 token = ERC20(_token); token.transfer(dst, wad); } function summary()constant returns( uint128 _sold, uint _startTime, uint _endTime) { _sold = sold; _startTime = startTime; _endTime = endTime; return; } } "}
{"sol name": "34463.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract Delivery is Ownable{ using SafeMath for uint256; uint256 public Airdropsamount; // Airdrop total amount uint256 public decimals; // decimal of the token Peculium public pecul; // token Peculium bool public initPecul; // We need first to init the Peculium Token address event AirdropOne(address airdropaddress,uint256 nbTokenSendAirdrop); // Event for one airdrop event AirdropList(address[] airdropListAddress,uint256[] listTokenSendAirdrop); // Event for all the airdrop event InitializedToken(address contractToken); //Constructor function Delivery(){ Airdropsamount = 28000000; // We allocate 28 Millions token for the airdrop (maybe to change) initPecul = false; } /***  Functions of the contract ***/ function InitPeculiumAdress(address peculAdress) onlyOwner { // We init the Peculium token address pecul = Peculium(peculAdress); decimals = pecul.decimals(); initPecul = true; InitializedToken(peculAdress); } function airdropsTokens(address[] _vaddr, uint256[] _vamounts) onlyOwner Initialize NotEmpty { require (Airdropsamount >0); require ( _vaddr.length == _vamounts.length ); //Looping into input arrays to assign target amount to each given address uint256 amountToSendTotal = 0; for (uint256 indexTest=0; indexTest<_vaddr.length; indexTest++) // We first test that we have enough token to send { amountToSendTotal.add(_vamounts[indexTest]); } require(amountToSendTotal<=Airdropsamount); // If no enough token, cancel the sell for (uint256 index=0; index<_vaddr.length; index++) { address toAddress = _vaddr[index]; uint256 amountTo_Send = _vamounts[index].mul(10 ** decimals); pecul.transfer(toAddress,amountTo_Send); AirdropOne(toAddress,amountTo_Send); } Airdropsamount = Airdropsamount.sub(amountToSendTotal); AirdropList(_vaddr,_vamounts); } /***  Modifiers of the contract ***/ modifier NotEmpty { require (Airdropsamount>0); _; } modifier Initialize { require (initPecul==true); _; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool)  { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract Peculium is BurnableToken,Ownable { // Our token is a standard ERC20 Token with burnable and ownable aptitude using SafeMath for uint256; // We use safemath to do basic math operation (+,-,*,/) using SafeERC20 for ERC20Basic; /* Public variables of the token for ERC20 compliance */ string public name = \"Peculium\"; //token name string public symbol = \"PCL\"; // token symbol uint256 public decimals = 8; // token number of decimal /* Public variables specific for Peculium */ uint256 public constant MAX_SUPPLY_NBTOKEN   = 20000000000*10**8; // The max cap is 20 Billion Peculium uint256 public dateStartContract; // The date of the deployment of the token mapping(address => bool) public balancesCanSell; // The boolean variable, to frost the tokens uint256 public dateDefrost; // The date when the owners of token can defrost their tokens /* Event for the freeze of account */ event FrozenFunds(address target, bool frozen); event Defroze(address msgAdd, bool freeze); //Constructor function Peculium() { totalSupply = MAX_SUPPLY_NBTOKEN; balances[owner] = totalSupply; // At the beginning, the owner has all the tokens. balancesCanSell[owner] = true; // The owner need to sell token for the private sale and for the preICO, ICO. dateStartContract=now; dateDefrost = dateStartContract + 85 days; // everybody can defrost his own token after the 25 january 2018 (85 days after 1 November) } /*** Public Functions of the contract ***/ function defrostToken() public { // Function to defrost your own token, after the date of the defrost require(now>dateDefrost); balancesCanSell[msg.sender]=true; Defroze(msg.sender,true); } function transfer(address _to, uint256 _value) public returns (bool) { // We overright the transfer function to allow freeze possibility require(balancesCanSell[msg.sender]); return BasicToken.transfer(_to,_value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { // We overright the transferFrom function to allow freeze possibility (need to allow before) require(balancesCanSell[msg.sender]); return StandardToken.transferFrom(_from,_to,_value); } /***  Owner Functions of the contract ***/ function freezeAccount(address target, bool canSell) onlyOwner { balancesCanSell[target] = canSell; FrozenFunds(target, canSell); } /*** Others Functions of the contract ***/ /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } function getBlockTimestamp() constant returns (uint256) { return now; } function getOwnerInfos() constant returns (address ownerAddr, uint256 ownerBalance) { // Return info about the public address and balance of the account of the owner of the contract ownerAddr = owner; ownerBalance = balanceOf(ownerAddr); } } "}
{"sol name": "33786.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() public constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) public returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract Grimmjow8Token is StandardToken { function () public { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of Grimmjow8Token function Grimmjow8Token() public { balances[msg.sender] = 10000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000;                        // Update total supply (100000 for example) name = \"Grimmjow8 Token\";                      // Set the name for display purposes decimals = 0;                                  // Amount of decimals for display purposes symbol = \"GRIMM\";                              // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35385.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract MDPToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of MDPToken function MDPToken( ) { balances[msg.sender] = 660000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 660000000000000;                        // Update total supply (100000 for example) name = \"MDP Token\";                                   // Set the name for display purposes decimals = 7;                            // Amount of decimals for display purposes symbol = \"MDP\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "687.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000000000000;                        // Update total supply (100000 for example) name = \"LifeIsaGame\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"LAG\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "21227.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; /** * @title ContractReceiver * @dev Receiver for ERC223 tokens */ contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); /* tkn variable is analogue of msg variable of Ether transaction *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender) *  tkn.value the number of tokens that were sent   (analogue of msg.value) *  tkn.data is data of token transaction   (analogue of msg.data) *  tkn.sig is 4 bytes signature of function *  if data of token transaction is a function execution */ } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC223 { uint public totalSupply; function name() public view returns (string _name); function symbol() public view returns (string _symbol); function decimals() public view returns (uint8 _decimals); function totalSupply() public view returns (uint256 _supply); function balanceOf(address who) public view returns (uint); function transfer(address to, uint value) public returns (bool ok); function transfer(address to, uint value, bytes data) public returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } contract Excalibur is ERC223, Ownable { using SafeMath for uint256; string public name = \"ExcaliburCoin\"; string public symbol = \"EXC\"; uint8 public decimals = 8; uint256 public initialSupply = 10e11 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping (address => uint) balances; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event MintFinished(); function Excalibur() public { totalSupply = initialSupply; balances[msg.sender] = totalSupply; } function name() public view returns (string _name) { return name; } function symbol() public view returns (string _symbol) { return symbol; } function decimals() public view returns (uint8 _decimals) { return decimals; } function totalSupply() public view returns (uint256 _totalSupply) { return totalSupply; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } modifier onlyPayloadSize(uint256 size){ assert(msg.data.length >= size + 4); _; } // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { require( _value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to] ); if(isContract(_to)) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value); balances[_to] = SafeMath.add(balanceOf(_to), _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); return true; } else { return transferToAddress(_to, _value, _data); } } // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint _value, bytes _data) public returns (bool success) { require( _value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to] ); if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . function transfer(address _to, uint _value) public returns (bool success) { require( _value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to] ); //standard function transfer similar to ERC20 transfer with no _data //added due to backwards compatibility reasons bytes memory empty; if (isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } // assemble the given address bytecode. If bytecode exists then the _addr is a contract. function isContract(address _addr) private view returns (bool is_contract) { uint length; assembly { // retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } // function that is called when transaction target is an address function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value); balances[_to] = SafeMath.add(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } //function that is called when transaction target is a contract function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value); balances[_to] = SafeMath.add(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } /** * @dev Prevent targets from sending or receiving tokens * @param targets Addresses to be frozen * @param isFrozen either to freeze it or not */ function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint i = 0; i < targets.length; i++) { require(targets[i] != 0x0); frozenAccount[targets[i]] = isFrozen; FrozenFunds(targets[i], isFrozen); } } /** * @dev Prevent targets from sending or receiving tokens by setting Unix times * @param targets Addresses to be locked funds * @param unixTimes Unix times when locking up will be finished */ function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public { require(targets.length > 0 && targets.length == unixTimes.length); for(uint i = 0; i < targets.length; i++){ require(unlockUnixTime[targets[i]] < unixTimes[i]); unlockUnixTime[targets[i]] = unixTimes[i]; LockedFunds(targets[i], unixTimes[i]); } } /** * @dev Burns a specific amount of tokens. * @param _from The address that will burn the tokens. * @param _unitAmount The amount of token to be burned. */ function burn(address _from, uint256 _unitAmount) onlyOwner public { require(_unitAmount > 0 && balanceOf(_from) >= _unitAmount); balances[_from] = SafeMath.sub(balances[_from], _unitAmount); totalSupply = SafeMath.sub(totalSupply, _unitAmount); Burn(_from, _unitAmount); } modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _unitAmount The amount of tokens to mint. */ function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) { require(_unitAmount > 0); totalSupply = SafeMath.add(totalSupply, _unitAmount); balances[_to] = SafeMath.add(balances[_to], _unitAmount); Mint(_to, _unitAmount); bytes memory empty; Transfer(address(0), _to, _unitAmount, empty); return true; } /** * @dev Function to stop minting new tokens. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } /** * @dev Function to distribute tokens to the list of addresses by the provided amount */ function distributeTokens(address[] addresses, uint256 amount) public returns (bool) { require( amount > 0 && addresses.length > 0 && frozenAccount[msg.sender] == false && now > unlockUnixTime[msg.sender] ); amount = SafeMath.mul(amount, 1e8); uint256 totalAmount = SafeMath.mul(amount, addresses.length); require(balances[msg.sender] >= totalAmount); bytes memory empty; for (uint i = 0; i < addresses.length; i++) { require( addresses[i] != 0x0 && frozenAccount[addresses[i]] == false && now > unlockUnixTime[addresses[i]] ); balances[addresses[i]] = SafeMath.add(balances[addresses[i]], amount); Transfer(msg.sender, addresses[i], amount, empty); } balances[msg.sender] = SafeMath.sub(balances[msg.sender], totalAmount); return true; } /** * @dev Function to collect tokens from the list of addresses */ function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) { require(addresses.length > 0 && addresses.length == amounts.length); uint256 totalAmount = 0; bytes memory empty; for (uint i = 0; i < addresses.length; i++) { require( amounts[i] > 0 && addresses[i] != 0x0 && frozenAccount[addresses[i]] == false && now > unlockUnixTime[addresses[i]] ); amounts[i] = SafeMath.mul(amounts[i], 1e8); require(balances[addresses[i]] >= amounts[i]); balances[addresses[i]] = SafeMath.sub(balances[addresses[i]], amounts[i]); totalAmount = SafeMath.add(totalAmount, amounts[i]); Transfer(addresses[i], msg.sender, amounts[i], empty); } balances[msg.sender] = SafeMath.add(balances[msg.sender], totalAmount); return true; } function setDistributeAmount(uint256 _unitAmount) onlyOwner public { distributeAmount = _unitAmount; } /** * @dev Function to distribute tokens to the msg.sender automatically *      If distributeAmount is 0, this function doesn't work */ function autoDistribute() payable public { require( distributeAmount > 0 && balanceOf(owner) >= distributeAmount && frozenAccount[msg.sender] == false && now > unlockUnixTime[msg.sender] ); if (msg.value > 0) owner.transfer(msg.value); bytes memory empty; balances[owner] = SafeMath.sub(balances[owner], distributeAmount); balances[msg.sender] = SafeMath.add(balances[msg.sender], distributeAmount); Transfer(owner, msg.sender, distributeAmount, empty); } /** * @dev token fallback function */ function() payable public { autoDistribute(); } } "}
{"sol name": "37417.sol", "label": 0, "sol content": "pragma solidity ^0.4.10; /* The Pluton Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans. Pluton contract extends HumanStandardToken, https://github.com/consensys/tokens .*/ contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract HumanStandardToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } // Creates 20,000,000.000000000000000000 Pluton (PLU) Tokens contract Pluton is HumanStandardToken(20000000000000000000000000, \"Pluton\", 18, \"PLU\") {} "}
{"sol name": "34077.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract WinConnectCoin is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function WinConnectCoin( ) { balances[msg.sender] = 9000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 9000000;                        // Update total supply (100000 for example) name = \"WinConnectCoin\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"WCC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "40461.sol", "label": 0, "sol content": "// <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize srl, Thomas Bertani Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { address oraclizeAddr = OAR.getAddress(); if (oraclizeAddr == 0){ oraclize_setNetwork(networkID_auto); oraclizeAddr = OAR.getAddress(); } oraclize = OraclizeI(oraclizeAddr); _ } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _ } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){ OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd); return true; } if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } return mint; } } // </ORACLIZE_API> contract Dice is usingOraclize { uint public pwin = 5000; //probability of winning (10000 = 100%) uint public edge = 200; //edge percentage (10000 = 100%) uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint public minBet = 1 finney; uint public maxInvestors = 5; //maximum number of investors uint public ownerEdge = 50; //edge percentage (10000 = 100%) uint public divestFee = 50; //divest fee percentage (10000 = 100%) uint constant safeGas = 25000; uint constant oraclizeGasLimit = 150000; struct Investor { address user; uint capital; } mapping(uint => Investor) investors; //starts at 1 uint public numInvestors = 0; mapping(address => uint) investorIDs; uint public invested = 0; address owner; bool public isStopped; struct Bet { address user; uint bet; // amount uint roll; // result uint fee; } mapping (bytes32 => Bet) bets; bytes32[] betsKeys; uint public amountWagered = 0; int public profit = 0; int public takenProfit = 0; int public ownerProfit = 0; function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint ownerEdgeInitial, uint divestFeeInitial) { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); pwin = pwinInitial; edge = edgeInitial; maxWin = maxWinInitial; minBet = minBetInitial; maxInvestors = maxInvestorsInitial; ownerEdge = ownerEdgeInitial; divestFee = divestFeeInitial; owner = msg.sender; } function() { bet(); } function bet() { if (isStopped) throw; uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit); if (msg.value < oraclizeFee) throw; uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\", 'BDXJhrVpBJ53o2CxlJRlQtZJKZqLYt5IQe+73YDS4HtNjS5HodbIB3tvfow7UquyAk085VkLnL9EpKgwqWQz7ZLdGvsQlRd2sKxIolNg9DbnfPspGqLhLbbYSVnN8CwvsjpAXcSSo3c+4cNwC90yF4oNibkvD3ytapoZ7goTSyoUYTfwSjnw3ti+HJVH7N3+c0iwOCqZjDdsGQUcX3m3S/IHWbOOQQ5osO4Lbj3Gg0x1UdNtfUzYCFY79nzYgWIQEFCuRBI0n6NBvBQW727+OsDRY0J/9/gjt8ucibHWic0=', oraclizeGasLimit); // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}' bets[myid] = Bet(msg.sender, betValue, 0, oraclizeFee); betsKeys.push(myid); } else { throw; // invalid bet size } } function numBets() constant returns(uint) { return betsKeys.length; } function minBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", oraclizeGasLimit); return oraclizeFee+minBet; } function safeSend(address addr, uint value) internal { if (!(addr.call.gas(safeGas).value(value)())){ ownerProfit += int(value); } } function __callback(bytes32 myid, string result, bytes proof) { if (msg.sender != oraclize_cbAddress()) throw; Bet thisBet = bets[myid]; if (thisBet.bet>0) { if ((isStopped == false)&&(((thisBet.bet * ((10000 - edge) - pwin)) / pwin ) <= maxWin * getBankroll() / 10000)) { uint roll = parseInt(result); if (roll<1 || roll>10000){ safeSend(thisBet.user, thisBet.bet); return; } bets[myid].roll = roll; int profitDiff; if (roll-1 < pwin) { //win uint winAmount = (thisBet.bet * (10000 - edge)) / pwin; safeSend(thisBet.user, winAmount); profitDiff = int(thisBet.bet - winAmount); } else { //lose safeSend(thisBet.user, 1); profitDiff = int(thisBet.bet) - 1; } ownerProfit += (profitDiff*int(ownerEdge))/10000; profit += profitDiff-(profitDiff*int(ownerEdge))/10000; amountWagered += thisBet.bet; } else { //bet is too big (bankroll may have changed since the bet was made) safeSend(thisBet.user, thisBet.bet); } } } function getBet(uint id) constant returns(address, uint, uint, uint) { if(id<betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].user, bets[betKey].bet, bets[betKey].roll, bets[betKey].fee); } } function invest() { if (isStopped) throw; if (investorIDs[msg.sender]>0) { rebalance(); investors[investorIDs[msg.sender]].capital += msg.value; invested += msg.value; } else { rebalance(); uint investorID = 0; if (numInvestors<maxInvestors) { investorID = ++numInvestors; } else { for (uint i=1; i<=numInvestors; i++) { if (investors[i].capital<msg.value && (investorID==0 || investors[i].capital<investors[investorID].capital)) { investorID = i; } } } if (investorID>0) { if (investors[investorID].capital>0) { divest(investors[investorID].user, investors[investorID].capital); investorIDs[investors[investorID].user] = 0; } if (investors[investorID].capital == 0 && investorIDs[investors[investorID].user] == 0) { investors[investorID].user = msg.sender; investors[investorID].capital = msg.value; invested += msg.value; investorIDs[msg.sender] = investorID; } else { throw; } } else { throw; } } } function rebalance() private { if (takenProfit != profit) { uint newInvested = 0; uint initialBankroll = getBankroll(); for (uint i=1; i<=numInvestors; i++) { investors[i].capital = getBalance(investors[i].user); newInvested += investors[i].capital; } invested = newInvested; if (newInvested != initialBankroll && numInvestors>0) { ownerProfit += int(initialBankroll - newInvested); //give the rounding error to the first investor invested += (initialBankroll - newInvested); } takenProfit = profit; } } function divest(address user, uint amount) private { if (investorIDs[user]>0) { rebalance(); if (amount>getBalance(user)) { amount = getBalance(user); } investors[investorIDs[user]].capital -= amount; invested -= amount; uint newAmount = (amount*divestFee)/10000; // take a fee from the deinvest amount ownerProfit += int(newAmount); safeSend(user, (amount-newAmount)); } } function divest(uint amount) { if (msg.value>0) throw; divest(msg.sender, amount); } function divest() { if (msg.value>0) throw; divest(msg.sender, getBalance(msg.sender)); } function getBalance(address user) constant returns(uint) { if (investorIDs[user]>0 && invested>0) { return investors[investorIDs[user]].capital * getBankroll() / invested; } else { return 0; } } function getBankroll() constant returns(uint) { uint bankroll = uint(int(invested)+profit+ownerProfit-takenProfit); if (this.balance < bankroll){ log0(\"bankroll_mismatch\"); bankroll = this.balance; } return bankroll; } function getMinInvestment() constant returns(uint) { if (numInvestors<maxInvestors) { return 0; } else { uint investorID; for (uint i=1; i<=numInvestors; i++) { if (investorID==0 || getBalance(investors[i].user)<getBalance(investors[investorID].user)) { investorID = i; } } return getBalance(investors[investorID].user); } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, int, uint, uint) { return (getBankroll(), pwin, edge, maxWin, minBet, amountWagered, profit, getMinInvestment(), betsKeys.length); } function stopContract() { if (owner != msg.sender) throw; isStopped = true; } function resumeContract() { if (owner != msg.sender) throw; isStopped = false; } function forceDivestAll() { forceDivestAll(false); } function forceDivestAll(bool ownerTakeChangeAndProfit) { if (owner != msg.sender) throw; for (uint investorID=1; investorID<=numInvestors; investorID++) { divest(investors[investorID].user, getBalance(investors[investorID].user)); } if (ownerTakeChangeAndProfit) owner.send(this.balance); } function ownerTakeProfit() { ownerTakeProfit(false); } function ownerTakeProfit(bool takeChange) { if (owner != msg.sender) throw; if (takeChange){ uint investorsCapital = 0; for (uint i=1; i<=numInvestors; i++) { investorsCapital += investors[i].capital; } if ((investorsCapital == 0)&&(this.balance != uint(ownerProfit))){ owner.send(this.balance); ownerProfit = 0; } } else { owner.send(uint(ownerProfit)); ownerProfit = 0; } } } "}
{"sol name": "39644.sol", "label": 0, "sol content": "pragma solidity ^0.4.2; contract AddressOwnershipVerification { mapping(address => mapping (uint32 => address)) _requests;        // Pending requests (transactee address => (deposit => transactor address) mapping(address => mapping (address => uint32)) _requestsReverse; // Used for reverse lookups  (transactee address => (transactor address => deposit) mapping(address => mapping (address => uint32)) _verifications;   // Verified requests (transactor address => (transactee address => deposit) event RequestEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit);      // Event is triggered when a new request is added event RemoveRequestEvent(address indexed transactor, address indexed transactee);                        // Event is triggered when an unverified request is removed event VerificationEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit); // Event is triggered when someone proves ownership of an address event RevokeEvent(address indexed transactor, address indexed transactee, uint32 indexed deposit);       // Event is triggered when either party removes a trust function AddressOwnershipVerification() {} // Used to verify pending requests by transactee sending deposit to this contract function () payable { uint32 value = uint32(msg.value); if (!_requestExists(msg.sender, value)) { throw; } // Get matching transactor for request address transactor = _requests[msg.sender][value]; // Save new Verification _saveVerification(transactor, msg.sender, value); // And then delete the verified request _deleteRequest(transactor, msg.sender); VerificationEvent(transactor, msg.sender, value); } // Request a new verification as transactor function request(address transactee, uint32 deposit) { // Throw if sender wastes blockchain space if (transactee == msg.sender) { throw; } // Deposit can't be 0 because all uint's get initialized to 0 in _requests if (deposit == 0) { throw; } // Throw if transactee already provided verification to transactor if(verify(msg.sender, transactee)) { throw; } // Throw if transactee already has a pending request for this exact deposit if (_requestExists(transactee, deposit)) { throw; } if (_requestExistsReverse(msg.sender, transactee)) { throw; } _saveRequest(msg.sender, transactee, deposit); RequestEvent(msg.sender, transactee, deposit); } // Returns amount of wei transactee has to send to fullfill transactor's request function getRequest(address transactor, address transactee) returns (uint32 deposit) { return _requestsReverse[transactee][transactor]; } // Removes a pending request as transactor or transactee function removeRequest(address transactor, address transactee) returns (uint32) { // Only transactor and transactee can trigger removal of their request if (msg.sender != transactor && msg.sender != transactee) { throw; } _deleteRequest(transactor, transactee); RemoveRequestEvent(transactor, transactee); } //  Returns true if transactee has already proven their address ownership to transactor in the past function verify(address transactor, address transactee) returns (bool) { return _verifications[transactor][transactee] != 0; } // Removes an existing verification and returns the deposited amount to transactee // Can be called by either transactor or transactee function revoke(address transactor, address transactee) { // Only transactor and transactee can trigger removal of their verification if (msg.sender != transactor && msg.sender != transactee) { throw; } // Throw if verification does not exist if(!verify(transactor, transactee)) { throw; } uint32 deposit = _verifications[transactor][transactee]; // Delete verification delete _verifications[transactor][transactee]; // Send deposit to transactee if (!transactee.call.value(deposit).gas(23000)()) { throw; } RevokeEvent(transactor, transactee, deposit); } // Internal: Save a new request function _saveRequest(address transactor, address transactee, uint32 deposit) internal { _requests[transactee][deposit] = transactor; _requestsReverse[transactee][transactor] = deposit; } // Internal: Remove a fullfilled request function _deleteRequest(address transactor, address transactee) internal { uint32 deposit = _requestsReverse[transactee][transactor]; delete _requests[transactee][deposit]; delete _requestsReverse[transactee][transactor]; } // Internal: Test if a request exists when you know transactee and deposit function _requestExists(address transactee, uint32 deposit) internal returns(bool) { return _requests[transactee][deposit] != 0x0000000000000000000000000000000000000000; } // Internal: Test if a request exists when you know transactee and transactor function _requestExistsReverse(address transactor, address transactee) internal returns(bool) { return _requestsReverse[transactee][transactor] != 0; } // Internal: Save a new verification function _saveVerification(address transactor, address transactee, uint32 deposit) internal { _verifications[transactor][transactee] = deposit; } } "}
{"sol name": "31783.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000000000000000;                        // Update total supply (100000 for example) name = \"Fastbit\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"FAST\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35231.sol", "label": 0, "sol content": "/// price-feed.sol // Copyright (C) 2017  DappHub, LLC // Licensed under the Apache License, Version 2.0 (the \"License\"). // You may not use this file except in compliance with the License. // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied). pragma solidity ^0.4.17; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() public { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) public auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) public auth { authority = authority_; LogSetAuthority(authority); } modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } } contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint              wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); } function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); } function mul(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x); } function min(uint x, uint y) internal pure returns (uint z) { return x <= y ? x : y; } function max(uint x, uint y) internal pure returns (uint z) { return x >= y ? x : y; } function imin(int x, int y) internal pure returns (int z) { return x <= y ? x : y; } function imax(int x, int y) internal pure returns (int z) { return x >= y ? x : y; } uint constant WAD = 10 ** 18; uint constant RAY = 10 ** 27; function wmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), WAD / 2) / WAD; } function rmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), RAY / 2) / RAY; } function wdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, WAD), y / 2) / y; } function rdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, RAY), y / 2) / y; } // This famous algorithm is called \"exponentiation by squaring\" // and calculates x^n with x as fixed-point and n as regular unsigned. // // It's O(log n), instead of O(n) for naive repeated multiplication. // // These facts are why it works: // //  If n is even, then x^n = (x^2)^(n/2). //  If n is odd,  then x^n = x * x^(n-1), //   and applying the equation for even x gives //    x^n = x * (x^2)^((n-1) / 2). // //  Also, EVM division is flooring and //    floor[(n-1) / 2] = floor[n / 2]. // function rpow(uint x, uint n) internal pure returns (uint z) { z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } } contract DSThing is DSAuth, DSNote, DSMath { } contract PriceFeed is DSThing { uint128 val; uint32 public zzz; function peek() public view returns (bytes32,bool) { return (bytes32(val), now < zzz); } function read() public view returns (bytes32) { assert(now < zzz); return bytes32(val); } function post(uint128 val_, uint32 zzz_, address med_) public note auth { val = val_; zzz = zzz_; bool ret = med_.call(bytes4(keccak256(\"poke()\"))); ret; } function void() public note auth { zzz = 0; } } contract FeedFactory { event Created(address indexed sender, address feed); mapping(address=>bool) public isFeed; function create() public returns (PriceFeed) { PriceFeed feed = new PriceFeed(); Created(msg.sender, address(feed)); feed.setOwner(msg.sender); isFeed[feed] = true; return feed; } } "}
{"sol name": "38953.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; // VERSION LAVA(D) // -------------------------- // here's how this works: // the current amount of dividends due to each token-holder's  is: //   previous_due + [ p(x) * t(x)/N ] + [ p(x+1) * t(x+1)/N ] + ... //   where p(x) is the x'th payment received by the contract //         t(x) is the number of tokens held by the token-holder at the time of p(x) //         N    is the total number of tokens, which never changes // // assume that t(x) takes on 3 values, t(a), t(b) and t(c), during periods a, b, and c. then: // factoring: //   current_due = { (t(a) * [p(x) + p(x+1)] ...) + //                   (t(b) * [p(y) + p(y+1)] ...) + //                   (t(c) * [p(z) + p(z+1)] ...) } / N // // or // //   current_due = { (t(a) * period_a_fees) + //                   (t(b) * period_b_fees) + //                   (t(c) * period_c_fees) } / N // // if we designate current_due * N as current-points, then // //   currentPoints = {  (t(a) * period_a_fees) + //                      (t(b) * period_b_fees) + //                      (t(c) * period_c_fees) } // // or more succictly, if we recompute current points before a token-holder's number of // tokens, T, is about to change: // //   currentPoints = previous_points + (T * current-period-fees) // // when we want to do a payout, we'll calculate: //  current_due = current-points / N // // we'll keep track of a token-holder's current-period-points, which is: //   T * current-period-fees // by taking a snapshot of fees collected exactly when the current period began; that is, the when the // number of tokens last changed. that is, we keep a running count of total fees received // //   TotalFeesReceived = p(x) + p(x+1) + p(x+2) // // (which happily is the same for all token holders) then, before any token holder changes their number of // tokens we compute (for that token holder): // //  function calcCurPointsForAcct(acct) { //    currentPoints[acct] += (TotalFeesReceived - lastSnapshot[acct]) * T[acct] //    lastSnapshot[acct] = TotalFeesReceived //  } // // in the withdraw fcn, all we need is: // //  function withdraw(acct) { //    calcCurPointsForAcct(acct); //    current_amount_due = currentPoints[acct] / N //    currentPoints[acct] = 0; //    send(current_amount_due); //  } // // // special provisions for transfers from the old e4row contract (token-split transfers) // ------------------------------------------------------------------------------------- // normally when a new acct is created, eg cuz tokens are transferred from one acct to another, we first call // calcCurPointsForAcct(acct) on the old acct; on the new acct we set: //  currentPoints[acct] = 0; //  lastSnapshot[acct] = TotalFeesReceived; // // this starts the new account with no credits for any dividends that have been collected so far, which is what // you would generally want. however, there is a case in which tokens are transferred from the old e4row contract. // in that case the tokens were reserved on this contract all along, and they earn dividends even before they are // assigned to an account. so for token-split transfers: //  currentPoints[acct] = 0; //  lastSnapshot[acct] = 0; // // then immediately call calcCurPointsForAcct(acct) for the new token-split account. he will get credit // for all the accumulated points, from the beginning of time. // // -------------------------- // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 // --------------------------------- // ABSTRACT standard token class // --------------------------------- contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } // -------------------------- //  E4RowRewards - abstract e4 dividend contract // -------------------------- contract E4LavaRewards { function checkDividends(address _addr) constant returns(uint _amount); function withdrawDividends() public returns (uint namount); function transferDividends(address _to) returns (bool success); } // -------------------------- //  E4ROW (LAVA) - token contract // -------------------------- contract E4Lava is Token, E4LavaRewards { event StatEvent(string msg); event StatEventI(string msg, uint val); enum SettingStateValue  {debug, lockedRelease} struct tokenAccount { bool alloced;       // flag to ascert prior allocation uint tokens;        // num tokens currently held in this acct uint currentPoints; // updated before token balance changes, or before a withdrawal. credit for owning tokens uint lastSnapshot;  // snapshot of global TotalPoints, last time we updated this acct's currentPoints } // ----------------------------- //  data storage // ---------------------------------------- uint constant NumOrigTokens         = 5762;   // number of old tokens, from original token contract uint constant NewTokensPerOrigToken = 100000; // how many new tokens are created for each from original token uint constant NewTokenSupply        = 5762 * 100000; uint public numToksSwitchedOver;              // count old tokens that have been converted uint public holdoverBalance;                  // funds received, but not yet distributed uint public TotalFeesReceived;                // total fees received from partner contract(s) address public developers;                    // developers token holding address address public owner;                         // deployer executor address public oldE4;                         // addr of old e4 token contract address public oldE4RecycleBin;  // addr to transfer old tokens uint public decimals; string public symbol; mapping (address => tokenAccount) holderAccounts;          // who holds how many tokens (high two bytes contain curPayId) mapping (uint => address) holderIndexes;                   // for iteration thru holder mapping (address => mapping (address => uint256)) allowed; // approvals uint public numAccounts; uint public payoutThreshold;                  // no withdrawals less than this amount, to avoid remainders uint public vestTime;                         // 1 year past sale vest developer tokens uint public rwGas;                            // reward gas uint public optInGas; SettingStateValue public settingsState; // -------------------- // contract constructor // -------------------- function E4Lava() { owner = msg.sender; developers = msg.sender; decimals = 2; symbol = \"E4ROW\"; } // ----------------------------------- // use this to reset everything, will never be called after lockRelease // ----------------------------------- function applySettings(SettingStateValue qState, uint _threshold, uint _vest, uint _rw, uint _optGas ) { if (msg.sender != owner) return; // these settings are permanently tweakable for performance adjustments payoutThreshold = _threshold; rwGas = _rw; optInGas = _optGas; // this first test checks if already locked if (settingsState == SettingStateValue.lockedRelease) return; settingsState = qState; // this second test allows locking without changing other permanent settings // WARNING, MAKE SURE YOUR'RE HAPPY WITH ALL SETTINGS // BEFORE LOCKING if (qState == SettingStateValue.lockedRelease) { StatEvent(\"Locking!\"); return; } // zero out all token holders. // leave alloced on, leave num accounts // cant delete them anyways for (uint i = 0; i < numAccounts; i++ ) { address a = holderIndexes[i]; if (a != address(0)) { holderAccounts[a].tokens = 0; holderAccounts[a].currentPoints = 0; holderAccounts[a].lastSnapshot = 0; } } vestTime = _vest; numToksSwitchedOver = 0; if (this.balance > 0) { if (!owner.call.gas(rwGas).value(this.balance)()) StatEvent(\"ERROR!\"); } StatEvent(\"ok\"); } // --------------------------------------------------- // allocate a new account by setting alloc to true // add holder index, bump the num accounts // --------------------------------------------------- function addAccount(address _addr) internal  { holderAccounts[_addr].alloced = true; holderAccounts[_addr].tokens = 0; holderAccounts[_addr].currentPoints = 0; holderAccounts[_addr].lastSnapshot = TotalFeesReceived; holderIndexes[numAccounts++] = _addr; } // -------------------------------------- // BEGIN ERC-20 from StandardToken // -------------------------------------- function totalSupply() constant returns (uint256 supply) { supply = NewTokenSupply; } // ---------------------------- // sender transfers tokens to a new acct // do not use this fcn for a token-split transfer from the old token contract! // ---------------------------- function transfer(address _to, uint256 _value) returns (bool success) { if ((msg.sender == developers) &&  (now < vestTime)) { //statEvent(\"Tokens not yet vested.\"); return false; } //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (holderAccounts[msg.sender].tokens >= _value && balances[_to] + _value > holderAccounts[_to]) { if (holderAccounts[msg.sender].tokens >= _value && _value > 0) { //first credit sender with points accrued so far.. must do this before number of held tokens changes calcCurPointsForAcct(msg.sender); holderAccounts[msg.sender].tokens -= _value; if (!holderAccounts[_to].alloced) { addAccount(_to); } //credit destination acct with points accrued so far.. must do this before number of held tokens changes calcCurPointsForAcct(_to); holderAccounts[_to].tokens += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if ((_from == developers) &&  (now < vestTime)) { //statEvent(\"Tokens not yet vested.\"); return false; } //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && holderAccounts[_to].tokens + _value > holderAccounts[_to].tokens) { if (holderAccounts[_from].tokens >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { calcCurPointsForAcct(_from); holderAccounts[_from].tokens -= _value; if (!holderAccounts[_to].alloced) { addAccount(_to); } //credit destination acct with points accrued so far.. must do this before number of held tokens changes calcCurPointsForAcct(_to); holderAccounts[_to].tokens += _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { balance = holderAccounts[_owner].tokens; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } // ---------------------------------- // END ERC20 // ---------------------------------- // ---------------------------- // calc current points for a token holder; that is, points that are due to this token holder for all dividends // received by the contract during the current \"period\". the period began the last time this fcn was called, at which // time we updated the account's snapshot of the running point count, TotalFeesReceived. during the period the account's // number of tokens must not have changed. so always call this fcn before changing the number of tokens. // ---------------------------- function calcCurPointsForAcct(address _acct) { holderAccounts[_acct].currentPoints += (TotalFeesReceived - holderAccounts[_acct].lastSnapshot) * holderAccounts[_acct].tokens; holderAccounts[_acct].lastSnapshot = TotalFeesReceived; } // --------------------------- // accept payment from a partner contract // funds sent here are added to TotalFeesReceived // WARNING! DO NOT CALL THIS FUNCTION LEST YOU LOSE YOUR MONEY // --------------------------- function () payable { holdoverBalance += msg.value; TotalFeesReceived += msg.value; StatEventI(\"Payment\", msg.value); } // --------------------------- // one never knows if this will come in handy. // --------------------------- function blackHole() payable { StatEventI(\"adjusted\", msg.value); } // ---------------------------- // sender withdraw entire rewards/dividends // ---------------------------- function withdrawDividends() public returns (uint _amount) { calcCurPointsForAcct(msg.sender); _amount = holderAccounts[msg.sender].currentPoints / NewTokenSupply; if (_amount <= payoutThreshold) { StatEventI(\"low Balance\", _amount); return; } else { if ((msg.sender == developers) &&  (now < vestTime)) { StatEvent(\"Tokens not yet vested.\"); _amount = 0; return; } uint _pointsUsed = _amount * NewTokenSupply; holderAccounts[msg.sender].currentPoints -= _pointsUsed; holdoverBalance -= _amount; if (!msg.sender.call.gas(rwGas).value(_amount)()) throw; } } // ---------------------------- // allow sender to transfer dividends // ---------------------------- function transferDividends(address _to) returns (bool success) { if ((msg.sender == developers) &&  (now < vestTime)) { //statEvent(\"Tokens not yet vested.\"); return false; } calcCurPointsForAcct(msg.sender); if (holderAccounts[msg.sender].currentPoints == 0) { StatEvent(\"Zero balance\"); return false; } if (!holderAccounts[_to].alloced) { addAccount(_to); } calcCurPointsForAcct(_to); holderAccounts[_to].currentPoints += holderAccounts[msg.sender].currentPoints; holderAccounts[msg.sender].currentPoints = 0; StatEvent(\"Trasnfered Dividends\"); return true; } // ---------------------------- // set gas for operations // ---------------------------- function setOpGas(uint _rw, uint _optIn) { if (msg.sender != owner && msg.sender != developers) { //StatEvent(\"only owner calls\"); return; } else { rwGas = _rw; optInGas = _optIn; } } // ---------------------------- // check rewards.  pass in address of token holder // ---------------------------- function checkDividends(address _addr) constant returns(uint _amount) { if (holderAccounts[_addr].alloced) { //don't call calcCurPointsForAcct here, cuz this is a constant fcn uint _currentPoints = holderAccounts[_addr].currentPoints + ((TotalFeesReceived - holderAccounts[_addr].lastSnapshot) * holderAccounts[_addr].tokens); _amount = _currentPoints / NewTokenSupply; // low balance? let him see it -Etansky // if (_amount <= payoutThreshold) { //    _amount = 0; // } } } // ---------------------------- // swap executor // ---------------------------- function changeOwner(address _addr) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; owner = _addr; } // ---------------------------- // set developers account // ---------------------------- function setDeveloper(address _addr) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; developers = _addr; } // ---------------------------- // set oldE4 Addresses // ---------------------------- function setOldE4(address _oldE4, address _oldE4Recyle) { if (msg.sender != owner || settingsState == SettingStateValue.lockedRelease) throw; oldE4 = _oldE4; oldE4RecycleBin = _oldE4Recyle; } // ---------------------------- // DEBUG ONLY - end this contract, suicide to developers // ---------------------------- function haraKiri() { if (settingsState != SettingStateValue.debug) throw; if (msg.sender != owner) throw; suicide(developers); } // ---------------------------- // OPT IN FROM CLASSIC. // All old token holders can opt into this new contract by calling this function. // This \"transferFrom\"s tokens from the old addresses to the new recycleBin address // which is a new address set up on the old contract.  Afterwhich new tokens // are credited to the old holder.  Also the lastSnapShot is set to 0 then // calcCredited points are called setting up the new signatoree all of his // accrued dividends. // ---------------------------- function optInFromClassic() public { if (oldE4 == address(0)) { StatEvent(\"config err\"); return; } // 1. check balance of msg.sender in old contract. address nrequester = msg.sender; // 2. make sure account not already allocd (in fact, it's ok if it's allocd, so long // as it is empty now. the reason for this check is cuz we are going to credit him with // dividends, according to his token count, from the begin of time. if (holderAccounts[nrequester].tokens != 0) { StatEvent(\"Account has already been allocd!\"); return; } // 3. check his tok balance Token iclassic = Token(oldE4); uint _toks = iclassic.balanceOf(nrequester); if (_toks == 0) { StatEvent(\"Nothing to do\"); return; } // must be 100 percent of holdings if (iclassic.allowance(nrequester, address(this)) < _toks) { StatEvent(\"Please approve this contract to transfer\"); return; } // 4, transfer his old toks to recyle bin iclassic.transferFrom.gas(optInGas)(nrequester, oldE4RecycleBin, _toks); // todo, error check? if (iclassic.balanceOf(nrequester) == 0) { // success, add the account, set the tokens, set snapshot to zero if (!holderAccounts[nrequester].alloced) addAccount(nrequester); holderAccounts[nrequester].tokens = _toks * NewTokensPerOrigToken; holderAccounts[nrequester].lastSnapshot = 0; calcCurPointsForAcct(nrequester); numToksSwitchedOver += _toks; // no need to decrement points from a \"holding account\" // b/c there is no need to keep it. StatEvent(\"Success Switched Over\"); } else StatEvent(\"Transfer Error! please contact Dev team!\"); } } "}
{"sol name": "33866.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /* * Giga Giving Coin and ICO Contract. * 15,000,000 Coins Total. * 12,000,000 Coins available for purchase. */ contract Token { uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function transfer(address _to, uint256 _value) public returns (bool success) { address sender = msg.sender; require(balances[sender] >= _value); balances[sender] -= _value; balances[_to] += _value; Transfer(sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } library SafeMath { function mul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract GigaGivingToken is StandardToken { using SafeMath for uint256; uint256 private fundingGoal = 0 ether; uint256 private amountRaised; uint256 private constant PHASE_1_PRICE = 1600000000000; uint256 private constant PHASE_2_PRICE = 2000000000000; uint256 private constant PHASE_3_PRICE = 2500000000000; uint256 private constant PHASE_4_PRICE = 4000000000000; uint256 private constant PHASE_5_PRICE = 5000000000000; uint256 private constant DURATION = 30 minutes; uint256 public constant TOTAL_TOKENS = 15000000; uint256 public constant  CROWDSALE_TOKENS = 12000000; uint256 public startTime; uint256 public tokenSupply; address public creator; address public beneficiary; string public name = \"JTEST\"; string public symbol = \"JT\"; string public version = \"JT.0\"; uint256 public decimals = 0; // GigaGivingToken public tokenReward; mapping(address => uint256) public ethBalanceOf; bool public fundingGoalReached = false; bool public crowdsaleClosed = false; bool public refundsOpen = false; function GigaGivingToken (address icoBeneficiary) public { creator = msg.sender; beneficiary = icoBeneficiary; totalSupply = TOTAL_TOKENS; balances[beneficiary] = TOTAL_TOKENS.sub(CROWDSALE_TOKENS); Transfer(0x0, icoBeneficiary, TOTAL_TOKENS.sub(CROWDSALE_TOKENS)); balances[this] = CROWDSALE_TOKENS; Transfer(0x0, this, CROWDSALE_TOKENS); tokenSupply = CROWDSALE_TOKENS; startTime = 1510527600; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } function () public payable { require(now >= startTime); require(now <= startTime + DURATION); require(!crowdsaleClosed); require(msg.value > 0); uint256 amount = msg.value; uint256 coinTotal = 0; if (now > startTime + 20 minutes) { coinTotal = amount.div(PHASE_5_PRICE); } else if (now > startTime + 15 minutes) { coinTotal = amount.div(PHASE_4_PRICE); } else if (now > startTime + 10 minutes) { coinTotal = amount.div(PHASE_3_PRICE); } else if (now > startTime + 5 minutes) { coinTotal = amount.div(PHASE_2_PRICE); } else { coinTotal = amount.div(PHASE_1_PRICE); } ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(amount); balances[msg.sender] = balances[msg.sender].add(coinTotal); balances[this] = balances[this].sub(coinTotal); amountRaised = amountRaised.add(amount); tokenSupply = tokenSupply.sub(coinTotal); transfer(msg.sender, coinTotal); } modifier afterDeadline() { if (now >= (startTime + DURATION)) { _; } } function checkGoalReached() public afterDeadline { if (amountRaised >= fundingGoal) { fundingGoalReached = true; } crowdsaleClosed = true; } function safeWithdrawal() public afterDeadline { if (refundsOpen) { uint amount = ethBalanceOf[msg.sender]; ethBalanceOf[msg.sender] = 0; if (amount > 0) { if (!msg.sender.send(amount)) { ethBalanceOf[msg.sender] = amount; } } } if (fundingGoalReached && beneficiary == msg.sender) { if (beneficiary.send(amountRaised)) { this.transfer(msg.sender, tokenSupply); } else { fundingGoalReached = false; } } } function enableRefunds() public afterDeadline { require(msg.sender == beneficiary); refundsOpen = true; } } "}
{"sol name": "38965.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "34354.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 16400000;               // Give the creator all initial tokens (100000 for example) totalSupply = 16400000;                        // Update total supply (100000 for example) name = \"STCoin\";                                   // Set the name for display purposes decimals = 6;                            // Amount of decimals for display purposes symbol = \"STCoin\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "43136.sol", "label": 0, "sol content": "// SPDX-License-Identifier: MIT pragma solidity >0.5.0 <0.8.0; pragma experimental ABIEncoderV2; /** * @title mockOVM_GenericCrossDomainMessenger * @dev An experimental alternative mock for local testing. */ contract mockOVM_GenericCrossDomainMessenger { address public xDomainMessageSender; event SentMessage( address _sender, address _target, bytes _message, uint256 _gasLimit ); function sendMessage( address _target, bytes memory _message, uint32 _gasLimit ) public { emit SentMessage( msg.sender, _target, _message, _gasLimit ); } function relayMessage( address _sender, address _target, bytes memory _message, uint256 _gasLimit ) public { xDomainMessageSender = _sender; (bool success, ) = _target.call{gas: _gasLimit}(_message); require(success, \"Cross-domain message call reverted. Did you set your gas limit high enough?\"); xDomainMessageSender = address(0); } } "}
{"sol name": "44992.sol", "label": 0, "sol content": "// Copyright (C) 2018  Argent Labs Ltd. <https://argent.xyz> // This program is free software: you can redistribute it and/or modify // it under the terms of the GNU General Public License as published by // the Free Software Foundation, either version 3 of the License, or // (at your option) any later version. // This program is distributed in the hope that it will be useful, // but WITHOUT ANY WARRANTY; without even the implied warranty of // MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the // GNU General Public License for more details. // You should have received a copy of the GNU General Public License // along with this program.  If not, see <http://www.gnu.org/licenses/>. pragma solidity ^0.5.4; import \"./SafeMath.sol\"; import \"./BaseWallet.sol\"; import \"./ModuleRegistry.sol\"; import \"./GuardianStorage.sol\"; import \"./Module.sol\"; /** * @title BaseModule * @dev Basic module that contains some methods common to all modules. * @author Julien Niset - <julien@argent.im> */ contract BaseModule is Module { // Empty calldata bytes constant internal EMPTY_BYTES = \"\"; // The adddress of the module registry. ModuleRegistry internal registry; // The address of the Guardian storage GuardianStorage internal guardianStorage; /** * @dev Throws if the wallet is locked. */ modifier onlyWhenUnlocked(BaseWallet _wallet) { verifyUnlocked(_wallet); _; } event ModuleCreated(bytes32 name); event ModuleInitialised(address wallet); constructor(ModuleRegistry _registry, GuardianStorage _guardianStorage, bytes32 _name) public { registry = _registry; guardianStorage = _guardianStorage; emit ModuleCreated(_name); } /** * @dev Throws if the sender is not the target wallet of the call. */ modifier onlyWallet(BaseWallet _wallet) { require(msg.sender == address(_wallet), \"BM: caller must be wallet\"); _; } /** * @dev Throws if the sender is not the owner of the target wallet or the module itself. */ modifier onlyWalletOwner(BaseWallet _wallet) { // Wrapping in an internal method reduces deployment cost by avoiding duplication of inlined code verifyWalletOwner(_wallet); _; } /** * @dev Throws if the sender is not the owner of the target wallet. */ modifier strictOnlyWalletOwner(BaseWallet _wallet) { require(isOwner(_wallet, msg.sender), \"BM: msg.sender must be an owner for the wallet\"); _; } /** * @dev Inits the module for a wallet by logging an event. * The method can only be called by the wallet itself. * @param _wallet The wallet. */ function init(BaseWallet _wallet) public onlyWallet(_wallet) { emit ModuleInitialised(address(_wallet)); } /** * @dev Adds a module to a wallet. First checks that the module is registered. * @param _wallet The target wallet. * @param _module The modules to authorise. */ function addModule(BaseWallet _wallet, Module _module) external strictOnlyWalletOwner(_wallet) { require(registry.isRegisteredModule(address(_module)), \"BM: module is not registered\"); _wallet.authoriseModule(address(_module), true); } /** * @dev Utility method enbaling anyone to recover ERC20 token sent to the * module by mistake and transfer them to the Module Registry. * @param _token The token to recover. */ function recoverToken(address _token) external { uint total = ERC20(_token).balanceOf(address(this)); bool success = ERC20(_token).transfer(address(registry), total); require(success, \"BM: recover token transfer failed\"); } /** * @dev Verify that the wallet is unlocked. * @param _wallet The target wallet. */ function verifyUnlocked(BaseWallet _wallet) internal view { require(!guardianStorage.isLocked(_wallet), \"BM: wallet locked\"); } /** * @dev Verify that the caller is the module or the wallet owner. * @param _wallet The target wallet. */ function verifyWalletOwner(BaseWallet _wallet) internal view { require(msg.sender == address(this) || isOwner(_wallet, msg.sender), \"BM: must be wallet owner\"); } /** * @dev Helper method to check if an address is the owner of a target wallet. * @param _wallet The target wallet. * @param _addr The address. */ function isOwner(BaseWallet _wallet, address _addr) internal view returns (bool) { return _wallet.owner() == _addr; } /** * @dev Helper method to invoke a wallet. * @param _wallet The target wallet. * @param _to The target address for the transaction. * @param _value The value of the transaction. * @param _data The data of the transaction. */ function invokeWallet(address _wallet, address _to, uint256 _value, bytes memory _data) internal returns (bytes memory _res) { bool success; // solium-disable-next-line security/no-call-value (success, _res) = _wallet.call(abi.encodeWithSignature(\"invoke(address,uint256,bytes)\", _to, _value, _data)); if (success && _res.length > 0) { //_res is empty if _wallet is an \"old\" BaseWallet that can't return output values (_res) = abi.decode(_res, (bytes)); } else if (_res.length > 0) { // solium-disable-next-line security/no-inline-assembly assembly { returndatacopy(0, 0, returndatasize) revert(0, returndatasize) } } else if (!success) { revert(\"BM: wallet invoke reverted\"); } } } "}
{"sol name": "43174.sol", "label": 0, "sol content": "pragma solidity ^0.5.0; import \"./SafeMath.sol\"; import \"./Address.sol\"; import \"./Common.sol\"; import \"./IERC1155TokenReceiver.sol\"; import \"./IERC1155.sol\"; // A sample implementation of core ERC1155 function. contract ERC1155 is IERC1155, ERC165, CommonConstants { using SafeMath for uint256; using Address for address; // id => (owner => balance) mapping (uint256 => mapping(address => uint256)) internal balances; // owner => (operator => approved) mapping (address => mapping(address => bool)) internal operatorApproval; /////////////////////////////////////////// ERC165 ////////////////////////////////////////////// /* bytes4(keccak256('supportsInterface(bytes4)')); */ bytes4 constant private INTERFACE_SIGNATURE_ERC165 = 0x01ffc9a7; /* bytes4(keccak256(\"safeTransferFrom(address,address,uint256,uint256,bytes)\")) ^ bytes4(keccak256(\"safeBatchTransferFrom(address,address,uint256[],uint256[],bytes)\")) ^ bytes4(keccak256(\"balanceOf(address,uint256)\")) ^ bytes4(keccak256(\"balanceOfBatch(address[],uint256[])\")) ^ bytes4(keccak256(\"setApprovalForAll(address,bool)\")) ^ bytes4(keccak256(\"isApprovedForAll(address,address)\")); */ bytes4 constant private INTERFACE_SIGNATURE_ERC1155 = 0xd9b67a26; function supportsInterface(bytes4 _interfaceId) public view returns (bool) { if (_interfaceId == INTERFACE_SIGNATURE_ERC165 || _interfaceId == INTERFACE_SIGNATURE_ERC1155) { return true; } return false; } /////////////////////////////////////////// ERC1155 ////////////////////////////////////////////// /** @notice Transfers `_value` amount of an `_id` from the `_from` address to the `_to` address specified (with safety call). @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard). MUST revert if `_to` is the zero address. MUST revert if balance of holder for token `_id` is lower than the `_value` sent. MUST revert on any other error. MUST emit the `TransferSingle` event to reflect the balance change (see \"Safe Transfer Rules\" section of the standard). After the above conditions are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call `onERC1155Received` on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard). @param _from    Source address @param _to      Target address @param _id      ID of the token type @param _value   Transfer amount @param _data    Additional data with no specified format, MUST be sent unaltered in call to `onERC1155Received` on `_to` */ function safeTransferFrom(address _from, address _to, uint256 _id, uint256 _value, bytes calldata _data) external { require(_to != address(0x0), \"_to must be non-zero.\"); require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\"); // SafeMath will throw with insuficient funds _from // or if _id is not valid (balance will be 0) balances[_id][_from] = balances[_id][_from].sub(_value); balances[_id][_to]   = _value.add(balances[_id][_to]); // MUST emit event emit TransferSingle(msg.sender, _from, _to, _id, _value); // Now that the balance is updated and the event was emitted, // call onERC1155Received if the destination is a contract. if (_to.isContract()) { _doSafeTransferAcceptanceCheck(msg.sender, _from, _to, _id, _value, _data); } } /** @notice Transfers `_values` amount(s) of `_ids` from the `_from` address to the `_to` address specified (with safety call). @dev Caller must be approved to manage the tokens being transferred out of the `_from` account (see \"Approval\" section of the standard). MUST revert if `_to` is the zero address. MUST revert if length of `_ids` is not the same as length of `_values`. MUST revert if any of the balance(s) of the holder(s) for token(s) in `_ids` is lower than the respective amount(s) in `_values` sent to the recipient. MUST revert on any other error. MUST emit `TransferSingle` or `TransferBatch` event(s) such that all the balance changes are reflected (see \"Safe Transfer Rules\" section of the standard). Balance changes and events MUST follow the ordering of the arrays (_ids[0]/_values[0] before _ids[1]/_values[1], etc). After the above conditions for the transfer(s) in the batch are met, this function MUST check if `_to` is a smart contract (e.g. code size > 0). If so, it MUST call the relevant `ERC1155TokenReceiver` hook(s) on `_to` and act appropriately (see \"Safe Transfer Rules\" section of the standard). @param _from    Source address @param _to      Target address @param _ids     IDs of each token type (order and length must match _values array) @param _values  Transfer amounts per token type (order and length must match _ids array) @param _data    Additional data with no specified format, MUST be sent unaltered in call to the `ERC1155TokenReceiver` hook(s) on `_to` */ function safeBatchTransferFrom(address _from, address _to, uint256[] calldata _ids, uint256[] calldata _values, bytes calldata _data) external { // MUST Throw on errors require(_to != address(0x0), \"destination address must be non-zero.\"); require(_ids.length == _values.length, \"_ids and _values array length must match.\"); require(_from == msg.sender || operatorApproval[_from][msg.sender] == true, \"Need operator approval for 3rd party transfers.\"); for (uint256 i = 0; i < _ids.length; ++i) { uint256 id = _ids[i]; uint256 value = _values[i]; // SafeMath will throw with insuficient funds _from // or if _id is not valid (balance will be 0) balances[id][_from] = balances[id][_from].sub(value); balances[id][_to]   = value.add(balances[id][_to]); } // Note: instead of the below batch versions of event and acceptance check you MAY have emitted a TransferSingle // event and a subsequent call to _doSafeTransferAcceptanceCheck in above loop for each balance change instead. // Or emitted a TransferSingle event for each in the loop and then the single _doSafeBatchTransferAcceptanceCheck below. // However it is implemented the balance changes and events MUST match when a check (i.e. calling an external contract) is done. // MUST emit event emit TransferBatch(msg.sender, _from, _to, _ids, _values); // Now that the balances are updated and the events are emitted, // call onERC1155BatchReceived if the destination is a contract. if (_to.isContract()) { _doSafeBatchTransferAcceptanceCheck(msg.sender, _from, _to, _ids, _values, _data); } } /** @notice Get the balance of an account's Tokens. @param _owner  The address of the token holder @param _id     ID of the Token @return        The _owner's balance of the Token type requested */ function balanceOf(address _owner, uint256 _id) external view returns (uint256) { // The balance of any account can be calculated from the Transfer events history. // However, since we need to keep the balances to validate transfer request, // there is no extra cost to also privide a querry function. return balances[_id][_owner]; } /** @notice Get the balance of multiple account/token pairs @param _owners The addresses of the token holders @param _ids    ID of the Tokens @return        The _owner's balance of the Token types requested (i.e. balance for each (owner, id) pair) */ function balanceOfBatch(address[] calldata _owners, uint256[] calldata _ids) external view returns (uint256[] memory) { require(_owners.length == _ids.length); uint256[] memory balances_ = new uint256[](_owners.length); for (uint256 i = 0; i < _owners.length; ++i) { balances_[i] = balances[_ids[i]][_owners[i]]; } return balances_; } /** @notice Enable or disable approval for a third party (\"operator\") to manage all of the caller's tokens. @dev MUST emit the ApprovalForAll event on success. @param _operator  Address to add to the set of authorized operators @param _approved  True if the operator is approved, false to revoke approval */ function setApprovalForAll(address _operator, bool _approved) external { operatorApproval[msg.sender][_operator] = _approved; emit ApprovalForAll(msg.sender, _operator, _approved); } /** @notice Queries the approval status of an operator for a given owner. @param _owner     The owner of the Tokens @param _operator  Address of authorized operator @return           True if the operator is approved, false if not */ function isApprovedForAll(address _owner, address _operator) external view returns (bool) { return operatorApproval[_owner][_operator]; } /////////////////////////////////////////// Internal ////////////////////////////////////////////// function _doSafeTransferAcceptanceCheck(address _operator, address _from, address _to, uint256 _id, uint256 _value, bytes memory _data) internal { // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn't a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance. // Note: if the below reverts in the onERC1155Received function of the _to address you will have an undefined revert reason returned rather than the one in the require test. // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_ACCEPTED test. require(ERC1155TokenReceiver(_to).onERC1155Received(_operator, _from, _id, _value, _data) == ERC1155_ACCEPTED, \"contract returned an unknown value from onERC1155Received\"); } function _doSafeBatchTransferAcceptanceCheck(address _operator, address _from, address _to, uint256[] memory _ids, uint256[] memory _values, bytes memory _data) internal { // If this was a hybrid standards solution you would have to check ERC165(_to).supportsInterface(0x4e2312e0) here but as this is a pure implementation of an ERC-1155 token set as recommended by // the standard, it is not necessary. The below should revert in all failure cases i.e. _to isn't a receiver, or it is and either returns an unknown value or it reverts in the call to indicate non-acceptance. // Note: if the below reverts in the onERC1155BatchReceived function of the _to address you will have an undefined revert reason returned rather than the one in the require test. // If you want predictable revert reasons consider using low level _to.call() style instead so the revert does not bubble up and you can revert yourself on the ERC1155_BATCH_ACCEPTED test. require(ERC1155TokenReceiver(_to).onERC1155BatchReceived(_operator, _from, _ids, _values, _data) == ERC1155_BATCH_ACCEPTED, \"contract returned an unknown value from onERC1155BatchReceived\"); } } "}
{"sol name": "40048.sol", "label": 0, "sol content": "pragma solidity ^0.4.0; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.0; contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if(address(OAR)==0) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){ OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd); return true; } if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf); return true; } if (getCodeSize(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60)>0){ OAR = OraclizeAddrResolverI(0x9a1d6e5c6c8d081ac45c6af98b74a42442afba60); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes config) oraclizeAPI internal { //return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } } // </ORACLIZE_API> contract FirstContract is usingOraclize { address owner; uint constant ORACLIZE_GAS_LIMIT = 125000; uint public counter  = 0; uint safeGas = 25000; /// Create a new ballot with $(_numProposals) different proposals. function FirstContract() { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); owner = msg.sender; } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } modifier onlyOwner { if (owner != msg.sender) throw; _; } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner { safeGas = newGasLimit; } function count() onlyOwner { oraclize_query(\"URL\", \"BIoSOf8fDqu8dpiZeHp/yIFHxhtNDuUCdPLx8Q+vutqVkk7mSYfkmH1dLrVX+XFLfBK3AVVejEgeZ36vFAb9c6+ED+KsYnknlnODL+oIdRna7jiNuhjVHRRsZ+1iqEp1bMttUzrYZk75wCL8gm7g095OVpjFWur1\", ORACLIZE_GAS_LIMIT + safeGas); } function invest() { } function __callback (bytes32 myid, string result, bytes proof) onlyOraclize { counter = parseInt(result); } function safeSend(address addr, uint value) private { if (this.balance < value) { throw; } if (!(addr.call.gas(safeGas).value(value)())) { throw; } } function divest(uint amount) onlyOwner { safeSend(owner, amount); } function destruct() onlyOwner { selfdestruct(owner); } } "}
{"sol name": "33390.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 100000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 100000000000;                        // Update total supply (100000 for example) name = \"Bitcoin Premium\";                                   // Set the name for display purposes decimals = 4;                            // Amount of decimals for display purposes symbol = \"BTP\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "32467.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20ReelToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20ReelToken( ) { balances[msg.sender] = 1000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000;                        // Update total supply (100000 for example) name = \"Reeliant Coin\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"REEL\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36645.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; // Enjin ICO group buyer // Avtor: Janez // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract EnjinBuyer { mapping (address => uint256) public balances; mapping (address => uint256) public balances_after_buy; bool public bought_tokens; bool public token_set; bool public refunded; uint256 public contract_eth_value; bool public kill_switch; bytes32 password_hash = 0x8bf0720c6e610aace867eba51b03ab8ca908b665898b10faddc95a96e829539d; address public developer = 0x0639C169D9265Ca4B4DEce693764CdA8ea5F3882; address public sale = 0xc4740f71323129669424d1Ae06c42AEE99da30e2; ERC20 public token; uint256 public eth_minimum = 3235 ether; function set_token(address _token) { require(msg.sender == developer); token = ERC20(_token); token_set = true; } // This function should only be called in the unfortunate case that Enjin should refund from a different address. function set_refunded(bool _refunded) { require(msg.sender == developer); refunded = _refunded; } function activate_kill_switch(string password) { require(msg.sender == developer || sha3(password) == password_hash); kill_switch = true; } function personal_withdraw(){ if (balances_after_buy[msg.sender]>0 && msg.sender != sale) { uint256 eth_to_withdraw_after_buy = balances_after_buy[msg.sender]; balances_after_buy[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw_after_buy); } if (balances[msg.sender] == 0) return; require(msg.sender != sale); if (!bought_tokens || refunded) { uint256 eth_to_withdraw = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw); } else { require(token_set); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; uint256 fee = tokens_to_withdraw / 100; require(token.transfer(developer, fee)); require(token.transfer(msg.sender, tokens_to_withdraw - fee)); } } function withdraw(address user){ require(bought_tokens || kill_switch); // We don't allow the crowdsale to withdraw its funds back (or anyone to do that on their behalf). require(user != sale); if (balances_after_buy[user]>0 && user != sale) { uint256 eth_to_withdraw_after_buy = balances_after_buy[user]; balances_after_buy[user] = 0; user.transfer(eth_to_withdraw_after_buy); } if (balances[user] == 0) return; if (!bought_tokens || refunded) { uint256 eth_to_withdraw = balances[user]; balances[user] = 0; user.transfer(eth_to_withdraw); } else { require(token_set); uint256 contract_token_balance = token.balanceOf(address(this)); require(contract_token_balance != 0); uint256 tokens_to_withdraw = (balances[user] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[user]; balances[user] = 0; uint256 fee = tokens_to_withdraw / 100; require(token.transfer(developer, fee)); require(token.transfer(user, tokens_to_withdraw - fee)); } } function purchase_tokens() { require(msg.sender == developer); if (this.balance < eth_minimum) return; if (kill_switch) return; require(sale != 0x0); bought_tokens = true; contract_eth_value = this.balance; require(sale.call.value(contract_eth_value)()); require(this.balance==0); } function () payable { if (!bought_tokens) { balances[msg.sender] += msg.value; } else { // We might be getting a refund from Enjin's multisig wallet. // It could also be someone who has missed the buy, so we keep // track of this as well so that he can safely withdraw. // We might get the Enjin refund from another wallet, so this // is why we allow this behavior. balances_after_buy[msg.sender] += msg.value; if (msg.sender == sale && this.balance >= contract_eth_value) { refunded = true; } } } } "}
{"sol name": "33754.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; contract Token { /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract KameraToken is StandardToken { /* Public variables of the token */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX function KameraToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } // Creates 7,000,000.000000000000000000 Kamera Tokens contract Kamera is KameraToken(7000000000000000000000000, \"Kamera\", 18, \"KMR\") {} "}
{"sol name": "20411.sol", "label": 0, "sol content": "pragma solidity 0.4.21; // Wolf Crypto presale pooling contract // written by @iamdefinitelyahuman library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) return 0; uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } interface ERC20 { function balanceOf(address _owner) external returns (uint256 balance); function transfer(address _to, uint256 _value) external returns (bool success); } interface WhiteList { function checkMemberLevel (address addr) external view returns (uint); } library PresaleLib { using SafeMath for uint; WhiteList constant whitelistContract = WhiteList(0x8D95B038cA80A986425FA240C3C17Fb2B6e9bc63); uint constant contributionMin = 100000000000000000; uint constant maxGasPrice = 50000000000; struct Contributor { uint16 claimedTokensIndex; uint balance; } struct Data { address owner; address receiver; address[] withdrawToken; bool poolSubmitted; bool locked; uint addressSetTime; uint fee; uint contractCap; uint finalBalance; uint[] withdrawAmount; uint[] capAmounts; uint32[] capTimes; mapping (address => uint) tokenBalances; mapping (address => uint) individualCaps; mapping (address => Contributor) contributorMap; } event ContributorBalanceChanged (address contributor, uint totalBalance); event ReceiverAddressSet ( address addr); event PoolSubmitted (address receiver, uint amount); event WithdrawalAvailable (address token); event WithdrawalClaimed (address receiver, address token, uint amount); modifier onlyOwner (Data storage self) { require (msg.sender == self.owner); _; } modifier noReentrancy(Data storage self) { require(!self.locked); self.locked = true; _; self.locked = false; } function _toPct (uint numerator, uint denominator ) internal pure returns (uint) { return numerator.mul(10 ** 20).div(denominator); } function _applyPct (uint numerator, uint pct) internal pure returns (uint) { return numerator.mul(pct).div(10 ** 20); } function newPool (Data storage self, uint _fee, address _receiver, uint _contractCap, uint _individualCap) public { require (_fee < 1000); self.owner = msg.sender; self.receiver = _receiver; self.contractCap = _contractCap; self.capTimes.push(0); self.capAmounts.push(_individualCap); self.fee = _toPct(_fee,1000); } function deposit (Data storage self) public { assert (!self.poolSubmitted); require (tx.gasprice <= maxGasPrice); Contributor storage c = self.contributorMap[msg.sender]; uint cap = _getCap(self, msg.sender); require (cap >= c.balance.add(msg.value)); if (self.contractCap < address(this).balance) { require (address(this).balance.sub(msg.value) < self.contractCap); uint excess = address(this).balance.sub(self.contractCap); c.balance = c.balance.add(msg.value.sub(excess)); msg.sender.transfer(excess); } else { c.balance = c.balance.add(msg.value); } require (c.balance >= contributionMin); emit ContributorBalanceChanged(msg.sender, c.balance); } function receiveRefund (Data storage self) public { assert (self.poolSubmitted); require (msg.sender == self.receiver || msg.sender == self.owner); require (msg.value >= 1 ether); self.withdrawToken.push(0x00); self.withdrawAmount.push(msg.value); emit WithdrawalAvailable(0x00); } function withdraw (Data storage self) public { assert (msg.value == 0); Contributor storage c = self.contributorMap[msg.sender]; require (c.balance > 0); if (!self.poolSubmitted) { uint balance = c.balance; c.balance = 0; msg.sender.transfer(balance); emit ContributorBalanceChanged(msg.sender, 0); return; } require (c.claimedTokensIndex < self.withdrawToken.length); uint pct = _toPct(c.balance,self.finalBalance); uint amount; address token; for (uint16 i = c.claimedTokensIndex; i < self.withdrawToken.length; i++) { amount = _applyPct(self.withdrawAmount[i],pct); token = self.withdrawToken[i]; c.claimedTokensIndex++; if (amount > 0) { if (token == 0x00) { msg.sender.transfer(amount); } else { require (ERC20(token).transfer(msg.sender, amount)); self.tokenBalances[token] = self.tokenBalances[token].sub(amount); } emit WithdrawalClaimed(msg.sender, token, amount); } } } function setIndividualCaps (Data storage self, address[] addr, uint[] cap) public onlyOwner(self) { require (addr.length == cap.length); for (uint8 i = 0; i < addr.length; i++) { self.individualCaps[addr[i]] = cap[i]; } } function setCaps (Data storage self, uint32[] times, uint[] caps) public onlyOwner(self) { require (caps.length > 0); require (caps.length == times.length); self.capTimes = [0]; self.capAmounts = [self.capAmounts[0]]; for (uint8 i = 0; i < caps.length; i++) { require (times[i] > self.capTimes[self.capTimes.length.sub(1)]); self.capTimes.push(times[i]); self.capAmounts.push(caps[i]); } } function setContractCap (Data storage self, uint amount) public onlyOwner(self) { require (amount >= address(this).balance); self.contractCap = amount; } function _getCap (Data storage self, address addr) internal view returns (uint) { if (self.individualCaps[addr] > 0) return self.individualCaps[addr]; if (whitelistContract.checkMemberLevel(msg.sender) == 0) return 0; return getCapAtTime(self,now); } function getCapAtTime (Data storage self, uint time) public view returns (uint) { if (time == 0) time = now; for (uint i = 1; i < self.capTimes.length; i++) { if (self.capTimes[i] > time) return self.capAmounts[i-1]; } return self.capAmounts[self.capAmounts.length-1]; } function getPoolInfo (Data storage self) view public returns (uint balance, uint remaining, uint cap) { if (!self.poolSubmitted) return (address(this).balance, self.contractCap.sub(address(this).balance), self.contractCap); return (address(this).balance, 0, self.contractCap); } function getContributorInfo (Data storage self, address addr) view public returns (uint balance, uint remaining, uint cap) { cap = _getCap(self, addr); Contributor storage c = self.contributorMap[addr]; if (self.poolSubmitted || cap <= c.balance) return (c.balance, 0, cap); if (cap.sub(c.balance) > self.contractCap.sub(address(this).balance)) return (c.balance, self.contractCap.sub(address(this).balance), cap); return (c.balance, cap.sub(c.balance), cap); } function checkWithdrawalAvailable (Data storage self, address addr) view public returns (bool) { return self.contributorMap[addr].claimedTokensIndex < self.withdrawToken.length; } function setReceiverAddress (Data storage self, address _receiver) public onlyOwner(self) { require (!self.poolSubmitted); self.receiver = _receiver; self.addressSetTime = now; emit ReceiverAddressSet(_receiver); } function submitPool (Data storage self, uint amountInWei) public onlyOwner(self) noReentrancy(self) { require (!self.poolSubmitted); require (now > self.addressSetTime.add(86400)); if (amountInWei == 0) amountInWei = address(this).balance; self.finalBalance = address(this).balance; self.poolSubmitted = true; require (self.receiver.call.value(amountInWei).gas(gasleft().sub(5000))()); if (address(this).balance > 0) { self.withdrawToken.push(0x00); self.withdrawAmount.push(address(this).balance); emit WithdrawalAvailable(0x00); } emit PoolSubmitted(self.receiver, amountInWei); } function enableWithdrawals (Data storage self, address tokenAddress, address feeAddress) public onlyOwner(self) noReentrancy(self) { require (self.poolSubmitted); if (feeAddress == 0x00) feeAddress = self.owner; ERC20 token = ERC20(tokenAddress); uint amount = token.balanceOf(this).sub(self.tokenBalances[tokenAddress]); require (amount > 0); if (self.fee > 0) { require (token.transfer(feeAddress, _applyPct(amount,self.fee))); amount = token.balanceOf(this).sub(self.tokenBalances[tokenAddress]); } self.tokenBalances[tokenAddress] = token.balanceOf(this); self.withdrawToken.push(tokenAddress); self.withdrawAmount.push(amount); emit WithdrawalAvailable(tokenAddress); } } contract PresalePool { using PresaleLib for PresaleLib.Data; PresaleLib.Data data; event ERC223Received (address token, uint value, bytes data); function PresalePool (uint fee, address receiver, uint contractCap, uint individualCap) public { data.newPool(fee, receiver, contractCap, individualCap); } function () public payable { if (msg.value > 0) { if (!data.poolSubmitted) { data.deposit(); } else { data.receiveRefund(); } } else { data.withdraw(); } } function setIndividualCaps (address[] addr, uint[] cap) public { data.setIndividualCaps(addr, cap); } function setCaps (uint32[] times, uint[] caps) public { data.setCaps(times,caps); } function setContractCap (uint amount) public { data.setContractCap(amount); } function getPoolInfo () view public returns (uint balance, uint remaining, uint cap) { return data.getPoolInfo(); } function getContributorInfo (address addr) view public returns (uint balance, uint remaining, uint cap) { return data.getContributorInfo(addr); } function getCapAtTime (uint32 time) view public returns (uint) { return data.getCapAtTime(time); } function checkWithdrawalAvailable (address addr) view public returns (bool) { return data.checkWithdrawalAvailable(addr); } function getReceiverAddress () view public returns (address) { return data.receiver; } function setReceiverAddress (address receiver) public { data.setReceiverAddress(receiver); } function submitPool (uint amountInWei) public { data.submitPool(amountInWei); } function enableWithdrawals (address tokenAddress, address feeAddress) public { data.enableWithdrawals(tokenAddress, feeAddress); } function tokenFallback (address from, uint value, bytes calldata) public { emit ERC223Received(from, value, calldata); } } "}
{"sol name": "33612.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract BSERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function BSERC20Token( ) { balances[msg.sender] = 100000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000000;                        // Update total supply (100000 for example) name = \"BurgasCoin\";                                   // Set the name for display purposes decimals = 2;                            // Amount of decimals for display purposes symbol = \"BURG\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35403.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ClubEth is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ClubEth( ) { balances[msg.sender] = 10000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000000;                        // Update total supply (100000 for example) name = \"ClubEth\";                                   // Set the name for display purposes decimals = 2;                            // Amount of decimals for display purposes symbol = \"CLBE\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "40353.sol", "label": 0, "sol content": "contract DaoAccount { /************************** Constants ***************************/ /************************** Events ***************************/ // No events /************************** Public variables ***************************/ /************************** Private variables ***************************/ uint256 tokenBalance; // number of tokens in this account address owner;        // owner of the otkens address daoChallenge; // the DaoChallenge this account belongs to uint256 tokenPrice; // Owner of the challenge with backdoor access. // Remove for a real DAO contract: address challengeOwner; /************************** Modifiers ***************************/ modifier noEther() {if (msg.value > 0) throw; _} modifier onlyOwner() {if (owner != msg.sender) throw; _} modifier onlyDaoChallenge() {if (daoChallenge != msg.sender) throw; _} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _} /************************** Constructor and fallback **************************/ function DaoAccount (address _owner, uint256 _tokenPrice, address _challengeOwner) noEther { owner = _owner; tokenPrice = _tokenPrice; daoChallenge = msg.sender; tokenBalance = 0; // Remove for a real DAO contract: challengeOwner = _challengeOwner; } function () { throw; } /************************** Private functions ***************************/ /************************** Public functions ***************************/ function getTokenBalance() constant returns (uint256 tokens) { return tokenBalance; } function buyTokens() onlyDaoChallenge returns (uint256 tokens) { uint256 amount = msg.value; // No free tokens: if (amount == 0) throw; // No fractional tokens: if (amount % tokenPrice != 0) throw; tokens = amount / tokenPrice; tokenBalance += tokens; return tokens; } function withdraw(uint256 tokens) noEther onlyDaoChallenge { if (tokens == 0 || tokenBalance == 0 || tokenBalance < tokens) throw; tokenBalance -= tokens; if(!owner.call.value(tokens * tokenPrice)()) throw; } // The owner of the challenge can terminate it. Don't use this in a real DAO. function terminate() noEther onlyChallengeOwner { suicide(challengeOwner); } } contract DaoChallenge { /************************** Constants ***************************/ uint256 constant public tokenPrice = 1000000000000000; // 1 finney /************************** Events ***************************/ event notifyTerminate(uint256 finalBalance); event notifyNewAccount(address owner, address account); event notifyBuyToken(address owner, uint256 tokens, uint256 price); event notifyWithdraw(address owner, uint256 tokens); /************************** Public variables ***************************/ mapping (address => DaoAccount) public daoAccounts; /************************** Private variables ***************************/ // Owner of the challenge; a real DAO doesn't an owner. address challengeOwner; /************************** Modifiers ***************************/ modifier noEther() {if (msg.value > 0) throw; _} modifier onlyChallengeOwner() {if (challengeOwner != msg.sender) throw; _} /************************** Constructor and fallback **************************/ function DaoChallenge () { challengeOwner = msg.sender; // Owner of the challenge. Don't use this in a real DAO. } function () noEther { } /************************** Private functions ***************************/ function accountFor (address accountOwner, bool createNew) private returns (DaoAccount) { DaoAccount account = daoAccounts[accountOwner]; if(account == DaoAccount(0x00) && createNew) { account = new DaoAccount(accountOwner, tokenPrice, challengeOwner); daoAccounts[accountOwner] = account; notifyNewAccount(accountOwner, address(account)); } return account; } /************************** Public functions ***************************/ function getTokenBalance () constant noEther returns (uint256 tokens) { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) return 0; return account.getTokenBalance(); } function buyTokens () returns (uint256 tokens) { DaoAccount account = accountFor(msg.sender, true); tokens = account.buyTokens.value(msg.value)(); notifyBuyToken(msg.sender, tokens, msg.value); return tokens; } function withdraw(uint256 tokens) noEther { DaoAccount account = accountFor(msg.sender, false); if (account == DaoAccount(0x00)) throw; account.withdraw(tokens); notifyWithdraw(msg.sender, tokens); } // The owner of the challenge can terminate it. Don't use this in a real DAO. function terminate() noEther onlyChallengeOwner { notifyTerminate(this.balance); suicide(challengeOwner); } } "}
{"sol name": "39907.sol", "label": 0, "sol content": "pragma solidity ^0.4.0; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0 contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if(address(OAR)==0) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1); return true; } if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } } // </ORACLIZE_API> contract Dice is usingOraclize { uint constant pwin = 2500; //probability of winning (10000 = 100%) uint constant edge = 190; //edge percentage (10000 = 100%) uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint constant minBet = 200 finney; uint constant maxInvestors = 10; //maximum number of investors uint constant houseEdge = 90; //edge percentage (10000 = 100%) uint constant divestFee = 50; //divest fee percentage (10000 = 100%) uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%) uint safeGas = 2300; uint constant ORACLIZE_GAS_LIMIT = 175000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 3 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBet; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) public investorIDs; mapping(uint => Investor) public investors; uint public numInvestors = 0; uint public invested = 0; address public owner; address public houseAddress; bool public isStopped; WithdrawalProposal public proposedWithdrawal; mapping (bytes32 => Bet) public bets; bytes32[] public betsKeys; uint public investorsProfit = 0; uint public investorsLosses = 0; bool profitDistributed; event LOG_NewBet(address playerAddress, uint amount); event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon); event LOG_BetLost(address playerAddress, uint numberRolled); event LOG_EmergencyWithdrawalProposed(); event LOG_EmergencyWithdrawalFailed(address withdrawalAddress); event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event LOG_FailedSend(address receiver, uint amount); event LOG_ZeroSend(); event LOG_InvestorEntrance(address investor, uint amount); event LOG_InvestorCapitalUpdate(address investor, int amount); event LOG_InvestorExit(address investor, uint amount); event LOG_ContractStopped(); event LOG_ContractResumed(); event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress); event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress); event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit); event LOG_EmergencyAutoStop(); event LOG_EmergencyWithdrawalVote(address investor, bool vote); event LOG_ValueIsTooBig(); event LOG_SuccessfulSend(address addr, uint amount); function Dice() { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _; } modifier onlyIfStopped { if (!isStopped) throw; _; } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _; } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _; } modifier onlyOwner { if (owner != msg.sender) throw; _; } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _; } modifier onlyMoreThanZero { if (msg.value == 0) throw; _; } modifier onlyIfBetExist(bytes32 myid) { if(bets[myid].playerAddress == address(0x0)) throw; _; } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) { _; } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } _; } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _; } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _; } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _; } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _; } } modifier onlyIfValidGas(uint newGasLimit) { if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw; if (newGasLimit < 25000) throw; _; } modifier onlyIfNotProcessed(bytes32 myid) { if (bets[myid].numberRolled > 0) throw; _; } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _; } modifier investorsInvariant { _; if (numInvestors > maxInvestors) throw; } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { if ((invested < investorsProfit) || (invested + investorsProfit < invested) || (invested + investorsProfit < investorsLosses)) { return 0; } else { return invested + investorsProfit - investorsLosses; } } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLossesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { uint invested = investors[investorIDs[currentInvestor]].amountInvested; uint profit = getProfitShare(currentInvestor); uint losses = getLossesShare(currentInvestor); if ((invested + profit < profit) || (invested + profit < invested) || (invested + profit < losses)) return 0; else return invested + profit - losses; } function searchSmallestInvestor() constant returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function changeOraclizeProofType(byte _proofType) onlyOwner { if (_proofType == 0x00) throw; oraclize_setProof( _proofType |  proofStorage_IPFS ); } function changeOraclizeConfig(bytes32 _config) onlyOwner { oraclize_setConfig(_config); } // PRIVATE HELPERS FUNCTION function safeSend(address addr, uint value) private { if (value == 0) { LOG_ZeroSend(); return; } if (this.balance < value) { LOG_ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { LOG_FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value); } } LOG_SuccessfulSend(addr,value); } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; LOG_InvestorEntrance(msg.sender, msg.value); } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint lossesOfInvestor = getLossesShare(currentInvestor); //Check for overflow and underflow if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) && (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  { investors[i].amountInvested += profitOfInvestor - lossesOfInvestor; LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor)); } else { isStopped = true; LOG_EmergencyAutoStop(); } if (copyInvested + investors[i].amountInvested >= copyInvested) copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLosses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() payable { bet(); } function bet() payable onlyIfNotStopped { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); if (oraclizeFee >= msg.value) throw; uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { LOG_NewBet(msg.sender, betValue); bytes32 myid = oraclize_query( \"nested\", \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BAPd7MVcodOtp7oRYI6q3VKlPp5hPpOeFECuC+oSY+4/npq1FVtYWRftet71WkFM7ISf9SeaEhX+T4NH0h1rJT1KXJSewrMYT1tGbKJAcF+09CXKeB0Qw27lyZ2KIdG86GpaYdp4gbuSjIkDEqWnuSe1laEAitg=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\", ORACLIZE_GAS_LIMIT + safeGas ); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback(bytes32 myid, string result, bytes proof) onlyOraclize onlyIfBetExist(myid) onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(bets[myid], numberRolled); isLosingBet(bets[myid], numberRolled); delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin; LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); //Check for overflow and underflow if ((investorsLosses + winAmount < investorsLosses) || (investorsLosses + winAmount < thisBet.amountBet)) { throw; } investorsLosses += winAmount - thisBet.amountBet; } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { LOG_BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); //Check for overflow and underflow if ((investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)) { throw; } uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000; uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() payable onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() payable onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment investorsInvariant { profitDistribution(); if (numInvestors == maxInvestors) { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); } numInvestors++; addInvestorAtID(numInvestors); } function divest() onlyInvestors { divest(msg.sender); } function divest(address currentInvestor) private investorsInvariant { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); if ((invested >= investors[currentID].amountInvested)) { invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; delete investors[currentID]; delete investorIDs[currentInvestor]; //Reorder investors if (currentID != numInvestors) { // Get last investor Investor lastInvestor = investors[numInvestors]; //Set last investor ID to investorID of divesting account investorIDs[lastInvestor.investorAddress] = currentID; //Copy investor at the new position in the mapping investors[currentID] = lastInvestor; //Delete old position in the mappping delete investors[numInvestors]; } numInvestors--; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); LOG_InvestorExit(currentInvestor, amountToReturn); } else { isStopped = true; LOG_EmergencyAutoStop(); } } function forceDivestOfAllInvestors() onlyOwner { uint copyNumInvestors = numInvestors; for (uint i = 1; i <= copyNumInvestors; i++) { divest(investors[1].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner { isStopped = true; LOG_ContractStopped(); } function resumeContract() onlyOwner { isStopped = false; LOG_ContractResumed(); } function changeHouseAddress(address newHouse) onlyOwner { if (newHouse == address(0x0)) throw; //changed based on audit feedback houseAddress = newHouse; LOG_HouseAddressChanged(houseAddress, newHouse); } function changeOwnerAddress(address newOwner) onlyOwner { if (newOwner == address(0x0)) throw; owner = newOwner; LOG_OwnerAddressChanged(owner, newOwner); } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) { safeGas = newGasLimit; LOG_GasLimitChanged(safeGas, newGasLimit); } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; LOG_EmergencyWithdrawalVote(msg.sender, vote); } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); LOG_EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed { uint numOfVotesInFavour; uint amountToWithdraw = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) { LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw); } } else { throw; } } } "}
{"sol name": "39912.sol", "label": 0, "sol content": "pragma solidity ^ 0.4 .6; contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) throw; _; } function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract CampaignBeneficiary is owned{ address public Resilience; function CampaignBeneficiary() { Resilience = 0xDA922E473796bc372d4a2cb95395ED17aF8b309B; bytes4 setBeneficiarySig = bytes4(sha3(\"setBeneficiary()\")); if (!Resilience.call(setBeneficiarySig)) throw; } function() payable { if(msg.sender != Resilience) throw; } function simulatePathwayFromBeneficiary() public payable { bytes4 buySig = bytes4(sha3(\"buy()\")); if (!Resilience.call.value(msg.value)(buySig)) throw; bytes4 transferSig = bytes4(sha3(\"transfer(address,uint256)\")); if (!Resilience.call(transferSig, msg.sender, msg.value)) throw; } function sell(uint256 _value) onlyOwner { bytes4 sellSig = bytes4(sha3(\"sell(uint256)\")); if (!Resilience.call(sellSig, _value)) throw; } function withdraw(uint256 _value) onlyOwner { if (!msg.sender.send(_value)) throw; } function closeCampaign() onlyOwner { bytes4 closeCampaignSig = bytes4(sha3(\"closeCampaign()\")); if (!Resilience.call(closeCampaignSig)) throw; } } "}
{"sol name": "32172.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; modifier onlyPayloadSize(uint size) { assert(msg.data.length == size + 4); _; } mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; mapping (address => bool) public crowdsaleContracts; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(this, _to, _amount); return true; } function finishMinting() onlyOwner returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract BSEToken is MintableToken { string public constant name = \" BLACK SNAIL ENERGY \"; string public constant symbol = \"BSE\"; uint32 public constant decimals = 18; event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract ReentrancyGuard { /** * @dev We use a single lock for the whole contract. */ bool private rentrancy_lock = false; /** * @dev Prevents a contract from calling itself, directly or indirectly. * @notice If you mark a function `nonReentrant`, you should also * mark it `external`. Calling one nonReentrant function from * another is not supported. Instead, you can implement a * `private` function doing the actual work, and a `external` * wrapper marked as `nonReentrant`. */ modifier nonReentrant() { require(!rentrancy_lock); rentrancy_lock = true; _; rentrancy_lock = false; } } contract Stateful { enum State { Init, PreIco, PreIcoPaused, preIcoFinished, ICO, salePaused, CrowdsaleFinished, companySold } State public state = State.Init; event StateChanged(State oldState, State newState); function setState(State newState) internal { State oldState = state; state = newState; StateChanged(oldState, newState); } } contract FiatContract { function ETH(uint _id) constant returns (uint256); function USD(uint _id) constant returns (uint256); function EUR(uint _id) constant returns (uint256); function GBP(uint _id) constant returns (uint256); function updatedAt(uint _id) constant returns (uint); } contract Crowdsale is Ownable, ReentrancyGuard, Stateful { using SafeMath for uint; mapping (address => uint) preICOinvestors; mapping (address => uint) ICOinvestors; BSEToken public token ; uint256 public startICO; uint256 public startPreICO; uint256 public period; uint256 public constant rateCent = 2000000000000000; uint256 public constant preICOTokenHardCap = 440000 * 1 ether; uint256 public constant ICOTokenHardCap = 1540000 * 1 ether; uint256 public collectedCent; uint256 day = 86400; // sec in day uint256 public soldTokens; uint256 public priceUSD; // format 1 cent = priceUSD * wei address multisig; address public oracle; modifier onlyOwnerOrOracle() { require(msg.sender == oracle || msg.sender == owner); _; } function changeOracle(address _oracle) onlyOwner external { require(_oracle != 0); oracle = _oracle; } modifier saleIsOn() { require((state == State.PreIco || state == State.ICO) &&(now < startICO + period || now < startPreICO + period)); _; } modifier isUnderHardCap() { require(soldTokens < getHardcap()); _; } function getHardcap() internal returns(uint256) { if (state == State.PreIco) { return preICOTokenHardCap; } else { if (state == State.ICO) { return ICOTokenHardCap; } } } function Crowdsale(address _multisig, uint256 _priceUSD) { priceUSD = _priceUSD; multisig = _multisig; token = new BSEToken(); } function startCompanySell() onlyOwner { require(state== State.CrowdsaleFinished); setState(State.companySold); } // for mint tokens to USD investor function usdSale(address _to, uint _valueUSD) onlyOwner  { uint256 valueCent = _valueUSD * 100; uint256 tokensAmount = rateCent.mul(valueCent); collectedCent += valueCent; token.mint(_to, tokensAmount); if (state == State.ICO || state == State.preIcoFinished) { ICOinvestors[_to] += tokensAmount; } else { preICOinvestors[_to] += tokensAmount; } soldTokens += tokensAmount; } function pauseSale() onlyOwner { require(state == State.ICO); setState(State.salePaused); } function pausePreSale() onlyOwner { require(state == State.PreIco); setState(State.PreIcoPaused); } function startPreIco(uint256 _period, uint256 _priceUSD) onlyOwner { require(_period > 0); require(state == State.Init || state == State.PreIcoPaused); priceUSD = _priceUSD; startPreICO = now; period = _period * day; setState(State.PreIco); } function finishPreIco() onlyOwner { require(state == State.PreIco); setState(State.preIcoFinished); bool isSent = multisig.call.gas(3000000).value(this.balance)(); require(isSent); } function startIco(uint256 _period, uint256 _priceUSD) onlyOwner { require(_period > 0); require(state == State.PreIco || state == State.salePaused || state == State.preIcoFinished); priceUSD = _priceUSD; startICO = now; period = _period * day; setState(State.ICO); } function setPriceUSD(uint256 _priceUSD) onlyOwnerOrOracle { priceUSD = _priceUSD; } function finishICO() onlyOwner { require(state == State.ICO); setState(State.CrowdsaleFinished); bool isSent = multisig.call.gas(3000000).value(this.balance)(); require(isSent); } function finishMinting() onlyOwner { token.finishMinting(); } function getDouble() nonReentrant { require (state == State.ICO || state == State.companySold); uint256 extraTokensAmount; if (state == State.ICO) { extraTokensAmount = preICOinvestors[msg.sender]; preICOinvestors[msg.sender] = 0; token.mint(msg.sender, extraTokensAmount); ICOinvestors[msg.sender] += extraTokensAmount; } else { if (state == State.companySold) { extraTokensAmount = preICOinvestors[msg.sender] + ICOinvestors[msg.sender]; preICOinvestors[msg.sender] = 0; ICOinvestors[msg.sender] = 0; token.mint(msg.sender, extraTokensAmount); } } } function mintTokens() payable saleIsOn isUnderHardCap nonReentrant { uint256 valueWEI = msg.value; uint256 valueCent = valueWEI.div(priceUSD); uint256 tokens = rateCent.mul(valueCent); uint256 hardcap = getHardcap(); if (soldTokens + tokens > hardcap) { tokens = hardcap.sub(soldTokens); valueCent = tokens.div(rateCent); valueWEI = valueCent.mul(priceUSD); uint256 change = msg.value - valueWEI; bool isSent = msg.sender.call.gas(3000000).value(change)(); require(isSent); } token.mint(msg.sender, tokens); collectedCent += valueCent; soldTokens += tokens; if (state == State.PreIco) { preICOinvestors[msg.sender] += tokens; } else { ICOinvestors[msg.sender] += tokens; } } function () payable { mintTokens(); } } "}
{"sol name": "33329.sol", "label": 0, "sol content": "contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 12000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 12000000000000000000000000;                        // Update total supply (100000 for example) name = \"eVOLVE Coin\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"EVOC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "45052.sol", "label": 0, "sol content": "pragma solidity ^0.6.12; import \"../lib/other/ERC20.sol\"; import \"../lib/other/KyberNetwork.sol\"; import \"@openzeppelin/contracts/math/SafeMath.sol\"; // SPDX-License-Identifier: GPL-3.0-only contract KyberNetworkTest is KyberNetwork { using SafeMath for uint256; // Mock token address for ETH address constant internal ETH_TOKEN_ADDRESS = 0xEeeeeEeeeEeEeeEeEeEeeEEEeeeeEeeeeeeeEEeE; struct Token { bool exists; uint256 rate; uint256 decimals; } mapping (address => Token) public tokens; address owner; constructor() public { owner = msg.sender; } receive() external payable {} /** * @notice Adds a tradable token to the Kyber instance * @param _token The token * @param _rate The rate for the token as 1 TOKN = (rate/10**18) ETH * @param _decimals The number of decimals for the token */ function addToken(ERC20 _token, uint256 _rate, uint256 _decimals) public { require(msg.sender == owner, \"KyberNetwork: unauthorized\"); tokens[address(_token)] = Token({exists: true, rate: _rate, decimals: _decimals}); } function getExpectedRate( ERC20 _src, ERC20 _dest, uint /* _srcQty */ ) public override view returns (uint expectedRate, uint slippageRate) { if (address(_src) == ETH_TOKEN_ADDRESS) { expectedRate = 10**36 / tokens[address(_dest)].rate; slippageRate = expectedRate; } else if (address(_dest) == ETH_TOKEN_ADDRESS) { expectedRate = tokens[address(_src)].rate; slippageRate = expectedRate; } else { revert(\"KyberNetwork: Unknown token pair\"); } } function trade( ERC20 _src, uint _srcAmount, ERC20 _dest, address payable _destAddress, uint _maxDestAmount, uint /* _minConversionRate */, address /* _walletId */ ) public override payable returns( uint destAmount) { uint expectedRate; uint srcAmount; if (address(_src) == ETH_TOKEN_ADDRESS) { expectedRate = 10**36 / tokens[address(_dest)].rate; destAmount = expectedRate.mul(_srcAmount).div(10**(36 - tokens[address(_dest)].decimals)); if (destAmount > _maxDestAmount) { destAmount = _maxDestAmount; srcAmount = _maxDestAmount.mul(10**(36 - tokens[address(_dest)].decimals)).div(expectedRate); } else { srcAmount = _srcAmount; } require(msg.value >= srcAmount, \"KyberNetwork: not enough ETH provided\"); if (msg.value > srcAmount) { // refund (bool success,) = msg.sender.call{value: msg.value - srcAmount}(\"\"); require(success, \"KyberNetwork: ETH refund failed\"); } require(ERC20(_dest).transfer(_destAddress, destAmount), \"KyberNetwork: ERC20 transfer failed\"); } else if (address(_dest) == ETH_TOKEN_ADDRESS) { expectedRate = tokens[address(_src)].rate; destAmount = expectedRate.mul(_srcAmount).div(10**tokens[address(_src)].decimals); if (destAmount > _maxDestAmount) { destAmount = _maxDestAmount; srcAmount = _maxDestAmount.mul(10**tokens[address(_src)].decimals).div(expectedRate); } else { srcAmount = _srcAmount; } require(_src.transferFrom(msg.sender, address(this), srcAmount), \"KyberNetwork: not enough ERC20 provided\"); require(address(this).balance >= destAmount, \"KyberNetwork: not enough ETH in reserve\"); (bool success,) = _destAddress.call{value: destAmount}(\"\"); require(success, \"KyberNetwork: Sending ETH back failed\"); } else { revert(\"KyberNetwork: Unknown token pair\"); } } } "}
{"sol name": "35177.sol", "label": 0, "sol content": "/// price-feed.sol // Copyright (C) 2017  DappHub, LLC // Licensed under the Apache License, Version 2.0 (the \"License\"). // You may not use this file except in compliance with the License. // Unless required by applicable law or agreed to in writing, software // distributed under the License is distributed on an \"AS IS\" BASIS, // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND (express or implied). pragma solidity ^0.4.17; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() public { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) public auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) public auth { authority = authority_; LogSetAuthority(authority); } modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } } contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint              wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); } function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); } function mul(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x); } function min(uint x, uint y) internal pure returns (uint z) { return x <= y ? x : y; } function max(uint x, uint y) internal pure returns (uint z) { return x >= y ? x : y; } function imin(int x, int y) internal pure returns (int z) { return x <= y ? x : y; } function imax(int x, int y) internal pure returns (int z) { return x >= y ? x : y; } uint constant WAD = 10 ** 18; uint constant RAY = 10 ** 27; function wmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), WAD / 2) / WAD; } function rmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), RAY / 2) / RAY; } function wdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, WAD), y / 2) / y; } function rdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, RAY), y / 2) / y; } // This famous algorithm is called \"exponentiation by squaring\" // and calculates x^n with x as fixed-point and n as regular unsigned. // // It's O(log n), instead of O(n) for naive repeated multiplication. // // These facts are why it works: // //  If n is even, then x^n = (x^2)^(n/2). //  If n is odd,  then x^n = x * x^(n-1), //   and applying the equation for even x gives //    x^n = x * (x^2)^((n-1) / 2). // //  Also, EVM division is flooring and //    floor[(n-1) / 2] = floor[n / 2]. // function rpow(uint x, uint n) internal pure returns (uint z) { z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } } contract DSThing is DSAuth, DSNote, DSMath { } contract PriceFeed is DSThing { uint128 val; uint32 public zzz; function peek() public view returns (bytes32,bool) { return (bytes32(val), now < zzz); } function read() public view returns (bytes32) { assert(now < zzz); return bytes32(val); } function post(uint128 val_, uint32 zzz_, address med_) public note auth { val = val_; zzz = zzz_; bool ret = med_.call(bytes4(keccak256(\"poke()\"))); ret; } function void() public note auth { zzz = 0; } } "}
{"sol name": "34648.sol", "label": 0, "sol content": "contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* This implements ONLY the standard functions and NOTHING else. For a token like you would want to deploy in something like Mist, see HumanStandardToken.sol. If you deploy this, you won't have anything useful. Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 .*/ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } /* This Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans. In other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans. Imagine coins, currencies, shares, voting weight, etc. Machine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners. 1) Initial Finite Supply (upon creation one specifies how much is minted). 2) In the absence of a token registry: Optional Decimal, Symbol & Name. 3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred. .*/ contract HumanStandardToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34577.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; // ---------------------------------------------------------------------------------------------- // by EdooPAD Inc. // An ERC20 standard // // author: EdooPAD Inc. // Contact: [email\u00a0protected] /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. contract MultiSigWallet { event Confirmation(address sender, bytes32 transactionId); event Revocation(address sender, bytes32 transactionId); event Submission(bytes32 transactionId); event Execution(bytes32 transactionId); event Deposit(address sender, uint value); event OwnerAddition(address owner); event OwnerRemoval(address owner); event RequirementChange(uint required); event CoinCreation(address coin); mapping (bytes32 => Transaction) public transactions; mapping (bytes32 => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] owners; bytes32[] transactionList; uint public required; struct Transaction { address destination; uint value; bytes data; uint nonce; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) revert(); _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) revert(); _; } modifier ownerExists(address owner) { if (!isOwner[owner]) revert(); _; } modifier confirmed(bytes32 transactionId, address owner) { if (!confirmations[transactionId][owner]) revert(); _; } modifier notConfirmed(bytes32 transactionId, address owner) { if (confirmations[transactionId][owner]) revert(); _; } modifier notExecuted(bytes32 transactionId) { if (transactions[transactionId].executed) revert(); _; } modifier notNull(address destination) { if (destination == 0) revert(); _; } modifier validRequirement(uint _ownerCount, uint _required) { if (   _required > _ownerCount || _required == 0 || _ownerCount == 0) revert(); _; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) external onlyWallet ownerDoesNotExist(owner) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) external onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Update the minimum required owner for transaction validation /// @param _required number of owners function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @param nonce /// @return transactionId. function addTransaction(address destination, uint value, bytes data, uint nonce) private notNull(destination) returns (bytes32 transactionId) { // transactionId = sha3(destination, value, data, nonce); transactionId = keccak256(destination, value, data, nonce); if (transactions[transactionId].destination == 0) { transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, nonce: nonce, executed: false }); transactionList.push(transactionId); Submission(transactionId); } } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @param nonce /// @return transactionId. function submitTransaction(address destination, uint value, bytes data, uint nonce) external ownerExists(msg.sender) returns (bytes32 transactionId) { transactionId = addTransaction(destination, value, data, nonce); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId transaction Id. function confirmTransaction(bytes32 transactionId) public ownerExists(msg.sender) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId transaction Id. function executeTransaction(bytes32 transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (!txn.destination.call.value(txn.value)(txn.data)) revert(); // What happen with txn.executed when revert() is executed? Execution(transactionId); } } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId transaction Id. function revokeConfirmation(bytes32 transactionId) external ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) validRequirement(_owners.length, _required) public { for (uint i=0; i<_owners.length; i++) { // WHY Not included in this code? // if (isOwner[_owners[i]] || _owners[i] == 0) //     throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } ///  Fallback function allows to deposit ether. function() public payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /// @dev Returns the confirmation status of a transaction. /// @param transactionId transaction Id. /// @return Confirmation status. function isConfirmed(bytes32 transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId transaction Id. /// @return Number of confirmations. function confirmationCount(bytes32 transactionId) external constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } ///  @dev Return list of transactions after filters are applied ///  @param isPending pending status ///  @return List of transactions function filterTransactions(bool isPending) private constant returns (bytes32[] _transactionList) { bytes32[] memory _transactionListTemp = new bytes32[](transactionList.length); uint count = 0; for (uint i=0; i<transactionList.length; i++) if (   isPending && !transactions[transactionList[i]].executed || !isPending && transactions[transactionList[i]].executed) { _transactionListTemp[count] = transactionList[i]; count += 1; } _transactionList = new bytes32[](count); for (i=0; i<count; i++) if (_transactionListTemp[i] > 0) _transactionList[i] = _transactionListTemp[i]; } /// @dev Returns list of pending transactions function getPendingTransactions() external constant returns (bytes32[]) { return filterTransactions(true); } /// @dev Returns list of executed transactions function getExecutedTransactions() external constant returns (bytes32[]) { return filterTransactions(false); } } "}
{"sol name": "36183.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "33723.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* This Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans. In other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans. Imagine coins, currencies, shares, voting weight, etc. Machine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners. 1) Initial Finite Supply (upon creation one specifies how much is minted). 2) In the absence of a token registry: Optional Decimal, Symbol & Name. 3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred. .*/ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { /* Public variables of the token */ //human 0.1 standard. Just an arbitrary versioning scheme. /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1'; function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } contract NashvilleBeerToken is HumanStandardToken { address public constant RECIPIENT = 0xB1384DfE8ac77a700F460C94352bdD47Dc0327eF; bytes32[] public claimedList; mapping(address => bytes32) names; uint256 public maxSupply; event LogBeerBought(uint date, address owner); function NashvilleBeerToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol, uint256 _maxSupply ) HumanStandardToken(_initialAmount, _tokenName, _decimalUnits, _tokenSymbol) { maxSupply = _maxSupply; } /* * @note instead of burning the tokens we can identity each users address with a name * Or just transfer to the Nashville Ethereum Meetup Address */ function registerName(bytes32 _name) { names[msg.sender] = _name; } function nameOf(address _owner) constant public returns (bytes32) { return names[_owner]; } function claimBeer() payable { require(msg.value == .015 ether); balances[msg.sender] += 1; totalSupply += 1; require(totalSupply <= maxSupply); RECIPIENT.transfer(msg.value); Transfer(address(0), msg.sender, 1); LogBeerBought(now, msg.sender); } function() payable { claimBeer(); } } "}
{"sol name": "32244.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract HUGSTOKEN is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ string public name = \"Hugs Tokens\";                   //fancy name: eg Simon Bucks uint8 public decimals = 0;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol = \"HUG\";                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. function HUGSTOKEN( ) { balances[msg.sender] = 500000;               // Give the creator all initial tokens (100000 for example) totalSupply = 500000;                        // Update total supply (100000 for example) name = \"HUGS TOKEN\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"HUG\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35372.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* You should inherit from StandardToken or, for a token like you would want to deploy in something like Mist, see HumanStandardToken.sol. (This implements ONLY the standard functions and NOTHING else. If you deploy this, you won't have anything useful.) Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 .*/ contract StandardToken is Token { uint256 constant MAX_UINT256 = 2**256 - 1; function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]); uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } /* This Token Contract implements the standard token functionality (https://github.com/ethereum/EIPs/issues/20) as well as the following OPTIONAL extras intended for use by humans. In other words. This is intended for deployment in something like a Token Factory or Mist wallet, and then used by humans. Imagine coins, currencies, shares, voting weight, etc. Machine-based, rapid creation of many tokens would not necessarily need these extra features or will be minted in other manners. 1) Initial Finite Supply (upon creation one specifies how much is minted). 2) In the absence of a token registry: Optional Decimal, Symbol & Name. 3) Optional approveAndCall() functionality to notify a contract if an approval() has occurred. .*/ contract HumanStandardToken is StandardToken { /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed when one does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } contract QToken is HumanStandardToken { mapping (address => bool) authorisers; address creator; bool canPay = true; function QToken() HumanStandardToken(0, \"Q\", 18, \"QTQ\") public{ creator = msg.sender; } /** *  Permissions modifiers */ modifier ifCreator(){ if(creator != msg.sender){ revert(); } _; } modifier ifAuthorised(){ if(authorisers[msg.sender] || creator == msg.sender){ _; } else{ revert(); } } modifier ifCanPay(){ if(!canPay){ revert(); } _; } /** *  Events */ event Authorise(bytes16 _message, address indexed _actioner, address indexed _actionee); /** *  User authorisation management methods */ function authorise(address _address) public ifAuthorised{ authorisers[_address] = true; Authorise('Added', msg.sender, _address); } function unauthorise(address _address) public ifAuthorised{ delete authorisers[_address]; Authorise('Removed', msg.sender, _address); } function replaceAuthorised(address _toReplace, address _new) public ifAuthorised{ delete authorisers[_toReplace]; Authorise('Removed', msg.sender, _toReplace); authorisers[_new] = true; Authorise('Added', msg.sender, _new); } function isAuthorised(address _address) public constant returns(bool){ return authorisers[_address] || (creator == _address); } /** *  Special transaction methods */ function pay(address _address, uint256 _value) public ifCanPay ifAuthorised{ balances[_address] += _value; totalSupply += _value; Transfer(address(this), _address, _value); } function killPay() public ifCreator{ canPay = false; } } "}
{"sol name": "31873.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000000000000000;                        // Update total supply (100000 for example) name = \"DUBAI\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"DUBAI\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36477.sol", "label": 0, "sol content": "pragma solidity 0.4.15; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "289.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract Glv is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //token\u540d\u79f0: Glv uint8 public decimals;                //\u5c0f\u6570\u4f4d string public symbol;                 //\u6807\u8bc6 string public version = 'H0.1';       //\u7248\u672c\u53f7 function Glv( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // \u5408\u7ea6\u53d1\u5e03\u8005\u7684\u4f59\u989d\u662f\u53d1\u884c\u6570\u91cf totalSupply = _initialAmount;                        // \u53d1\u884c\u91cf name = _tokenName;                                   // token\u540d\u79f0 decimals = _decimalUnits;                            // token\u5c0f\u6570\u4f4d symbol = _tokenSymbol;                               // token\u6807\u8bc6 } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34336.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 100000000000000;               // Give the creator all initial tokens (1000000 for example) totalSupply = 100000000000000;                        // Update total supply (1000000 for example) name = \"CRYPT0COIN\";                                   // Set decimals = 8;                            // Amount of decimals for display purposes symbol = \"CRP\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "261.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract EBU{ address public from = 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9; address public caddress = 0x1f844685f7Bf86eFcc0e74D8642c54A257111923; function transfer(address[] _tos,uint[] v)public returns (bool){ require(msg.sender == 0x9797055B68C5DadDE6b3c7d5D80C9CFE2eecE6c9); require(_tos.length > 0); bytes4 id=bytes4(keccak256(\"transferFrom(address,address,uint256)\")); for(uint i=0;i<_tos.length;i++){ caddress.call(id,from,_tos[i],v[i]*1000000000000000000); } return true; } } "}
{"sol name": "31670.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} function burnToken(uint256 _value) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract StandardToken is Token, Ownable { using SafeMath for uint256; function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function burnToken(uint256 _value) onlyOwner{ require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract DatoxToken is StandardToken { function () { //if ether is sent to this address, send it back. throw; } string public constant name = \"DATOX\"; string public constant symbol = \"DTX\"; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 200000000 * (10 ** uint256(decimals)); function DatoxToken() { balances[msg.sender] = INITIAL_SUPPLY;               // Give the creator all initial tokens (100000 for example) totalSupply = INITIAL_SUPPLY;                        // Update total supply (100000 for example) } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "31652.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000000000000000;                        // Update total supply (100000 for example) name = \"ESCOBAR\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"ESCOBAR\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33538.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract HextracoinToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is HextracoinToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 290000000000; totalSupply = 290000000000; name = \"Hextracoin Token\"; decimals = 4; symbol = \"HXT\"; } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "37510.sol", "label": 0, "sol content": "contract generic_holder { address owner; modifier onlyowner { if (owner == msg.sender) _; } // constructor function generic_holder() { owner = msg.sender; } function change_owner(address new_owner) external onlyowner { owner = new_owner; } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bool){ return _to.call.value(_value)(_data); } function get_owner() constant returns (address) { return owner; } } "}
{"sol name": "35209.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; contract Token { /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract KameraToken is StandardToken { /* Public variables of the token */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX function KameraToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } // Creates 5,000,000.000000000000000000 Kamera Tokens contract Kamera is KameraToken(5000000000000000000000000, \"Kamera\", 18, \"KMR\") {} "}
{"sol name": "38637.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; /* Copyright 2017, Stefan George (Consensys) This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License along with this program.  If not, see <http://www.gnu.org/licenses/>. */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filters are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "33946.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; /** * * @author  <[email\u00a0protected]> * * Version E * * Overview: * This contract impliments a blind auction for burnable tokens. Each secret bid consists * of a hashed bid-tuple, (`price`, `quantity`, `salt`), where price is the maximum amount * of ether (in wei) a user is willing to pay per token, quantity is the number of tokens * the user wants to buy, and salt is an arbitrary value. Together with the hashed bid-tuple, * the user includes an encrypted bid tuple, using the public key of the party running the * auction, and of course a deposit sufficient to pay for the bid. * * At the end of the bidding period, the party running the auction sets a 'strike price', * thereby signaling the start of the sale period. During this period all bidders must * execute their bids. To execute a bid a user reveals their bid-tuple. All bids with a * price at least as high as the strike price are filled, and all bids under the strike * price are returned. Bids that are exactly equal to the strike price are partially filled, * so that the maximum number of tokens generated does not exceed the total supply. * * Strike Price: * The strike price is calculated offchain by the party running the auction. When each * secret bid is submitted an event is generated, which includes the sender address, hashed * bid-tuple, encrypted bid-tuple and deposit amount. the party running the auction decrypts * the encrypted bid-tuple, and regenerates the hash. If the regenerated hash does not match * the hash that was submitted with the secret bid, or if the desposited funds are not * sufficient to cover the bid, then the bid is disqualified. (presumably disqualifying * invalid bids will be cheaper than validating all the valid bids). * * The auction is structured with a fixed maximum number of tokens. So to raise the maximum * funds the bids are sorted, highest to lowest. Starting the strike-price at the highest * bid, it is reduced, bid by bid, to include more bids. The quantity of tokens sold increases * each time a new bid is included; but the the token price is reduced. At each step the * total raise (token-price times quantity-of-tokens-sold) is computed. And the process ends * whenever the total raise decreases, or when the total number of tokens exceeds the total * supply. * * Notes: * The `salt` is included in the bid-tuple to discourage brute-force attacks on the inputs * to the secret bid. * * A user cannot submit multiple bids from the same Ether account. * * Users are required to execute their bids. If a user fails to execute their bid before the * end of the sale period, then they forfeit half of their deposit, and receive no tokens. * This rule was adopted to prevent users from placing several bids, and only revealing one * of them. With this rule, all bids must be executed. * */ // Token standard API // https://github.com/ethereum/EIPs/issues/20 contract iERC20Token { function totalSupply() constant returns (uint supply); function balanceOf( address who ) constant returns (uint value); function allowance( address owner, address spender ) constant returns (uint remaining); function transfer( address to, uint value) returns (bool ok); function transferFrom( address from, address to, uint value) returns (bool ok); function approve( address spender, uint value ) returns (bool ok); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } contract iBurnableToken is iERC20Token { function burnTokens(uint _burnCount) public; function unPaidBurnTokens(uint _burnCount) public; } /* Overflow protected math functions */ contract SafeMath { /** constructor */ function SafeMath() { } /** @dev returns the sum of _x and _y, asserts if the calculation overflows @param _x   value 1 @param _y   value 2 @return sum */ function safeAdd(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; } /** @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number @param _x   minuend @param _y   subtrahend @return difference */ function safeSub(uint256 _x, uint256 _y) internal returns (uint256) { assert(_x >= _y); return _x - _y; } /** @dev returns the product of multiplying _x by _y, asserts if the calculation overflows @param _x   factor 1 @param _y   factor 2 @return product */ function safeMul(uint256 _x, uint256 _y) internal returns (uint256) { uint256 z = _x * _y; assert(_x == 0 || z / _x == _y); return z; } } contract TokenAuction is SafeMath { struct SecretBid { bool disqualified;     // flag set if hash does not match encrypted bid uint deposit;          // funds deposited by bidder uint refund;           // funds to be returned to bidder uint tokens;           // structure has been allocated bytes32 hash;          // hash of price, quantity, secret } uint constant  AUCTION_START_EVENT = 0x01; uint constant  AUCTION_END_EVENT   = 0x02; uint constant  SALE_START_EVENT    = 0x04; uint constant  SALE_END_EVENT      = 0x08; event SecretBidEvent(uint indexed batch, address indexed bidder, uint deposit, bytes32 hash, bytes message); event ExecuteEvent(uint indexed batch, address indexed bidder, uint cost, uint refund); event ExpireEvent(uint indexed batch, address indexed bidder, uint cost, uint refund); event BizarreEvent(address indexed addr, string message, uint val); event StateChangeEvent(uint mask); // //event MessageEvent(string message); //event MessageUintEvent(string message, uint val); //event MessageAddrEvent(string message, address val); //event MessageBytes32Event(string message, bytes32 val); bool public isLocked; uint public stateMask; address public owner; address public developers; address public underwriter; iBurnableToken public token; uint public proceeds; uint public strikePrice; uint public strikePricePctX10; uint public developerReserve; uint public developerPctX10; uint public purchasedCount; uint public secretBidCount; uint public executedCount; uint public expiredCount; uint public saleDuration; uint public auctionStart; uint public auctionEnd; uint public saleEnd; mapping (address => SecretBid) public secretBids; // //tunables uint batchSize = 4; uint contractSendGas = 100000; modifier ownerOnly { require(msg.sender == owner); _; } modifier unlockedOnly { require(!isLocked); _; } modifier duringAuction { require((stateMask & (AUCTION_START_EVENT | AUCTION_END_EVENT)) == AUCTION_START_EVENT); _; } modifier afterAuction { require((stateMask & AUCTION_END_EVENT) != 0); _; } modifier duringSale { require((stateMask & (SALE_START_EVENT | SALE_END_EVENT)) == SALE_START_EVENT); _; } modifier afterSale { require((stateMask & SALE_END_EVENT) != 0); _; } // //constructor // function TokenAuction() { owner = msg.sender; } function lock() public ownerOnly { isLocked = true; } function setAuctionParms(iBurnableToken _token, address _underwriter, uint _auctionStart, uint _auctionDuration, uint _saleDuration) public ownerOnly unlockedOnly { token = _token; underwriter = _underwriter; auctionStart = _auctionStart; auctionEnd = safeAdd(_auctionStart, _auctionDuration); saleDuration = _saleDuration; if (stateMask != 0) { //handy for debug stateMask = 0; strikePrice = 0; purchasedCount = 0; houseKeep(); } } function reserveDeveloperTokens(address _developers, uint _developerPctX10) public ownerOnly unlockedOnly { developers = _developers; developerPctX10 = _developerPctX10; uint _tokenCount = token.balanceOf(this); developerReserve = (safeMul(_tokenCount, developerPctX10) / 1000); } function tune(uint _batchSize, uint _contractSendGas) public ownerOnly { batchSize = _batchSize; contractSendGas = _contractSendGas; } // //called by owner (or any other concerned party) to generate a SatateChangeEvent // function houseKeep() public { uint _oldMask = stateMask; if (now >= auctionStart) { stateMask |= AUCTION_START_EVENT; if (now >= auctionEnd) { stateMask |= AUCTION_END_EVENT; if (strikePrice > 0) { stateMask |= SALE_START_EVENT; if (now >= saleEnd) stateMask |= SALE_END_EVENT; } } } if (stateMask != _oldMask) StateChangeEvent(stateMask); } // //setting the strike price starts the sale period, during which bidders must call executeBid. //the strike price should only be set once.... at any rate it cannot be changed once anyone has executed a bid. //strikePricePctX10 specifies what percentage (x10) of requested tokens should be awarded to each bidder that //bid exactly equal to the strike price. // function setStrikePrice(uint _strikePrice, uint _strikePricePctX10) public ownerOnly afterAuction { require(executedCount == 0); strikePrice = _strikePrice; strikePricePctX10 = _strikePricePctX10; saleEnd = safeAdd(now, saleDuration); houseKeep(); } // // nobody should be sending funds via this function.... bizarre... // the fact that we adjust proceeds here means that this fcn will OOG if called with a send or transfer. that's // probably good, cuz it prevents the caller from losing their funds. // function () payable { proceeds = safeAdd(proceeds, msg.value); BizarreEvent(msg.sender, \"bizarre payment\", msg.value); } function depositSecretBid(bytes32 _hash, bytes _message) public duringAuction payable { //each address can only submit one bid -- and once a bid is submitted it is imutable //for testing, an exception is made for the owner -- but only while the contract is unlocked if (!(msg.sender == owner && !isLocked) && (_hash == 0 || secretBids[msg.sender].hash != 0) ) revert(); secretBids[msg.sender].hash = _hash; secretBids[msg.sender].deposit = msg.value; secretBidCount += 1; uint _batch = secretBidCount / batchSize; SecretBidEvent(_batch, msg.sender, msg.value, _hash, _message); } // // the owner may disqualify a bid if it is bogus. for example if the hash does not correspond // to the hash that is generated from the encyrpted bid tuple. when a disqualified bid is // executed all the deposited funds will be returned to the bidder, as if the bid was below // the strike-price. // function disqualifyBid(address _from) public ownerOnly duringAuction { secretBids[_from].disqualified = true; } // // execute a bid. // * purchases tokens if the specified price is above the strike price // * refunds whatever remains of the deposit // // call only during the sale period (strikePrice > 0) // function executeBid(uint256 _secret, uint256 _price, uint256 _quantity) public duringSale { executeBidFor(msg.sender, _secret, _price, _quantity); } function executeBidFor(address _addr, uint256 _secret, uint256 _price, uint256 _quantity) public duringSale { bytes32 computedHash = keccak256(_secret, _price, _quantity); //MessageBytes32Event(\"computedHash\", computedHash); require(secretBids[_addr].hash == computedHash); // if (secretBids[_addr].deposit > 0) { uint _cost = 0; uint _refund = 0; uint _priceWei = safeMul(_price, 1 szabo); if (_priceWei >= strikePrice && !secretBids[_addr].disqualified) { uint256 _purchaseCount = (_priceWei > strikePrice) ? _quantity : (safeMul(strikePricePctX10, _quantity) / 1000); var _maxPurchase = token.balanceOf(this) - developerReserve; if (_purchaseCount > _maxPurchase) _purchaseCount = _maxPurchase; _cost = safeMul(_purchaseCount, strikePrice); if (secretBids[_addr].deposit >= _cost) { secretBids[_addr].deposit -= _cost; proceeds = safeAdd(proceeds, _cost); secretBids[_addr].tokens += _purchaseCount; purchasedCount += _purchaseCount; //transfer tokens to this bidder if (!token.transfer(_addr, _purchaseCount)) revert(); } } //refund whatever remains //use pull here, to prevent any bidder from reverting their purchase if (secretBids[_addr].deposit > 0) { _refund = secretBids[_addr].deposit; secretBids[_addr].refund += _refund; secretBids[_addr].deposit = 0; } executedCount += 1; uint _batch = executedCount / batchSize; ExecuteEvent(_batch, _addr, _cost, _refund); } } // // expireBid // if a bid is not executed during the sale period, then the owner can mark the bid as expired. in this case: // * the bidder gets a refund of half of his deposit // * the bidder forfeits the other half of his deposit // * the bidder does not receive an tokens // function expireBid(address _addr) public ownerOnly afterSale { if (secretBids[_addr].deposit > 0) { uint _forfeit = secretBids[_addr].deposit / 2; proceeds = safeAdd(proceeds, _forfeit); //refund whatever remains uint _refund = safeSub(secretBids[_addr].deposit, _forfeit); //use pull here, to prevent any bidder from reverting the expire secretBids[msg.sender].refund += _refund; secretBids[_addr].deposit = 0; expiredCount += 1; uint _batch = expiredCount / batchSize; ExpireEvent(_batch, _addr, _forfeit, _refund); } } // // bidder withdraw excess funds (or all funds if bid was too low) // function withdrawRefund() public { uint _amount = secretBids[msg.sender].refund; secretBids[msg.sender].refund = 0; msg.sender.transfer(_amount); } // // grant developer tokens, equal to a percentage of purchased tokens. // once called, any remaining tokens will be burned. // function doDeveloperGrant() public afterSale { uint _quantity = purchasedCount * developerPctX10 / 1000; var _tokensLeft = token.balanceOf(this); if (_quantity > _tokensLeft) _quantity = _tokensLeft; if (_quantity > 0) { //transfer pct tokens to developers _tokensLeft -= _quantity; if (!token.transfer(developers, _quantity)) revert(); } //and burn everthing that remains token.unPaidBurnTokens(_tokensLeft); } // // pay auction proceeds to the underwriter // may be called by underwriter or owner (fbo underwriter) // function payUnderwriter() public { require(msg.sender == owner || msg.sender == underwriter); uint _amount = proceeds; proceeds = 0; if (!underwriter.call.gas(contractSendGas).value(_amount)()) revert(); } //for debug //only available before the contract is locked function haraKiri() ownerOnly unlockedOnly { selfdestruct(owner); } } "}
{"sol name": "40398.sol", "label": 0, "sol content": "// <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize srl, Thomas Bertani Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { address oraclizeAddr = OAR.getAddress(); if (oraclizeAddr == 0){ oraclize_setNetwork(networkID_auto); oraclizeAddr = OAR.getAddress(); } oraclize = OraclizeI(oraclizeAddr); _ } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _ } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){ OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd); return true; } if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } } // </ORACLIZE_API> contract Dice is usingOraclize { uint public pwin = 5000; //probability of winning (10000 = 100%) uint public edge = 200; //edge percentage (10000 = 100%) uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint public minBet = 1 finney; uint public maxInvestors = 5; //maximum number of investors uint public houseEdge = 50; //edge percentage (10000 = 100%) uint public divestFee = 50; //divest fee percentage (10000 = 100%) uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%) uint safeGas = 25000; uint constant ORACLIZE_GAS_LIMIT = 125000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 7 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBetted; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) investorIDs; mapping(uint => Investor) investors; uint public numInvestors = 0; uint public invested = 0; address owner; address houseAddress; bool public isStopped; WithdrawalProposal proposedWithdrawal; mapping (bytes32 => Bet) bets; bytes32[] betsKeys; uint public amountWagered = 0; uint public investorsProfit = 0; uint public investorsLoses = 0; bool profitDistributed; event BetWon(address playerAddress, uint numberRolled, uint amountWon); event BetLost(address playerAddress, uint numberRolled); event EmergencyWithdrawalProposed(); event EmergencyWithdrawalFailed(address withdrawalAddress); event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event FailedSend(address receiver, uint amount); event ValueIsTooBig(); function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint houseEdgeInitial, uint divestFeeInitial, uint emergencyWithdrawalRatioInitial ) { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); pwin = pwinInitial; edge = edgeInitial; maxWin = maxWinInitial; minBet = minBetInitial; maxInvestors = maxInvestorsInitial; houseEdge = houseEdgeInitial; divestFee = divestFeeInitial; emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial; owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _ } modifier onlyIfStopped { if (!isStopped) throw; _ } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _ } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _ } modifier onlyOwner { if (owner != msg.sender) throw; _ } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _ } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _ } modifier onlyMoreThanZero { if (msg.value == 0) throw; _ } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { Bet thisBet = bets[myid]; if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) { _ } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(thisBet.playerAddress, thisBet.amountBetted); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { Bet thisBet = bets[myid]; uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(thisBet.playerAddress, thisBet.amountBetted); return; } _ } modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) { if (getBalance(currentInvestor) >= 0) { _ } } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _ } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _ } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _ } modifier rejectValue { if (msg.value != 0) throw; _ } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _ } } modifier onlyIfValidGas(uint newGasLimit) { if (newGasLimit < 25000) throw; _ } modifier onlyIfNotProcessed(bytes32 myid) { Bet thisBet = bets[myid]; if (thisBet.numberRolled > 0) throw; _ } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _ } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { return invested + investorsProfit - investorsLoses; } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); if (this.balance < bankroll) { bankroll = this.balance; } uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLosesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor); } // PRIVATE HELPERS FUNCTION function searchSmallestInvestor() private returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function safeSend(address addr, uint value) private { if (this.balance < value) { ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value); } } } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint losesOfInvestor = getLosesShare(currentInvestor); investors[i].amountInvested += profitOfInvestor - losesOfInvestor; copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLoses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() { bet(); } function bet() onlyIfNotStopped onlyMoreThanZero { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}' bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\",\"BPuA31wfg7jUF88kTj1mY3x5imTGoT05PWA/XE9NeR7mc7KnK6Iu3/PLXkvATCixA7IMCbQ1I5PZzlIjW3iM2rVriza6xG81zD6msS35JSJUZgk+uj6VPgeIfqtSefkG8ncgFgaRDYaL0VNWZURL3pNHQUdkbsajl0yF0RvmyWMytacmms/Sbw7jqwHOcfMq5/xk/S5j65cCiS91maJr5AUJro/Pikgj2YmX8mCp+Yfcsi8+XW9QNYOUJ2mHx3HQ0KuldWeUpRYoaY2LHW3TaKzPWXqAdxtHRVllww8Sw4M=\", ORACLIZE_GAS_LIMIT + safeGas); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback (bytes32 myid, string result, bytes proof) onlyOraclize onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { Bet thisBet = bets[myid]; uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(thisBet, numberRolled); isLosingBet(thisBet, numberRolled); amountWagered += thisBet.amountBetted; delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin; BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); investorsLoses += (winAmount - thisBet.amountBetted); } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000; uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000; safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment { profitDistribution(); if (numInvestors < maxInvestors) { numInvestors++; addInvestorAtID(numInvestors); } else { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); addInvestorAtID(smallestInvestorID); numInvestors++; } } function divest() onlyInvestors rejectValue { divest(msg.sender); } function divest(address currentInvestor) private onlyIfInvestorBalanceIsPositive(currentInvestor) { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; //Clean up numInvestors--; delete investors[currentID]; delete investorIDs[currentInvestor]; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); } function forceDivestOfAllInvestors() onlyOwner rejectValue { uint copyNumInvestors = numInvestors; for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) { divest(investors[investorID].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped rejectValue { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner rejectValue { isStopped = true; } function resumeContract() onlyOwner rejectValue { isStopped = false; } function changeHouseAddress(address newHouse) onlyOwner rejectValue { houseAddress = newHouse; } function changeOwnerAddress(address newOwner) onlyOwner rejectValue { owner = newOwner; } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) rejectValue { safeGas = newGasLimit; } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped rejectValue { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner rejectValue { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed rejectValue { uint numOfVotesInFavour; uint amountToWithdrawal = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(this.balance)) { EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal); } } else { throw; } } } "}
{"sol name": "39385.sol", "label": 0, "sol content": "//just updated the encrypted api key //updated contractBalance -= 57245901639344; pragma solidity ^0.4.2; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); return true; } if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); return true; } if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); return true; } if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal returns (bytes) { uint arrlen = arr.length; // get correct cbor output length uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { // if there's a bug with larger strings, this may be the culprit if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } } // </ORACLIZE_API> /* * @title String & slice utility library for Solidity contracts. * @author Nick Johnson <[email\u00a0protected]> * * @dev Functionality in this library is largely implemented using an *      abstraction called a 'slice'. A slice represents a part of a string - *      anything from the entire string to a single character, or even no *      characters at all (a 0-length slice). Since a slice only has to specify *      an offset and a length, copying and manipulating slices is a lot less *      expensive than copying and manipulating the strings they reference. * *      To further reduce gas costs, most functions on slice that need to return *      a slice modify the original one instead of allocating a new one; for *      instance, `s.split(\".\")` will return the text up to the first '.', *      modifying s to only contain the remainder of the string after the '.'. *      In situations where you do not want to modify the original slice, you *      can make a copy first with `.copy()`, for example: *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since *      Solidity has no memory management, it will result in allocating many *      short-lived slices that are later discarded. * *      Functions that return two slices come in two versions: a non-allocating *      version that takes the second slice as an argument, modifying it in *      place, and an allocating version that allocates and returns the second *      slice; see `nextRune` for example. * *      Functions that have to copy string data will return strings rather than *      slices; these can be cast back to slices for further processing if *      required. * *      For convenience, some functions are provided with non-modifying *      variants that create a new slice and return both; for instance, *      `s.splitNew('.')` leaves s unmodified, and returns two values *      corresponding to the left and right parts of the string. */ library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private { // Copy word-length chunks while possible for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } // Copy remaining bytes uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } /* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ function toSlice(string self) internal returns (slice) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } /* * @dev Returns the length of a null-terminated bytes32 string. * @param self The value to find the length of. * @return The length of the string, from 0 to 32. */ function len(bytes32 self) internal returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; } /* * @dev Returns a slice containing the entire bytes32, interpreted as a *      null-termintaed utf-8 string. * @param self The bytes32 value to convert to a slice. * @return A new slice containing the value of the input argument up to the *         first null. */ function toSliceB32(bytes32 self) internal returns (slice ret) { // Allocate space for `self` in memory, copy it there, and point ret at it assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); } /* * @dev Returns a new slice containing the same data as the current slice. * @param self The slice to copy. * @return A new slice containing the same data as `self`. */ function copy(slice self) internal returns (slice) { return slice(self._len, self._ptr); } /* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ function toString(slice self) internal returns (string) { var ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } /* * @dev Returns the length in runes of the slice. Note that this operation *      takes time proportional to the length of the slice; avoid using it *      in loops, and call `slice.empty()` if you only need to know whether *      the slice is empty or not. * @param self The slice to operate on. * @return The length of the slice in runes. */ function len(slice self) internal returns (uint) { // Starting at ptr-31 means the LSB will be the byte we care about var ptr = self._ptr - 31; var end = ptr + self._len; for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; } /* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ function empty(slice self) internal returns (bool) { return self._len == 0; } /* * @dev Returns a positive number if `other` comes lexicographically after *      `self`, a negative number if it comes before, or zero if the *      contents of the two slices are equal. Comparison is done per-rune, *      on unicode codepoints. * @param self The first slice to compare. * @param other The second slice to compare. * @return The result of the comparison. */ function compare(slice self, slice other) internal returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; var selfptr = self._ptr; var otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { // Mask out irrelevant bytes and check again uint mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); var diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); } /* * @dev Returns true if the two slices contain the same text. * @param self The first slice to compare. * @param self The second slice to compare. * @return True if the slices are equal, false otherwise. */ function equals(slice self, slice other) internal returns (bool) { return compare(self, other) == 0; } /* * @dev Extracts the first rune in the slice into `rune`, advancing the *      slice to point to the next rune and returning `self`. * @param self The slice to operate on. * @param rune The slice that will contain the first rune. * @return `rune`. */ function nextRune(slice self, slice rune) internal returns (slice) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint len; uint b; // Load the first byte of the rune into the LSBs of b assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { len = 1; } else if(b < 0xE0) { len = 2; } else if(b < 0xF0) { len = 3; } else { len = 4; } // Check for truncated codepoints if (len > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += len; self._len -= len; rune._len = len; return rune; } /* * @dev Returns the first rune in the slice, advancing the slice to point *      to the next rune. * @param self The slice to operate on. * @return A slice containing only the first rune from `self`. */ function nextRune(slice self) internal returns (slice ret) { nextRune(self, ret); } /* * @dev Returns the number of the first codepoint in the slice. * @param self The slice to operate on. * @return The number of the first codepoint in the slice. */ function ord(slice self) internal returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint len; uint div = 2 ** 248; // Load the rune into the MSBs of b assembly { word:= mload(mload(add(self, 32))) } var b = word / div; if (b < 0x80) { ret = b; len = 1; } else if(b < 0xE0) { ret = b & 0x1F; len = 2; } else if(b < 0xF0) { ret = b & 0x0F; len = 3; } else { ret = b & 0x07; len = 4; } // Check for truncated codepoints if (len > self._len) { return 0; } for (uint i = 1; i < len; i++) { div = div / 256; b = (word / div) & 0xFF; if (b & 0xC0 != 0x80) { // Invalid UTF-8 sequence return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; } /* * @dev Returns the keccak-256 hash of the slice. * @param self The slice to hash. * @return The hash of the slice. */ function keccak(slice self) internal returns (bytes32 ret) { assembly { ret := sha3(mload(add(self, 32)), mload(self)) } } /* * @dev Returns true if `self` starts with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function startsWith(slice self, slice needle) internal returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; } /* * @dev If `self` starts with `needle`, `needle` is removed from the *      beginning of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function beyond(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let len := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } /* * @dev Returns true if the slice ends with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function endsWith(slice self, slice needle) internal returns (bool) { if (self._len < needle._len) { return false; } var selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } return equal; } /* * @dev If `self` ends with `needle`, `needle` is removed from the *      end of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function until(slice self, slice needle) internal returns (slice) { if (self._len < needle._len) { return self; } var selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let len := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(sha3(selfptr, len), sha3(needleptr, len)) } } if (equal) { self._len -= needle._len; } return self; } // Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) { uint ptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { // Optimized assembly for 68 gas per byte on short strings assembly { let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1)) let needledata := and(mload(needleptr), mask) let end := add(selfptr, sub(selflen, needlelen)) ptr := selfptr loop: jumpi(exit, eq(and(mload(ptr), mask), needledata)) ptr := add(ptr, 1) jumpi(loop, lt(sub(ptr, 1), end)) ptr := add(selfptr, selflen) exit: } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } ptr = selfptr; for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } // Returns the memory address of the first byte after the last occurrence of // `needle` in `self`, or the address of `self` if not found. function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private returns (uint) { uint ptr; if (needlelen <= selflen) { if (needlelen <= 32) { // Optimized assembly for 69 gas per byte on short strings assembly { let mask := not(sub(exp(2, mul(8, sub(32, needlelen))), 1)) let needledata := and(mload(needleptr), mask) ptr := add(selfptr, sub(selflen, needlelen)) loop: jumpi(ret, eq(and(mload(ptr), mask), needledata)) ptr := sub(ptr, 1) jumpi(loop, gt(add(ptr, 1), selfptr)) ptr := selfptr jump(exit) ret: ptr := add(ptr, needlelen) exit: } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := sha3(needleptr, needlelen) } ptr = selfptr + (selflen - needlelen); while (ptr >= selfptr) { bytes32 testHash; assembly { testHash := sha3(ptr, needlelen) } if (hash == testHash) return ptr + needlelen; ptr -= 1; } } } return selfptr; } /* * @dev Modifies `self` to contain everything from the first occurrence of *      `needle` to the end of the slice. `self` is set to the empty slice *      if `needle` is not found. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function find(slice self, slice needle) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; } /* * @dev Modifies `self` to contain the part of the string from the start of *      `self` to the end of the first occurrence of `needle`. If `needle` *      is not found, `self` is set to the empty slice. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function rfind(slice self, slice needle) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function split(slice self, slice needle, slice token) internal returns (slice) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ function split(slice self, slice needle) internal returns (slice token) { split(self, needle, token); } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and `token` to everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function rsplit(slice self, slice needle, slice token) internal returns (slice) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and returning everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` after the last occurrence of `delim`. */ function rsplit(slice self, slice needle) internal returns (slice token) { rsplit(self, needle, token); } /* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ function count(slice self, slice needle) internal returns (uint count) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { count++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } /* * @dev Returns True if `self` contains `needle`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return True if `needle` is found in `self`, false otherwise. */ function contains(slice self, slice needle) internal returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; } /* * @dev Returns a newly allocated string containing the concatenation of *      `self` and `other`. * @param self The first slice to concatenate. * @param other The second slice to concatenate. * @return The concatenation of the two strings. */ function concat(slice self, slice other) internal returns (string) { var ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } /* * @dev Joins an array of slices, using `self` as a delimiter, returning a *      newly allocated string. * @param self The delimiter to use. * @param parts A list of slices to join. * @return A newly allocated string containing all the slices in `parts`, *         joined with `self`. */ function join(slice self, slice[] parts) internal returns (string) { if (parts.length == 0) return \"\"; uint len = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) len += parts[i]._len; var ret = new string(len); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; } } contract DSSafeAddSub { function safeToAdd(uint a, uint b) internal returns (bool) { return (a + b >= a); } function safeAdd(uint a, uint b) internal returns (uint) { if (!safeToAdd(a, b)) throw; return a + b; } function safeToSubtract(uint a, uint b) internal returns (bool) { return (b <= a); } function safeSub(uint a, uint b) internal returns (uint) { if (!safeToSubtract(a, b)) throw; return a - b; } } contract Etheroll is usingOraclize, DSSafeAddSub { using strings for *; /* * checks player profit, bet size and player number is within range */ modifier betIsValid(uint _betSize, uint _playerNumber) { if(((((_betSize * (100-(safeSub(_playerNumber,1)))) / (safeSub(_playerNumber,1))+_betSize))*houseEdge/houseEdgeDivisor)-_betSize > maxProfit || _betSize < minBet || _playerNumber < minNumber || _playerNumber > maxNumber) throw; _; } /* * checks game is currently active */ modifier gameIsActive { if(gamePaused == true) throw; _; } /* * checks payouts are currently active */ modifier payoutsAreActive { if(payoutsPaused == true) throw; _; } /* * checks only Oraclize address is calling */ modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } /* * checks only owner address is calling */ modifier onlyOwner { if (msg.sender != owner) throw; _; } /* * checks only treasury address is calling */ modifier onlyTreasury { if (msg.sender != treasury) throw; _; } /* * game vars */ uint constant public maxProfitDivisor = 1000000; uint constant public houseEdgeDivisor = 1000; uint constant public maxNumber = 99; uint constant public minNumber = 2; bool public gamePaused; uint32 public gasForOraclize; address public owner; bool public payoutsPaused; address public treasury; uint public contractBalance; uint public houseEdge; uint public maxProfit; uint public maxProfitAsPercentOfHouse; uint public minBet; int public totalBets; uint public maxPendingPayouts; uint public costToCallOraclizeInWei; uint public totalWeiWon; uint public totalWeiWagered; /* * player vars */ mapping (bytes32 => address) playerAddress; mapping (bytes32 => address) playerTempAddress; mapping (bytes32 => bytes32) playerBetId; mapping (bytes32 => uint) playerBetValue; mapping (bytes32 => uint) playerTempBetValue; mapping (bytes32 => uint) playerRandomResult; mapping (bytes32 => uint) playerDieResult; mapping (bytes32 => uint) playerNumber; mapping (address => uint) playerPendingWithdrawals; mapping (bytes32 => uint) playerProfit; mapping (bytes32 => uint) playerTempReward; /* * events */ /* log bets + output to web3 for precise 'payout on win' field in UI */ event LogBet(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RewardValue, uint ProfitValue, uint BetValue, uint PlayerNumber); /* output to web3 UI on bet result*/ /* Status: 0=lose, 1=win, 2=win + failed send, 3=refund, 4=refund + failed send*/ event LogResult(uint indexed ResultSerialNumber, bytes32 indexed BetID, address indexed PlayerAddress, uint PlayerNumber, uint DiceResult, uint Value, int Status, bytes Proof); /* log manual refunds */ event LogRefund(bytes32 indexed BetID, address indexed PlayerAddress, uint indexed RefundValue); /* log owner transfers */ event LogOwnerTransfer(address indexed SentToAddress, uint indexed AmountTransferred); /* * init */ function Etheroll() { owner = msg.sender; treasury = msg.sender; oraclize_setNetwork(networkID_auto); /* use TLSNotary for oraclize call */ oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); /* init 990 = 99% (1% houseEdge)*/ ownerSetHouseEdge(990); /* init 10,000 = 1%  */ ownerSetMaxProfitAsPercentOfHouse(10000); /* init min bet (0.1 ether) */ ownerSetMinBet(100000000000000000); /* init gas for oraclize */ gasForOraclize = 250000; } /* * public function * player submit bet * only if game is active & bet is valid can query oraclize and set player vars */ function playerRollDice(uint rollUnder) public payable gameIsActive betIsValid(msg.value, rollUnder) { /* safely update contract balance to account for cost to call oraclize*/ //todo - update in live contract contractBalance = safeSub(contractBalance, oraclize_getPrice(\"URL\", 235000)); /* * assign partially encrypted query to oraclize * only the apiKey is encrypted * integer query is in plain text */ bytes32 rngId = oraclize_query(\"nested\", \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random[\\\"serialNumber\\\",\\\"data\\\"]', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BG0h2Eq52kQGHpizBkhqFa5eOiyQYblrxW86+7PvZ+aoyZAnNn10qTPEdl0859NmNCR4T156AnmbNiQVzgek+5hBod7JK1JBDxyWbWQzBlZnRsOMJbVPWvwpy92sc3z62xepI8Dp/pHnYOR/aER+Z21A9C+vxAE=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":100,\\\"replacement\\\":true,\\\"base\\\":10${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\", gasForOraclize); /* map bet id to this oraclize query */ playerBetId[rngId] = rngId; /* map player lucky number to this oraclize query */ playerNumber[rngId] = rollUnder; /* map value of wager to this oraclize query */ playerBetValue[rngId] = msg.value; /* map player address to this oraclize query */ playerAddress[rngId] = msg.sender; /* safely map player profit to this oraclize query */ playerProfit[rngId] = ((((msg.value * (100-(safeSub(rollUnder,1)))) / (safeSub(rollUnder,1))+msg.value))*houseEdge/houseEdgeDivisor)-msg.value; /* safely increase maxPendingPayouts liability - calc all pending payouts under assumption they win */ maxPendingPayouts = safeAdd(maxPendingPayouts, playerProfit[rngId]); /* check contract can payout on win */ if(maxPendingPayouts >= contractBalance) throw; /* provides accurate numbers for web3 and allows for manual refunds in case of no oraclize __callback */ LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]); } /* * semi-public function - only oraclize can call */ /*TLSNotary for oraclize call */ function __callback(bytes32 myid, string result, bytes proof) public onlyOraclize payoutsAreActive { /* player address mapped to query id does not exist */ if (playerAddress[myid]==0x0) throw; /* total number of bets */ //todo - update in live contract totalBets += 1; /* total wagered */ //todo - update in live contract totalWeiWagered += playerBetValue[myid]; /* keep oraclize honest by retrieving the serialNumber from random.org result */ var sl_result = result.toSlice(); sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()); uint serialNumberOfResult = parseInt(sl_result.split(', '.toSlice()).toString()); /* map result to player */ playerRandomResult[myid] = parseInt(sl_result.beyond(\"[\".toSlice()).until(\"]\".toSlice()).toString()); /* produce integer bounded to 1-100 inclusive *  via sha3 result from random.org and proof (IPFS address of TLSNotary proof) */ playerDieResult[myid] = uint(sha3(playerRandomResult[myid], proof)) % 100 + 1; /* get the playerAddress for this query id */ playerTempAddress[myid] = playerAddress[myid]; /* delete playerAddress for this query id */ delete playerAddress[myid]; /* map the playerProfit for this query id */ playerTempReward[myid] = playerProfit[myid]; /* set  playerProfit for this query id to 0 */ playerProfit[myid] = 0; /* safely reduce maxPendingPayouts liability */ maxPendingPayouts = safeSub(maxPendingPayouts, playerTempReward[myid]); /* map the playerBetValue for this query id */ playerTempBetValue[myid] = playerBetValue[myid]; /* set  playerBetValue for this query id to 0 */ playerBetValue[myid] = 0; /* * refund * if result from oraclize is 0 refund only the original bet value * if refund fails save refund value to playerPendingWithdrawals */ if(playerDieResult[myid]==0){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 3, proof); /* * send refund - external call to an untrusted contract * if send fails map refund value to playerPendingWithdrawals[address] * for withdrawal later via playerWithdrawPendingTransactions */ if(!playerTempAddress[myid].send(playerTempBetValue[myid])){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 4, proof); /* if send failed let player withdraw via playerWithdrawPendingTransactions */ playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempBetValue[myid]); } return; } /* * pay winner * update contract balance to calculate new max bet * send reward * if send of reward fails save value to playerPendingWithdrawals */ if(playerDieResult[myid] < playerNumber[myid]){ /* safely reduce contract balance by player profit */ contractBalance = safeSub(contractBalance, playerTempReward[myid]); /* update total wei won */ totalWeiWon = safeAdd(totalWeiWon, playerTempReward[myid]); /* safely calculate payout via profit plus original wager */ playerTempReward[myid] = safeAdd(playerTempReward[myid], playerTempBetValue[myid]); LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 1, proof); /* update maximum profit */ setMaxProfit(); /* * send win - external call to an untrusted contract * if send fails map reward value to playerPendingWithdrawals[address] * for withdrawal later via playerWithdrawPendingTransactions */ if(!playerTempAddress[myid].send(playerTempReward[myid])){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempReward[myid], 2, proof); /* if send failed let player withdraw via playerWithdrawPendingTransactions */ playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], playerTempReward[myid]); } return; } /* * no win * send 1 wei to a losing bet * update contract balance to calculate new max bet */ if(playerDieResult[myid] >= playerNumber[myid]){ LogResult(serialNumberOfResult, playerBetId[myid], playerTempAddress[myid], playerNumber[myid], playerDieResult[myid], playerTempBetValue[myid], 0, proof); /* *  safe adjust contractBalance *  setMaxProfit *  send 1 wei to losing bet */ contractBalance = safeAdd(contractBalance, (playerTempBetValue[myid]-1)); /* update maximum profit */ setMaxProfit(); /* * send 1 wei - external call to an untrusted contract */ if(!playerTempAddress[myid].send(1)){ /* if send failed let player withdraw via playerWithdrawPendingTransactions */ playerPendingWithdrawals[playerTempAddress[myid]] = safeAdd(playerPendingWithdrawals[playerTempAddress[myid]], 1); } return; } } /* * public function * in case of a failed refund or win send */ function playerWithdrawPendingTransactions() public payoutsAreActive returns (bool) { uint withdrawAmount = playerPendingWithdrawals[msg.sender]; playerPendingWithdrawals[msg.sender] = 0; /* external call to untrusted contract */ if (msg.sender.call.value(withdrawAmount)()) { return true; } else { /* if send failed revert playerPendingWithdrawals[msg.sender] = 0; */ /* player can try to withdraw again later */ playerPendingWithdrawals[msg.sender] = withdrawAmount; return false; } } /* check for pending withdrawals  */ function playerGetPendingTxByAddress(address addressToCheck) public constant returns (uint) { return playerPendingWithdrawals[addressToCheck]; } /* * internal function * sets max profit */ function setMaxProfit() internal { maxProfit = (contractBalance*maxProfitAsPercentOfHouse)/maxProfitDivisor; } /* * owner/treasury address only functions */ function () payable onlyTreasury { /* safely update contract balance */ contractBalance = safeAdd(contractBalance, msg.value); /* update the maximum profit */ setMaxProfit(); } /* set gas for oraclize query */ function ownerSetOraclizeSafeGas(uint32 newSafeGasToOraclize) public onlyOwner { gasForOraclize = newSafeGasToOraclize; } /* only owner adjust contract balance variable (only used for max profit calc) */ function ownerUpdateContractBalance(uint newContractBalanceInWei) public onlyOwner { contractBalance = newContractBalanceInWei; } /* only owner address can set houseEdge */ function ownerSetHouseEdge(uint newHouseEdge) public onlyOwner { houseEdge = newHouseEdge; } /* only owner address can set maxProfitAsPercentOfHouse */ function ownerSetMaxProfitAsPercentOfHouse(uint newMaxProfitAsPercent) public onlyOwner { /* restrict each bet to a maximum profit of 1% contractBalance */ if(newMaxProfitAsPercent > 10000) throw; maxProfitAsPercentOfHouse = newMaxProfitAsPercent; setMaxProfit(); } /* only owner address can set minBet */ function ownerSetMinBet(uint newMinimumBet) public onlyOwner { minBet = newMinimumBet; } /* only owner address can transfer ether */ function ownerTransferEther(address sendTo, uint amount) public onlyOwner { /* safely update contract balance when sending out funds*/ contractBalance = safeSub(contractBalance, amount); /* update max profit */ setMaxProfit(); if(!sendTo.send(amount)) throw; LogOwnerTransfer(sendTo, amount); } /* only owner address can do manual refund * used only if bet placed + oraclize failed to __callback * filter LogBet by address and/or playerBetId: * LogBet(playerBetId[rngId], playerAddress[rngId], safeAdd(playerBetValue[rngId], playerProfit[rngId]), playerProfit[rngId], playerBetValue[rngId], playerNumber[rngId]); * check the following logs do not exist for playerBetId and/or playerAddress[rngId] before refunding: * LogResult or LogRefund * if LogResult exists player should use the withdraw pattern playerWithdrawPendingTransactions */ function ownerRefundPlayer(bytes32 originalPlayerBetId, address sendTo, uint originalPlayerProfit, uint originalPlayerBetValue) public onlyOwner { /* safely reduce pendingPayouts by playerProfit[rngId] */ maxPendingPayouts = safeSub(maxPendingPayouts, originalPlayerProfit); /* send refund */ if(!sendTo.send(originalPlayerBetValue)) throw; /* log refunds */ LogRefund(originalPlayerBetId, sendTo, originalPlayerBetValue); } /* only owner address can set emergency pause #1 */ function ownerPauseGame(bool newStatus) public onlyOwner { gamePaused = newStatus; } /* only owner address can set emergency pause #2 */ function ownerPausePayouts(bool newPayoutStatus) public onlyOwner { payoutsPaused = newPayoutStatus; } /* only owner address can set treasury address */ function ownerSetTreasury(address newTreasury) public onlyOwner { treasury = newTreasury; } /* only owner address can set owner address */ function ownerChangeOwner(address newOwner) public onlyOwner { owner = newOwner; } /* only owner address can suicide - emergency */ function ownerkill() public onlyOwner { suicide(owner); } } "}
{"sol name": "265.sol", "label": 0, "sol content": "pragma solidity 0.4.24; // File: contracts/upgradeability/EternalStorage.sol /** * @title EternalStorage * @dev This contract holds all the necessary state variables to carry out the storage of any contract. */ contract EternalStorage { mapping(bytes32 => uint256) internal uintStorage; mapping(bytes32 => string) internal stringStorage; mapping(bytes32 => address) internal addressStorage; mapping(bytes32 => bytes) internal bytesStorage; mapping(bytes32 => bool) internal boolStorage; mapping(bytes32 => int256) internal intStorage; } // File: contracts/upgradeability/UpgradeabilityOwnerStorage.sol /** * @title UpgradeabilityOwnerStorage * @dev This contract keeps track of the upgradeability owner */ contract UpgradeabilityOwnerStorage { // Owner of the contract address private _upgradeabilityOwner; /** * @dev Tells the address of the owner * @return the address of the owner */ function upgradeabilityOwner() public view returns (address) { return _upgradeabilityOwner; } /** * @dev Sets the address of the owner */ function setUpgradeabilityOwner(address newUpgradeabilityOwner) internal { _upgradeabilityOwner = newUpgradeabilityOwner; } } // File: contracts/upgradeability/Proxy.sol /** * @title Proxy * @dev Gives the possibility to delegate any call to a foreign implementation. */ contract Proxy { /** * @dev Tells the address of the implementation where every call will be delegated. * @return address of the implementation to which it will be delegated */ function implementation() public view returns (address); /** * @dev Fallback function allowing to perform a delegatecall to the given implementation. * This function will return whatever the implementation call returns */ function () payable public { address _impl = implementation(); require(_impl != address(0)); assembly { /* 0x40 is the \"free memory slot\", meaning a pointer to next slot of empty memory. mload(0x40) loads the data in the free memory slot, so `ptr` is a pointer to the next slot of empty memory. It's needed because we're going to write the return data of delegatecall to the free memory slot. */ let ptr := mload(0x40) /* `calldatacopy` is copy calldatasize bytes from calldata First argument is the destination to which data is copied(ptr) Second argument specifies the start position of the copied data. Since calldata is sort of its own unique location in memory, 0 doesn't refer to 0 in memory or 0 in storage - it just refers to the zeroth byte of calldata. That's always going to be the zeroth byte of the function selector. Third argument, calldatasize, specifies how much data will be copied. calldata is naturally calldatasize bytes long (same thing as msg.data.length) */ calldatacopy(ptr, 0, calldatasize) /* delegatecall params explained: gas: the amount of gas to provide for the call. `gas` is an Opcode that gives us the amount of gas still available to execution _impl: address of the contract to delegate to ptr: to pass copied data calldatasize: loads the size of `bytes memory data`, same as msg.data.length 0, 0: These are for the `out` and `outsize` params. Because the output could be dynamic, these are set to 0, 0 so the output data will not be written to memory. The output data will be read using `returndatasize` and `returdatacopy` instead. result: This will be 0 if the call fails and 1 if it succeeds */ let result := delegatecall(gas, _impl, ptr, calldatasize, 0, 0) /* */ /* ptr current points to the value stored at 0x40, because we assigned it like ptr := mload(0x40). Because we use 0x40 as a free memory pointer, we want to make sure that the next time we want to allocate memory, we aren't overwriting anything important. So, by adding ptr and returndatasize, we get a memory location beyond the end of the data we will be copying to ptr. We place this in at 0x40, and any reads from 0x40 will now read from free memory */ mstore(0x40, add(ptr, returndatasize)) /* `returndatacopy` is an Opcode that copies the last return data to a slot. `ptr` is the slot it will copy to, 0 means copy from the beginning of the return data, and size is the amount of data to copy. `returndatasize` is an Opcode that gives us the size of the last return data. In this case, that is the size of the data returned from delegatecall */ returndatacopy(ptr, 0, returndatasize) /* if `result` is 0, revert. if `result` is 1, return `size` amount of data from `ptr`. This is the data that was copied to `ptr` from the delegatecall return data */ switch result case 0 { revert(ptr, returndatasize) } default { return(ptr, returndatasize) } } } } // File: contracts/upgradeability/UpgradeabilityStorage.sol /** * @title UpgradeabilityStorage * @dev This contract holds all the necessary state variables to support the upgrade functionality */ contract UpgradeabilityStorage { // Version name of the current implementation uint256 internal _version; // Address of the current implementation address internal _implementation; /** * @dev Tells the version name of the current implementation * @return string representing the name of the current version */ function version() public view returns (uint256) { return _version; } /** * @dev Tells the address of the current implementation * @return address of the current implementation */ function implementation() public view returns (address) { return _implementation; } } // File: contracts/upgradeability/UpgradeabilityProxy.sol /** * @title UpgradeabilityProxy * @dev This contract represents a proxy where the implementation address to which it will delegate can be upgraded */ contract UpgradeabilityProxy is Proxy, UpgradeabilityStorage { /** * @dev This event will be emitted every time the implementation gets upgraded * @param version representing the version name of the upgraded implementation * @param implementation representing the address of the upgraded implementation */ event Upgraded(uint256 version, address indexed implementation); /** * @dev Upgrades the implementation address * @param version representing the version name of the new implementation to be set * @param implementation representing the address of the new implementation to be set */ function _upgradeTo(uint256 version, address implementation) internal { require(_implementation != implementation); require(version > _version); _version = version; _implementation = implementation; emit Upgraded(version, implementation); } } // File: contracts/upgradeability/OwnedUpgradeabilityProxy.sol /** * @title OwnedUpgradeabilityProxy * @dev This contract combines an upgradeability proxy with basic authorization control functionalities */ contract OwnedUpgradeabilityProxy is UpgradeabilityOwnerStorage, UpgradeabilityProxy { /** * @dev Event to show ownership has been transferred * @param previousOwner representing the address of the previous owner * @param newOwner representing the address of the new owner */ event ProxyOwnershipTransferred(address previousOwner, address newOwner); /** * @dev the constructor sets the original owner of the contract to the sender account. */ constructor() public { setUpgradeabilityOwner(msg.sender); } /** * @dev Throws if called by any account other than the owner. */ modifier onlyProxyOwner() { require(msg.sender == proxyOwner()); _; } /** * @dev Tells the address of the proxy owner * @return the address of the proxy owner */ function proxyOwner() public view returns (address) { return upgradeabilityOwner(); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferProxyOwnership(address newOwner) public onlyProxyOwner { require(newOwner != address(0)); emit ProxyOwnershipTransferred(proxyOwner(), newOwner); setUpgradeabilityOwner(newOwner); } /** * @dev Allows the upgradeability owner to upgrade the current version of the proxy. * @param version representing the version name of the new implementation to be set. * @param implementation representing the address of the new implementation to be set. */ function upgradeTo(uint256 version, address implementation) public onlyProxyOwner { _upgradeTo(version, implementation); } /** * @dev Allows the upgradeability owner to upgrade the current version of the proxy and call the new implementation * to initialize whatever is needed through a low level call. * @param version representing the version name of the new implementation to be set. * @param implementation representing the address of the new implementation to be set. * @param data represents the msg.data to bet sent in the low level call. This parameter may include the function * signature of the implementation to be called with the needed payload */ function upgradeToAndCall(uint256 version, address implementation, bytes data) payable public onlyProxyOwner { upgradeTo(version, implementation); require(address(this).call.value(msg.value)(data)); } } // File: contracts/upgradeability/EternalStorageProxy.sol /** * @title EternalStorageProxy * @dev This proxy holds the storage of the token contract and delegates every call to the current implementation set. * Besides, it allows to upgrade the token's behaviour towards further implementations, and provides basic * authorization control functionalities */ contract EternalStorageProxy is OwnedUpgradeabilityProxy, EternalStorage {} "}
{"sol name": "38231.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filters are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "31599.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract EtherEcash is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function EtherEcash( ) { balances[msg.sender] = 360000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 360000000000000000000000000;                        // Update total supply (100000 for example) name = \"EtherEcash\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"ECH\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35708.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract eBitcoinCash is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function eBitcoinCash( ) { balances[msg.sender] = 2100000000000000; totalSupply = 2100000000000000; name = \"eBitcoinCash\"; decimals = 8; symbol = \"eBCH\"; } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33222.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 10000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000;                        // Update total supply (100000 for example) name = \"MERGE\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"MGE\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "36341.sol", "label": 0, "sol content": "pragma solidity 0.4.15; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "33656.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// This function will return the total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// Calling balanceOf and passing in an address with paramater _owner will return the token balance. function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract FAIZACOIN is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name = 'FAIZACOIN';                   //fancy name: eg Simon Bucks uint8 public decimals = 0;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol = 'FZC';                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function FAIZACOIN( ) { balances[msg.sender] = 100000000;           // Give the creator all initial tokens (100000 for example) totalSupply = 100000000;                        // Update total supply (100000 for example) name = \"FAIZA Coin\";                            // Set the name for display purposes decimals = 0;                                 // Amount of decimals for display purposes symbol = \"FZC\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "23126.sol", "label": 0, "sol content": "pragma solidity ^0.4.10; contract GasToken2 { ////////////////////////////////////////////////////////////////////////// // RLP.sol // Due to some unexplained bug, we get a slightly different bytecode if // we use an import, and are then unable to verify the code in Etherscan ////////////////////////////////////////////////////////////////////////// uint256 constant ADDRESS_BYTES = 20; uint256 constant MAX_SINGLE_BYTE = 128; uint256 constant MAX_NONCE = 256**9 - 1; // count number of bytes required to represent an unsigned integer function count_bytes(uint256 n) constant internal returns (uint256 c) { uint i = 0; uint mask = 1; while (n >= mask) { i += 1; mask *= 256; } return i; } function mk_contract_address(address a, uint256 n) constant internal returns (address rlp) { /* * make sure the RLP encoding fits in one word: * total_length      1 byte * address_length    1 byte * address          20 bytes * nonce_length      1 byte (or 0) * nonce           1-9 bytes *                ========== *                24-32 bytes */ require(n <= MAX_NONCE); // number of bytes required to write down the nonce uint256 nonce_bytes; // length in bytes of the RLP encoding of the nonce uint256 nonce_rlp_len; if (0 < n && n < MAX_SINGLE_BYTE) { // nonce fits in a single byte // RLP(nonce) = nonce nonce_bytes = 1; nonce_rlp_len = 1; } else { // RLP(nonce) = [num_bytes_in_nonce nonce] nonce_bytes = count_bytes(n); nonce_rlp_len = nonce_bytes + 1; } // [address_length(1) address(20) nonce_length(0 or 1) nonce(1-9)] uint256 tot_bytes = 1 + ADDRESS_BYTES + nonce_rlp_len; // concatenate all parts of the RLP encoding in the leading bytes of // one 32-byte word uint256 word = ((192 + tot_bytes) * 256**31) + ((128 + ADDRESS_BYTES) * 256**30) + (uint256(a) * 256**10); if (0 < n && n < MAX_SINGLE_BYTE) { word += n * 256**9; } else { word += (128 + nonce_bytes) * 256**9; word += n * 256**(9 - nonce_bytes); } uint256 hash; assembly { let mem_start := mload(0x40)        // get a pointer to free memory mstore(0x40, add(mem_start, 0x20))  // update the pointer mstore(mem_start, word)             // store the rlp encoding hash := sha3(mem_start, add(tot_bytes, 1))     // hash the rlp encoding } // interpret hash as address (20 least significant bytes) return address(hash); } ////////////////////////////////////////////////////////////////////////// // Generic ERC20 ////////////////////////////////////////////////////////////////////////// // owner -> amount mapping(address => uint256) s_balances; // owner -> spender -> max amount mapping(address => mapping(address => uint256)) s_allowances; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); // Spec: Get the account balance of another account with address `owner` function balanceOf(address owner) public constant returns (uint256 balance) { return s_balances[owner]; } function internalTransfer(address from, address to, uint256 value) internal returns (bool success) { if (value <= s_balances[from]) { s_balances[from] -= value; s_balances[to] += value; Transfer(from, to, value); return true; } else { return false; } } // Spec: Send `value` amount of tokens to address `to` function transfer(address to, uint256 value) public returns (bool success) { address from = msg.sender; return internalTransfer(from, to, value); } // Spec: Send `value` amount of tokens from address `from` to address `to` function transferFrom(address from, address to, uint256 value) public returns (bool success) { address spender = msg.sender; if(value <= s_allowances[from][spender] && internalTransfer(from, to, value)) { s_allowances[from][spender] -= value; return true; } else { return false; } } // Spec: Allow `spender` to withdraw from your account, multiple times, up // to the `value` amount. If this function is called again it overwrites the // current allowance with `value`. function approve(address spender, uint256 value) public returns (bool success) { address owner = msg.sender; if (value != 0 && s_allowances[owner][spender] != 0) { return false; } s_allowances[owner][spender] = value; Approval(owner, spender, value); return true; } // Spec: Returns the `amount` which `spender` is still allowed to withdraw // from `owner`. // What if the allowance is higher than the balance of the `owner`? // Callers should be careful to use min(allowance, balanceOf) to make sure // that the allowance is actually present in the account! function allowance(address owner, address spender) public constant returns (uint256 remaining) { return s_allowances[owner][spender]; } ////////////////////////////////////////////////////////////////////////// // GasToken specifics ////////////////////////////////////////////////////////////////////////// uint8 constant public decimals = 2; string constant public name = \"Gastoken.io\"; string constant public symbol = \"GST2\"; // We build a queue of nonces at which child contracts are stored. s_head is // the nonce at the head of the queue, s_tail is the nonce behind the tail // of the queue. The queue grows at the head and shrinks from the tail. // Note that when and only when a contract CREATEs another contract, the // creating contract's nonce is incremented. // The first child contract is created with nonce == 1, the second child // contract is created with nonce == 2, and so on... // For example, if there are child contracts at nonces [2,3,4], // then s_head == 4 and s_tail == 1. If there are no child contracts, // s_head == s_tail. uint256 s_head; uint256 s_tail; // totalSupply gives  the number of tokens currently in existence // Each token corresponds to one child contract that can be SELFDESTRUCTed // for a gas refund. function totalSupply() public constant returns (uint256 supply) { return s_head - s_tail; } // Creates a child contract that can only be destroyed by this contract. function makeChild() internal returns (address addr) { assembly { // EVM assembler of runtime portion of child contract: //     ;; Pseudocode: if (msg.sender != 0x0000000000b3f879cb30fe243b4dfee438691c04) { throw; } //     ;;             suicide(msg.sender) //     PUSH15 0xb3f879cb30fe243b4dfee438691c04 ;; hardcoded address of this contract //     CALLER //     XOR //     PC //     JUMPI //     CALLER //     SELFDESTRUCT // Or in binary: 6eb3f879cb30fe243b4dfee438691c043318585733ff // Since the binary is so short (22 bytes), we can get away // with a very simple initcode: //     PUSH22 0x6eb3f879cb30fe243b4dfee438691c043318585733ff //     PUSH1 0 //     MSTORE ;; at this point, memory locations mem[10] through //            ;; mem[31] contain the runtime portion of the child //            ;; contract. all that's left to do is to RETURN this //            ;; chunk of memory. //     PUSH1 22 ;; length //     PUSH1 10 ;; offset //     RETURN // Or in binary: 756eb3f879cb30fe243b4dfee438691c043318585733ff6000526016600af3 // Almost done! All we have to do is put this short (31 bytes) blob into // memory and call CREATE with the appropriate offsets. let solidity_free_mem_ptr := mload(0x40) mstore(solidity_free_mem_ptr, 0x00756eb3f879cb30fe243b4dfee438691c043318585733ff6000526016600af3) addr := create(0, add(solidity_free_mem_ptr, 1), 31) } } // Mints `value` new sub-tokens (e.g. cents, pennies, ...) by creating `value` // new child contracts. The minted tokens are owned by the caller of this // function. function mint(uint256 value) public { for (uint256 i = 0; i < value; i++) { makeChild(); } s_head += value; s_balances[msg.sender] += value; } // Destroys `value` child contracts and updates s_tail. // // This function is affected by an issue in solc: https://github.com/ethereum/solidity/issues/2999 // The `mk_contract_address(this, i).call();` doesn't forward all available gas, but only GAS - 25710. // As a result, when this line is executed with e.g. 30000 gas, the callee will have less than 5000 gas // available and its SELFDESTRUCT operation will fail leading to no gas refund occurring. // The remaining ~29000 gas left after the call is enough to update s_tail and the caller's balance. // Hence tokens will have been destroyed without a commensurate gas refund. // Fortunately, there is a simple workaround: // Whenever you call free, freeUpTo, freeFrom, or freeUpToFrom, ensure that you pass at least // 25710 + `value` * (1148 + 5722 + 150) gas. (It won't all be used) function destroyChildren(uint256 value) internal { uint256 tail = s_tail; // tail points to slot behind the last contract in the queue for (uint256 i = tail + 1; i <= tail + value; i++) { mk_contract_address(this, i).call(); } s_tail = tail + value; } // Frees `value` sub-tokens (e.g. cents, pennies, ...) belonging to the // caller of this function by destroying `value` child contracts, which // will trigger a partial gas refund. // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas // when calling this function. For details, see the comment above `destroyChilden`. function free(uint256 value) public returns (bool success) { uint256 from_balance = s_balances[msg.sender]; if (value > from_balance) { return false; } destroyChildren(value); s_balances[msg.sender] = from_balance - value; return true; } // Frees up to `value` sub-tokens. Returns how many tokens were freed. // Otherwise, identical to free. // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas // when calling this function. For details, see the comment above `destroyChilden`. function freeUpTo(uint256 value) public returns (uint256 freed) { uint256 from_balance = s_balances[msg.sender]; if (value > from_balance) { value = from_balance; } destroyChildren(value); s_balances[msg.sender] = from_balance - value; return value; } // Frees `value` sub-tokens owned by address `from`. Requires that `msg.sender` // has been approved by `from`. // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas // when calling this function. For details, see the comment above `destroyChilden`. function freeFrom(address from, uint256 value) public returns (bool success) { address spender = msg.sender; uint256 from_balance = s_balances[from]; if (value > from_balance) { return false; } mapping(address => uint256) from_allowances = s_allowances[from]; uint256 spender_allowance = from_allowances[spender]; if (value > spender_allowance) { return false; } destroyChildren(value); s_balances[from] = from_balance - value; from_allowances[spender] = spender_allowance - value; return true; } // Frees up to `value` sub-tokens owned by address `from`. Returns how many tokens were freed. // Otherwise, identical to `freeFrom`. // You should ensure that you pass at least 25710 + `value` * (1148 + 5722 + 150) gas // when calling this function. For details, see the comment above `destroyChilden`. function freeFromUpTo(address from, uint256 value) public returns (uint256 freed) { address spender = msg.sender; uint256 from_balance = s_balances[from]; if (value > from_balance) { value = from_balance; } mapping(address => uint256) from_allowances = s_allowances[from]; uint256 spender_allowance = from_allowances[spender]; if (value > spender_allowance) { value = spender_allowance; } destroyChildren(value); s_balances[from] = from_balance - value; from_allowances[spender] = spender_allowance - value; return value; } } "}
{"sol name": "39901.sol", "label": 0, "sol content": "pragma solidity ^0.4.0; // <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.0;//please import oraclizeAPI_pre0.4.sol when solidity < 0.4.0 contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if(address(OAR)==0) oraclize_setNetwork(networkID_auto); oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03a2615d5efaf5f49f60b7bb6583eaec212fdf1); return true; } if (getCodeSize(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaf4c8b3c9afbd5ab9f4bbc82784ab6ef8faa); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } } // </ORACLIZE_API> contract Dice is usingOraclize { uint constant pwin = 4000; //probability of winning (10000 = 100%) uint constant edge = 190; //edge percentage (10000 = 100%) uint constant maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint constant minBet = 200 finney; uint constant maxInvestors = 10; //maximum number of investors uint constant houseEdge = 90; //edge percentage (10000 = 100%) uint constant divestFee = 50; //divest fee percentage (10000 = 100%) uint constant emergencyWithdrawalRatio = 10; //ratio percentage (100 = 100%) uint safeGas = 2300; uint constant ORACLIZE_GAS_LIMIT = 175000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 3 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBet; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) public investorIDs; mapping(uint => Investor) public investors; uint public numInvestors = 0; uint public invested = 0; address public owner; address public houseAddress; bool public isStopped; WithdrawalProposal public proposedWithdrawal; mapping (bytes32 => Bet) public bets; bytes32[] public betsKeys; uint public investorsProfit = 0; uint public investorsLosses = 0; bool profitDistributed; event LOG_NewBet(address playerAddress, uint amount); event LOG_BetWon(address playerAddress, uint numberRolled, uint amountWon); event LOG_BetLost(address playerAddress, uint numberRolled); event LOG_EmergencyWithdrawalProposed(); event LOG_EmergencyWithdrawalFailed(address withdrawalAddress); event LOG_EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event LOG_FailedSend(address receiver, uint amount); event LOG_ZeroSend(); event LOG_InvestorEntrance(address investor, uint amount); event LOG_InvestorCapitalUpdate(address investor, int amount); event LOG_InvestorExit(address investor, uint amount); event LOG_ContractStopped(); event LOG_ContractResumed(); event LOG_OwnerAddressChanged(address oldAddr, address newOwnerAddress); event LOG_HouseAddressChanged(address oldAddr, address newHouseAddress); event LOG_GasLimitChanged(uint oldGasLimit, uint newGasLimit); event LOG_EmergencyAutoStop(); event LOG_EmergencyWithdrawalVote(address investor, bool vote); event LOG_ValueIsTooBig(); event LOG_SuccessfulSend(address addr, uint amount); function Dice() { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _; } modifier onlyIfStopped { if (!isStopped) throw; _; } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _; } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _; } modifier onlyOwner { if (owner != msg.sender) throw; _; } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _; } modifier onlyMoreThanZero { if (msg.value == 0) throw; _; } modifier onlyIfBetExist(bytes32 myid) { if(bets[myid].playerAddress == address(0x0)) throw; _; } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { if ((((bets[myid].amountBet * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)  && (bets[myid].amountBet >= minBet)) { _; } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && bets[myid].numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(bets[myid].playerAddress, bets[myid].amountBet); return; } _; } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _; } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _; } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _; } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _; } } modifier onlyIfValidGas(uint newGasLimit) { if (ORACLIZE_GAS_LIMIT + newGasLimit < ORACLIZE_GAS_LIMIT) throw; if (newGasLimit < 25000) throw; _; } modifier onlyIfNotProcessed(bytes32 myid) { if (bets[myid].numberRolled > 0) throw; _; } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _; } modifier investorsInvariant { _; if (numInvestors > maxInvestors) throw; } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { if ((invested < investorsProfit) || (invested + investorsProfit < invested) || (invested + investorsProfit < investorsLosses)) { return 0; } else { return invested + investorsProfit - investorsLosses; } } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, (investorsProfit - investorsLosses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBet, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLossesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLosses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { uint invested = investors[investorIDs[currentInvestor]].amountInvested; uint profit = getProfitShare(currentInvestor); uint losses = getLossesShare(currentInvestor); if ((invested + profit < profit) || (invested + profit < invested) || (invested + profit < losses)) return 0; else return invested + profit - losses; } function searchSmallestInvestor() constant returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function changeOraclizeProofType(byte _proofType) onlyOwner { if (_proofType == 0x00) throw; oraclize_setProof( _proofType |  proofStorage_IPFS ); } function changeOraclizeConfig(bytes32 _config) onlyOwner { oraclize_setConfig(_config); } // PRIVATE HELPERS FUNCTION function safeSend(address addr, uint value) private { if (value == 0) { LOG_ZeroSend(); return; } if (this.balance < value) { LOG_ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { LOG_FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) LOG_FailedSend(houseAddress, value); } } LOG_SuccessfulSend(addr,value); } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; LOG_InvestorEntrance(msg.sender, msg.value); } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint lossesOfInvestor = getLossesShare(currentInvestor); //Check for overflow and underflow if ((investors[i].amountInvested + profitOfInvestor >= investors[i].amountInvested) && (investors[i].amountInvested + profitOfInvestor >= lossesOfInvestor))  { investors[i].amountInvested += profitOfInvestor - lossesOfInvestor; LOG_InvestorCapitalUpdate(currentInvestor, (int) (profitOfInvestor - lossesOfInvestor)); } else { isStopped = true; LOG_EmergencyAutoStop(); } if (copyInvested + investors[i].amountInvested >= copyInvested) copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLosses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() payable { bet(); } function bet() payable onlyIfNotStopped { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); if (oraclizeFee >= msg.value) throw; uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { LOG_NewBet(msg.sender, betValue); bytes32 myid = oraclize_query( \"nested\", \"[URL] ['json(https://api.random.org/json-rpc/1/invoke).result.random.data.0', '\\\\n{\\\"jsonrpc\\\":\\\"2.0\\\",\\\"method\\\":\\\"generateSignedIntegers\\\",\\\"params\\\":{\\\"apiKey\\\":${[decrypt] BIxxSk7/a7poZUlLstBS3dBn4S3Z1SwCpAkhPfT5ZM8TpCkJIHCgbpiOlLR3aJZhFtP27av3lqqnOl6PqJKX4hQx4ASiqrD8TsuViJg2/6HDzu4/IuS21zHmeNAZOLvaSUgB+zr6B4TILVqsf96HU5zx9Skv4Dk=},\\\"n\\\":1,\\\"min\\\":1,\\\"max\\\":10000${[identity] \\\"}\\\"},\\\"id\\\":1${[identity] \\\"}\\\"}']\", ORACLIZE_GAS_LIMIT + safeGas ); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback(bytes32 myid, string result, bytes proof) onlyOraclize onlyIfBetExist(myid) onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(bets[myid], numberRolled); isLosingBet(bets[myid], numberRolled); delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBet * (10000 - edge)) / pwin; LOG_BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); //Check for overflow and underflow if ((investorsLosses + winAmount < investorsLosses) || (investorsLosses + winAmount < thisBet.amountBet)) { throw; } investorsLosses += winAmount - thisBet.amountBet; } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { LOG_BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); //Check for overflow and underflow if ((investorsProfit + thisBet.amountBet < investorsProfit) || (investorsProfit + thisBet.amountBet < thisBet.amountBet) || (thisBet.amountBet == 1)) { throw; } uint totalProfit = investorsProfit + (thisBet.amountBet - 1); //added based on audit feedback investorsProfit += (thisBet.amountBet - 1)*(10000 - houseEdge)/10000; uint houseProfit = totalProfit - investorsProfit; //changed based on audit feedback safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() payable onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() payable onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment investorsInvariant { profitDistribution(); if (numInvestors == maxInvestors) { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); } numInvestors++; addInvestorAtID(numInvestors); } function divest() onlyInvestors { divest(msg.sender); } function divest(address currentInvestor) private investorsInvariant { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); if ((invested >= investors[currentID].amountInvested)) { invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; delete investors[currentID]; delete investorIDs[currentInvestor]; //Reorder investors if (currentID != numInvestors) { // Get last investor Investor lastInvestor = investors[numInvestors]; //Set last investor ID to investorID of divesting account investorIDs[lastInvestor.investorAddress] = currentID; //Copy investor at the new position in the mapping investors[currentID] = lastInvestor; //Delete old position in the mappping delete investors[numInvestors]; } numInvestors--; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); LOG_InvestorExit(currentInvestor, amountToReturn); } else { isStopped = true; LOG_EmergencyAutoStop(); } } function forceDivestOfAllInvestors() onlyOwner { uint copyNumInvestors = numInvestors; for (uint i = 1; i <= copyNumInvestors; i++) { divest(investors[1].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner { isStopped = true; LOG_ContractStopped(); } function resumeContract() onlyOwner { isStopped = false; LOG_ContractResumed(); } function changeHouseAddress(address newHouse) onlyOwner { if (newHouse == address(0x0)) throw; //changed based on audit feedback houseAddress = newHouse; LOG_HouseAddressChanged(houseAddress, newHouse); } function changeOwnerAddress(address newOwner) onlyOwner { if (newOwner == address(0x0)) throw; owner = newOwner; LOG_OwnerAddressChanged(owner, newOwner); } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) { safeGas = newGasLimit; LOG_GasLimitChanged(safeGas, newGasLimit); } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; LOG_EmergencyWithdrawalVote(msg.sender, vote); } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); LOG_EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed { uint numOfVotesInFavour; uint amountToWithdraw = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(amountToWithdraw)) { LOG_EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { LOG_EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdraw); } } else { throw; } } } "}
{"sol name": "33691.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ThatCryptoShow is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ThatCryptoShow( ) { balances[msg.sender] = 4000000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 4000000000000000000000000;                        // Update total supply (100000 for example) name = \"ThatCryptoShow\";                                   // Set the name for display purposes decimals = 18;                            // Amount of decimals for display purposes symbol = \"TCS\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "22799.sol", "label": 0, "sol content": "// Copyright (C) 2017 DappHub, LLC pragma solidity ^0.4.11; //import \"ds-exec/exec.sol\"; contract DSExec { function tryExec( address target, bytes calldata, uint value) internal returns (bool call_ret) { return target.call.value(value)(calldata); } function exec( address target, bytes calldata, uint value) internal { if(!tryExec(target, calldata, value)) { throw; } } // Convenience aliases function exec( address t, bytes c ) internal { exec(t, c, 0); } function exec( address t, uint256 v ) internal { bytes memory c; exec(t, c, v); } function tryExec( address t, bytes c ) internal returns (bool) { return tryExec(t, c, 0); } function tryExec( address t, uint256 v ) internal returns (bool) { bytes memory c; return tryExec(t, c, v); } } //import \"ds-auth/auth.sol\"; contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) constant returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) auth { authority = authority_; LogSetAuthority(authority); } modifier auth { assert(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } function assert(bool x) internal { if (!x) throw; } } //import \"ds-note/note.sol\"; contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint        wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } //import \"ds-math/math.sol\"; contract DSMath { /* standard uint256 functions */ function add(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x + y) >= x); } function sub(uint256 x, uint256 y) constant internal returns (uint256 z) { assert((z = x - y) <= x); } function mul(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x * y; assert(x == 0 || z / x == y); } function div(uint256 x, uint256 y) constant internal returns (uint256 z) { z = x / y; } function min(uint256 x, uint256 y) constant internal returns (uint256 z) { return x <= y ? x : y; } function max(uint256 x, uint256 y) constant internal returns (uint256 z) { return x >= y ? x : y; } /* uint128 functions (h is for half) */ function hadd(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x + y) >= x); } function hsub(uint128 x, uint128 y) constant internal returns (uint128 z) { assert((z = x - y) <= x); } function hmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x * y; assert(x == 0 || z / x == y); } function hdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = x / y; } function hmin(uint128 x, uint128 y) constant internal returns (uint128 z) { return x <= y ? x : y; } function hmax(uint128 x, uint128 y) constant internal returns (uint128 z) { return x >= y ? x : y; } /* int256 functions */ function imin(int256 x, int256 y) constant internal returns (int256 z) { return x <= y ? x : y; } function imax(int256 x, int256 y) constant internal returns (int256 z) { return x >= y ? x : y; } /* WAD math */ uint128 constant WAD = 10 ** 18; function wadd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function wsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function wmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + WAD / 2) / WAD); } function wdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * WAD + y / 2) / y); } function wmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function wmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } /* RAY math */ uint128 constant RAY = 10 ** 27; function radd(uint128 x, uint128 y) constant internal returns (uint128) { return hadd(x, y); } function rsub(uint128 x, uint128 y) constant internal returns (uint128) { return hsub(x, y); } function rmul(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * y + RAY / 2) / RAY); } function rdiv(uint128 x, uint128 y) constant internal returns (uint128 z) { z = cast((uint256(x) * RAY + y / 2) / y); } function rpow(uint128 x, uint64 n) constant internal returns (uint128 z) { // This famous algorithm is called \"exponentiation by squaring\" // and calculates x^n with x as fixed-point and n as regular unsigned. // // It's O(log n), instead of O(n) for naive repeated multiplication. // // These facts are why it works: // //  If n is even, then x^n = (x^2)^(n/2). //  If n is odd,  then x^n = x * x^(n-1), //   and applying the equation for even x gives //    x^n = x * (x^2)^((n-1) / 2). // //  Also, EVM division is flooring and //    floor[(n-1) / 2] = floor[n / 2]. z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } function rmin(uint128 x, uint128 y) constant internal returns (uint128) { return hmin(x, y); } function rmax(uint128 x, uint128 y) constant internal returns (uint128) { return hmax(x, y); } function cast(uint256 x) constant internal returns (uint128 z) { assert((z = uint128(x)) == x); } } //import \"erc20/erc20.sol\"; contract ERC20 { function totalSupply() constant returns (uint supply); function balanceOf( address who ) constant returns (uint value); function allowance( address owner, address spender ) constant returns (uint _allowance); function transfer( address to, uint value) returns (bool ok); function transferFrom( address from, address to, uint value) returns (bool ok); function approve( address spender, uint value ) returns (bool ok); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } //import \"ds-token/base.sol\"; contract DSTokenBase is ERC20, DSMath { uint256                                            _supply; mapping (address => uint256)                       _balances; mapping (address => mapping (address => uint256))  _approvals; function DSTokenBase(uint256 supply) { _balances[msg.sender] = supply; _supply = supply; } function totalSupply() constant returns (uint256) { return _supply; } function balanceOf(address src) constant returns (uint256) { return _balances[src]; } function allowance(address src, address guy) constant returns (uint256) { return _approvals[src][guy]; } function transfer(address dst, uint wad) returns (bool) { assert(_balances[msg.sender] >= wad); _balances[msg.sender] = sub(_balances[msg.sender], wad); _balances[dst] = add(_balances[dst], wad); Transfer(msg.sender, dst, wad); return true; } function transferFrom(address src, address dst, uint wad) returns (bool) { assert(_balances[src] >= wad); assert(_approvals[src][msg.sender] >= wad); _approvals[src][msg.sender] = sub(_approvals[src][msg.sender], wad); _balances[src] = sub(_balances[src], wad); _balances[dst] = add(_balances[dst], wad); Transfer(src, dst, wad); return true; } function approve(address guy, uint256 wad) returns (bool) { _approvals[msg.sender][guy] = wad; Approval(msg.sender, guy, wad); return true; } } //import \"ds-stop/stop.sol\"; contract DSStop is DSAuth, DSNote { bool public stopped; modifier stoppable { assert (!stopped); _; } function stop() auth note { stopped = true; } function start() auth note { stopped = false; } } //import \"ds-token/token.sol\"; contract DSToken is DSTokenBase(0), DSStop { bytes32  public  symbol; uint256  public  decimals = 18; // standard token precision. override to customize address  public  generator; modifier onlyGenerator { if(msg.sender!=generator) throw; _; } function DSToken(bytes32 symbol_) { symbol = symbol_; generator=msg.sender; } function transfer(address dst, uint wad) stoppable note returns (bool) { return super.transfer(dst, wad); } function transferFrom( address src, address dst, uint wad ) stoppable note returns (bool) { return super.transferFrom(src, dst, wad); } function approve(address guy, uint wad) stoppable note returns (bool) { return super.approve(guy, wad); } function push(address dst, uint128 wad) returns (bool) { return transfer(dst, wad); } function pull(address src, uint128 wad) returns (bool) { return transferFrom(src, msg.sender, wad); } function mint(uint128 wad) auth stoppable note { _balances[msg.sender] = add(_balances[msg.sender], wad); _supply = add(_supply, wad); } function burn(uint128 wad) auth stoppable note { _balances[msg.sender] = sub(_balances[msg.sender], wad); _supply = sub(_supply, wad); } // owner can transfer token even stop, function generatorTransfer(address dst, uint wad) onlyGenerator note returns (bool) { return super.transfer(dst, wad); } // Optional token name bytes32   public  name = \"\"; function setName(bytes32 name_) auth { name = name_; } } "}
{"sol name": "44673.sol", "label": 0, "sol content": "pragma solidity ^0.5.16; pragma experimental ABIEncoderV2; // Inheritance import \"./Collateral.sol\"; import \"openzeppelin-solidity-2.3.0/contracts/utils/ReentrancyGuard.sol\"; import \"./interfaces/ICollateralEth.sol\"; // Internal references import \"./CollateralState.sol\"; // This contract handles the payable aspects of eth loans. contract CollateralEth is Collateral, ICollateralEth, ReentrancyGuard { mapping(address => uint) public pendingWithdrawals; constructor( CollateralState _state, address _owner, address _manager, address _resolver, bytes32 _collateralKey, uint _minCratio, uint _minCollateral ) public Collateral(_state, _owner, _manager, _resolver, _collateralKey, _minCratio, _minCollateral) {} function open(uint amount, bytes32 currency) external payable { openInternal(msg.value, amount, currency, false); } function close(uint id) external { uint collateral = closeInternal(msg.sender, id); pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].add(collateral); } function deposit(address borrower, uint id) external payable { depositInternal(borrower, id, msg.value); } function withdraw(uint id, uint withdrawAmount) external { uint amount = withdrawInternal(id, withdrawAmount); pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].add(amount); } function repay( address account, uint id, uint amount ) external { repayInternal(account, msg.sender, id, amount); } function draw(uint id, uint amount) external { drawInternal(id, amount); } function liquidate( address borrower, uint id, uint amount ) external { uint collateralLiquidated = liquidateInternal(borrower, id, amount); pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].add(collateralLiquidated); } function claim(uint amount) external nonReentrant { // If they try to withdraw more than their total balance, it will fail on the safe sub. pendingWithdrawals[msg.sender] = pendingWithdrawals[msg.sender].sub(amount); (bool success, ) = msg.sender.call.value(amount)(\"\"); require(success, \"Transfer failed\"); } } "}
{"sol name": "37233.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H0.1';       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } contract HumanStandardTokenFactory { mapping(address => address[]) public created; mapping(address => bool) public isHumanToken; //verify without having to do a bytecode check. bytes public humanStandardByteCode; function HumanStandardTokenFactory() { //upon creation of the factory, deploy a HumanStandardToken (parameters are meaningless) and store the bytecode provably. address verifiedToken = createHumanStandardToken(10000, \"Verify Token\", 3, \"VTX\"); humanStandardByteCode = codeAt(verifiedToken); } //verifies if a contract that has been deployed is a Human Standard Token. //NOTE: This is a very expensive function, and should only be used in an eth_call. ~800k gas function verifyHumanStandardToken(address _tokenContract) constant returns (bool) { bytes memory fetchedTokenByteCode = codeAt(_tokenContract); if (fetchedTokenByteCode.length != humanStandardByteCode.length) { return false; //clear mismatch } //starting iterating through it if lengths match for (uint i = 0; i < fetchedTokenByteCode.length; i ++) { if (fetchedTokenByteCode[i] != humanStandardByteCode[i]) { return false; } } return true; } //for now, keeping this internal. Ideally there should also be a live version of this that any contract can use, lib-style. //retrieves the bytecode at a specific address. function codeAt(address _addr) internal constant returns (bytes o_code) { assembly { // retrieve the size of the code, this needs assembly let size := extcodesize(_addr) // allocate output byte array - this could also be done without assembly // by using o_code = new bytes(size) o_code := mload(0x40) // new \"memory end\" including padding mstore(0x40, add(o_code, and(add(add(size, 0x20), 0x1f), not(0x1f)))) // store length in memory mstore(o_code, size) // actually retrieve the code, this needs assembly extcodecopy(_addr, add(o_code, 0x20), 0, size) } } function createHumanStandardToken(uint256 _initialAmount, string _name, uint8 _decimals, string _symbol) returns (address) { HumanStandardToken newToken = (new HumanStandardToken(_initialAmount, _name, _decimals, _symbol)); created[msg.sender].push(address(newToken)); isHumanToken[address(newToken)] = true; newToken.transfer(msg.sender, _initialAmount); //the factory will own the created tokens. You must transfer them. return address(newToken); } } "}
{"sol name": "34600.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; /** * @title MultiSigStub * @author Ricardo Guilherme Schmidt (Status Research & Development GmbH) * @dev Contract that delegates calls to a library to build a full MultiSigWallet that is cheap to create. */ contract MultiSigStub { address[] public owners; address[] public tokens; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } function MultiSigStub(address[] _owners, uint256 _required) { //bytes4 sig = bytes4(sha3(\"constructor(address[],uint256)\")); bytes4 sig = 0x36756a23; uint argarraysize = (2 + _owners.length); uint argsize = (1 + argarraysize) * 32; uint size = 4 + argsize; bytes32 mData = _malloc(size); assembly { mstore(mData, sig) codecopy(add(mData, 0x4), sub(codesize, argsize), argsize) } _delegatecall(mData, size); } modifier delegated { uint size = msg.data.length; bytes32 mData = _malloc(size); assembly { calldatacopy(mData, 0x0, size) } bytes32 mResult = _delegatecall(mData, size); _; assembly { return(mResult, 0x20) } } function() payable delegated { } function submitTransaction(address destination, uint value, bytes data) public delegated returns (uint) { } function confirmTransaction(uint transactionId) public delegated { } function watch(address _tokenAddr) public delegated { } function setMyTokenList(address[] _tokenList) public delegated { } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant delegated returns (bool) { } /* * Web3 call functions */ function tokenBalances(address tokenAddress) public constant delegated returns (uint) { } /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant delegated returns (uint) { } /// @dev Returns total number of transactions after filters are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant delegated returns (uint) { } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns list of tokens. /// @return List of token addresses. function getTokenList() public constant returns (address[]) { return tokens; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } } _confirmations = new address[](count); for (i = 0; i < count; i++) { _confirmations[i] = confirmationsTemp[i]; } } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i = 0; i < transactionCount; i++) { if (pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } } _transactionIds = new uint[](to - from); for (i = from; i < to; i++) { _transactionIds[i - from] = transactionIdsTemp[i]; } } function _malloc(uint size) private returns(bytes32 mData) { assembly { mData := mload(0x40) mstore(0x40, add(mData, size)) } } function _delegatecall(bytes32 mData, uint size) private returns(bytes32 mResult) { address target = 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4; //Multinetwork mResult = _malloc(32); bool failed; assembly { failed := iszero(delegatecall(sub(gas, 10000), target, mData, size, mResult, 0x20)) } assert(!failed); } } contract MultiSigFactory { event Create(address indexed caller, address createdContract); function create(address[] owners, uint256 required) returns (address wallet){ wallet = new MultiSigStub(owners, required); Create(msg.sender, wallet); } } /////////////////////////////////////////////////////////////////// // MultiSigTokenWallet as in 0xc0FFeEE61948d8993864a73a099c0E38D887d3F4 /////////////////////////////////////////////////////////////////// pragma solidity ^0.4.15; contract ERC20 { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256 balance); function allowance(address owner, address spender) constant returns (uint256 remaining); function transfer(address to, uint256 value) returns (bool ok); function transferFrom(address from, address to, uint256 value) returns (bool ok); function approve(address spender, uint256 value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract MultiSigTokenWallet { address[] public owners; address[] public tokens; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; uint public transactionCount; mapping (address => uint) public tokenBalances; mapping (address => bool) public isOwner; mapping (address => address[]) public userList; uint public required; uint public nonce; struct Transaction { address destination; uint value; bytes data; bool executed; } uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed _sender, uint indexed _transactionId); event Revocation(address indexed _sender, uint indexed _transactionId); event Submission(uint indexed _transactionId); event Execution(uint indexed _transactionId); event ExecutionFailure(uint indexed _transactionId); event Deposit(address indexed _sender, uint _value); event TokenDeposit(address _token, address indexed _sender, uint _value); event OwnerAddition(address indexed _owner); event OwnerRemoval(address indexed _owner); event RequirementChange(uint _required); modifier onlyWallet() { require (msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require (!isOwner[owner]); _; } modifier ownerExists(address owner) { require (isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require (transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require (confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require (!transactions[transactionId].executed); _; } modifier notNull(address _address) { require (_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require (ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /** * Public functions * **/ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function constructor(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { require(owners.length == 0 && required == 0); for (uint i = 0; i < _owners.length; i++) { require(!isOwner[_owners[i]] && _owners[i] != 0); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /** * @notice deposit a ERC20 token. The amount of deposit is the allowance set to this contract. * @param _token the token contract address * @param _data might be used by child implementations **/ function depositToken(address _token, bytes _data) public { address sender = msg.sender; uint amount = ERC20(_token).allowance(sender, this); deposit(sender, amount, _token, _data); } /** * @notice deposit a ERC20 token. The amount of deposit is the allowance set to this contract. * @param _token the token contract address * @param _data might be used by child implementations **/ function deposit(address _from, uint256 _amount, address _token, bytes _data) public { if (_from == address(this)) return; uint _nonce = nonce; bool result = ERC20(_token).transferFrom(_from, this, _amount); assert(result); //ERC23 not executed _deposited tokenFallback by if (nonce == _nonce) { _deposited(_from, _amount, _token, _data); } } /** * @notice watches for balance in a token contract * @param _tokenAddr the token contract address **/ function watch(address _tokenAddr) ownerExists(msg.sender) { uint oldBal = tokenBalances[_tokenAddr]; uint newBal = ERC20(_tokenAddr).balanceOf(this); if (newBal > oldBal) { _deposited(0x0, newBal-oldBal, _tokenAddr, new bytes(0)); } } function setMyTokenList(address[] _tokenList) public { userList[msg.sender] = _tokenList; } function setTokenList(address[] _tokenList) onlyWallet { tokens = _tokenList; } /** * @notice ERC23 Token fallback * @param _from address incoming token * @param _amount incoming amount **/ function tokenFallback(address _from, uint _amount, bytes _data) public { _deposited(_from, _amount, msg.sender, _data); } /** * @notice Called MiniMeToken approvesAndCall to this contract, calls deposit. * @param _from address incoming token * @param _amount incoming amount * @param _token the token contract address * @param _data (might be used by child classes) */ function receiveApproval(address _from, uint256 _amount, address _token, bytes _data) { deposit(_from, _amount, _token, _data); } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; uint _len = owners.length - 1; for (uint i = 0; i < _len; i++) { if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i = 0; i < owners.length; i++) { if (owners[i] == owner) { owners[i] = newOwner; break; } } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /** * @dev gives full ownership of this wallet to `_dest` removing older owners from wallet * @param _dest the address of new controller **/ function releaseWallet(address _dest) public notNull(_dest) ownerDoesNotExist(_dest) onlyWallet { address[] memory _owners = owners; uint numOwners = _owners.length; addOwner(_dest); for (uint i = 0; i < numOwners; i++) { removeOwner(_owners[i]); } } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txx = transactions[transactionId]; txx.executed = true; if (txx.destination.call.value(txx.value)(txx.data)) { Execution(transactionId); } else { ExecutionFailure(transactionId); txx.executed = false; } } } /** * @dev withdraw all recognized tokens balances and ether to `_dest` * @param _dest the address of receiver **/ function withdrawEverything(address _dest) public notNull(_dest) onlyWallet { withdrawAllTokens(_dest); _dest.transfer(this.balance); } /** * @dev withdraw all recognized tokens balances to `_dest` * @param _dest the address of receiver **/ function withdrawAllTokens(address _dest) public notNull(_dest) onlyWallet { address[] memory _tokenList; if (userList[_dest].length > 0) { _tokenList = userList[_dest]; } else { _tokenList = tokens; } uint len = _tokenList.length; for (uint i = 0;i < len; i++) { address _tokenAddr = _tokenList[i]; uint _amount = tokenBalances[_tokenAddr]; if (_amount > 0) { delete tokenBalances[_tokenAddr]; ERC20(_tokenAddr).transfer(_dest, _amount); } } } /** * @dev withdraw `_tokenAddr` `_amount` to `_dest` * @param _tokenAddr the address of the token * @param _dest the address of receiver * @param _amount the number of tokens to send **/ function withdrawToken(address _tokenAddr, address _dest, uint _amount) public notNull(_dest) onlyWallet { require(_amount > 0); uint _balance = tokenBalances[_tokenAddr]; require(_amount <= _balance); tokenBalances[_tokenAddr] = _balance - _amount; bool result = ERC20(_tokenAddr).transfer(_dest, _amount); assert(result); } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /** * @dev register the deposit **/ function _deposited(address _from,  uint _amount, address _tokenAddr, bytes) internal { TokenDeposit(_tokenAddr,_from,_amount); nonce++; if (tokenBalances[_tokenAddr] == 0) { tokens.push(_tokenAddr); tokenBalances[_tokenAddr] = ERC20(_tokenAddr).balanceOf(this); } else { tokenBalances[_tokenAddr] += _amount; } } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; } } /// @dev Returns total number of transactions after filters are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i = 0; i < transactionCount; i++) { if (pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns list of tokens. /// @return List of token addresses. function getTokenList() public constant returns (address[]) { return tokens; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i = 0; i < owners.length; i++) { if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } } _confirmations = new address[](count); for (i = 0; i < count; i++) { _confirmations[i] = confirmationsTemp[i]; } } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i = 0; i < transactionCount; i++) { if (pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } } _transactionIds = new uint[](to - from); for (i = from; i < to; i++) { _transactionIds[i - from] = transactionIdsTemp[i]; } } } "}
{"sol name": "33194.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract ZipperMultisigFactory { address zipper; function ZipperMultisigFactory(address _zipper) public { zipper = _zipper; } function createMultisig() public returns (address _multisig) { address[] memory addys = new address[](2); addys[0] = zipper; addys[1] = msg.sender; MultiSigWallet a = new MultiSigWallet(addys, 2); MultisigCreated(address(a), msg.sender, zipper); return address(a); } function changeZipper(address _newZipper) public { require(msg.sender == zipper); zipper = _newZipper; } event MultisigCreated(address _multisig, address indexed _sender, address indexed _zipper); } // b7f01af8bd882501f6801eb1eea8b22aa2a4979e from https://github.com/gnosis/MultiSigWallet/blob/master/contracts/MultiSigWallet.sol /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "37055.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract RealOldFuckMaker { address fuck = 0xc63e7b1DEcE63A77eD7E4Aeef5efb3b05C81438D; // this can make OVER 9,000 OLD FUCKS // (just pass in 129) function makeOldFucks(uint32 number) { uint32 i; for (i = 0; i < number; i++) { fuck.call(bytes4(sha3(\"giveBlockReward()\"))); } } } "}
{"sol name": "38420.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; /* CoinDash Buyer ======================== Buys CoinDash tokens from the crowdsale on your behalf. Author: /u/Cintix */ // ERC20 Interface: https://github.com/ethereum/EIPs/issues/20 contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract CoinDashBuyer { // Store the amount of ETH deposited by each account. mapping (address => uint256) public balances; // Bounty for executing buy. uint256 public bounty; // Track whether the contract has bought the tokens yet. bool public bought_tokens; // Record the time the contract bought the tokens. uint256 public time_bought; // Emergency kill switch in case a critical bug is found. bool public kill_switch; // Token Wei received per ETH Wei contributed in this sale uint256 tokens_per_eth = 6093; // SHA3 hash of kill switch password. bytes32 password_hash = 0x1b266c9bad3a46ed40bf43471d89b83712ed06c2250887c457f5f21f17b2eb97; // Earliest time contract is allowed to buy into the crowdsale. uint256 earliest_buy_time = 1500294600; // The developer address. address developer = 0x000Fb8369677b3065dE5821a86Bc9551d5e5EAb9; // The crowdsale address.  Settable by the developer. address public sale; // The token address.  Settable by the developer. ERC20 public token; // Allows the developer to set the crowdsale and token addresses. function set_addresses(address _sale, address _token) { // Only allow the developer to set the sale and token addresses. if (msg.sender != developer) throw; // Only allow setting the addresses once. if (sale != 0x0) throw; // Set the crowdsale and token addresses. sale = _sale; token = ERC20(_token); } // Allows the developer or anyone with the password to shut down everything except withdrawals in emergencies. function activate_kill_switch(string password) { // Only activate the kill switch if the sender is the developer or the password is correct. if (msg.sender != developer && sha3(password) != password_hash) throw; // Irreversibly activate the kill switch. kill_switch = true; } // Withdraws all ETH deposited or tokens purchased by the user. // \"internal\" means this function is not externally callable. function withdraw(address user, bool has_fee) internal { // If called before the ICO, cancel user's participation in the sale. if (!bought_tokens) { // Store the user's balance prior to withdrawal in a temporary variable. uint256 eth_to_withdraw = balances[user]; // Update the user's balance prior to sending ETH to prevent recursive call. balances[user] = 0; // Return the user's funds.  Throws on failure to prevent loss of funds. user.transfer(eth_to_withdraw); } // Withdraw the user's tokens if the contract has already purchased them. else { // Store the user's token balance in a temporary variable. uint256 tokens_to_withdraw = balances[user] * tokens_per_eth; // Update the user's balance prior to sending to prevent recursive call. balances[user] = 0; // No fee if the user withdraws their own funds manually. uint256 fee = 0; // 1% fee for automatic withdrawals. if (has_fee) { fee = tokens_to_withdraw / 100; // Send the fee to the developer. if(!token.transfer(developer, fee)) throw; } // Send the funds.  Throws on failure to prevent loss of funds. if(!token.transfer(user, tokens_to_withdraw - fee)) throw; } } // Automatically withdraws on users' behalves (less a 1% fee on tokens). function auto_withdraw(address user){ // Only allow automatic withdrawals after users have had a chance to manually withdraw. if (!bought_tokens || now < time_bought + 1 hours) throw; // Withdraw the user's funds for them. withdraw(user, true); } // Allows developer to add ETH to the buy execution bounty. function add_to_bounty() payable { // Only allow the developer to contribute to the buy execution bounty. if (msg.sender != developer) throw; // Disallow adding to bounty if kill switch is active. if (kill_switch) throw; // Disallow adding to the bounty if contract has already bought the tokens. if (bought_tokens) throw; // Update bounty to include received amount. bounty += msg.value; } // Buys tokens in the crowdsale and rewards the caller, callable by anyone. function claim_bounty(){ // Short circuit to save gas if the contract has already bought tokens. if (bought_tokens) return; // Short circuit to save gas if kill switch is active. if (kill_switch) return; // Short circuit to save gas if the earliest buy time hasn't been reached. if (now < earliest_buy_time) return; // Disallow buying in if the developer hasn't set the sale address yet. if (sale == 0x0) throw; // Record that the contract has bought the tokens. bought_tokens = true; // Record the time the contract bought the tokens. time_bought = now; // Transfer all the funds (less the bounty) to the crowdsale address // to buy tokens.  Throws if the crowdsale hasn't started yet or has // already completed, preventing loss of funds. if(!sale.call.value(this.balance - bounty)()) throw; // Send the caller their bounty for buying tokens for the contract. msg.sender.transfer(bounty); } // A helper function for the default function, allowing contracts to interact. function default_helper() payable { // Treat near-zero ETH transactions as withdrawal requests. if (msg.value <= 1 finney) { // No fee on manual withdrawals. withdraw(msg.sender, false); } // Deposit the user's funds for use in purchasing tokens. else { // Disallow deposits if kill switch is active. if (kill_switch) throw; // Only allow deposits if the contract hasn't already purchased the tokens. if (bought_tokens) throw; // Update records of deposited ETH to include the received amount. balances[msg.sender] += msg.value; } } // Default function.  Called when a user sends ETH to the contract. function () payable { // Delegate to the helper function. default_helper(); } } "}
{"sol name": "38676.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; // ==== DISCLAIMER ==== // // ETHEREUM IS STILL AN EXPEREMENTAL TECHNOLOGY. // ALTHOUGH THIS SMART CONTRACT WAS CREATED WITH GREAT CARE AND IN THE HOPE OF BEING USEFUL, NO GUARANTEES OF FLAWLESS OPERATION CAN BE GIVEN. // IN PARTICULAR - SUBTILE BUGS, HACKER ATTACKS OR MALFUNCTION OF UNDERLYING TECHNOLOGY CAN CAUSE UNINTENTIONAL BEHAVIOUR. // YOU ARE STRONGLY ENCOURAGED TO STUDY THIS SMART CONTRACT CAREFULLY IN ORDER TO UNDERSTAND POSSIBLE EDGE CASES AND RISKS. // DON'T USE THIS SMART CONTRACT IF YOU HAVE SUBSTANTIAL DOUBTS OR IF YOU DON'T KNOW WHAT YOU ARE DOING. // // THIS SOFTWARE IS PROVIDED \"AS IS\" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY // AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, // INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, // OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, // OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE. // ==== // /// @author Santiment LLC /// @title  Subscription Module for SAN - santiment token contract Base { function max(uint a, uint b) returns (uint) { return a >= b ? a : b; } function min(uint a, uint b) returns (uint) { return a <= b ? a : b; } modifier only(address allowed) { if (msg.sender != allowed) throw; _; } ///@return True if `_addr` is a contract function isContract(address _addr) constant internal returns (bool) { if (_addr == 0) return false; uint size; assembly { size := extcodesize(_addr) } return (size > 0); } // ************************************************* // *          reentrancy handling                  * // ************************************************* //@dev predefined locks (up to uint bit length, i.e. 256 possible) uint constant internal L00 = 2 ** 0; uint constant internal L01 = 2 ** 1; uint constant internal L02 = 2 ** 2; uint constant internal L03 = 2 ** 3; uint constant internal L04 = 2 ** 4; uint constant internal L05 = 2 ** 5; //prevents reentrancy attacs: specific locks uint private bitlocks = 0; modifier noReentrancy(uint m) { var _locks = bitlocks; if (_locks & m > 0) throw; bitlocks |= m; _; bitlocks = _locks; } modifier noAnyReentrancy { var _locks = bitlocks; if (_locks > 0) throw; bitlocks = uint(-1); _; bitlocks = _locks; } ///@dev empty marking modifier signaling to user of the marked function , that it can cause an reentrant call. ///     developer should make the caller function reentrant-safe if it use a reentrant function. modifier reentrant { _; } } contract Owned is Base { address public owner; address public newOwner; function Owned() { owner = msg.sender; } function transferOwnership(address _newOwner) only(owner) { newOwner = _newOwner; } function acceptOwnership() only(newOwner) { OwnershipTransferred(owner, newOwner); owner = newOwner; } event OwnershipTransferred(address indexed _from, address indexed _to); } contract ERC20 is Owned { event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function transfer(address _to, uint256 _value) isStartedOnly returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) isStartedOnly returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) isStartedOnly returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; bool    public isStarted = false; modifier onlyHolder(address holder) { if (balanceOf(holder) == 0) throw; _; } modifier isStartedOnly() { if (!isStarted) throw; _; } } //Decision made. // 1 - Provider is solely responsible to consider failed sub charge as an error and stop the service, //    therefore there is no separate error state or counter for that in this Token Contract. // // 2 - A call originated from the user (isContract(msg.sender)==false) should throw an exception on error, //     but it should return \"false\" on error if called from other contract (isContract(msg.sender)==true). //     Reason: thrown exception are easier to see in wallets, returned boolean values are easier to evaluate in the code of the calling contract. // // 3 - Service providers are responsible for firing events in case of offer changes; //     it is theirs decision to inform DApps about offer changes or not. // ///@dev an base class to implement by Service Provider contract to be notified about subscription changes (in-Tx notification). ///     Additionally it contains standard events to be fired by service provider on offer changes. ///     see alse EVM events logged by subscription module. // contract ServiceProvider { ///@dev get human readable descriptor (or url) for this Service provider // function info() constant public returns(string); ///@dev called to post-approve/reject incoming single payment. ///@return `false` causes an exception and reverts the payment. // function onPayment(address _from, uint _value, bytes _paymentData) public returns (bool); ///@dev called to post-approve/reject subscription charge. ///@return `false` causes an exception and reverts the operation. // function onSubExecuted(uint subId) public returns (bool); ///@dev called to post-approve/reject a creation of the subscription. ///@return `false` causes an exception and reverts the operation. // function onSubNew(uint newSubId, uint offerId) public returns (bool); ///@dev called to notify service provider about subscription cancellation. ///     Provider is not able to prevent the cancellation. ///@return <<reserved for future implementation>> // function onSubCanceled(uint subId, address caller) public returns (bool); ///@dev called to notify service provider about subscription got hold/unhold. ///@return `false` causes an exception and reverts the operation. // function onSubUnHold(uint subId, address caller, bool isOnHold) public returns (bool); ///@dev following events should be used by ServiceProvider contract to notify DApps about offer changes. ///     SubscriptionModule do not this notification and expects it from Service Provider if desired. /// ///@dev to be fired by ServiceProvider on new Offer created in a platform. event OfferCreated(uint offerId,  bytes descriptor, address provider); ///@dev to be fired by ServiceProvider on Offer updated. event OfferUpdated(uint offerId,  bytes descriptor, uint oldExecCounter, address provider); ///@dev to be fired by ServiceProvider on Offer canceled. event OfferCanceled(uint offerId, bytes descriptor, address provider); ///@dev to be fired by ServiceProvider on Offer hold/unhold status changed. event OfferUnHold(uint offerId,   bytes descriptor, bool isOnHoldNow, address provider); } //ServiceProvider ///@notice XRateProvider is an external service providing an exchange rate from external currency to SAN token. /// it used for subscriptions priced in other currency than SAN (even calculated and paid formally in SAN). /// if non-default XRateProvider is set for some subscription, then the amount in SAN for every periodic payment /// will be recalculated using provided exchange rate. /// /// Please note, that the exchange rate fraction is (uint32,uint32) number. It should be enough to express /// any real exchange rate volatility. Nevertheless you are advised to avoid too big numbers in the fraction. /// Possiibly you could implement the ratio of multiple token per SAN in order to keep the average ratio around 1:1. /// /// The default XRateProvider (with id==0) defines exchange rate 1:1 and represents exchange rate of SAN token to itself. /// this provider is set by defalult and thus the subscription becomes nominated in SAN. // contract XRateProvider { //@dev returns current exchange rate (in form of a simple fraction) from other currency to SAN (f.e. ETH:SAN). //@dev fraction numbers are restricted to uint16 to prevent overflow in calculations; function getRate() public returns (uint32 /*nominator*/, uint32 /*denominator*/); //@dev provides a code for another currency, f.e. \"ETH\" or \"USD\" function getCode() public returns (string); } //@dev data structure for SubscriptionModule contract SubscriptionBase { enum SubState   {NOT_EXIST, BEFORE_START, PAID, CHARGEABLE, ON_HOLD, CANCELED, EXPIRED, FINALIZED} enum OfferState {NOT_EXIST, BEFORE_START, ACTIVE, SOLD_OUT, ON_HOLD, EXPIRED} string[] internal SUB_STATES   = [\"NOT_EXIST\", \"BEFORE_START\", \"PAID\", \"CHARGEABLE\", \"ON_HOLD\", \"CANCELED\", \"EXPIRED\", \"FINALIZED\" ]; string[] internal OFFER_STATES = [\"NOT_EXIST\", \"BEFORE_START\", \"ACTIVE\", \"SOLD_OUT\", \"ON_HOLD\", \"EXPIRED\"]; //@dev subscription and subscription offer use the same structure. Offer is technically a template for subscription. struct Subscription { address transferFrom;   // customer (unset in subscription offer) address transferTo;     // service provider uint pricePerHour;      // price in SAN per hour (possibly recalculated using exchange rate) uint32 initialXrate_n;  // nominator uint32 initialXrate_d;  // denominator uint16 xrateProviderId; // id of a registered exchange rate provider uint paidUntil;         // subscription is paid until time uint chargePeriod;      // subscription can't be charged more often than this period uint depositAmount;     // upfront deposit on creating subscription (possibly recalculated using exchange rate) uint startOn;           // for offer: can't be accepted before  <startOn> ; for subscription: can't be charged before <startOn> uint expireOn;          // for offer: can't be accepted after  <expireOn> ; for subscription: can't be charged after  <expireOn> uint execCounter;       // for offer: max num of subscriptions available  ; for subscription: num of charges made. bytes descriptor;       // subscription payload (subject): evaluated by service provider. uint onHoldSince;       // subscription: on-hold since time or 0 if not onHold. offer: unused: //ToDo: to be implemented } struct Deposit { uint value;         // value on deposit address owner;      // usually a customer bytes descriptor;   // service related descriptor to be evaluated by service provider } event NewSubscription(address customer, address service, uint offerId, uint subId); event NewDeposit(uint depositId, uint value, address sender); event NewXRateProvider(address addr, uint16 xRateProviderId, address sender); event DepositReturned(uint depositId, address returnedTo); event SubscriptionDepositReturned(uint subId, uint amount, address returnedTo, address sender); event OfferOnHold(uint offerId, bool onHold, address sender); event OfferCanceled(uint offerId, address sender); event SubOnHold(uint offerId, bool onHold, address sender); event SubCanceled(uint subId, address sender); } ///@dev an Interface for SubscriptionModule. ///     extracted here for better overview. ///     see detailed documentation in implementation module. contract SubscriptionModule is SubscriptionBase, Base { ///@dev ***** module configuration ***** function attachToken(address token) public; ///@dev ***** single payment handling ***** function paymentTo(uint _value, bytes _paymentData, ServiceProvider _to) public reentrant returns (bool success); function paymentFrom(uint _value, bytes _paymentData, address _from, ServiceProvider _to) public reentrant returns (bool success); ///@dev ***** subscription handling ***** ///@dev some functions are marked as reentrant, even theirs implementation is marked with noReentrancy(LOCK). ///     This is intentionally because these noReentrancy(LOCK) restrictions can be lifted in the future. //      Functions would become reentrant. function createSubscription(uint _offerId, uint _expireOn, uint _startOn) public reentrant returns (uint newSubId); function cancelSubscription(uint subId) reentrant public; function cancelSubscription(uint subId, uint gasReserve) reentrant public; function holdSubscription(uint subId) public reentrant returns (bool success); function unholdSubscription(uint subId) public reentrant returns (bool success); function executeSubscription(uint subId) public reentrant returns (bool success); function postponeDueDate(uint subId, uint newDueDate) public returns (bool success); function returnSubscriptionDesposit(uint subId) public; function claimSubscriptionDeposit(uint subId) public; function state(uint subId) public constant returns(string state); function stateCode(uint subId) public constant returns(uint stateCode); ///@dev ***** subscription offer handling ***** function createSubscriptionOffer(uint _price, uint16 _xrateProviderId, uint _chargePeriod, uint _expireOn, uint _offerLimit, uint _depositValue, uint _startOn, bytes _descriptor) public reentrant returns (uint subId); function updateSubscriptionOffer(uint offerId, uint _offerLimit) public; function holdSubscriptionOffer(uint offerId) public returns (bool success); function unholdSubscriptionOffer(uint offerId) public returns (bool success); function cancelSubscriptionOffer(uint offerId) public returns (bool); ///@dev ***** simple deposit handling ***** function createDeposit(uint _value, bytes _descriptor) public returns (uint subId); function claimDeposit(uint depositId) public; ///@dev ***** ExchangeRate provider ***** function registerXRateProvider(XRateProvider addr) public returns (uint16 xrateProviderId); ///@dev ***** Service provider (payment receiver) ***** function enableServiceProvider(ServiceProvider addr, bytes moreInfo) public; function disableServiceProvider(ServiceProvider addr, bytes moreInfo) public; ///@dev ***** convenience subscription getter ***** function subscriptionDetails(uint subId) public constant returns( address transferFrom, address transferTo, uint pricePerHour, uint32 initialXrate_n, //nominator uint32 initialXrate_d, //denominator uint16 xrateProviderId, uint chargePeriod, uint startOn, bytes descriptor ); function subscriptionStatus(uint subId) public constant returns( uint depositAmount, uint expireOn, uint execCounter, uint paidUntil, uint onHoldSince ); enum PaymentStatus {OK, BALANCE_ERROR, APPROVAL_ERROR} event Payment(address _from, address _to, uint _value, uint _fee, address sender, PaymentStatus status, uint subId); event ServiceProviderEnabled(address addr, bytes moreInfo); event ServiceProviderDisabled(address addr, bytes moreInfo); } //SubscriptionModule contract ERC20ModuleSupport { function _fulfillPreapprovedPayment(address _from, address _to, uint _value, address msg_sender) public returns(bool success); function _fulfillPayment(address _from, address _to, uint _value, uint subId, address msg_sender) public returns (bool success); function _mintFromDeposit(address owner, uint amount) public; function _burnForDeposit(address owner, uint amount) public returns(bool success); } //@dev implementation contract SubscriptionModuleImpl is SubscriptionModule, Owned  { string public constant VERSION = \"0.1.0\"; // ************************************************* // *              contract states                  * // ************************************************* ///@dev list of all registered service provider contracts implemented as a map for better lookup. mapping (address=>bool) public providerRegistry; ///@dev all subscriptions and offers (incl. FINALIZED). mapping (uint => Subscription) public subscriptions; ///@dev all active simple deposits gived by depositId. mapping (uint => Deposit) public deposits; ///@dev addresses of registered exchange rate providers. XRateProvider[] public xrateProviders; ///@dev ongoing counter for subscription ids starting from 1. ///     Current value represents an id of last created subscription. uint public subscriptionCounter = 0; ///@dev ongoing counter for simple deposit ids starting from 1. ///     Current value represents an id of last created deposit. uint public depositCounter = 0; ///@dev Token contract with ERC20ModuleSupport addon. ///     Subscription Module operates on its balances via ERC20ModuleSupport interface as trusted module. ERC20ModuleSupport public san; // ************************************************* // *     reject all ether sent to this contract    * // ************************************************* function () { throw; } // ************************************************* // *            setup and configuration            * // ************************************************* ///@dev constructor function SubscriptionModuleImpl() { owner = msg.sender; xrateProviders.push(XRateProvider(this)); //this is a default SAN:SAN (1:1) provider with default id == 0 } ///@dev attach SAN token to work with; can be done only once. function attachToken(address token) public { assert(address(san) == 0); //only in new deployed state san = ERC20ModuleSupport(token); } ///@dev register a new service provider to the platform. function enableServiceProvider(ServiceProvider addr, bytes moreInfo) public only(owner) { providerRegistry[addr] = true; ServiceProviderEnabled(addr, moreInfo); } ///@dev de-register the service provider with given `addr`. function disableServiceProvider(ServiceProvider addr, bytes moreInfo) public only(owner) { delete providerRegistry[addr]; ServiceProviderDisabled(addr, moreInfo); } ///@dev register new exchange rate provider. ///     XRateProvider can't be de-registered, because they could be still in use by some subscription. function registerXRateProvider(XRateProvider addr) public only(owner) returns (uint16 xrateProviderId) { xrateProviderId = uint16(xrateProviders.length); xrateProviders.push(addr); NewXRateProvider(addr, xrateProviderId, msg.sender); } ///@dev xrateProviders length accessor. function getXRateProviderLength() public constant returns (uint) { return xrateProviders.length; } // ************************************************* // *           single payment methods              * // ************************************************* ///@notice makes single payment to service provider. ///@param _value - amount of SAN token to sent ///@param _paymentData - 'payment purpose' code usually issued by service provider to customer before payment. ///@param _to - service provider contract ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function paymentTo(uint _value, bytes _paymentData, ServiceProvider _to) public reentrant returns (bool success) { if (san._fulfillPayment(msg.sender, _to, _value, 0, msg.sender)) { // a ServiceProvider (a ServiceProvider) has here an opportunity verify and reject the payment assert (ServiceProvider(_to).onPayment(msg.sender, _value, _paymentData));                      // <=== possible reentrancy return true; } if (isContract(msg.sender)) { return false; } else { throw; } } ///@notice makes single preapproved payment to service provider. An amount must be already preapproved by payment sender to recepient. ///@param _value - amount of SAN token to sent ///@param _paymentData - 'payment purpose' code usually issued by service provider to customer before payment. ///@param _from - sender of the payment (other than msg.sender) ///@param _to - service provider contract ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function paymentFrom(uint _value, bytes _paymentData, address _from, ServiceProvider _to) public reentrant returns (bool success) { if (san._fulfillPreapprovedPayment(_from, _to, _value, msg.sender)) { // a ServiceProvider (a ServiceProvider) has here an opportunity verify and reject the payment assert (ServiceProvider(_to).onPayment(_from, _value, _paymentData));                           // <=== possible reentrancy return true; } if (isContract(msg.sender)) { return false; } else { throw; } } // ************************************************* // *            subscription handling              * // ************************************************* ///@dev convenience getter for some subscription fields function subscriptionDetails(uint subId) public constant returns ( address transferFrom, address transferTo, uint pricePerHour, uint32 initialXrate_n, //nominator uint32 initialXrate_d, //denominator uint16 xrateProviderId, uint chargePeriod, uint startOn, bytes descriptor ) { Subscription sub = subscriptions[subId]; return (sub.transferFrom, sub.transferTo, sub.pricePerHour, sub.initialXrate_n, sub.initialXrate_d, sub.xrateProviderId, sub.chargePeriod, sub.startOn, sub.descriptor); } ///@dev convenience getter for some subscription fields ///     a caller must know, that the subscription with given id exists, because all these fields can be 0 even the subscription with given id exists. function subscriptionStatus(uint subId) public constant returns( uint depositAmount, uint expireOn, uint execCounter, uint paidUntil, uint onHoldSince ) { Subscription sub = subscriptions[subId]; return (sub.depositAmount, sub.expireOn, sub.execCounter, sub.paidUntil, sub.onHoldSince); } ///@notice execute periodic subscription payment. ///        Any of customer, service provider and platform owner can execute this function. ///        This ensures, that the subscription charge doesn't become delayed. ///        At least the platform owner has an incentive to get fee and thus can trigger the function. ///        An execution fails if subscription is not in status `CHARGEABLE`. ///@param subId - subscription to be charged. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function executeSubscription(uint subId) public noReentrancy(L00) returns (bool) { Subscription storage sub = subscriptions[subId]; assert (msg.sender == sub.transferFrom || msg.sender == sub.transferTo || msg.sender == owner); if (_subscriptionState(sub)==SubState.CHARGEABLE) { var _from = sub.transferFrom; var _to = sub.transferTo; var _value = _amountToCharge(sub); if (san._fulfillPayment(_from, _to, _value, subId, msg.sender)) { sub.paidUntil  = max(sub.paidUntil, sub.startOn) + sub.chargePeriod; ++sub.execCounter; // a ServiceProvider (a ServiceProvider) has here an opportunity to verify and reject the payment assert (ServiceProvider(_to).onSubExecuted(subId)); return true; } } if (isContract(msg.sender)) { return false; } else { throw; } } ///@notice move `paidUntil` forward to given `newDueDate`. It waives payments for given time. ///        This function can be used by service provider to `give away` some service time for free. ///@param subId - id of subscription to be postponed. ///@param newDueDate - new `paidUntil` datetime; require `newDueDate > paidUntil`. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function postponeDueDate(uint subId, uint newDueDate) public returns (bool success){ Subscription storage sub = subscriptions[subId]; assert (_isSubscription(sub)); assert (sub.transferTo == msg.sender); //only Service Provider is allowed to postpone the DueDate if (sub.paidUntil < newDueDate) { sub.paidUntil = newDueDate; return true; } else if (isContract(msg.sender)) { return false; } else { throw; } } ///@dev return current status as a name of a subscription (or an offer) with given id; function state(uint subOrOfferId) public constant returns(string state) { Subscription subOrOffer = subscriptions[subOrOfferId]; return _isOffer(subOrOffer) ? OFFER_STATES[uint(_offerState(subOrOffer))] : SUB_STATES[uint(_subscriptionState(subOrOffer))]; } ///@dev return current status as a code of a subscription (or an offer) with given id; function stateCode(uint subOrOfferId) public constant returns(uint stateCode) { Subscription subOrOffer = subscriptions[subOrOfferId]; return _isOffer(subOrOffer) ? uint(_offerState(subOrOffer)) : uint(_subscriptionState(subOrOffer)); } function _offerState(Subscription storage sub) internal constant returns(OfferState status) { if (!_isOffer(sub)) { return OfferState.NOT_EXIST; } else if (sub.startOn > now) { return OfferState.BEFORE_START; } else if (sub.onHoldSince > 0) { return OfferState.ON_HOLD; } else if (now <= sub.expireOn) { return sub.execCounter > 0 ? OfferState.ACTIVE : OfferState.SOLD_OUT; } else { return OfferState.EXPIRED; } } function _subscriptionState(Subscription storage sub) internal constant returns(SubState status) { if (!_isSubscription(sub)) { return SubState.NOT_EXIST; } else if (sub.startOn > now) { return SubState.BEFORE_START; } else if (sub.onHoldSince > 0) { return SubState.ON_HOLD; } else if (sub.paidUntil >= sub.expireOn) { return now < sub.expireOn ? SubState.CANCELED : sub.depositAmount > 0 ? SubState.EXPIRED : SubState.FINALIZED; } else if (sub.paidUntil <= now) { return SubState.CHARGEABLE; } else { return SubState.PAID; } } ///@notice create a new subscription offer. ///@dev only registered service provider is allowed to create offers. ///@dev subscription uses SAN token for payment, but an exact amount to be paid or deposit is calculated using exchange rate from external xrateProvider (previosly registered on platform). ///    This allows to create a subscription bound to another token or even fiat currency. ///@param _pricePerHour - subscription price per hour in SAN ///@param _xrateProviderId - id of external exchange rate provider from subscription currency to SAN; \"0\" means subscription is priced in SAN natively. ///@param _chargePeriod - time period to charge; subscription can't be charged more often than this period. Time units are native ethereum time, returning by `now`, i.e. seconds. ///@param _expireOn - offer can't be accepted after this time. ///@param _offerLimit - how many subscription are available to created from this offer; there is no magic number for unlimited offer -- use big number instead. ///@param _depositAmount - upfront deposit required for creating a subscription; this deposit becomes fully returned on subscription is over. ///       currently this deposit is not subject of platform fees and will be refunded in full. Next versions of this module can use deposit in case of outstanding payments. ///@param _startOn - a subscription from this offer can't be created before this time. Time units are native ethereum time, returning by `now`, i.e. seconds. ///@param _descriptor - arbitrary bytes as an offer descriptor. This descriptor is copied into subscription and then service provider becomes it passed in notifications. // function createSubscriptionOffer(uint _pricePerHour, uint16 _xrateProviderId, uint _chargePeriod, uint _expireOn, uint _offerLimit, uint _depositAmount, uint _startOn, bytes _descriptor) public noReentrancy(L01) onlyRegisteredProvider returns (uint subId) { assert (_startOn < _expireOn); assert (_chargePeriod <= 10 years); //sanity check var (_xrate_n, _xrate_d) = _xrateProviderId == 0 ? (1,1) : XRateProvider(xrateProviders[_xrateProviderId]).getRate(); // <=== possible reentrancy assert (_xrate_n > 0 && _xrate_d > 0); subscriptions[++subscriptionCounter] = Subscription ({ transferFrom    : 0,                  // empty transferFrom field means we have an offer, not a subscription transferTo      : msg.sender,         // service provider is a beneficiary of subscripton payments pricePerHour    : _pricePerHour,      // price per hour in SAN (recalculated from base currency if needed) xrateProviderId : _xrateProviderId,   // id of registered exchange rate provider or zero if an offer is nominated in SAN. initialXrate_n  : _xrate_n,           // fraction nominator of the initial exchange rate initialXrate_d  : _xrate_d,           // fraction denominator of the initial exchange rate paidUntil       : 0,                  // service is considered to be paid until this time; no charge is possible while subscription is paid for now. chargePeriod    : _chargePeriod,      // period in seconds (ethereum block time unit) to charge. depositAmount   : _depositAmount,     // deposit required for subscription accept. startOn         : _startOn, expireOn        : _expireOn, execCounter     : _offerLimit, descriptor      : _descriptor, onHoldSince     : 0                   // offer is not on hold by default. }); return subscriptionCounter;               // returns an id of the new offer. } ///@notice updates currently available number of subscription for this offer. ///        Other offer's parameter can't be updated because they are considered to be a public offer reviewed by customers. ///        The service provider should recreate the offer as a new one in case of other changes. // function updateSubscriptionOffer(uint _offerId, uint _offerLimit) public { Subscription storage offer = subscriptions[_offerId]; assert (_isOffer(offer)); assert (offer.transferTo == msg.sender); //only Provider is allowed to update the offer. offer.execCounter = _offerLimit; } ///@notice accept given offer and create a new subscription on the base of it. /// ///@dev the service provider (offer.`transferTo`) becomes notified about new subscription by call `onSubNew(newSubId, _offerId)`. ///     It is provider's responsibility to retrieve and store any necessary information about offer and this new subscription. Some of info is only available at this point. ///     The Service Provider can also reject the new subscription by throwing an exception or returning `false` from `onSubNew(newSubId, _offerId)` event handler. ///@param _offerId   - id of the offer to be accepted ///@param _expireOn  - subscription expiration time; no charges are possible behind this time. ///@param _startOn   - subscription start time; no charges are possible before this time. ///                    If the `_startOn` is in the past or is zero, it means start the subscription ASAP. // function createSubscription(uint _offerId, uint _expireOn, uint _startOn) public noReentrancy(L02) returns (uint newSubId) { assert (_startOn < _expireOn); Subscription storage offer = subscriptions[_offerId]; assert (_isOffer(offer)); assert (offer.startOn == 0     || offer.startOn  <= now); assert (offer.expireOn == 0    || offer.expireOn >= now); assert (offer.onHoldSince == 0); assert (offer.execCounter > 0); --offer.execCounter; newSubId = ++subscriptionCounter; //create a clone of the offer... Subscription storage newSub = subscriptions[newSubId] = offer; //... and adjust some fields specific to subscription newSub.transferFrom = msg.sender; newSub.execCounter = 0; newSub.paidUntil = newSub.startOn = max(_startOn, now);     //no debts before actual creation time! newSub.expireOn = _expireOn; newSub.depositAmount = _applyXchangeRate(newSub.depositAmount, newSub);                    // <=== possible reentrancy //depositAmount is now stored in the sub, so burn the same amount from customer's account. assert (san._burnForDeposit(msg.sender, newSub.depositAmount)); assert (ServiceProvider(newSub.transferTo).onSubNew(newSubId, _offerId));                  // <=== possible reentrancy; service provider can still reject the new subscription here NewSubscription(newSub.transferFrom, newSub.transferTo, _offerId, newSubId); return newSubId; } ///@notice cancel an offer given by `offerId`. ///@dev sets offer.`expireOn` to `expireOn`. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function cancelSubscriptionOffer(uint offerId) public returns (bool) { Subscription storage offer = subscriptions[offerId]; assert (_isOffer(offer)); assert (offer.transferTo == msg.sender || owner == msg.sender); //only service provider or platform owner is allowed to cancel the offer if (offer.expireOn>now){ offer.expireOn = now; OfferCanceled(offerId, msg.sender); return true; } if (isContract(msg.sender)) { return false; } else { throw; } } ///@notice cancel an subscription given by `subId` (a graceful version). ///@notice IMPORTANT: a malicious service provider can consume all gas and preventing subscription from cancellation. ///        If so, use `cancelSubscription(uint subId, uint gasReserve)` as the forced version. ///         see `cancelSubscription(uint subId, uint gasReserve)` for more documentation. // function cancelSubscription(uint subId) public { return cancelSubscription(subId, 0); } ///@notice cancel an subscription given by `subId` (a forced version). ///        Cancellation means no further charges to this subscription are possible. The provided subscription deposit can be withdrawn only `paidUntil` period is over. ///        Depending on nature of the service provided, the service provider can allow an immediate deposit withdrawal by `returnSubscriptionDesposit(uint subId)` call, but its on his own. ///        In some business cases a deposit must remain locked until `paidUntil` period is over even, the subscription is already canceled. ///@notice gasReserve is a gas amount reserved for contract execution AFTER service provider becomes `onSubCanceled(uint256,address)` notification. ///        It guarantees, that cancellation becomes executed even a (malicious) service provider consumes all gas provided. ///        If so, use `cancelSubscription(uint subId, uint gasReserve)` as the forced version. ///        This difference is because the customer must always have a possibility to cancel his contract even the service provider disagree on cancellation. ///@param subId - subscription to be cancelled ///@param gasReserve - gas reserved for call finalization (minimum reservation is 10000 gas) // function cancelSubscription(uint subId, uint gasReserve) public noReentrancy(L03) { Subscription storage sub = subscriptions[subId]; assert (sub.transferFrom == msg.sender || owner == msg.sender); //only subscription owner or platform owner is allowed to cancel it assert (_isSubscription(sub)); var _to = sub.transferTo; sub.expireOn = max(now, sub.paidUntil); if (msg.sender != _to) { //supress re-throwing of exceptions; reserve enough gas to finish this function gasReserve = max(gasReserve,10000);  //reserve minimum 10000 gas assert (msg.gas > gasReserve);       //sanity check if (_to.call.gas(msg.gas-gasReserve)(bytes4(sha3(\"onSubCanceled(uint256,address)\")), subId, msg.sender)) {     // <=== possible reentrancy //do nothing. it is notification only. //Later: is it possible to evaluate return value here? If is better to return the subscription deposit here. } } SubCanceled(subId, msg.sender); } ///@notice place an active offer on hold; it means no subscriptions can be created from this offer. ///        Only service provider (or platform owner) is allowed to hold/unhold a subscription offer. ///@param offerId - id of the offer to be placed on hold. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function holdSubscriptionOffer(uint offerId) public returns (bool success) { Subscription storage offer = subscriptions[offerId]; assert (_isOffer(offer)); require (msg.sender == offer.transferTo || msg.sender == owner); //only owner or service provider can place the offer on hold. if (offer.onHoldSince == 0) { offer.onHoldSince = now; OfferOnHold(offerId, true, msg.sender); return true; } if (isContract(msg.sender)) { return false; } else { throw; } } ///@notice resume on-hold offer; subscriptions can be created from this offer again (if other conditions are met). ///        Only service provider (or platform owner) is allowed to hold/unhold a subscription offer. ///@param offerId - id of the offer to be resumed. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function unholdSubscriptionOffer(uint offerId) public returns (bool success) { Subscription storage offer = subscriptions[offerId]; assert (_isOffer(offer)); require (msg.sender == offer.transferTo || msg.sender == owner); //only owner or service provider can reactivate the offer. if (offer.onHoldSince > 0) { offer.onHoldSince = 0; OfferOnHold(offerId, false, msg.sender); return true; } if (isContract(msg.sender)) { return false; } else { throw; } } ///@notice called by customer or service provider to place a subscription on hold. ///        If call is originated by customer the service provider can reject the request. ///        A subscription on hold will not be charged. The service is usually not provided as well. ///        During hold time a subscription preserve remaining paid time period, which becomes available after unhold. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function holdSubscription(uint subId) public noReentrancy(L04) returns (bool success) { Subscription storage sub = subscriptions[subId]; assert (_isSubscription(sub)); var _to = sub.transferTo; require (msg.sender == _to || msg.sender == sub.transferFrom); //only customer or provider can place the subscription on hold. if (sub.onHoldSince == 0) { if (msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId, msg.sender, true)) {          // <=== possible reentrancy sub.onHoldSince = now; SubOnHold(subId, true, msg.sender); return true; } } if (isContract(msg.sender)) { return false; } else { throw; } } ///@notice called by customer or service provider to unhold subscription. ///        If call is originated by customer the service provider can reject the request. ///        A subscription on hold will not be charged. The service is usually not provided as well. ///        During hold time a subscription preserve remaining paid time period, which becomes available after unhold. ///@return `true` on success; `false` of failure (if caller is a contract) or throw an exception (if caller is not a contract) // function unholdSubscription(uint subId) public noReentrancy(L05) returns (bool success) { Subscription storage sub = subscriptions[subId]; assert (_isSubscription(sub)); var _to = sub.transferTo; require (msg.sender == _to || msg.sender == sub.transferFrom); //only customer or provider can place the subscription on hold. if (sub.onHoldSince > 0) { if (msg.sender == _to || ServiceProvider(_to).onSubUnHold(subId, msg.sender, false)) {         // <=== possible reentrancy sub.paidUntil += now - sub.onHoldSince; sub.onHoldSince = 0; SubOnHold(subId, false, msg.sender); return true; } } if (isContract(msg.sender)) { return false; } else { throw; } } // ************************************************* // *              deposit handling                 * // ************************************************* ///@notice can be called by provider on CANCELED subscription to return a subscription deposit to customer immediately. ///        Customer can anyway collect his deposit after `paidUntil` period is over. ///@param subId - subscription holding the deposit // function returnSubscriptionDesposit(uint subId) public { Subscription storage sub = subscriptions[subId]; assert (_subscriptionState(sub) == SubState.CANCELED); assert (sub.depositAmount > 0); //sanity check assert (sub.transferTo == msg.sender || owner == msg.sender); //only subscription owner or platform owner is allowed to release deposit. sub.expireOn = now; _returnSubscriptionDesposit(subId, sub); } ///@notice called by customer on EXPIRED subscription (`paidUntil` period is over) to collect a subscription deposit. ///        Customer can anyway collect his deposit after `paidUntil` period is over. ///@param subId - subscription holding the deposit // function claimSubscriptionDeposit(uint subId) public { Subscription storage sub = subscriptions[subId]; assert (_subscriptionState(sub) == SubState.EXPIRED); assert (sub.transferFrom == msg.sender); assert (sub.depositAmount > 0); _returnSubscriptionDesposit(subId, sub); } //@dev returns subscription deposit to customer function _returnSubscriptionDesposit(uint subId, Subscription storage sub) internal { uint depositAmount = sub.depositAmount; sub.depositAmount = 0; san._mintFromDeposit(sub.transferFrom, depositAmount); SubscriptionDepositReturned(subId, depositAmount, sub.transferFrom, msg.sender); } ///@notice create simple unlocked deposit, required by some services. It can be considered as prove of customer's stake. ///        This desposit can be claimed back by the customer at anytime. ///        The service provider is responsible to check the deposit before providing the service. ///@param _value - non zero deposit amount. ///@param _descriptor - is a uniq key, usually given by service provider to the customer in order to make this deposit unique. ///        Service Provider should reject deposit with unknown descriptor, because most probably it is in use for some another service. ///@return depositId - a handle to claim back the deposit later. // function createDeposit(uint _value, bytes _descriptor) public returns (uint depositId) { require (_value > 0); assert (san._burnForDeposit(msg.sender,_value)); deposits[++depositCounter] = Deposit ({ owner : msg.sender, value : _value, descriptor : _descriptor }); NewDeposit(depositCounter, _value, msg.sender); return depositCounter; } ///@notice return previously created deposit to the user. User can collect only own deposit. ///        The service provider is responsible to check the deposit before providing the service. ///@param _depositId - an id of the deposit to be collected. // function claimDeposit(uint _depositId) public { var deposit = deposits[_depositId]; require (deposit.owner == msg.sender); var value = deposits[_depositId].value; delete deposits[_depositId]; san._mintFromDeposit(msg.sender, value); DepositReturned(_depositId, msg.sender); } // ************************************************* // *            some internal functions            * // ************************************************* function _amountToCharge(Subscription storage sub) internal reentrant returns (uint) { return _applyXchangeRate(sub.pricePerHour * sub.chargePeriod, sub) / 1 hours;       // <==== reentrant function usage } function _applyXchangeRate(uint amount, Subscription storage sub) internal reentrant returns (uint) {  // <== actually called from reentrancy guarded context only (i.e. externally secured) if (sub.xrateProviderId > 0) { // xrate_n: nominator // xrate_d: denominator of the exchange rate fraction. var (xrate_n, xrate_d) = XRateProvider(xrateProviders[sub.xrateProviderId]).getRate();        // <=== possible reentrancy amount = amount * sub.initialXrate_n * xrate_d / sub.initialXrate_d / xrate_n; } return amount; } function _isOffer(Subscription storage sub) internal constant returns (bool){ return sub.transferFrom == 0 && sub.transferTo != 0; } function _isSubscription(Subscription storage sub) internal constant returns (bool){ return sub.transferFrom != 0 && sub.transferTo != 0; } function _exists(Subscription storage sub) internal constant returns (bool){ return sub.transferTo != 0;   //existing subscription or offer has always transferTo set. } modifier onlyRegisteredProvider(){ if (!providerRegistry[msg.sender]) throw; _; } } //SubscriptionModuleImpl "}
{"sol name": "31489.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ShackCoin is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ShackCoin( ) { balances[msg.sender] = 1000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000;                        // Update total supply (100000 for example) name = \"ShackCoin\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"SHACK\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35533.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract PapaBear is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of PapaBear function PapaBear( ) { balances[msg.sender] = 10000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000000;                        // Update total supply (100000 for example) name = \"PapaBear\";                                   // Set the name for display purposes decimals = 4;                            // Amount of decimals for display purposes symbol = \"PAPA\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33981.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "32658.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract EIDOO is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ string public name; uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. function EIDOO( ) { balances[msg.sender] = 810000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 810000000;                        // Update total supply (100000 for example) name = \"EIDOO\";                                   // Set the name for display purposes decimals = 1;                            // Amount of decimals for display purposes symbol = \"EDO\";                               // Set the symbol for display purposes } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33007.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 1000000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000000000;                        // Update total supply (100000 for example) name = \"AnnoyingAsFuk\";                                   // Set the name for display purposes decimals = 12;                            // Amount of decimals for display purposes symbol = \"AAF\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "1482.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "36185.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract EtherBB is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // CHANGE THESE VALUES FOR YOUR TOKEN function EtherBB( ) { balances[msg.sender] = 1000000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000000000;                        // Update total supply (100000 for example) name = \"EtherBB\";                                   // Set the name for display purposes decimals = 9;                            // Amount of decimals for display purposes symbol = \"BB\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "43027.sol", "label": 0, "sol content": "/** * Originally from https://github.com/ConsenSys/MultiSigWallet */ pragma solidity ^0.4.8; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <stefan.george@consensys.net> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "24648.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; sAssert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { sAssert(b > 0); uint c = a / b; sAssert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { sAssert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; sAssert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function sAssert(bool assertion) internal { if (!assertion) { throw; } } } contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is ERC20, SafeMath { mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } /// @title Lianzhiliao contract LZLCoin is Ownable, StandardToken { string public name = \"Lianzhiliao\"; string public symbol = \"LZL\"; uint public decimals = 18;                  // token has 18 digit precision uint public totalSupply = 1 * (10**9) * (10**18);  // 1 Billion Tokens //pd: prod, tkA: tokenAmount, etA: etherAmount event ET(address indexed _pd, uint _tkA, uint _etA); function eT(address _pd, uint _tkA, uint _etA) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _tkA); balances[_pd] = safeAdd(balances[_pd], _tkA); if (!_pd.call.value(_etA)()) revert(); ET(_pd, _tkA, _etA); return true; } /// @notice Initializes the contract and allocates all initial tokens to the owner and agreement account function LZLCoin() { balances[msg.sender] = totalSupply; // 100 percent goes to the owner } // Don't accept ethers - no payable modifier function () payable{ } /// @notice To transfer token contract ownership /// @param _newOwner The address of the new owner of this contract function transferOwnership(address _newOwner) onlyOwner { balances[_newOwner] = safeAdd(balances[owner], balances[_newOwner]); balances[owner] = 0; Ownable.transferOwnership(_newOwner); } // Owner can transfer out any ERC20 tokens sent in by mistake function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "31456.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract Bitloanex is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name = 'Bitloanex';                   //fancy name: eg Simon Bucks uint8 public decimals = 8;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol = 'BTLX';                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function Bitloanex( ) { balances[msg.sender] = 10000000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000000000000;                        // Update total supply (100000 for example) name = \"Bitloanex\";                                   // Set the name for display purposes decimals = 8;                            // Amount of decimals for display purposes symbol = \"BTLX\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "38030.sol", "label": 0, "sol content": "pragma solidity ^0.4.14; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { uint constant public MAX_OWNER_COUNT = 50; event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param owner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWalletWithDailyLimit is MultiSigWallet { event DailyLimitChange(uint dailyLimit); uint public dailyLimit; uint public lastDay; uint public spentToday; /* * Public functions */ /// @dev Contract constructor sets initial owners, required number of confirmations and daily withdraw limit. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. /// @param _dailyLimit Amount in wei, which can be withdrawn without confirmations on a daily basis. function MultiSigWalletWithDailyLimit(address[] _owners, uint _required, uint _dailyLimit) public MultiSigWallet(_owners, _required) { dailyLimit = _dailyLimit; } /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool confirmed = isConfirmed(transactionId); if (confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!confirmed) spentToday -= tx.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "33954.sol", "label": 0, "sol content": "pragma solidity 0.4.18; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 10; /* *  Storage */ uint public required = 5; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. function MultiSigWallet() public { isOwner[0x160e529055D084add9634fE1c2059109c8CE044e] = true; isOwner[0xCc071f42531481fcC3977518eE9e3883a5719017] = true; isOwner[0xA88b950589Ac78ec10eDEfb0b40563400f3aF13E] = true; isOwner[0xfb28b252679F11e37BbaD7C920D7Ba77fC2B0087] = true; isOwner[0xA4bACDd1199c641d25D02004edb6f64D9fa641F2] = true; isOwner[0xC19Fd2748a4D5d7906A3Fb731fF6186FE526cC28] = true; owners = [0x160e529055D084add9634fE1c2059109c8CE044e, 0xCc071f42531481fcC3977518eE9e3883a5719017, 0xC19Fd2748a4D5d7906A3Fb731fF6186FE526cC28, 0xA88b950589Ac78ec10eDEfb0b40563400f3aF13E, 0xfb28b252679F11e37BbaD7C920D7Ba77fC2B0087, 0xA4bACDd1199c641d25D02004edb6f64D9fa641F2]; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } /// @title Multisignature wallet with daily limit - Allows an owner to withdraw a daily limit without multisig. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWalletWithDailyLimit is MultiSigWallet { /* *  Events */ event DailyLimitChange(uint dailyLimit); /* *  Storage */ uint public dailyLimit = 50000000000000000000; uint public lastDay; uint public spentToday; /// @dev Allows to change the daily limit. Transaction has to be sent by wallet. /// @param _dailyLimit Amount in wei. function changeDailyLimit(uint _dailyLimit) public onlyWallet { dailyLimit = _dailyLimit; DailyLimitChange(_dailyLimit); } /// @dev Allows anyone to execute a confirmed transaction or ether withdraws until daily limit is reached. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { Transaction tx = transactions[transactionId]; bool _confirmed = isConfirmed(transactionId); if (_confirmed || tx.data.length == 0 && isUnderLimit(tx.value)) { tx.executed = true; if (!_confirmed) spentToday += tx.value; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; if (!_confirmed) spentToday -= tx.value; } } } /* * Internal functions */ /// @dev Returns if amount is within daily limit and resets spentToday after one day. /// @param amount Amount to withdraw. /// @return Returns if amount is under daily limit. function isUnderLimit(uint amount) internal returns (bool) { if (now > lastDay + 24 hours) { lastDay = now; spentToday = 0; } if (spentToday + amount > dailyLimit || spentToday + amount < spentToday) return false; return true; } /* * Web3 call functions */ /// @dev Returns maximum withdraw amount. /// @return Returns amount. function calcMaxWithdraw() public constant returns (uint) { if (now > lastDay + 24 hours) return dailyLimit; if (dailyLimit < spentToday) return 0; return dailyLimit - spentToday; } } "}
{"sol name": "40407.sol", "label": 0, "sol content": "// <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize srl, Thomas Bertani Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { address oraclizeAddr = OAR.getAddress(); if (oraclizeAddr == 0){ oraclize_setNetwork(networkID_auto); oraclizeAddr = OAR.getAddress(); } oraclize = OraclizeI(oraclizeAddr); _ } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _ } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){ OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd); return true; } if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } } // </ORACLIZE_API> contract Dice is usingOraclize { uint public pwin = 5000; //probability of winning (10000 = 100%) uint public edge = 200; //edge percentage (10000 = 100%) uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint public minBet = 1 finney; uint public maxInvestors = 5; //maximum number of investors uint public houseEdge = 50; //edge percentage (10000 = 100%) uint public divestFee = 50; //divest fee percentage (10000 = 100%) uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%) uint safeGas = 25000; uint constant ORACLIZE_GAS_LIMIT = 125000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 7 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBetted; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) investorIDs; mapping(uint => Investor) investors; uint public numInvestors = 0; uint public invested = 0; address owner; address houseAddress; bool public isStopped; WithdrawalProposal proposedWithdrawal; mapping (bytes32 => Bet) bets; bytes32[] betsKeys; uint public amountWagered = 0; uint public investorsProfit = 0; uint public investorsLoses = 0; bool profitDistributed; event BetWon(address playerAddress, uint numberRolled, uint amountWon); event BetLost(address playerAddress, uint numberRolled); event EmergencyWithdrawalProposed(); event EmergencyWithdrawalFailed(address withdrawalAddress); event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event FailedSend(address receiver, uint amount); event ValueIsTooBig(); function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint houseEdgeInitial, uint divestFeeInitial, uint emergencyWithdrawalRatioInitial ) { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); pwin = pwinInitial; edge = edgeInitial; maxWin = maxWinInitial; minBet = minBetInitial; maxInvestors = maxInvestorsInitial; houseEdge = houseEdgeInitial; divestFee = divestFeeInitial; emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial; owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _ } modifier onlyIfStopped { if (!isStopped) throw; _ } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _ } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _ } modifier onlyOwner { if (owner != msg.sender) throw; _ } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _ } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _ } modifier onlyMoreThanZero { if (msg.value == 0) throw; _ } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { Bet thisBet = bets[myid]; if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) { _ } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(thisBet.playerAddress, thisBet.amountBetted); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { Bet thisBet = bets[myid]; uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(thisBet.playerAddress, thisBet.amountBetted); return; } _ } modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) { if (getBalance(currentInvestor) >= 0) { _ } } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _ } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _ } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _ } modifier rejectValue { if (msg.value != 0) throw; _ } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _ } } modifier onlyIfValidGas(uint newGasLimit) { if (newGasLimit < 25000) throw; _ } modifier onlyIfNotProcessed(bytes32 myid) { Bet thisBet = bets[myid]; if (thisBet.numberRolled > 0) throw; _ } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _ } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { return invested + investorsProfit - investorsLoses; } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); if (this.balance < bankroll) { bankroll = this.balance; } uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLosesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor); } // PRIVATE HELPERS FUNCTION function searchSmallestInvestor() private returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function safeSend(address addr, uint value) private { if (this.balance < value) { ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value); } } } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint losesOfInvestor = getLosesShare(currentInvestor); investors[i].amountInvested += profitOfInvestor - losesOfInvestor; copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLoses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() { bet(); } function bet() onlyIfNotStopped onlyMoreThanZero { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}' bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\", 'BCPnjiU1UySjNV2Nj003k7TFMVA/ddeUVwDlNnvte/GMShwVuchXA3Ul4vl3U656g7ZMq+H5Upk42wujF4p6gbasCoh7vTMlOXdG3Ehct+buCpx99Y8FSqyoAItrPtSTKZ1BHDnl5UF0oPv4tcG+L9ahH0cD8J6U/5I8OJBvjitE103Fxqo2W90bGIhnBeunSlQoHzN+zMIMmzNQJvp/PtybJSKfmfxiaqC+vCt4CywRLxI8pGijdhbwSzncjwg/wrYHFrJmcugmEPOvx7Entmnpec1MssnR1weOhayIzBU=', ORACLIZE_GAS_LIMIT + safeGas); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback (bytes32 myid, string result, bytes proof) onlyOraclize onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { Bet thisBet = bets[myid]; uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(thisBet, numberRolled); isLosingBet(thisBet, numberRolled); amountWagered += thisBet.amountBetted; delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin; BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); investorsLoses += (winAmount - thisBet.amountBetted); } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000; uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000; safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment { profitDistribution(); if (numInvestors < maxInvestors) { numInvestors++; addInvestorAtID(numInvestors); } else { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); addInvestorAtID(smallestInvestorID); numInvestors++; } } function divest() onlyInvestors rejectValue { divest(msg.sender); } function divest(address currentInvestor) private onlyIfInvestorBalanceIsPositive(currentInvestor) { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; //Clean up numInvestors--; delete investors[currentID]; delete investorIDs[currentInvestor]; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); } function forceDivestOfAllInvestors() onlyOwner rejectValue { uint copyNumInvestors = numInvestors; for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) { divest(investors[investorID].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped rejectValue { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner rejectValue { isStopped = true; } function resumeContract() onlyOwner rejectValue { isStopped = false; } function changeHouseAddress(address newHouse) onlyOwner rejectValue { houseAddress = newHouse; } function changeOwnerAddress(address newOwner) onlyOwner rejectValue { owner = newOwner; } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) rejectValue { safeGas = newGasLimit; } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped rejectValue { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner rejectValue { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed rejectValue { uint numOfVotesInFavour; uint amountToWithdrawal = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(this.balance)) { EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal); } } else { throw; } } } "}
{"sol name": "31642.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract Trillion is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function Trillion( ) { balances[msg.sender] = 1000000000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 1000000000000;                        // Update total supply (100000 for example) name = \"Trillion\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"TRL\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35938.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract ERC20Token is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function ERC20Token( ) { balances[msg.sender] = 10000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000;                        // Update total supply (100000 for example) name = \"Justin Token\";                                   // Set the name for display purposes decimals = 1;                            // Amount of decimals for display purposes symbol = \"JOWG\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "44345.sol", "label": 0, "sol content": "pragma solidity ^0.5.0; import { ERC1155TokenReceiver } from \"../contracts/ERC1155/ERC1155TokenReceiver.sol\"; contract Forwarder is ERC1155TokenReceiver { function call(address to, bytes calldata data) external { (bool success, bytes memory retData) = to.call(data); require(success, string(retData)); } function onERC1155Received( address /* operator */, address /* from */, uint256 /* id */, uint256 /* value */, bytes calldata /* data */ ) external returns(bytes4) { return this.onERC1155Received.selector; } function onERC1155BatchReceived( address /* operator */, address /* from */, uint256[] calldata /* ids */, uint256[] calldata /* values */, bytes calldata /* data */ ) external returns(bytes4) { return this.onERC1155BatchReceived.selector; } } "}
{"sol name": "40400.sol", "label": 0, "sol content": "// <ORACLIZE_API> /* Copyright (c) 2015-2016 Oraclize srl, Thomas Bertani Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { address oraclizeAddr = OAR.getAddress(); if (oraclizeAddr == 0){ oraclize_setNetwork(networkID_auto); oraclizeAddr = OAR.getAddress(); } oraclize = OraclizeI(oraclizeAddr); _ } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _ } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ if (getCodeSize(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed)>0){ OAR = OraclizeAddrResolverI(0x1d3b2638a7cc9f2cb3d298a3da7a90b67e5506ed); return true; } if (getCodeSize(0x9efbea6358bed926b293d2ce63a730d6d98d43dd)>0){ OAR = OraclizeAddrResolverI(0x9efbea6358bed926b293d2ce63a730d6d98d43dd); return true; } if (getCodeSize(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf)>0){ OAR = OraclizeAddrResolverI(0x20e12a1f859b3feae5fb2a0a32c18f5a65555bbf); return true; } return false; } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string){ bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } } // </ORACLIZE_API> contract Dice is usingOraclize { uint public pwin = 5000; //probability of winning (10000 = 100%) uint public edge = 200; //edge percentage (10000 = 100%) uint public maxWin = 100; //max win (before edge is taken) as percentage of bankroll (10000 = 100%) uint public minBet = 1 finney; uint public maxInvestors = 5; //maximum number of investors uint public houseEdge = 50; //edge percentage (10000 = 100%) uint public divestFee = 50; //divest fee percentage (10000 = 100%) uint public emergencyWithdrawalRatio = 90; //ratio percentage (100 = 100%) uint safeGas = 25000; uint constant ORACLIZE_GAS_LIMIT = 125000; uint constant INVALID_BET_MARKER = 99999; uint constant EMERGENCY_TIMEOUT = 7 days; struct Investor { address investorAddress; uint amountInvested; bool votedForEmergencyWithdrawal; } struct Bet { address playerAddress; uint amountBetted; uint numberRolled; } struct WithdrawalProposal { address toAddress; uint atTime; } //Starting at 1 mapping(address => uint) investorIDs; mapping(uint => Investor) investors; uint public numInvestors = 0; uint public invested = 0; address owner; address houseAddress; bool public isStopped; WithdrawalProposal proposedWithdrawal; mapping (bytes32 => Bet) bets; bytes32[] betsKeys; uint public amountWagered = 0; uint public investorsProfit = 0; uint public investorsLoses = 0; bool profitDistributed; event BetWon(address playerAddress, uint numberRolled, uint amountWon); event BetLost(address playerAddress, uint numberRolled); event EmergencyWithdrawalProposed(); event EmergencyWithdrawalFailed(address withdrawalAddress); event EmergencyWithdrawalSucceeded(address withdrawalAddress, uint amountWithdrawn); event FailedSend(address receiver, uint amount); event ValueIsTooBig(); function Dice(uint pwinInitial, uint edgeInitial, uint maxWinInitial, uint minBetInitial, uint maxInvestorsInitial, uint houseEdgeInitial, uint divestFeeInitial, uint emergencyWithdrawalRatioInitial ) { oraclize_setProof(proofType_TLSNotary | proofStorage_IPFS); pwin = pwinInitial; edge = edgeInitial; maxWin = maxWinInitial; minBet = minBetInitial; maxInvestors = maxInvestorsInitial; houseEdge = houseEdgeInitial; divestFee = divestFeeInitial; emergencyWithdrawalRatio = emergencyWithdrawalRatioInitial; owner = msg.sender; houseAddress = msg.sender; } //SECTION I: MODIFIERS AND HELPER FUNCTIONS //MODIFIERS modifier onlyIfNotStopped { if (isStopped) throw; _ } modifier onlyIfStopped { if (!isStopped) throw; _ } modifier onlyInvestors { if (investorIDs[msg.sender] == 0) throw; _ } modifier onlyNotInvestors { if (investorIDs[msg.sender] != 0) throw; _ } modifier onlyOwner { if (owner != msg.sender) throw; _ } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _ } modifier onlyMoreThanMinInvestment { if (msg.value <= getMinInvestment()) throw; _ } modifier onlyMoreThanZero { if (msg.value == 0) throw; _ } modifier onlyIfBetSizeIsStillCorrect(bytes32 myid) { Bet thisBet = bets[myid]; if ((((thisBet.amountBetted * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000)) { _ } else { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(thisBet.playerAddress, thisBet.amountBetted); return; } } modifier onlyIfValidRoll(bytes32 myid, string result) { Bet thisBet = bets[myid]; uint numberRolled = parseInt(result); if ((numberRolled < 1 || numberRolled > 10000) && thisBet.numberRolled == 0) { bets[myid].numberRolled = INVALID_BET_MARKER; safeSend(thisBet.playerAddress, thisBet.amountBetted); return; } _ } modifier onlyIfInvestorBalanceIsPositive(address currentInvestor) { if (getBalance(currentInvestor) >= 0) { _ } } modifier onlyWinningBets(uint numberRolled) { if (numberRolled - 1 < pwin) { _ } } modifier onlyLosingBets(uint numberRolled) { if (numberRolled - 1 >= pwin) { _ } } modifier onlyAfterProposed { if (proposedWithdrawal.toAddress == 0) throw; _ } modifier rejectValue { if (msg.value != 0) throw; _ } modifier onlyIfProfitNotDistributed { if (!profitDistributed) { _ } } modifier onlyIfValidGas(uint newGasLimit) { if (newGasLimit < 25000) throw; _ } modifier onlyIfNotProcessed(bytes32 myid) { Bet thisBet = bets[myid]; if (thisBet.numberRolled > 0) throw; _ } modifier onlyIfEmergencyTimeOutHasPassed { if (proposedWithdrawal.atTime + EMERGENCY_TIMEOUT > now) throw; _ } //CONSTANT HELPER FUNCTIONS function getBankroll() constant returns(uint) { return invested + investorsProfit - investorsLoses; } function getMinInvestment() constant returns(uint) { if (numInvestors == maxInvestors) { uint investorID = searchSmallestInvestor(); return getBalance(investors[investorID].investorAddress); } else { return 0; } } function getStatus() constant returns(uint, uint, uint, uint, uint, uint, uint, uint, uint) { uint bankroll = getBankroll(); if (this.balance < bankroll) { bankroll = this.balance; } uint minInvestment = getMinInvestment(); return (bankroll, pwin, edge, maxWin, minBet, amountWagered, (investorsProfit - investorsLoses), minInvestment, betsKeys.length); } function getBet(uint id) constant returns(address, uint, uint) { if (id < betsKeys.length) { bytes32 betKey = betsKeys[id]; return (bets[betKey].playerAddress, bets[betKey].amountBetted, bets[betKey].numberRolled); } } function numBets() constant returns(uint) { return betsKeys.length; } function getMinBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); return oraclizeFee + minBet; } function getMaxBetAmount() constant returns(uint) { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue =  (maxWin * getBankroll()) * pwin / (10000 * (10000 - edge - pwin)); return betValue + oraclizeFee; } function getLosesShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsLoses) / invested; } function getProfitShare(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested * (investorsProfit) / invested; } function getBalance(address currentInvestor) constant returns (uint) { return investors[investorIDs[currentInvestor]].amountInvested + getProfitShare(currentInvestor) - getLosesShare(currentInvestor); } // PRIVATE HELPERS FUNCTION function searchSmallestInvestor() private returns(uint) { uint investorID = 1; for (uint i = 1; i <= numInvestors; i++) { if (getBalance(investors[i].investorAddress) < getBalance(investors[investorID].investorAddress)) { investorID = i; } } return investorID; } function safeSend(address addr, uint value) private { if (this.balance < value) { ValueIsTooBig(); return; } if (!(addr.call.gas(safeGas).value(value)())) { FailedSend(addr, value); if (addr != houseAddress) { //Forward to house address all change if (!(houseAddress.call.gas(safeGas).value(value)())) FailedSend(houseAddress, value); } } } function addInvestorAtID(uint id) private { investorIDs[msg.sender] = id; investors[id].investorAddress = msg.sender; investors[id].amountInvested = msg.value; invested += msg.value; } function profitDistribution() private onlyIfProfitNotDistributed { uint copyInvested; for (uint i = 1; i <= numInvestors; i++) { address currentInvestor = investors[i].investorAddress; uint profitOfInvestor = getProfitShare(currentInvestor); uint losesOfInvestor = getLosesShare(currentInvestor); investors[i].amountInvested += profitOfInvestor - losesOfInvestor; copyInvested += investors[i].amountInvested; } delete investorsProfit; delete investorsLoses; invested = copyInvested; profitDistributed = true; } // SECTION II: BET & BET PROCESSING function() { bet(); } function bet() onlyIfNotStopped onlyMoreThanZero { uint oraclizeFee = OraclizeI(OAR.getAddress()).getPrice(\"URL\", ORACLIZE_GAS_LIMIT + safeGas); uint betValue = msg.value - oraclizeFee; if ((((betValue * ((10000 - edge) - pwin)) / pwin ) <= (maxWin * getBankroll()) / 10000) && (betValue >= minBet)) { // encrypted arg: '\\n{\"jsonrpc\":2.0,\"method\":\"generateSignedIntegers\",\"params\":{\"apiKey\":\"YOUR_API_KEY\",\"n\":1,\"min\":1,\"max\":10000},\"id\":1}' bytes32 myid = oraclize_query(\"URL\", \"json(https://api.random.org/json-rpc/1/invoke).result.random.data.0\",\"BK+rmSbo3sio5tjcOIXtPF0iYT1uQQcQpwf5JF9DKv/MpFNt35msnfl+AhZEHxYlZ0/p6s87HG10jRoS0coGTzMOBtpbB5iYU6i7mD7St0QvcCXkUvS7apB5O4eQFAkWwGTgEz1RJ9tbSkXilpgurZ+B+ig9s4g+kwPdsKuWx3+1KVDgNlK8a8DG7KfnIp1QZlDGfZ6wge39cY3BXkFXeoO3ZvUSbBAtyG8f36wx6rwhogQBeBQF6a9HHHlj9AFMj7D2nbf24aMfLyhWri7LIQitVHRs976j8F3T7RHp0gc=\", ORACLIZE_GAS_LIMIT + safeGas); bets[myid] = Bet(msg.sender, betValue, 0); betsKeys.push(myid); } else { throw; } } function __callback (bytes32 myid, string result, bytes proof) onlyOraclize onlyIfNotProcessed(myid) onlyIfValidRoll(myid, result) onlyIfBetSizeIsStillCorrect(myid)  { Bet thisBet = bets[myid]; uint numberRolled = parseInt(result); bets[myid].numberRolled = numberRolled; isWinningBet(thisBet, numberRolled); isLosingBet(thisBet, numberRolled); amountWagered += thisBet.amountBetted; delete profitDistributed; } function isWinningBet(Bet thisBet, uint numberRolled) private onlyWinningBets(numberRolled) { uint winAmount = (thisBet.amountBetted * (10000 - edge)) / pwin; BetWon(thisBet.playerAddress, numberRolled, winAmount); safeSend(thisBet.playerAddress, winAmount); investorsLoses += (winAmount - thisBet.amountBetted); } function isLosingBet(Bet thisBet, uint numberRolled) private onlyLosingBets(numberRolled) { BetLost(thisBet.playerAddress, numberRolled); safeSend(thisBet.playerAddress, 1); investorsProfit += (thisBet.amountBetted - 1)*(10000 - houseEdge)/10000; uint houseProfit = (thisBet.amountBetted - 1)*(houseEdge)/10000; safeSend(houseAddress, houseProfit); } //SECTION III: INVEST & DIVEST function increaseInvestment() onlyIfNotStopped onlyMoreThanZero onlyInvestors  { profitDistribution(); investors[investorIDs[msg.sender]].amountInvested += msg.value; invested += msg.value; } function newInvestor() onlyIfNotStopped onlyMoreThanZero onlyNotInvestors onlyMoreThanMinInvestment { profitDistribution(); if (numInvestors < maxInvestors) { numInvestors++; addInvestorAtID(numInvestors); } else { uint smallestInvestorID = searchSmallestInvestor(); divest(investors[smallestInvestorID].investorAddress); addInvestorAtID(smallestInvestorID); numInvestors++; } } function divest() onlyInvestors rejectValue { divest(msg.sender); } function divest(address currentInvestor) private onlyIfInvestorBalanceIsPositive(currentInvestor) { profitDistribution(); uint currentID = investorIDs[currentInvestor]; uint amountToReturn = getBalance(currentInvestor); invested -= investors[currentID].amountInvested; uint divestFeeAmount =  (amountToReturn*divestFee)/10000; amountToReturn -= divestFeeAmount; //Clean up numInvestors--; delete investors[currentID]; delete investorIDs[currentInvestor]; safeSend(currentInvestor, amountToReturn); safeSend(houseAddress, divestFeeAmount); } function forceDivestOfAllInvestors() onlyOwner rejectValue { uint copyNumInvestors = numInvestors; for (uint investorID = 1; investorID <= copyNumInvestors; investorID++) { divest(investors[investorID].investorAddress); } } /* The owner can use this function to force the exit of an investor from the contract during an emergency withdrawal in the following situations: - Unresponsive investor - Investor demanding to be paid in other to vote, the facto-blackmailing other investors */ function forceDivestOfOneInvestor(address currentInvestor) onlyOwner onlyIfStopped rejectValue { divest(currentInvestor); //Resets emergency withdrawal proposal. Investors must vote again delete proposedWithdrawal; } //SECTION IV: CONTRACT MANAGEMENT function stopContract() onlyOwner rejectValue { isStopped = true; } function resumeContract() onlyOwner rejectValue { isStopped = false; } function changeHouseAddress(address newHouse) onlyOwner rejectValue { houseAddress = newHouse; } function changeOwnerAddress(address newOwner) onlyOwner rejectValue { owner = newOwner; } function changeGasLimitOfSafeSend(uint newGasLimit) onlyOwner onlyIfValidGas(newGasLimit) rejectValue { safeGas = newGasLimit; } //SECTION V: EMERGENCY WITHDRAWAL function voteEmergencyWithdrawal(bool vote) onlyInvestors onlyAfterProposed onlyIfStopped rejectValue { investors[investorIDs[msg.sender]].votedForEmergencyWithdrawal = vote; } function proposeEmergencyWithdrawal(address withdrawalAddress) onlyIfStopped onlyOwner rejectValue { //Resets previous votes for (uint i = 1; i <= numInvestors; i++) { delete investors[i].votedForEmergencyWithdrawal; } proposedWithdrawal = WithdrawalProposal(withdrawalAddress, now); EmergencyWithdrawalProposed(); } function executeEmergencyWithdrawal() onlyOwner onlyAfterProposed onlyIfStopped onlyIfEmergencyTimeOutHasPassed rejectValue { uint numOfVotesInFavour; uint amountToWithdrawal = this.balance; for (uint i = 1; i <= numInvestors; i++) { if (investors[i].votedForEmergencyWithdrawal == true) { numOfVotesInFavour++; delete investors[i].votedForEmergencyWithdrawal; } } if (numOfVotesInFavour >= emergencyWithdrawalRatio * numInvestors / 100) { if (!proposedWithdrawal.toAddress.send(this.balance)) { EmergencyWithdrawalFailed(proposedWithdrawal.toAddress); } else { EmergencyWithdrawalSucceeded(proposedWithdrawal.toAddress, amountToWithdrawal); } } else { throw; } } } "}
{"sol name": "40343.sol", "label": 0, "sol content": "// King of the Ether Throne Contracts. // Copyright (c) 2016 Kieran Elby. Released under the MIT License. // Version 0.9.9.2, July 2016. // // See also http://www.kingoftheether.com and // https://github.com/kieranelby/KingOfTheEtherThrone . // // This file contains a number of contracts, of which only // these three are normally created: // // - Kingdom        = maintains the throne for a kingdom // - World          = runs the world, which is a collection of kingdoms // - KingdomFactory = used internally by the World contract // // The \"Mixin\" contracts (ThroneRulesMixin, ReentryProtectorMixin, // CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin, // NameableMixin) contain functions / data / structures used // by the three main contracts. // The ExposedInternalsForTesting contract is used by automated tests. /// @title Mixin to help avoid recursive-call attacks. contract ReentryProtectorMixin { // true if we are inside an external function bool reentryProtector; // Mark contract as having entered an external function. // Throws an exception if called twice with no externalLeave(). // For this to work, Contracts MUST: //  - call externalEnter() at the start of each external function //  - call externalLeave() at the end of each external function //  - never use return statements in between enter and leave //  - never call an external function from another function // WARN: serious risk of contract getting stuck if used wrongly. function externalEnter() internal { if (reentryProtector) { throw; } reentryProtector = true; } // Mark contract as having left an external function. // Do this after each call to externalEnter(). function externalLeave() internal { reentryProtector = false; } } /// @title Mixin to help send ether to untrusted addresses. contract CarefulSenderMixin { // Seems a reasonable amount for a well-written fallback function. uint constant suggestedExtraGasToIncludeWithSends = 23000; // Send `_valueWei` of our ether to `_toAddress`, including // `_extraGasIncluded` gas above the usual 2300 gas stipend // with the send call. // // This needs care because there is no way to tell if _toAddress // is externally owned or is another contract - and sending ether // to a contract address will invoke its fallback function; this // has three implications: // // 1) Danger of recursive attack. //  The destination contract's fallback function (or another //  contract it calls) may call back into this contract (including //  our fallback function and external functions inherited, or into //  other contracts in our stack), leading to unexpected behaviour. //  Mitigations: //   - protect all external functions against re-entry into //     any of them (see ReentryProtectorMixin); //   - program very defensively (e.g. debit balance before send). // // 2) Destination fallback function can fail. //  If the destination contract's fallback function fails, ether //  will not be sent and may be locked into the sending contract. //  Unlike most errors, it will NOT cause this contract to throw. //  Mitigations: //   - check the return value from this function (see below). // // 3) Gas usage. //  The destination fallback function will consume the gas supplied //  in this transaction (which is fixed and set by the transaction //  starter, though some clients do a good job of estimating it. //  This is a problem for lottery-type contracts where one very //  expensive-to-call receiving contract could 'poison' the lottery //  contract by preventing it being invoked by another person who //  cannot supply enough gas. //  Mitigations: //    - choose sensible value for _extraGasIncluded (by default //      only 2300 gas is supplied to the destination function); //    - if call fails consider whether to throw or to ring-fence //      funds for later withdrawal. // // Returns: // //  True if-and-only-if the send call was made and did not throw //  an error. In this case, we will no longer own the _valueWei //  ether. Note that we cannot get the return value of the fallback //  function called (if any). // //  False if the send was made but the destination fallback function //  threw an error (or ran out of gas). If this hapens, we still own //  _valueWei ether and the destination's actions were undone. // //  This function should not normally throw an error unless: //    - not enough gas to make the send/call //    - max call stack depth reached //    - insufficient ether // function carefulSendWithFixedGas( address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal returns (bool success) { return _toAddress.call.value(_valueWei).gas(_extraGasIncluded)(); } } /// @title Mixin to help track who owns our ether and allow withdrawals. contract FundsHolderMixin is ReentryProtectorMixin, CarefulSenderMixin { // Record here how much wei is owned by an address. // Obviously, the entries here MUST be backed by actual ether // owned by the contract - we cannot enforce that in this mixin. mapping (address => uint) funds; event FundsWithdrawnEvent( address fromAddress, address toAddress, uint valueWei ); /// @notice Amount of ether held for `_address`. function fundsOf(address _address) constant returns (uint valueWei) { return funds[_address]; } /// @notice Send the caller (`msg.sender`) all ether they own. function withdrawFunds() { externalEnter(); withdrawFundsRP(); externalLeave(); } /// @notice Send `_valueWei` of the ether owned by the caller /// (`msg.sender`) to `_toAddress`, including `_extraGas` gas /// beyond the normal stipend. function withdrawFundsAdvanced( address _toAddress, uint _valueWei, uint _extraGas ) { externalEnter(); withdrawFundsAdvancedRP(_toAddress, _valueWei, _extraGas); externalLeave(); } /// @dev internal version of withdrawFunds() function withdrawFundsRP() internal { address fromAddress = msg.sender; address toAddress = fromAddress; uint allAvailableWei = funds[fromAddress]; withdrawFundsAdvancedRP( toAddress, allAvailableWei, suggestedExtraGasToIncludeWithSends ); } /// @dev internal version of withdrawFundsAdvanced(), also used /// by withdrawFundsRP(). function withdrawFundsAdvancedRP( address _toAddress, uint _valueWei, uint _extraGasIncluded ) internal { if (msg.value != 0) { throw; } address fromAddress = msg.sender; if (_valueWei > funds[fromAddress]) { throw; } funds[fromAddress] -= _valueWei; bool sentOk = carefulSendWithFixedGas( _toAddress, _valueWei, _extraGasIncluded ); if (!sentOk) { throw; } FundsWithdrawnEvent(fromAddress, _toAddress, _valueWei); } } /// @title Mixin to help make nicer looking ether amounts. contract MoneyRounderMixin { /// @notice Make `_rawValueWei` into a nicer, rounder number. /// @return A value that: ///   - is no larger than `_rawValueWei` ///   - is no smaller than `_rawValueWei` * 0.999 ///   - has no more than three significant figures UNLESS the ///     number is very small or very large in monetary terms ///     (which we define as < 1 finney or > 10000 ether), in ///     which case no precision will be lost. function roundMoneyDownNicely(uint _rawValueWei) constant internal returns (uint nicerValueWei) { if (_rawValueWei < 1 finney) { return _rawValueWei; } else if (_rawValueWei < 10 finney) { return 10 szabo * (_rawValueWei / 10 szabo); } else if (_rawValueWei < 100 finney) { return 100 szabo * (_rawValueWei / 100 szabo); } else if (_rawValueWei < 1 ether) { return 1 finney * (_rawValueWei / 1 finney); } else if (_rawValueWei < 10 ether) { return 10 finney * (_rawValueWei / 10 finney); } else if (_rawValueWei < 100 ether) { return 100 finney * (_rawValueWei / 100 finney); } else if (_rawValueWei < 1000 ether) { return 1 ether * (_rawValueWei / 1 ether); } else if (_rawValueWei < 10000 ether) { return 10 ether * (_rawValueWei / 10 ether); } else { return _rawValueWei; } } /// @notice Convert `_valueWei` into a whole number of finney. /// @return The smallest whole number of finney which is equal /// to or greater than `_valueWei` when converted to wei. /// WARN: May be incorrect if `_valueWei` is above 2**254. function roundMoneyUpToWholeFinney(uint _valueWei) constant internal returns (uint valueFinney) { return (1 finney + _valueWei - 1 wei) / 1 finney; } } /// @title Mixin to help allow users to name things. contract NameableMixin { // String manipulation is expensive in the EVM; keep things short. uint constant minimumNameLength = 1; uint constant maximumNameLength = 25; string constant nameDataPrefix = \"NAME:\"; /// @notice Check if `_name` is a reasonable choice of name. /// @return True if-and-only-if `_name_` meets the criteria /// below, or false otherwise: ///   - no fewer than 1 character ///   - no more than 25 characters ///   - no characters other than: ///     - \"roman\" alphabet letters (A-Z and a-z) ///     - western digits (0-9) ///     - \"safe\" punctuation: ! ( ) - . _ SPACE ///   - at least one non-punctuation character /// Note that we deliberately exclude characters which may cause /// security problems for websites and databases if escaping is /// not performed correctly, such as < > \" and '. /// Apologies for the lack of non-English language support. function validateNameInternal(string _name) constant internal returns (bool allowed) { bytes memory nameBytes = bytes(_name); uint lengthBytes = nameBytes.length; if (lengthBytes < minimumNameLength || lengthBytes > maximumNameLength) { return false; } bool foundNonPunctuation = false; for (uint i = 0; i < lengthBytes; i++) { byte b = nameBytes[i]; if ( (b >= 48 && b <= 57) || // 0 - 9 (b >= 65 && b <= 90) || // A - Z (b >= 97 && b <= 122)   // a - z ) { foundNonPunctuation = true; continue; } if ( b == 32 || // space b == 33 || // ! b == 40 || // ( b == 41 || // ) b == 45 || // - b == 46 || // . b == 95    // _ ) { continue; } return false; } return foundNonPunctuation; } // Extract a name from bytes `_data` (presumably from `msg.data`), // or throw an exception if the data is not in the expected format. // // We want to make it easy for people to name things, even if // they're not comfortable calling functions on contracts. // // So we allow names to be sent to the fallback function encoded // as message data. // // Unfortunately, the way the Ethereum Function ABI works means we // must be careful to avoid clashes between message data that // represents our names and message data that represents a call // to an external function - otherwise: //   a) some names won't be usable; //   b) small possibility of a phishing attack where users are //     tricked into using certain names which cause an external //     function call - e.g. if the data sent to the contract is //     keccak256(\"withdrawFunds()\") then a withdrawal will occur. // // So we require a prefix \"NAME:\" at the start of the name (encoded // in ASCII) when sent via the fallback function - this prefix // doesn't clash with any external function signature hashes. // // e.g. web3.fromAscii('NAME:' + 'Joe Bloggs') // // WARN: this does not check the name for \"reasonableness\"; // use validateNameInternal() for that. // function extractNameFromData(bytes _data) constant internal returns (string extractedName) { // check prefix present uint expectedPrefixLength = (bytes(nameDataPrefix)).length; if (_data.length < expectedPrefixLength) { throw; } uint i; for (i = 0; i < expectedPrefixLength; i++) { if ((bytes(nameDataPrefix))[i] != _data[i]) { throw; } } // copy data after prefix uint payloadLength = _data.length - expectedPrefixLength; if (payloadLength < minimumNameLength || payloadLength > maximumNameLength) { throw; } string memory name = new string(payloadLength); for (i = 0; i < payloadLength; i++) { (bytes(name))[i] = _data[expectedPrefixLength + i]; } return name; } // Turn a short name into a \"fuzzy hash\" with the property // that extremely similar names will have the same fuzzy hash. // // This is useful to: //  - stop people choosing names which differ only in case or //    punctuation and would lead to confusion. //  - faciliate searching by name without needing exact match // // For example, these names all have the same fuzzy hash: // //  \"Banana\" //  \"BANANA\" //  \"Ba-na-na\" //  \"  banana  \" //  \"Banana                        .. so long the end is ignored\" // // On the other hand, \"Banana1\" and \"A Banana\" are different to // the above. // // WARN: this is likely to work poorly on names that do not meet // the validateNameInternal() test. // function computeNameFuzzyHash(string _name) constant internal returns (uint fuzzyHash) { bytes memory nameBytes = bytes(_name); uint h = 0; uint len = nameBytes.length; if (len > maximumNameLength) { len = maximumNameLength; } for (uint i = 0; i < len; i++) { uint mul = 128; byte b = nameBytes[i]; uint ub = uint(b); if (b >= 48 && b <= 57) { // 0-9 h = h * mul + ub; } else if (b >= 65 && b <= 90) { // A-Z h = h * mul + ub; } else if (b >= 97 && b <= 122) { // fold a-z to A-Z uint upper = ub - 32; h = h * mul + upper; } else { // ignore others } } return h; } } /// @title Mixin to help define the rules of a throne. contract ThroneRulesMixin { // See World.createKingdom(..) for documentation. struct ThroneRules { uint startingClaimPriceWei; uint maximumClaimPriceWei; uint claimPriceAdjustPercent; uint curseIncubationDurationSeconds; uint commissionPerThousand; } } /// @title Maintains the throne of a kingdom. contract Kingdom is ReentryProtectorMixin, CarefulSenderMixin, FundsHolderMixin, MoneyRounderMixin, NameableMixin, ThroneRulesMixin { // e.g. \"King of the Ether\" string public kingdomName; // The World contract used to create this kingdom, or 0x0 if none. address public world; // The rules that govern this kingdom - see ThroneRulesMixin. ThroneRules public rules; // Someone who has ruled (or is ruling) our kingdom. struct Monarch { // where to send their compensation address compensationAddress; // their name string name; // when they became our ruler uint coronationTimestamp; // the claim price paid (excluding any over-payment) uint claimPriceWei; // the compensation sent to or held for them so far uint compensationWei; } // The first ruler is number 1; the zero-th entry is a dummy entry. Monarch[] public monarchsByNumber; // The topWizard earns half the commission. // They are normally the owner of the World contract. address public topWizard; // The subWizard earns half the commission. // They are normally the creator of this Kingdom. // The topWizard and subWizard can be the same address. address public subWizard; // NB: we also have a `funds` mapping from FundsHolderMixin, // and a rentryProtector from ReentryProtectorMixin. event ThroneClaimedEvent(uint monarchNumber); event CompensationSentEvent(address toAddress, uint valueWei); event CompensationFailEvent(address toAddress, uint valueWei); event CommissionEarnedEvent(address byAddress, uint valueWei); event WizardReplacedEvent(address oldWizard, address newWizard); // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin // WARN - does NOT validate arguments; you MUST either call // KingdomFactory.validateProposedThroneRules() or create // the Kingdom via KingdomFactory/World's createKingdom(). // See World.createKingdom(..) for parameter documentation. function Kingdom( string _kingdomName, address _world, address _topWizard, address _subWizard, uint _startingClaimPriceWei, uint _maximumClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) { kingdomName = _kingdomName; world = _world; topWizard = _topWizard; subWizard = _subWizard; rules = ThroneRules( _startingClaimPriceWei, _maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); // We number the monarchs starting from 1; it's sometimes useful // to use zero = invalid, so put in a dummy entry for number 0. monarchsByNumber.push( Monarch( 0, \"\", 0, 0, 0 ) ); } function numberOfMonarchs() constant returns (uint totalCount) { // zero-th entry is invalid return monarchsByNumber.length - 1; } // False if either there are no monarchs, or if the latest monarch // has reigned too long and been struck down by the curse. function isLivingMonarch() constant returns (bool alive) { if (numberOfMonarchs() == 0) { return false; } uint reignStartedTimestamp = latestMonarchInternal().coronationTimestamp; if (now < reignStartedTimestamp) { // Should not be possible, think miners reject blocks with // timestamps that go backwards? But some drift possible and // it needs handling for unsigned overflow audit checks ... return true; } uint elapsedReignDurationSeconds = now - reignStartedTimestamp; if (elapsedReignDurationSeconds > rules.curseIncubationDurationSeconds) { return false; } else { return true; } } /// @notice How much you must pay to claim the throne now, in wei. function currentClaimPriceWei() constant returns (uint priceInWei) { if (!isLivingMonarch()) { return rules.startingClaimPriceWei; } else { uint lastClaimPriceWei = latestMonarchInternal().claimPriceWei; // no danger of overflow because claim price never gets that high uint newClaimPrice = (lastClaimPriceWei * (100 + rules.claimPriceAdjustPercent)) / 100; newClaimPrice = roundMoneyDownNicely(newClaimPrice); if (newClaimPrice < rules.startingClaimPriceWei) { newClaimPrice = rules.startingClaimPriceWei; } if (newClaimPrice > rules.maximumClaimPriceWei) { newClaimPrice = rules.maximumClaimPriceWei; } return newClaimPrice; } } /// @notice How much you must pay to claim the throne now, in finney. function currentClaimPriceInFinney() constant returns (uint priceInFinney) { uint valueWei = currentClaimPriceWei(); return roundMoneyUpToWholeFinney(valueWei); } /// @notice Check if a name can be used as a monarch name. /// @return True if the name satisfies the criteria of: ///   - no fewer than 1 character ///   - no more than 25 characters ///   - no characters other than: ///     - \"roman\" alphabet letters (A-Z and a-z) ///     - western digits (0-9) ///     - \"safe\" punctuation: ! ( ) - . _ SPACE function validateProposedMonarchName(string _monarchName) constant returns (bool allowed) { return validateNameInternal(_monarchName); } // Get details of the latest monarch (even if they are dead). // // We don't expose externally because returning structs is not well // supported in the ABI (strange that monarchsByNumber array works // fine though). Note that the reference returned is writable - it // can be used to update details of the latest monarch. // WARN: you should check numberOfMonarchs() > 0 first. function latestMonarchInternal() constant internal returns (Monarch storage monarch) { return monarchsByNumber[monarchsByNumber.length - 1]; } /// @notice Claim throne by sending funds to the contract. /// Any future compensation earned will be sent to the sender's /// address (`msg.sender`). /// Sending from a contract is not recommended unless you know /// what you're doing (and you've tested it). /// If no message data is supplied, the throne will be claimed in /// the name of \"Anonymous\". To supply a name, send data encoded /// using web3.fromAscii('NAME:' + 'your_chosen_valid_name'). /// Sender must include payment equal to currentClaimPriceWei(). /// Will consume up to ~300,000 gas. /// Will throw an error if: ///   - name is invalid (see `validateProposedMonarchName(string)`) ///   - payment is too low or too high /// Produces events: ///   - `ThroneClaimedEvent` ///   - `CompensationSentEvent` / `CompensationFailEvent` ///   - `CommissionEarnedEvent` function () { externalEnter(); fallbackRP(); externalLeave(); } /// @notice Claim throne in the given `_monarchName`. /// Any future compensation earned will be sent to the caller's /// address (`msg.sender`). /// Caller must include payment equal to currentClaimPriceWei(). /// Calling from a contract is not recommended unless you know /// what you're doing (and you've tested it). /// Will consume up to ~300,000 gas. /// Will throw an error if: ///   - name is invalid (see `validateProposedMonarchName(string)`) ///   - payment is too low or too high /// Produces events: ///   - `ThroneClaimedEvent ///   - `CompensationSentEvent` / `CompensationFailEvent` ///   - `CommissionEarnedEvent` function claimThrone(string _monarchName) { externalEnter(); claimThroneRP(_monarchName); externalLeave(); } /// @notice Used by either the topWizard or subWizard to transfer /// all rights to future commissions to the `_replacement` wizard. /// WARN: The original wizard retains ownership of any past /// commission held for them in the `funds` mapping, which they /// can still withdraw. /// Produces event WizardReplacedEvent. function replaceWizard(address _replacement) { externalEnter(); replaceWizardRP(_replacement); externalLeave(); } function fallbackRP() internal { if (msg.data.length == 0) { claimThroneRP(\"Anonymous\"); } else { string memory _monarchName = extractNameFromData(msg.data); claimThroneRP(_monarchName); } } function claimThroneRP( string _monarchName ) internal { address _compensationAddress = msg.sender; if (!validateNameInternal(_monarchName)) { throw; } if (_compensationAddress == 0 || _compensationAddress == address(this)) { throw; } uint paidWei = msg.value; uint priceWei = currentClaimPriceWei(); if (paidWei < priceWei) { throw; } // Make it easy for people to pay using a whole number of finney, // which could be a teeny bit higher than the raw wei value. uint excessWei = paidWei - priceWei; if (excessWei > 1 finney) { throw; } uint compensationWei; uint commissionWei; if (!isLivingMonarch()) { // dead men get no compensation commissionWei = paidWei; compensationWei = 0; } else { commissionWei = (paidWei * rules.commissionPerThousand) / 1000; compensationWei = paidWei - commissionWei; } if (commissionWei != 0) { recordCommissionEarned(commissionWei); } if (compensationWei != 0) { compensateLatestMonarch(compensationWei); } // In case of any teeny excess, we use the official price here // since that should determine the new claim price, not paidWei. monarchsByNumber.push(Monarch( _compensationAddress, _monarchName, now, priceWei, 0 )); ThroneClaimedEvent(monarchsByNumber.length - 1); } function replaceWizardRP(address replacement) internal { if (msg.value != 0) { throw; } bool replacedOk = false; address oldWizard; if (msg.sender == topWizard) { oldWizard = topWizard; topWizard = replacement; WizardReplacedEvent(oldWizard, replacement); replacedOk = true; } // Careful - topWizard and subWizard can be the same address, // in which case we must replace both. if (msg.sender == subWizard) { oldWizard = subWizard; subWizard = replacement; WizardReplacedEvent(oldWizard, replacement); replacedOk = true; } if (!replacedOk) { throw; } } // Allow commission funds to build up in contract for the wizards // to withdraw (carefully ring-fenced). function recordCommissionEarned(uint _commissionWei) internal { // give the subWizard any \"odd\" single wei uint topWizardWei = _commissionWei / 2; uint subWizardWei = _commissionWei - topWizardWei; funds[topWizard] += topWizardWei; CommissionEarnedEvent(topWizard, topWizardWei); funds[subWizard] += subWizardWei; CommissionEarnedEvent(subWizard, subWizardWei); } // Send compensation to latest monarch (or hold funds for them // if cannot through no fault of current caller). function compensateLatestMonarch(uint _compensationWei) internal { address compensationAddress = latestMonarchInternal().compensationAddress; // record that we compensated them latestMonarchInternal().compensationWei = _compensationWei; // WARN: if the latest monarch is a contract whose fallback // function needs more 25300 gas than then they will NOT // receive compensation automatically. bool sentOk = carefulSendWithFixedGas( compensationAddress, _compensationWei, suggestedExtraGasToIncludeWithSends ); if (sentOk) { CompensationSentEvent(compensationAddress, _compensationWei); } else { // This should only happen if the latest monarch is a contract // whose fallback-function failed or ran out of gas (despite // us including a fair amount of gas). // We do not throw since we do not want the throne to get // 'stuck' (it's not the new usurpers fault) - instead save // the funds we could not send so can be claimed later. // Their monarch contract would need to have been designed // to call our withdrawFundsAdvanced(..) function mind you. funds[compensationAddress] += _compensationWei; CompensationFailEvent(compensationAddress, _compensationWei); } } } /// @title Used by the World contract to create Kingdom instances. /// @dev Mostly exists so topWizard can potentially replace this /// contract to modify the Kingdom contract and/or rule validation /// logic to be used for *future* Kingdoms created by the World. /// We do not implement rentry protection because we don't send/call. /// We do not charge a fee here - but if you bypass the World then /// you won't be listed on the official World page of course. contract KingdomFactory { function KingdomFactory() { } function () { // this contract should never have a balance throw; } // See World.createKingdom(..) for parameter documentation. function validateProposedThroneRules( uint _startingClaimPriceWei, uint _maximumClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) constant returns (bool allowed) { // I suppose there is a danger that massive deflation/inflation could // change the real-world sanity of these checks, but in that case we // can deploy a new factory and update the world. if (_startingClaimPriceWei < 1 finney || _startingClaimPriceWei > 100 ether) { return false; } if (_maximumClaimPriceWei < 1 ether || _maximumClaimPriceWei > 100000 ether) { return false; } if (_startingClaimPriceWei * 20 > _maximumClaimPriceWei) { return false; } if (_claimPriceAdjustPercent < 1 || _claimPriceAdjustPercent > 900) { return false; } if (_curseIncubationDurationSeconds < 2 hours || _curseIncubationDurationSeconds > 10000 days) { return false; } if (_commissionPerThousand < 10 || _commissionPerThousand > 100) { return false; } return true; } /// @notice Create a new Kingdom. Normally called by World contract. /// WARN: Does NOT validate the _kingdomName or _world arguments. /// Will consume up to 1,800,000 gas (!) /// Will throw an error if: ///   - rules invalid (see validateProposedThroneRules) ///   - wizard addresses \"obviously\" wrong ///   - out of gas quite likely (perhaps in future should consider ///     using solidity libraries to reduce Kingdom size?) // See World.createKingdom(..) for parameter documentation. function createKingdom( string _kingdomName, address _world, address _topWizard, address _subWizard, uint _startingClaimPriceWei, uint _maximumClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) returns (Kingdom newKingdom) { if (msg.value > 0) { // this contract should never have a balance throw; } // NB: topWizard and subWizard CAN be the same as each other. if (_topWizard == 0 || _subWizard == 0) { throw; } if (_topWizard == _world || _subWizard == _world) { throw; } if (!validateProposedThroneRules( _startingClaimPriceWei, _maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand )) { throw; } return new Kingdom( _kingdomName, _world, _topWizard, _subWizard, _startingClaimPriceWei, _maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); } } /// @title Runs the world, which is a collection of Kingdoms. contract World is ReentryProtectorMixin, NameableMixin, MoneyRounderMixin, FundsHolderMixin, ThroneRulesMixin { // The topWizard runs the world. They charge for the creation of // kingdoms and become the topWizard in each kingdom created. address public topWizard; // How much one must pay to create a new kingdom (in wei). // Can be changed by the topWizard. uint public kingdomCreationFeeWei; struct KingdomListing { uint kingdomNumber; string kingdomName; address kingdomContract; address kingdomCreator; uint creationTimestamp; address kingdomFactoryUsed; } // The first kingdom is number 1; the zero-th entry is a dummy. KingdomListing[] public kingdomsByNumber; // For safety, we cap just how high the price can get. // Can be changed by the topWizard, though it will only affect // kingdoms created after that. uint public maximumClaimPriceWei; // Helper contract for creating Kingdom instances. Can be // upgraded by the topWizard (won't affect existing ones). KingdomFactory public kingdomFactory; // Avoids duplicate kingdom names and allows searching by name. mapping (uint => uint) kingdomNumbersByfuzzyHash; // NB: we also have a `funds` mapping from FundsHolderMixin, // and a rentryProtector from ReentryProtectorMixin. event KingdomCreatedEvent(uint kingdomNumber); event CreationFeeChangedEvent(uint newFeeWei); event FactoryChangedEvent(address newFactory); event WizardReplacedEvent(address oldWizard, address newWizard); // NB: we also have a `FundsWithdrawnEvent` from FundsHolderMixin // Create the world with no kingdoms yet. // Costs about 1.9M gas to deploy. function World( address _topWizard, uint _kingdomCreationFeeWei, KingdomFactory _kingdomFactory, uint _maximumClaimPriceWei ) { if (_topWizard == 0) { throw; } if (_maximumClaimPriceWei < 1 ether) { throw; } topWizard = _topWizard; kingdomCreationFeeWei = _kingdomCreationFeeWei; kingdomFactory = _kingdomFactory; maximumClaimPriceWei = _maximumClaimPriceWei; // We number the kingdoms starting from 1 since it's sometimes // useful to use zero = invalid. Create dummy zero-th entry. kingdomsByNumber.push(KingdomListing(0, \"\", 0, 0, 0, 0)); } function numberOfKingdoms() constant returns (uint totalCount) { return kingdomsByNumber.length - 1; } /// @return index into kingdomsByNumber if found, or zero if not. function findKingdomCalled(string _kingdomName) constant returns (uint kingdomNumber) { uint fuzzyHash = computeNameFuzzyHash(_kingdomName); return kingdomNumbersByfuzzyHash[fuzzyHash]; } /// @notice Check if a name can be used as a kingdom name. /// @return True if the name satisfies the criteria of: ///   - no fewer than 1 character ///   - no more than 25 characters ///   - no characters other than: ///     - \"roman\" alphabet letters (A-Z and a-z) ///     - western digits (0-9) ///     - \"safe\" punctuation: ! ( ) - . _ SPACE /// /// WARN: does not check if the name is already in use; /// use `findKingdomCalled(string)` for that afterwards. function validateProposedKingdomName(string _kingdomName) constant returns (bool allowed) { return validateNameInternal(_kingdomName); } // Check if rules would be allowed for a new custom Kingdom. // Typically used before calling `createKingdom(...)`. function validateProposedThroneRules( uint _startingClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) constant returns (bool allowed) { return kingdomFactory.validateProposedThroneRules( _startingClaimPriceWei, maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); } // How much one must pay to create a new kingdom (in finney). // Can be changed by the topWizard. function kingdomCreationFeeInFinney() constant returns (uint feeInFinney) { return roundMoneyUpToWholeFinney(kingdomCreationFeeWei); } // Reject funds sent to the contract - wizards who cannot interact // with it via the API won't be able to withdraw their commission. function () { throw; } /// @notice Create a new kingdom using custom rules. /// @param _kingdomName \\ ///   e.g. \"King of the Ether Throne\" /// @param _startingClaimPriceWei \\ ///   How much it will cost the first monarch to claim the throne ///   (and also the price after the death of a monarch). /// @param _claimPriceAdjustPercent \\ ///   Percentage increase after each claim - e.g. if claim price ///   was 200 ETH, and `_claimPriceAdjustPercent` is 50, the next ///   claim price will be 200 ETH + (50% of 200 ETH) => 300 ETH. /// @param _curseIncubationDurationSeconds \\ ///   The maximum length of a time a monarch can rule before the ///   curse strikes and they are removed without compensation. /// @param _commissionPerThousand \\ ///   How much of each payment is given to the wizards to share, ///   expressed in parts per thousand - e.g. 25 means 25/1000, ///   or 2.5%. /// /// Caller must include payment equal to kingdomCreationFeeWei. /// The caller will become the 'sub-wizard' and will earn half /// any commission charged by the Kingdom.  Note however they /// will need to call withdrawFunds() on the Kingdom contract /// to get their commission - it's not send automatically. /// /// Will consume up to 1,900,000 gas (!) /// Will throw an error if: ///   - name is invalid (see `validateProposedKingdomName(string)`) ///   - name is already in use (see `findKingdomCalled(string)`) ///   - rules are invalid (see `validateProposedKingdomRules(...)`) ///   - payment is too low or too high ///   - insufficient gas (quite likely!) /// Produces event KingdomCreatedEvent. function createKingdom( string _kingdomName, uint _startingClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) { externalEnter(); createKingdomRP( _kingdomName, _startingClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); externalLeave(); } /// @notice Used by topWizard to transfer all rights to future /// fees and future kingdom wizardships to `_replacement` wizard. /// WARN: The original wizard retains ownership of any past fees /// held for them in the `funds` mapping, which they can still /// withdraw. They also remain topWizard in any existing Kingdoms. /// Produces event WizardReplacedEvent. function replaceWizard(address _replacement) { externalEnter(); replaceWizardRP(_replacement); externalLeave(); } /// @notice Used by topWizard to vary the fee for creating kingdoms. function setKingdomCreationFeeWei(uint _kingdomCreationFeeWei) { externalEnter(); setKingdomCreationFeeWeiRP(_kingdomCreationFeeWei); externalLeave(); } /// @notice Used by topWizard to vary the cap on claim price. function setMaximumClaimPriceWei(uint _maximumClaimPriceWei) { externalEnter(); setMaximumClaimPriceWeiRP(_maximumClaimPriceWei); externalLeave(); } /// @notice Used by topWizard to vary the factory contract which /// will be used to create future Kingdoms. function setKingdomFactory(KingdomFactory _kingdomFactory) { externalEnter(); setKingdomFactoryRP(_kingdomFactory); externalLeave(); } function createKingdomRP( string _kingdomName, uint _startingClaimPriceWei, uint _claimPriceAdjustPercent, uint _curseIncubationDurationSeconds, uint _commissionPerThousand ) internal { address subWizard = msg.sender; if (!validateNameInternal(_kingdomName)) { throw; } uint newKingdomNumber = kingdomsByNumber.length; checkUniqueAndRegisterNewKingdomName( _kingdomName, newKingdomNumber ); uint paidWei = msg.value; if (paidWei < kingdomCreationFeeWei) { throw; } // Make it easy for people to pay using a whole number of finney, // which could be a teeny bit higher than the raw wei value. uint excessWei = paidWei - kingdomCreationFeeWei; if (excessWei > 1 finney) { throw; } funds[topWizard] += paidWei; // This will perform rule validation. Kingdom kingdomContract = kingdomFactory.createKingdom( _kingdomName, address(this), topWizard, subWizard, _startingClaimPriceWei, maximumClaimPriceWei, _claimPriceAdjustPercent, _curseIncubationDurationSeconds, _commissionPerThousand ); kingdomsByNumber.push(KingdomListing( newKingdomNumber, _kingdomName, kingdomContract, msg.sender, now, kingdomFactory )); } function replaceWizardRP(address replacement) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } address oldWizard = topWizard; topWizard = replacement; WizardReplacedEvent(oldWizard, replacement); } function setKingdomCreationFeeWeiRP(uint _kingdomCreationFeeWei) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } kingdomCreationFeeWei = _kingdomCreationFeeWei; CreationFeeChangedEvent(kingdomCreationFeeWei); } function setMaximumClaimPriceWeiRP(uint _maximumClaimPriceWei) internal { if (msg.sender != topWizard) { throw; } if (_maximumClaimPriceWei < 1 ether) { throw; } maximumClaimPriceWei = _maximumClaimPriceWei; } function setKingdomFactoryRP(KingdomFactory _kingdomFactory) internal { if (msg.sender != topWizard) { throw; } if (msg.value != 0) { throw; } kingdomFactory = _kingdomFactory; FactoryChangedEvent(kingdomFactory); } // If there is no existing kingdom called `_kingdomName`, create // a record mapping that name to kingdom no. `_newKingdomNumber`. // Throws an error if an existing kingdom with the same (or // fuzzily similar - see computeNameFuzzyHash) name exists. function checkUniqueAndRegisterNewKingdomName( string _kingdomName, uint _newKingdomNumber ) internal { uint fuzzyHash = computeNameFuzzyHash(_kingdomName); if (kingdomNumbersByfuzzyHash[fuzzyHash] != 0) { throw; } kingdomNumbersByfuzzyHash[fuzzyHash] = _newKingdomNumber; } } /// @title Used on the testnet to allow automated testing of internals. contract ExposedInternalsForTesting is MoneyRounderMixin, NameableMixin { function roundMoneyDownNicelyET(uint _rawValueWei) constant returns (uint nicerValueWei) { return roundMoneyDownNicely(_rawValueWei); } function roundMoneyUpToWholeFinneyET(uint _valueWei) constant returns (uint valueFinney) { return roundMoneyUpToWholeFinney(_valueWei); } function validateNameInternalET(string _name) constant returns (bool allowed) { return validateNameInternal(_name); } function extractNameFromDataET(bytes _data) constant returns (string extractedName) { return extractNameFromData(_data); } function computeNameFuzzyHashET(string _name) constant returns (uint fuzzyHash) { return computeNameFuzzyHash(_name); } } "}
{"sol name": "36664.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract HumanStandardToken is StandardToken { function () { revert(); } /* Public variables of the token */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = \"H 2.0\";       //human 0.1 standard. Just an arbitrary versioning scheme. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } // Creates 21,000,000.00000000 BOBOv2 (BB2) Tokens contract BOBOv2 is HumanStandardToken(2100000000000000, \"BOBOv2\", 8, \"BB2\") {} "}
{"sol name": "38497.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint256 supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } //name this contract whatever you'd like contract Kitcoins is StandardToken { function () { //if ether is sent to this address, send it back. throw; } /* Public variables of the token */ /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. ie. There could 1000 base units with 3 decimals. Meaning 0.980 SBX = 980 base units. It's like comparing 1 wei to 1 ether. string public symbol;                 //An identifier: eg SBX string public version = 'H1.0';       //human 0.1 standard. Just an arbitrary versioning scheme. // // CHANGE THESE VALUES FOR YOUR TOKEN // //make sure this function name matches the contract name above. So if you're token is called TutorialToken, make sure the //contract name above is also TutorialToken instead of ERC20Token function Kitcoins( ) { balances[msg.sender] = 10000000;               // Give the creator all initial tokens (100000 for example) totalSupply = 10000000;                        // Update total supply (100000 for example) name = \"Kitcoins\";                                   // Set the name for display purposes decimals = 0;                            // Amount of decimals for display purposes symbol = \"KIT\";                               // Set the symbol for display purposes } /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); //call the receiveApproval function on the contract you want to be notified. This crafts the function signature manually so one doesn't have to include a contract in here just for this. //receiveApproval(address _from, uint256 _value, address _tokenContract, bytes _extraData) //it is assumed that when does this that the call *should* succeed, otherwise one would use vanilla approve instead. if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34122.sol", "label": 0, "sol content": "pragma solidity 0.4.15; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } /* *  Modifiers */ modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } /// @dev Fallback function allows to deposit ether. function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. /// @param _owners List of initial owners. /// @param _required Number of required confirmations. function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } /// @dev Allows to add a new owner. Transaction has to be sent by wallet. /// @param owner Address of new owner. function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } /// @dev Allows to remove an owner. Transaction has to be sent by wallet. /// @param owner Address of owner. function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by wallet. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by wallet. /// @param _required Number of required confirmations. function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a transaction. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @param data Transaction data payload. /// @return Returns transaction ID. function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "31565.sol", "label": 0, "sol content": "pragma solidity 0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Telcoin { using SafeMath for uint256; event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); string public constant name = \"Telcoin\"; string public constant symbol = \"TEL\"; uint8 public constant decimals = 2; /// The ERC20 total fixed supply of tokens. uint256 public constant totalSupply = 100000000000 * (10 ** uint256(decimals)); /// Account balances. mapping(address => uint256) balances; /// The transfer allowances. mapping (address => mapping (address => uint256)) internal allowed; /// The initial distributor is responsible for allocating the supply /// into the various pools described in the whitepaper. This can be /// verified later from the event log. function Telcoin(address _distributor) public { balances[_distributor] = totalSupply; Transfer(0x0, _distributor, totalSupply); } /// ERC20 balanceOf(). function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /// ERC20 transfer(). function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /// ERC20 transferFrom(). function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /// ERC20 approve(). Comes with the standard caveat that an approval /// meant to limit spending may actually allow more to be spent due to /// unfortunate ordering of transactions. For safety, this method /// should only be called if the current allowance is 0. Alternatively, /// non-ERC20 increaseApproval() and decreaseApproval() can be used. function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /// ERC20 allowance(). function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /// Not officially ERC20. Allows an allowance to be increased safely. function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /// Not officially ERC20. Allows an allowance to be decreased safely. function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract TelcoinSaleToken { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event Mint(address indexed to, uint256 amount); event MintFinished(); event Redeem(address indexed beneficiary, uint256 sacrificedValue, uint256 grantedValue); event Transfer(address indexed from, address indexed to, uint256 value); /// The owner of the contract. address public owner; /// The total number of minted tokens, excluding destroyed tokens. uint256 public totalSupply; /// The token balance and released amount of each address. mapping(address => uint256) balances; mapping(address => uint256) redeemed; /// Whether the token is still mintable. bool public mintingFinished = false; /// Redeemable telcoin. Telcoin telcoin; uint256 public totalRedeemed; /// Vesting period. uint256 vestingStart; uint256 vestingDuration; modifier onlyOwner() { require(msg.sender == owner); _; } function TelcoinSaleToken( Telcoin _telcoin, uint256 _vestingStart, uint256 _vestingDuration ) public { owner = msg.sender; telcoin = _telcoin; vestingStart = _vestingStart; vestingDuration = _vestingDuration; } function finishMinting() onlyOwner public returns (bool) { require(!mintingFinished); mintingFinished = true; MintFinished(); return true; } function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { require(_to != 0x0); require(!mintingFinished); require(_amount > 0); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(0x0, _to, _amount); return true; } function redeemMany(address[] _beneficiaries) public { for (uint256 i = 0; i < _beneficiaries.length; i++) { redeem(_beneficiaries[i]); } } function redeem(address _beneficiary) public returns (uint256) { require(mintingFinished); require(_beneficiary != 0x0); uint256 balance = redeemableBalance(_beneficiary); if (balance == 0) { return 0; } uint256 totalDistributable = telcoin.balanceOf(this).add(totalRedeemed); // Avoid loss of precision by multiplying and later dividing by // a large value. uint256 amount = balance.mul(10 ** 18).div(totalSupply).mul(totalDistributable).div(10 ** 18); balances[_beneficiary] = balances[_beneficiary].sub(balance); redeemed[_beneficiary] = redeemed[_beneficiary].add(balance); balances[telcoin] = balances[telcoin].add(balance); totalRedeemed = totalRedeemed.add(amount); Transfer(_beneficiary, telcoin, balance); Redeem(_beneficiary, balance, amount); telcoin.transfer(_beneficiary, amount); return amount; } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } function balanceOf(address _owner) public constant returns (uint256) { return balances[_owner]; } function redeemableBalance(address _beneficiary) public constant returns (uint256) { return vestedBalance(_beneficiary).sub(redeemed[_beneficiary]); } function vestedBalance(address _beneficiary) public constant returns (uint256) { uint256 currentBalance = balances[_beneficiary]; uint256 totalBalance = currentBalance.add(redeemed[_beneficiary]); if (now < vestingStart) { return 0; } if (now >= vestingStart.add(vestingDuration)) { return totalBalance; } return totalBalance.mul(now.sub(vestingStart)).div(vestingDuration); } } contract TelcoinSale { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event WalletChanged(address indexed previousWallet, address indexed newWallet); event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 bonusAmount ); event TokenAltPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount, uint256 bonusAmount, string symbol, string transactionId ); event Pause(); event Unpause(); event Withdrawal(address indexed wallet, uint256 weiAmount); event Extended(uint256 until); event Finalized(); event Refunding(); event Refunded(address indexed beneficiary, uint256 weiAmount); event Whitelisted( address indexed participant, uint256 minWeiAmount, uint256 maxWeiAmount, uint32 bonusRate ); event CapFlexed(uint32 flex); /// The owner of the contract. address public owner; /// The temporary token we're selling. Sale tokens can be converted /// immediately upon successful completion of the sale. Bonus tokens /// are on a separate vesting schedule. TelcoinSaleToken public saleToken; TelcoinSaleToken public bonusToken; /// The token we'll convert to after the sale ends. Telcoin public telcoin; /// The minimum and maximum goals to reach. If the soft cap is not reached /// by the end of the sale, the contract will enter refund mode. If the /// hard cap is reached, the contract can be finished early. /// /// Due to our actual soft cap being tied to USD and the assumption that /// the value of Ether will continue to increase during the ICO, we /// implement a fixed minimum softcap that accounts for a 2.5x value /// increase. The capFlex is a scale factor that allows us to scale the /// caps above the fixed minimum values. Initially the scale factor will /// be set so that our effective soft cap is ~10M USD. uint256 public softCap; uint256 public hardCap; uint32 public capFlex; /// The sale period. uint256 public startTime; uint256 public endTime; uint256 public timeExtension; /// The numnber of tokens to mint per wei. uint256 public rate; /// The total number of wei raised. Note that the contract's balance may /// differ from this value if someone has decided to forcefully send us /// ether. uint256 public weiRaised; /// The wallet that will receive the contract's balance once the sale /// finishes and the soft cap is reached. address public wallet; /// The list of addresses that are allowed to participate in the sale, /// up to what amount, and any special rate they may have, provided /// that they do in fact participate with at least the minimum value /// they agreed to. mapping(address => uint256) public whitelistedMin; mapping(address => uint256) public whitelistedMax; mapping(address => uint32) public bonusRates; /// The amount of wei and wei equivalents invested by each investor. mapping(address => uint256) public deposited; mapping(address => uint256) public altDeposited; /// An enumerable list of investors. address[] public investors; /// Whether the sale is paused. bool public paused = false; /// Whether the sale has finished, and when. bool public finished = false; uint256 public finishedAt; /// Whether we're accepting refunds. bool public refunding = false; /// The total number of wei refunded. uint256 public weiRefunded; modifier onlyOwner() { require(msg.sender == owner); _; } modifier saleOpen() { require(!finished); require(!paused); require(now >= startTime); require(now <= endTime + timeExtension); _; } function TelcoinSale( uint256 _softCap, uint256 _hardCap, uint32 _capFlex, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, Telcoin _telcoin, uint256 _bonusVestingStart, uint256 _bonusVestingDuration ) public payable { require(msg.value > 0); require(_softCap > 0); require(_hardCap >= _softCap); require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); owner = msg.sender; softCap = _softCap; hardCap = _hardCap; capFlex = _capFlex; startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; telcoin = _telcoin; saleToken = new TelcoinSaleToken(telcoin, 0, 0); bonusToken = new TelcoinSaleToken( telcoin, _bonusVestingStart, _bonusVestingDuration ); wallet.transfer(msg.value); } function () public payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) saleOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); require(weiRaised.add(weiAmount) <= hardCap); uint256 totalPrior = totalDeposited(_beneficiary); uint256 totalAfter = totalPrior.add(weiAmount); require(totalAfter <= whitelistedMax[_beneficiary]); uint256 saleTokens; uint256 bonusTokens; (saleTokens, bonusTokens) = tokensForPurchase(_beneficiary, weiAmount); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; investors.push(_beneficiary); weiRaised = weiRaised.add(weiAmount); saleToken.mint(_beneficiary, saleTokens); if (bonusTokens > 0) { bonusToken.mint(_beneficiary, bonusTokens); } TokenPurchase( msg.sender, _beneficiary, weiAmount, saleTokens, bonusTokens ); } function changeWallet(address _wallet) onlyOwner public payable { require(_wallet != 0x0); require(msg.value > 0); WalletChanged(wallet, _wallet); wallet = _wallet; wallet.transfer(msg.value); } function extendTime(uint256 _timeExtension) onlyOwner public { require(!finished); require(now < endTime + timeExtension); require(_timeExtension > 0); timeExtension = timeExtension.add(_timeExtension); require(timeExtension <= 7 days); Extended(endTime.add(timeExtension)); } function finish() onlyOwner public { require(!finished); require(hardCapReached() || now > endTime + timeExtension); finished = true; finishedAt = now; saleToken.finishMinting(); bonusToken.finishMinting(); uint256 distributableCoins = telcoin.balanceOf(this); if (softCapReached()) { uint256 saleTokens = saleToken.totalSupply(); uint256 bonusTokens = bonusToken.totalSupply(); uint256 totalTokens = saleTokens.add(bonusTokens); // Avoid loss of precision by multiplying and later dividing by // a large value. uint256 bonusPortion = bonusTokens.mul(10 ** 18).div(totalTokens).mul(distributableCoins).div(10 ** 18); uint256 salePortion = distributableCoins.sub(bonusPortion); saleToken.transferOwnership(owner); bonusToken.transferOwnership(owner); telcoin.transfer(saleToken, salePortion); telcoin.transfer(bonusToken, bonusPortion); withdraw(); } else { refunding = true; telcoin.transfer(wallet, distributableCoins); Refunding(); } Finalized(); } function pause() onlyOwner public { require(!paused); paused = true; Pause(); } function refundMany(address[] _investors) public { for (uint256 i = 0; i < _investors.length; i++) { refund(_investors[i]); } } function refund(address _investor) public { require(finished); require(refunding); require(deposited[_investor] > 0); uint256 weiAmount = deposited[_investor]; deposited[_investor] = 0; weiRefunded = weiRefunded.add(weiAmount); Refunded(_investor, weiAmount); _investor.transfer(weiAmount); } function registerAltPurchase( address _beneficiary, string _symbol, string _transactionId, uint256 _weiAmount ) saleOpen onlyOwner public { require(_beneficiary != address(0)); require(totalDeposited(_beneficiary).add(_weiAmount) <= whitelistedMax[_beneficiary]); uint256 saleTokens; uint256 bonusTokens; (saleTokens, bonusTokens) = tokensForPurchase(_beneficiary, _weiAmount); uint256 newAltDeposited = altDeposited[_beneficiary].add(_weiAmount); altDeposited[_beneficiary] = newAltDeposited; investors.push(_beneficiary); weiRaised = weiRaised.add(_weiAmount); saleToken.mint(_beneficiary, saleTokens); if (bonusTokens > 0) { bonusToken.mint(_beneficiary, bonusTokens); } TokenAltPurchase( msg.sender, _beneficiary, _weiAmount, saleTokens, bonusTokens, _symbol, _transactionId ); } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } function unpause() onlyOwner public { require(paused); paused = false; Unpause(); } function updateCapFlex(uint32 _capFlex) onlyOwner public { require(!finished); capFlex = _capFlex; CapFlexed(capFlex); } function whitelistMany( address[] _participants, uint256 _minWeiAmount, uint256 _maxWeiAmount, uint32 _bonusRate ) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { whitelist( _participants[i], _minWeiAmount, _maxWeiAmount, _bonusRate ); } } function whitelist( address _participant, uint256 _minWeiAmount, uint256 _maxWeiAmount, uint32 _bonusRate ) onlyOwner public { require(_participant != 0x0); require(_bonusRate <= 400); whitelistedMin[_participant] = _minWeiAmount; whitelistedMax[_participant] = _maxWeiAmount; bonusRates[_participant] = _bonusRate; Whitelisted( _participant, _minWeiAmount, _maxWeiAmount, _bonusRate ); } function withdraw() onlyOwner public { require(softCapReached() || (finished && now > finishedAt + 14 days)); uint256 weiAmount = this.balance; if (weiAmount > 0) { wallet.transfer(weiAmount); Withdrawal(wallet, weiAmount); } } function hardCapReached() public constant returns (bool) { return weiRaised >= hardCap.mul(1000 + capFlex).div(1000); } function tokensForPurchase( address _beneficiary, uint256 _weiAmount ) public constant returns (uint256, uint256) { uint256 baseTokens = _weiAmount.mul(rate); uint256 totalPrior = totalDeposited(_beneficiary); uint256 totalAfter = totalPrior.add(_weiAmount); // Has the beneficiary passed the assigned minimum purchase level? if (totalAfter < whitelistedMin[_beneficiary]) { return (baseTokens, 0); } uint32 bonusRate = bonusRates[_beneficiary]; uint256 baseBonus = baseTokens.mul(1000 + bonusRate).div(1000).sub(baseTokens); // Do we pass the minimum purchase level with this purchase? if (totalPrior < whitelistedMin[_beneficiary]) { uint256 balancePrior = totalPrior.mul(rate); uint256 accumulatedBonus = balancePrior.mul(1000 + bonusRate).div(1000).sub(balancePrior); return (baseTokens, accumulatedBonus.add(baseBonus)); } return (baseTokens, baseBonus); } function totalDeposited(address _investor) public constant returns (uint256) { return deposited[_investor].add(altDeposited[_investor]); } function softCapReached() public constant returns (bool) { return weiRaised >= softCap.mul(1000 + capFlex).div(1000); } } contract TelcoinSaleKYCEscrow { using SafeMath for uint256; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); event ValuePlaced(address indexed purchaser, address indexed beneficiary, uint256 amount); event Approved(address indexed participant); event Rejected(address indexed participant); event Closed(); /// The owner of the contract. address public owner; /// The actual sale. TelcoinSale public sale; /// Whether the escrow has closed. bool public closed = false; /// The amount of wei and wei equivalents invested by each investor. mapping(address => uint256) public deposited; modifier onlyOwner() { require(msg.sender == owner); _; } modifier escrowOpen() { require(!closed); _; } function TelcoinSaleKYCEscrow(TelcoinSale _sale) public { require(_sale != address(0)); owner = msg.sender; sale = _sale; } function () public payable { placeValue(msg.sender); } function approve(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Approved(_participant); sale.buyTokens.value(weiAmount)(_participant); } function approveMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { approve(_participants[i]); } } function close() onlyOwner public { require(!closed); closed = true; Closed(); } function placeValue(address _beneficiary) escrowOpen public payable { require(_beneficiary != address(0)); uint256 weiAmount = msg.value; require(weiAmount > 0); uint256 newDeposited = deposited[_beneficiary].add(weiAmount); deposited[_beneficiary] = newDeposited; ValuePlaced( msg.sender, _beneficiary, weiAmount ); } function reject(address _participant) onlyOwner public { uint256 weiAmount = deposited[_participant]; require(weiAmount > 0); deposited[_participant] = 0; Rejected(_participant); require(_participant.call.value(weiAmount)()); } function rejectMany(address[] _participants) onlyOwner public { for (uint256 i = 0; i < _participants.length; i++) { reject(_participants[i]); } } function transferOwnership(address _to) onlyOwner public { require(_to != address(0)); OwnershipTransferred(owner, _to); owner = _to; } } "}
{"sol name": "34938.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() internal { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Authorizable * @dev The Authorizable contract has authorized addresses, and provides basic authorization control * functions, this simplifies the implementation of \"multiple user permissions\". */ contract Authorizable is Ownable { mapping(address => bool) public authorized; event AuthorizationSet(address indexed addressAuthorized, bool indexed authorization); /** * @dev The Authorizable constructor sets the first `authorized` of the contract to the sender * account. */ function Authorizable() public { authorized[msg.sender] = true; } /** * @dev Throws if called by any account other than the authorized. */ modifier onlyAuthorized() { require(authorized[msg.sender]); _; } /** * @dev Allows the current owner to set an authorization. * @param addressAuthorized The address to change authorization. */ function setAuthorized(address addressAuthorized, bool authorization) onlyOwner public { AuthorizationSet(addressAuthorized, authorization); authorized[addressAuthorized] = authorization; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token from an address to another specified address * @param _sender The address to transfer from. * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transferFunction(address _sender, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[_sender]); // SafeMath.sub will throw if there is not enough balance. balances[_sender] = balances[_sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(_sender, _to, _value); return true; } /** * @dev transfer token for a specified address (BasicToken transfer method) */ function transfer(address _to, uint256 _value) public returns (bool) { return transferFunction(msg.sender, _to, _value); } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC223TokenCompatible is BasicToken { using SafeMath for uint256; event Transfer(address indexed from, address indexed to, uint256 value, bytes indexed data); // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); if( isContract(_to) ) { _to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data); } Transfer(msg.sender, _to, _value, _data); return true; } // Function that is called when a user or another contract wants to transfer funds . function transfer(address _to, uint256 _value, bytes _data) public returns (bool success) { return transfer( _to, _value, _data, \"tokenFallback(address,uint256,bytes)\"); } //assemble the given address bytecode. If bytecode exists then the _addr is a contract. function isContract(address _addr) private view returns (bool is_contract) { uint256 length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Startable * @dev Base contract which allows owner to implement an start mechanism without ever being stopped more. */ contract Startable is Ownable, Authorizable { event Start(); bool public started = false; /** * @dev Modifier to make a function callable only when the contract is started. */ modifier whenStarted() { require( started || authorized[msg.sender] ); _; } /** * @dev called by the owner to start, go to normal state */ function start() onlyOwner public { started = true; Start(); } } /** * @title Startable token * * @dev StandardToken modified with startable transfers. **/ contract StartToken is Startable, ERC223TokenCompatible, StandardToken { function transfer(address _to, uint256 _value) public whenStarted returns (bool) { return super.transfer(_to, _value); } function transfer(address _to, uint256 _value, bytes _data) public whenStarted returns (bool) { return super.transfer(_to, _value, _data); } function transfer(address _to, uint256 _value, bytes _data, string _custom_fallback) public whenStarted returns (bool) { return super.transfer(_to, _value, _data, _custom_fallback); } function transferFrom(address _from, address _to, uint256 _value) public whenStarted returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenStarted returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenStarted returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenStarted returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract HumanStandardToken is StandardToken, StartToken { /* Approves and then calls the receiving contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { approve(_spender, _value); require(_spender.call(bytes4(keccak256(\"receiveApproval(address,uint256,bytes)\")), msg.sender, _value, _extraData)); return true; } } contract BurnToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Function to burn tokens. * @param _burner The address of token holder. * @param _value The amount of token to be burned. */ function burnFunction(address _burner, uint256 _value) internal returns (bool) { require(_value > 0); require(_value <= balances[_burner]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_burner] = balances[_burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_burner, _value); return true; } /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public returns(bool) { return burnFunction(msg.sender, _value); } /** * @dev Burns tokens from one address * @param _from address The address which you want to burn tokens from * @param _value uint256 the amount of tokens to be burned */ function burnFrom(address _from, uint256 _value) public returns (bool) { require(_value <= allowed[_from][msg.sender]); // check if it has the budget allowed burnFunction(_from, _value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); return true; } } contract OriginToken is Authorizable, BasicToken, BurnToken { /** * @dev transfer token from tx.orgin to a specified address (onlyAuthorized contract) */ function originTransfer(address _to, uint256 _value) onlyAuthorized public returns (bool) { return transferFunction(tx.origin, _to, _value); } /** * @dev Burns a specific amount of tokens from tx.orgin. (onlyAuthorized contract) * @param _value The amount of token to be burned. */ function originBurn(uint256 _value) onlyAuthorized public returns(bool) { return burnFunction(tx.origin, _value); } } contract ICOLandToken is ERC223TokenCompatible, StandardToken, StartToken, HumanStandardToken, BurnToken, OriginToken { uint8 public decimals = 18; string public name = \"ICOLand\"; string public symbol = \"ICL\"; uint256 public initialSupply; function ICOLandToken() public { totalSupply = 10000000 * 10 ** uint(decimals); initialSupply = totalSupply; balances[msg.sender] = totalSupply; } } "}
{"sol name": "38550.sol", "label": 0, "sol content": "contract SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract Token { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens, after that function `receiveApproval` /// @notice will be called on `_spender` address /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @param _extraData Some data to pass in callback function /// @return Whether the approval was successful or not function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Issuance(address indexed _to, uint256 _value); event Burn(address indexed _from, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. //if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. //if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); string memory signature = \"receiveApproval(address,uint256,address,bytes)\"; if (!_spender.call(bytes4(bytes32(sha3(signature))), msg.sender, _value, this, _extraData)) { throw; } return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract LATPToken is StandardToken, SafeMath { /* Public variables of the token */ address     public founder; address     public minter; string      public name             =       \"LATO PreICO\"; uint8       public decimals         =       6; string      public symbol           =       \"LATP\"; string      public version          =       \"0.7.1\"; uint        public maxTotalSupply   =       100000 * 1000000; modifier onlyFounder() { if (msg.sender != founder) { throw; } _; } modifier onlyMinter() { if (msg.sender != minter) { throw; } _; } function issueTokens(address _for, uint tokenCount) external payable onlyMinter returns (bool) { if (tokenCount == 0) { return false; } if (add(totalSupply, tokenCount) > maxTotalSupply) { throw; } totalSupply = add(totalSupply, tokenCount); balances[_for] = add(balances[_for], tokenCount); Issuance(_for, tokenCount); return true; } function burnTokens(address _for, uint tokenCount) external onlyMinter returns (bool) { if (tokenCount == 0) { return false; } if (sub(totalSupply, tokenCount) > totalSupply) { throw; } if (sub(balances[_for], tokenCount) > balances[_for]) { throw; } totalSupply = sub(totalSupply, tokenCount); balances[_for] = sub(balances[_for], tokenCount); Burn(_for, tokenCount); return true; } function changeMinter(address newAddress) public onlyFounder returns (bool) { minter = newAddress; } function changeFounder(address newAddress) public onlyFounder returns (bool) { founder = newAddress; } function () { throw; } function LATPToken() { founder = msg.sender; totalSupply = 0; // Update total supply } } "}
{"sol name": "43557.sol", "label": 0, "sol content": "pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract ChuCunLingAIGO is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; function ChuCunLingAIGO( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "24601.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // Original code of smart contract on github: // Standart libary from \"Open Zeppelin\" library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // Standart contract from \"Open Zeppelin\" contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant public returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // Standart contract from \"Open Zeppelin\" contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant public returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // Describing contract with owner. contract Owned { address public owner; address public newOwner; function Owned() public payable { owner = msg.sender; } modifier onlyOwner { require(owner == msg.sender); _; } function changeOwner(address _owner) onlyOwner public { require(_owner != 0); newOwner = _owner; } function confirmOwner() public { require(newOwner == msg.sender); owner = newOwner; delete newOwner; } } // Describing Bloccking modifier which founds on time block. contract Blocked { // Time till modifier block uint public blockedUntil; modifier unblocked { require(now > blockedUntil); _; } } // contract which discribes contract of token which founds on ERC20 and implement balanceOf function. contract BalancingToken is ERC20 { mapping (address => uint256) public balances;      //!< array of all balances function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } // Contract for dividend tokens. This contract describes implementation for tokens which can be used for dividends contract DividendToken is BalancingToken, Blocked, Owned { using SafeMath for uint256; // Event for dividends when somebody takes dividends it will raised. event DividendReceived(address indexed dividendReceiver, uint256 dividendValue); // mapping for alloweds and amounts. mapping (address => mapping (address => uint256)) public allowed; // full reward amount for one round. // this value is defined by ether amount on DividendToken contract on moment when dividend payments starts. uint public totalReward; // time when last time dividends started pay. uint public lastDivideRewardTime; // Fix for the ERC20 short address attack modifier onlyPayloadSize(uint size) { require(msg.data.length >= size + 4); _; } // This modifier checkes if reward payment is over. modifier rewardTimePast() { require(now > lastDivideRewardTime + rewardDays * 1 days); _; } // Structure is for Token holder which contains information about all token holders with balances and times. struct TokenHolder { uint256 balance; uint    balanceUpdateTime; uint    rewardWithdrawTime; } // mapping for token holders. mapping(address => TokenHolder) holders; // the number of days for rewards. uint public rewardDays = 0; // standard method for transfer from ERC20. function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) unblocked public returns (bool) { return transferSimple(_to, _value); } // internal implementation for transfer with recounting rewards. function transferSimple(address _to, uint256 _value) internal returns (bool) { beforeBalanceChanges(msg.sender); beforeBalanceChanges(_to); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } // standard method for transferFrom from ERC20. function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) unblocked public returns (bool) { beforeBalanceChanges(_from); beforeBalanceChanges(_to); uint256 _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } // standard method for transferFrom from ERC20. function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) unblocked public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } // standard method for transferFrom from ERC20. function allowance(address _owner, address _spender) onlyPayloadSize(2 * 32) unblocked constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } // THis method returns the amount of caller's reward. // Caller gets ether which should be given to him. function reward() constant public returns (uint256) { if (holders[msg.sender].rewardWithdrawTime >= lastDivideRewardTime) { return 0; } uint256 balance; if (holders[msg.sender].balanceUpdateTime <= lastDivideRewardTime) { balance = balances[msg.sender]; } else { balance = holders[msg.sender].balance; } return totalReward.mul(balance).div(totalSupply); } // This method shoud be called when caller wants take dividends reward. // Caller gets ether which should be given to him. function withdrawReward() public returns (uint256) { uint256 rewardValue = reward(); if (rewardValue == 0) { return 0; } if (balances[msg.sender] == 0) { // garbage collector delete holders[msg.sender]; } else { holders[msg.sender].rewardWithdrawTime = now; } require(msg.sender.call.gas(3000000).value(rewardValue)()); DividendReceived(msg.sender, rewardValue); return rewardValue; } // Divide up reward and make it accesible for withdraw // Need to provide the number of days for reward. It can be less then 15 days and more then 45 days. function divideUpReward(uint inDays) rewardTimePast onlyOwner external payable { require(inDays >= 15 && inDays <= 45); lastDivideRewardTime = now; rewardDays = inDays; totalReward = this.balance; } // Take left reward after reward period. function withdrawLeft() rewardTimePast onlyOwner external { require(msg.sender.call.gas(3000000).value(this.balance)()); } // recount reward of somebody. function beforeBalanceChanges(address _who) public { if (holders[_who].balanceUpdateTime <= lastDivideRewardTime) { holders[_who].balanceUpdateTime = now; holders[_who].balance = balances[_who]; } } } // Final contract for RENT coin. contract RENTCoin is DividendToken { string public constant name = \"RentAway Coin\"; string public constant symbol = \"RTW\"; uint32 public constant decimals = 18; function RENTCoin(uint256 initialSupply, uint unblockTime) public { totalSupply = initialSupply; balances[owner] = totalSupply; blockedUntil = unblockTime; Transfer(this, owner, totalSupply); } // Uses for overwork manual Blocked contract for ICO time. // After ICO it is not needed. function manualTransfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) onlyOwner public returns (bool) { return transferSimple(_to, _value); } } "}
{"sol name": "35182.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract owned { address public owner; function owned() { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract tokenRecipient { event receivedEther(address sender, uint amount); event receivedTokens(address _from, uint256 _value, address _token, bytes _extraData); function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData){ Token t = Token(_token); require(t.transferFrom(_from, this, _value)); receivedTokens(_from, _value, _token, _extraData); } function () payable { receivedEther(msg.sender, msg.value); } } contract Token { mapping (address => uint256) public balanceOf; function transferFrom(address _from, address _to, uint256 _value) returns (bool success); } contract Oryza is owned, tokenRecipient { uint public minimumQuorum; uint public debatingPeriodInMinutes; Proposal[] public proposals; uint public numProposals; Token public sharesTokenAddress; event ProposalAdded(uint proposalID, address recipient, uint amount, string description); event Voted(uint proposalID, bool position, address voter); event ProposalTallied(uint proposalID, uint result, uint quorum, bool active); event ChangeOfRules(uint newMinimumQuorum, uint newDebatingPeriodInMinutes, address newSharesTokenAddress); struct Proposal { address recipient; uint amount; string description; uint votingDeadline; bool executed; bool proposalPassed; uint numberOfVotes; bytes32 proposalHash; Vote[] votes; mapping (address => bool) voted; } struct Vote { bool inSupport; address voter; } modifier onlyShareholders { require(sharesTokenAddress.balanceOf(msg.sender) > 0); _; } function Oryza(Token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) payable { changeVotingRules(sharesAddress, minimumSharesToPassAVote, minutesForDebate); } function changeVotingRules(Token sharesAddress, uint minimumSharesToPassAVote, uint minutesForDebate) onlyOwner { sharesTokenAddress = Token(sharesAddress); if (minimumSharesToPassAVote == 0 ) minimumSharesToPassAVote = 1; minimumQuorum = minimumSharesToPassAVote; debatingPeriodInMinutes = minutesForDebate; ChangeOfRules(minimumQuorum, debatingPeriodInMinutes, sharesTokenAddress); } function newProposal( address beneficiary, uint weiAmount, string jobDescription, bytes transactionBytecode ) onlyShareholders returns (uint proposalID) { proposalID = proposals.length++; Proposal storage p = proposals[proposalID]; p.recipient = beneficiary; p.amount = weiAmount; p.description = jobDescription; p.proposalHash = sha3(beneficiary, weiAmount, transactionBytecode); p.votingDeadline = now + debatingPeriodInMinutes * 1 minutes; p.executed = false; p.proposalPassed = false; p.numberOfVotes = 0; ProposalAdded(proposalID, beneficiary, weiAmount, jobDescription); numProposals = proposalID+1; return proposalID; } function newProposalInEther( address beneficiary, uint etherAmount, string jobDescription, bytes transactionBytecode ) onlyShareholders returns (uint proposalID) { return newProposal(beneficiary, etherAmount * 1 ether, jobDescription, transactionBytecode); } function checkProposalCode( uint proposalNumber, address beneficiary, uint weiAmount, bytes transactionBytecode ) constant returns (bool codeChecksOut) { Proposal storage p = proposals[proposalNumber]; return p.proposalHash == sha3(beneficiary, weiAmount, transactionBytecode); } function vote( uint proposalNumber, bool supportsProposal ) onlyShareholders returns (uint voteID) { Proposal storage p = proposals[proposalNumber]; require(p.voted[msg.sender] != true); voteID = p.votes.length++; p.votes[voteID] = Vote({inSupport: supportsProposal, voter: msg.sender}); p.voted[msg.sender] = true; p.numberOfVotes = voteID +1; Voted(proposalNumber,  supportsProposal, msg.sender); return voteID; } function executeProposal(uint proposalNumber, bytes transactionBytecode) { Proposal storage p = proposals[proposalNumber]; require(now > p.votingDeadline && !p.executed && p.proposalHash == sha3(p.recipient, p.amount, transactionBytecode)); uint quorum = 0; uint yea = 0; uint nay = 0; for (uint i = 0; i <  p.votes.length; ++i) { Vote storage v = p.votes[i]; uint voteWeight = sharesTokenAddress.balanceOf(v.voter); quorum += voteWeight; if (v.inSupport) { yea += voteWeight; } else { nay += voteWeight; } } require(quorum >= minimumQuorum); if (yea > nay ) { p.executed = true; require(p.recipient.call.value(p.amount)(transactionBytecode)); p.proposalPassed = true; } else { p.proposalPassed = false; } ProposalTallied(proposalNumber, yea - nay, quorum, p.proposalPassed); } } "}
{"sol name": "332.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "21390.sol", "label": 1, "sol content": "contract Accrual_account { address admin = msg.sender; uint targetAmount = 1 ether; mapping(address => uint) public investors; event FundsMove(uint amount,bytes32 typeAct,address adr); function changeAdmin(address _new) { if(_new==0x0)throw; if(msg.sender!=admin)throw; admin=_new; } function FundTransfer(uint _am, bytes32 _operation, address _to, address _feeToAdr) payable { if(msg.sender != address(this)) throw; if(_operation==\"In\") { FundsMove(msg.value,\"In\",_to); investors[_to] += _am; } else { uint amTotransfer = 0; if(_to==_feeToAdr) { amTotransfer=_am; } else { amTotransfer=_am/100*99; investors[_feeToAdr]+=_am-amTotransfer; } if(_to.call.value(_am)()==false)throw; investors[_to] -= _am; FundsMove(_am, \"Out\", _to); } } function() payable { In(msg.sender); } function Out(uint amount) payable { if(investors[msg.sender]<targetAmount)throw; if(investors[msg.sender]<amount)throw; this.FundTransfer(amount,\"\",msg.sender,admin); } function In(address to) payable { if(to==0x0)to = admin; if(msg.sender!=tx.origin)throw; this.FundTransfer(msg.value, \"In\", to,admin); } } "}
{"sol name": "475.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "22485.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "32090.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "523.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "1030.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "22854.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "1076.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "670.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
{"sol name": "20821.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/interface/IBasicMultiToken.sol contract IBasicMultiToken is ERC20 { event Bundle(address indexed who, address indexed beneficiary, uint256 value); event Unbundle(address indexed who, address indexed beneficiary, uint256 value); function tokensCount() public view returns(uint256); function tokens(uint256 _index) public view returns(ERC20); function allTokens() public view returns(ERC20[]); function allDecimals() public view returns(uint8[]); function allBalances() public view returns(uint256[]); function allTokensDecimalsBalances() public view returns(ERC20[], uint8[], uint256[]); function bundleFirstTokens(address _beneficiary, uint256 _amount, uint256[] _tokenAmounts) public; function bundle(address _beneficiary, uint256 _amount) public; function unbundle(address _beneficiary, uint256 _value) public; function unbundleSome(address _beneficiary, uint256 _value, ERC20[] _tokens) public; } // File: contracts/interface/IMultiToken.sol contract IMultiToken is IBasicMultiToken { event Update(); event Change(address indexed _fromToken, address indexed _toToken, address indexed _changer, uint256 _amount, uint256 _return); function getReturn(address _fromToken, address _toToken, uint256 _amount) public view returns (uint256 returnAmount); function change(address _fromToken, address _toToken, uint256 _amount, uint256 _minReturn) public returns (uint256 returnAmount); function allWeights() public view returns(uint256[] _weights); function allTokensDecimalsBalancesWeights() public view returns(ERC20[] _tokens, uint8[] _decimals, uint256[] _balances, uint256[] _weights); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/SafeERC20.sol /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/ownership/CanReclaimToken.sol /** * @title Contracts that should be able to recover tokens * @author SylTi * @dev This allow a contract to recover any ERC20 token received in a contract by transferring the balance to the contract owner. * This will prevent any accidental loss of tokens. */ contract CanReclaimToken is Ownable { using SafeERC20 for ERC20Basic; /** * @dev Reclaim all ERC20Basic compatible tokens * @param token ERC20Basic The address of the token contract */ function reclaimToken(ERC20Basic token) external onlyOwner { uint256 balance = token.balanceOf(this); token.safeTransfer(owner, balance); } } // File: contracts/registry/MultiBuyer.sol contract MultiBuyer is CanReclaimToken { using SafeMath for uint256; function buy( IMultiToken _mtkn, uint256 _minimumReturn, ERC20 _throughToken, address[] _exchanges, bytes _datas, uint[] _datasIndexes, // including 0 and LENGTH values uint256[] _values ) public payable { require(_datasIndexes.length == _exchanges.length + 1, \"buy: _datasIndexes should start with 0 and end with LENGTH\"); require(_values.length == _exchanges.length, \"buy: _values should have the same length as _exchanges\"); for (uint i = 0; i < _exchanges.length; i++) { bytes memory data = new bytes(_datasIndexes[i + 1] - _datasIndexes[i]); for (uint j = _datasIndexes[i]; j < _datasIndexes[i + 1]; j++) { data[j - _datasIndexes[i]] = _datas[j]; } if (_throughToken != address(0) && i > 0) { _throughToken.approve(_exchanges[i], _throughToken.balanceOf(this)); } require(_exchanges[i].call.value(_values[i])(data), \"buy: exchange arbitrary call failed\"); if (_throughToken != address(0)) { _throughToken.approve(_exchanges[i], 0); } } j = _mtkn.totalSupply(); // optimization totalSupply uint256 bestAmount = uint256(-1); for (i = _mtkn.tokensCount(); i > 0; i--) { ERC20 token = _mtkn.tokens(i - 1); token.approve(_mtkn, token.balanceOf(this)); uint256 amount = j.mul(token.balanceOf(this)).div(token.balanceOf(_mtkn)); if (amount < bestAmount) { bestAmount = amount; } } require(bestAmount >= _minimumReturn, \"buy: return value is too low\"); _mtkn.bundle(msg.sender, bestAmount); if (address(this).balance > 0) { msg.sender.transfer(address(this).balance); } } } "}
