{"sol name": "38925_0.sol", "label": 0, "sol content": "contract TimeBank { struct Holder { uint fundsDeposited; uint withdrawTime; } mapping (address => Holder) holders; function getInfo() constant returns(uint,uint,uint){ return(holders[msg.sender].fundsDeposited,holders[msg.sender].withdrawTime,block.timestamp); } function depositFunds(uint _withdrawTime) payable returns (uint _fundsDeposited){ require(msg.value > 0 && _withdrawTime > block.timestamp && _withdrawTime < block.timestamp + 157680000); if (!(holders[msg.sender].withdrawTime > 0)) holders[msg.sender].withdrawTime = _withdrawTime; holders[msg.sender].fundsDeposited += msg.value; return msg.value; } function withdrawFunds() { } } "}
{"sol name": "28429_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract ERC20Token is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function ERC20Token( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "21252_0.sol", "label": 0, "sol content": "contract Token { string public symbol = \"\"; string public name = \"\"; uint8 public constant decimals = 18; uint256 _totalSupply = 0; address owner = 0; bool setupDone = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token(address adr) { owner = adr; } function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply) { if (msg.sender == owner && setupDone == false) { symbol = tokenSymbol; name = tokenName; _totalSupply = tokenSupply * 1000000000000000000; balances[owner] = _totalSupply; setupDone = true; } } function totalSupply() constant returns (uint256 totalSupply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "7027_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30067200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x975f289E9844F1EADCCc5B0E3ac83c4F1EC9f21a; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "32326_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "2225_0.sol", "label": 0, "sol content": "contract F3Devents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract modularShort is F3Devents {} contract F5D is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x4e369A53c989CE99475814aa0ad81Ad8eBE346E8); address private admin = 0xAbcd3976464519C648758233f6Fd19fecdf70Eb6; address private coin_base = 0xe2300D461B62c8482C21e6E77E6DDf3F5B902478; string constant public name = \"F5D\"; string constant public symbol = \"F5D\"; constructor() public { } modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } function() isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function withdraw() isActivated() isHuman() public { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { F3Ddatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function getBuyPrice() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); } function getTimeLeft() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { uint256 _rID = rID_; if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; return ( ); } function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( ); } function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { core(_rID, _pID, msg.value, _affID, _team, _eventData_); } else { if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); core(_rID, _pID, _eth, _affID, _team, _eventData_); } else if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000) { uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); } } function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); return ( (_eth).keys() ); } function iWantXKeys(uint256 _keys) public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); return ( (_keys).eth() ); } function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function determinePID(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; if (_pID == 0) { _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); plyr_[_pID].lrnd = rID_; _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); _com = _com.add(_p3d.sub(_p3d / 100 )); coin_base.transfer(_com); _res = _res.add(_p3d / 100); round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } function updateTimer(uint256 _keys, uint256 _rID) private { uint256 _now = now; uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(coin_base).call.value(_com)()) { _p3d = _com; _com = 0; } uint256 _aff = _eth / 100 * 17; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _p3d.add(_aff); } _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { uint256 _potAmount = _p3d / 2; coin_base.transfer(_p3d.sub(_potAmount)); round_[_rID].pot = round_[_rID].pot.add(_potAmount); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } function potSwap() external payable { uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F3Devents.onPotSwapDeposit(_rID, msg.value); } function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; uint256 _air = (_eth / 100); airDropPot_ = airDropPot_.add(_air); _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100)); uint256 _pot = _eth.sub(_gen); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } function withdrawEarnings(uint256 _pID) private returns(uint256) { updateGenVault(_pID, plyr_[_pID].lrnd); uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } bool public activated_ = false; function activate() public { require(msg.sender == admin, \"only admin can activate\"); require(activated_ == false, \"FOMO Short already activated\"); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } library F3Ddatasets { struct EventReturns { uint256 compressedData; uint256 compressedIDs; } struct Player { } struct PlayerRounds { } struct Round { } struct TeamFee { } struct PotSplit { } } library F3DKeysCalcShort { using SafeMath for *; function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } bool _hasNonNumber; for (uint256 i = 0; i < _length; i++) { if (_temp[i] > 0x40 && _temp[i] < 0x5b) { _temp[i] = byte(uint(_temp[i]) + 32); if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( _temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "14754_0.sol", "label": 0, "sol content": "contract Ownable { address private owner; constructor() public { owner = msg.sender; } modifier onlyOwner() { require( msg.sender == owner, 'Only the administrator can change this' ); _; } } contract Blockchainedlove is Ownable { string public partner_1_name; string public partner_2_name; string public contract_date; bool public is_active; constructor() public { partner_1_name = 'Andrii Shekhirev'; partner_2_name = 'Inga Berkovica'; contract_date = '23 June 2009'; is_active = true; } function updateStatus(bool _status) public onlyOwner { is_active = _status; emit StatusChanged(is_active); } event StatusChanged(bool NewStatus); } "}
{"sol name": "14751_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract TokenContract is MintableToken { uint8 public decimals      = 18; } contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } contract Crowdsale { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public { require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } function createTokenContract() internal returns (MintableToken) { return new MintableToken(); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function forwardFunds() internal { wallet.transfer(msg.value); } function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } function hasEnded() public view returns (bool) { return now > endTime; } } contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } function finalization() internal { } } contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } function validPurchase() internal view returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } function hasEnded() public view returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; RefundVault public vault; function RefundableCrowdsale(uint256 _goal) public { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; } function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public view returns (bool) { return weiRaised >= goal; } } contract NacContract is CappedCrowdsale, RefundableCrowdsale { uint8 public decimals = 18; event EthTransferred(string text); event EthRefunded(string text); function NacContract(            uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _goal, uint256 _cap) CappedCrowdsale(_cap*10**18) FinalizableCrowdsale() RefundableCrowdsale(_goal*10**18) Crowdsale(_startTime, _endTime, _rate, _wallet) public { require(_goal <= _cap); } function createTokenContract() internal returns (MintableToken) { } function mintBountytokens(address _bountyWallet) public onlyOwner { token.mint(_bountyWallet,tokensBounty); } function setCurrentRate(uint256 _rate)  public onlyOwner { rate = _rate; } function setNewStartTime(uint256 _startTime) public onlyOwner { startTime = _startTime; } function setNewEndTime(uint256 _endTime) public onlyOwner { endTime = _endTime; } function () external payable { uint256 mintAfterPurchase = msg.value.mul(rate); if ((token.totalSupply() + mintAfterPurchase > totalTokensForSale)) { EthRefunded(\"sale Limit Hit\"); return; } buyTokens(msg.sender); } function forwardFunds() internal { EthTransferred(\"Pushing funds to smartEscrow\"); super.forwardFunds(); } function finish(address _teamFund, address _airdropFund) public onlyOwner { require(!isFinalized); uint256 alreadyMintedTokens = token.totalSupply(); require(alreadyMintedTokens < maxTokens); uint256 unsoldTokens = totalTokensForSale - alreadyMintedTokens; if (unsoldTokens > 0) { tokensAirdrop = tokensAirdrop + unsoldTokens; } token.mint(_airdropFund,tokensAirdrop); token.mint(_teamFund,tokensForTeam); finalize(); } function showTokenBalance(address sender) public constant returns (uint) { return token.balanceOf(sender); } function getWeiRaised() public constant returns (uint) { return weiRaised; } } "}
{"sol name": "6119_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 28944000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x975841C1d15578a509AC5Bcc1cBF9a08115527e9; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "25031_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract Illuminati is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function Illuminati( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "25501_0.sol", "label": 0, "sol content": "contract Token{ uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "34560_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract AbstractStarbaseToken { function isFundraiser(address fundraiserAddress) public returns (bool); function company() public returns (address); function allocateToCrowdsalePurchaser(address to, uint256 value) public returns (bool); function allocateToMarketingSupporter(address to, uint256 value) public returns (bool); } contract AbstractStarbaseCrowdsale { function startDate() constant returns (uint256) {} function endedAt() constant returns (uint256) {} function isEnded() constant returns (bool); function totalRaisedAmountInCny() constant returns (uint256); function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256); function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256); } contract StarbaseEarlyPurchase { uint public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; } AbstractStarbaseCrowdsale public starbaseCrowdsale; address public owner; EarlyPurchase[] public earlyPurchases; uint public earlyPurchaseClosedAt; modifier noEther() { if (msg.value > 0) { throw; } _; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } modifier onlyBeforeCrowdsale() { if (address(starbaseCrowdsale) != 0 && starbaseCrowdsale.startDate() > 0) { throw; } _; } modifier onlyEarlyPurchaseTerm() { if (earlyPurchaseClosedAt > 0) { throw; } _; } function purchasedAmountBy(address purchaser) external constant noEther returns (uint amount) { for (uint i; i < earlyPurchases.length; i++) { if (earlyPurchases[i].purchaser == purchaser) { amount += earlyPurchases[i].amount; } } } function totalAmountOfEarlyPurchases() constant noEther returns (uint totalAmount) { for (uint i; i < earlyPurchases.length; i++) { totalAmount += earlyPurchases[i].amount; } } function numberOfEarlyPurchases() external constant noEther returns (uint) { return earlyPurchases.length; } function appendEarlyPurchase(address purchaser, uint amount, uint purchasedAt) external noEther onlyOwner onlyBeforeCrowdsale onlyEarlyPurchaseTerm returns (bool) { if (amount == 0 || totalAmountOfEarlyPurchases() + amount > PURCHASE_AMOUNT_CAP) { return false; } if (purchasedAt == 0 || purchasedAt > now) { throw; } earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt)); return true; } function closeEarlyPurchase() external noEther onlyOwner returns (bool) { earlyPurchaseClosedAt = now; } function setup(address starbaseCrowdsaleAddress) external noEther onlyOwner returns (bool) { if (address(starbaseCrowdsale) == 0) { starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress); return true; } return false; } function StarbaseEarlyPurchase() noEther { owner = msg.sender; } function () { throw; } } contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint epIdx); event EarlyPurchaseAmended(uint epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint[] public invalidEarlyPurchaseIndexes; uint[] public amendedEarlyPurchaseIndexes; mapping (uint => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { if (msg.value > 0) { throw; } _; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } modifier onlyBeforeCrowdsale() { if (address(starbaseCrowdsale) != 0 && starbaseCrowdsale.startDate() > 0) { throw; } _; } modifier onlyEarlyPurchasesLoaded() { if (address(starbaseEarlyPurchase) == 0) { throw; } _; } function earlyPurchases(uint earlyPurchaseIndex) external constant onlyEarlyPurchasesLoaded returns (address purchaser, uint amount, uint purchasedAt) { return starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex); } function purchasedAmountBy(address purchaser) external constant noEther returns (uint amount) { StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP = normalizedEarlyPurchases(); for (uint i; i < normalizedEP.length; i++) { if (normalizedEP[i].purchaser == purchaser) { amount += normalizedEP[i].amount; } } } function totalAmountOfEarlyPurchases() constant noEther returns (uint totalAmount) { StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP = normalizedEarlyPurchases(); for (uint i; i < normalizedEP.length; i++) { totalAmount += normalizedEP[i].amount; } } function numberOfEarlyPurchases() external constant noEther returns (uint) { return normalizedEarlyPurchases().length; } function setup(address starbaseCrowdsaleAddress) external noEther onlyOwner returns (bool) { if (address(starbaseCrowdsale) == 0) { starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress); return true; } return false; } function invalidateEarlyPurchase(uint earlyPurchaseIndex) external noEther onlyOwner onlyEarlyPurchasesLoaded onlyBeforeCrowdsale returns (bool) { if (numberOfRawEarlyPurchases() <= earlyPurchaseIndex) { } for (uint i; i < invalidEarlyPurchaseIndexes.length; i++) { if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { } } invalidEarlyPurchaseIndexes.push(earlyPurchaseIndex); EarlyPurchaseInvalidated(earlyPurchaseIndex); return true; } function isInvalidEarlyPurchase(uint earlyPurchaseIndex) constant noEther returns (bool) { if (numberOfRawEarlyPurchases() <= earlyPurchaseIndex) { } for (uint i; i < invalidEarlyPurchaseIndexes.length; i++) { if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { return true; } } return false; } function amendEarlyPurchase(uint earlyPurchaseIndex, address purchaser, uint amount, uint purchasedAt) external noEther onlyOwner onlyEarlyPurchasesLoaded onlyBeforeCrowdsale returns (bool) { if (purchasedAt == 0 || purchasedAt > now) { throw; } if (numberOfRawEarlyPurchases() <= earlyPurchaseIndex) { } if (isInvalidEarlyPurchase(earlyPurchaseIndex)) { } if (!isAmendedEarlyPurchase(earlyPurchaseIndex)) { amendedEarlyPurchaseIndexes.push(earlyPurchaseIndex); } amendedEarlyPurchases[earlyPurchaseIndex] = StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt); EarlyPurchaseAmended(earlyPurchaseIndex); return true; } function isAmendedEarlyPurchase(uint earlyPurchaseIndex) constant noEther returns (bool) { if (numberOfRawEarlyPurchases() <= earlyPurchaseIndex) { } for (uint i; i < amendedEarlyPurchaseIndexes.length; i++) { if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { return true; } } return false; } function loadStarbaseEarlyPurchases(address starbaseEarlyPurchaseAddress) external noEther onlyOwner onlyBeforeCrowdsale returns (bool) { if (starbaseEarlyPurchaseAddress == 0 || address(starbaseEarlyPurchase) != 0) { throw; } starbaseEarlyPurchase = StarbaseEarlyPurchase(starbaseEarlyPurchaseAddress); if (starbaseEarlyPurchase.earlyPurchaseClosedAt() == 0) { } return true; } function StarbaseEarlyPurchaseAmendment() noEther { owner = msg.sender; } function () { throw; } function normalizedEarlyPurchases() constant internal returns (StarbaseEarlyPurchase.EarlyPurchase[] normalizedEP) { uint rawEPCount = numberOfRawEarlyPurchases(); normalizedEP = new StarbaseEarlyPurchase.EarlyPurchase[]( rawEPCount - invalidEarlyPurchaseIndexes.length); uint normalizedIdx; for (uint i; i < rawEPCount; i++) { if (isInvalidEarlyPurchase(i)) { } StarbaseEarlyPurchase.EarlyPurchase memory ep; if (isAmendedEarlyPurchase(i)) { } else { ep = getEarlyPurchase(i); } normalizedEP[normalizedIdx] = ep; normalizedIdx++; } } function getEarlyPurchase(uint earlyPurchaseIndex) internal constant onlyEarlyPurchasesLoaded returns (StarbaseEarlyPurchase.EarlyPurchase) { var (purchaser, amount, purchasedAt) = starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex); return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt); } function numberOfRawEarlyPurchases() internal constant onlyEarlyPurchasesLoaded returns (uint) { return starbaseEarlyPurchase.numberOfEarlyPurchases(); } } contract Certifier { event Confirmed(address indexed who); event Revoked(address indexed who); function certified(address) public constant returns (bool); function get(address, string) public constant returns (bytes32); function getAddress(address, string) public constant returns (address); function getUint(address, string) public constant returns (uint); } contract StarbaseCrowdsale is Ownable { using SafeMath for uint256; event CrowdsaleEnded(uint256 endedAt); event StarbasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate); event CnyEthRateUpdated(uint256 cnyEthRate); event CnyBtcRateUpdated(uint256 cnyBtcRate); event QualifiedPartnerAddress(address qualifiedPartner); AbstractStarbaseToken public starbaseToken; StarbaseEarlyPurchaseAmendment public starbaseEpAmendment; Certifier public picopsCertifier; uint256 constant public crowdsaleTokenAmount = 125000000e18; uint256 constant public earlyPurchaseTokenAmount = 50000000e18; struct CrowdsalePurchase { address purchaser; } struct QualifiedPartners { uint256 amountCap; uint256 amountRaised; bool    bonaFide; } enum BonusMilestones { First, Second, Third, Fourth, Fifth } BonusMilestones public bonusMilestones = BonusMilestones.First; address[] public earlyPurchasers; mapping (address => QualifiedPartners) public qualifiedPartners; uint256 public startDate; uint256 public endedAt; CrowdsalePurchase[] public crowdsalePurchases; uint256 public cnyEthRate; uint256 public firstBonusEnds; uint256 public secondBonusEnds; uint256 public thirdBonusEnds; uint256 public fourthBonusEnds; modifier minInvestment() { assert(msg.value >= MIN_INVESTMENT); _; } modifier whenEnded() { assert(isEnded()); _; } modifier hasBalance() { assert(this.balance > 0); _; } modifier rateIsSet(uint256 _rate) { assert(_rate != 0); _; } modifier whenNotEnded() { assert(!isEnded()); _; } modifier tokensNotDelivered() { assert(numOfDeliveredCrowdsalePurchases == 0); assert(numOfDeliveredEarlyPurchases == 0); _; } modifier onlyFundraiser() { assert(address(starbaseToken) != 0); assert(starbaseToken.isFundraiser(msg.sender)); _; } modifier onlyQualifiedPartner() { assert(qualifiedPartners[msg.sender].bonaFide); _; } modifier onlyQualifiedPartnerORPicopsCertified() { assert(qualifiedPartners[msg.sender].bonaFide || picopsCertifier.certified(msg.sender)); _; } function StarbaseCrowdsale(address starbaseEpAddr, address picopsCertifierAddr) { require(starbaseEpAddr != 0 && picopsCertifierAddr != 0); owner = msg.sender; starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseEpAddr); picopsCertifier = Certifier(picopsCertifierAddr); } function() payable { redirectToPurchase(); } function setup(address starbaseTokenAddress, uint256 _purchaseStartBlock) external onlyOwner returns (bool) { require(starbaseTokenAddress != address(0)); require(address(starbaseToken) == 0); starbaseToken = AbstractStarbaseToken(starbaseTokenAddress); purchaseStartBlock = _purchaseStartBlock; maxCrowdsaleCap = MAX_CAP.sub(totalAmountOfEarlyPurchasesWithoutBonus()); assert(maxCrowdsaleCap > 0); return true; } function withdrawForCompany() external onlyFundraiser hasBalance { address company = starbaseToken.company(); require(company != address(0)); company.transfer(this.balance); } function updateCnyEthRate(uint256 rate) external onlyFundraiser returns (bool) { cnyEthRate = rate; CnyEthRateUpdated(cnyEthRate); return true; } function updateCnyBtcRate(uint256 rate) external onlyFundraiser returns (bool) { cnyBtcRate = rate; CnyBtcRateUpdated(cnyBtcRate); return true; } function ownerStartsCrowdsale(uint256 timestamp) external onlyOwner { startCrowdsale(timestamp); } function endCrowdsale(uint256 timestamp) external onlyOwner { assert(timestamp > 0 && timestamp <= now); endedAt = timestamp; totalAmountOfEarlyPurchasesInCny = totalAmountOfEarlyPurchasesWithBonus(); totalAmountOfPurchasesInCny = totalRaisedAmountInCny(); CrowdsaleEnded(endedAt); } function withdrawPurchasedTokens() external whenEnded returns (bool) { assert(earlyPurchasesLoaded); assert(address(starbaseToken) != 0); if (crowdsalePurchaseAmountBy[msg.sender] > 0) { uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender]; crowdsalePurchaseAmountBy[msg.sender] = 0; uint256 tokenCount = SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) / totalAmountOfPurchasesInCny; numOfPurchasedTokensOnCsBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount)); numOfDeliveredCrowdsalePurchases++; } uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender]; earlyPurchasedAmountBy[msg.sender] = 0; uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchasesInCny; uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfPurchasesInCny; uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount); numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount)); numOfDeliveredEarlyPurchases++; } return true; } function loadEarlyPurchases() external onlyOwner returns (bool) { if (earlyPurchasesLoaded) { } uint256 numOfOrigEp = starbaseEpAmendment .starbaseEarlyPurchase() .numberOfEarlyPurchases(); for (uint256 i = numOfLoadedEarlyPurchases; i < numOfOrigEp && msg.gas > 200000; i++) { if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) { numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1); continue; } var (purchaser, amount,) = starbaseEpAmendment.isAmendedEarlyPurchase(i) ? starbaseEpAmendment.amendedEarlyPurchases(i) : starbaseEpAmendment.earlyPurchases(i); if (amount > 0) { if (earlyPurchasedAmountBy[purchaser] == 0) { earlyPurchasers.push(purchaser); } uint256 bonus = SafeMath.mul(amount, 20) / 100; uint256 amountWithBonus = SafeMath.add(amount, bonus); earlyPurchasedAmountBy[purchaser] = SafeMath.add(earlyPurchasedAmountBy[purchaser], amountWithBonus); } numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1); } assert(numOfLoadedEarlyPurchases <= numOfOrigEp); if (numOfLoadedEarlyPurchases == numOfOrigEp) { } return true; } function setQualifiedPartner(address _qualifiedPartner, uint256 _amountCap, uint256 _commissionFeePercentage) external onlyOwner { assert(!qualifiedPartners[_qualifiedPartner].bonaFide); qualifiedPartners[_qualifiedPartner].bonaFide = true; qualifiedPartners[_qualifiedPartner].amountCap = _amountCap; qualifiedPartners[_qualifiedPartner].commissionFeePercentage = _commissionFeePercentage; QualifiedPartnerAddress(_qualifiedPartner); } function unlistQualifiedPartner(address _qualifiedPartner) external onlyOwner { assert(qualifiedPartners[_qualifiedPartner].bonaFide); qualifiedPartners[_qualifiedPartner].bonaFide = false; } function updateQualifiedPartnerCapAmount(address _qualifiedPartner, uint256 _amountCap) external onlyOwner { assert(qualifiedPartners[_qualifiedPartner].bonaFide); qualifiedPartners[_qualifiedPartner].amountCap = _amountCap; } function isEnded() constant public returns (bool) { return (endedAt > 0 && endedAt <= now); } function numOfPurchases() constant public returns (uint256) { return crowdsalePurchases.length; } function totalAmountOfCrowdsalePurchases() constant public returns (uint256 amount) { for (uint256 i; i < crowdsalePurchases.length; i++) { amount = SafeMath.add(amount, crowdsalePurchases[i].amount); } } function totalAmountOfCrowdsalePurchasesWithoutBonus() constant public returns (uint256 amount) { for (uint256 i; i < crowdsalePurchases.length; i++) { amount = SafeMath.add(amount, crowdsalePurchases[i].rawAmount); } } function totalRaisedAmountInCny() constant public returns (uint256) { return SafeMath.add(totalAmountOfEarlyPurchasesWithBonus(), totalAmountOfCrowdsalePurchases()); } function totalAmountOfEarlyPurchasesWithBonus() constant public returns(uint256) { return starbaseEpAmendment.totalAmountOfEarlyPurchases().mul(120).div(100); } function totalAmountOfEarlyPurchasesWithoutBonus() constant public returns(uint256) { return starbaseEpAmendment.totalAmountOfEarlyPurchases(); } function purchaseAsQualifiedPartner() payable public rateIsSet(cnyEthRate) onlyQualifiedPartner returns (bool) { require(msg.value > 0); qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised); assert(qualifiedPartners[msg.sender].amountRaised <= qualifiedPartners[msg.sender].amountCap); uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18; recordPurchase(msg.sender, rawAmount, now); if (qualifiedPartners[msg.sender].commissionFeePercentage > 0) { sendQualifiedPartnerCommissionFee(msg.sender, msg.value); } return true; } function purchaseWithEth() payable public minInvestment whenNotEnded rateIsSet(cnyEthRate) onlyQualifiedPartnerORPicopsCertified returns (bool) { require(purchaseStartBlock > 0 && block.number >= purchaseStartBlock); if (startDate == 0) { startCrowdsale(block.timestamp); } uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18; recordPurchase(msg.sender, rawAmount, now); return true; } function startCrowdsale(uint256 timestamp) internal { startDate = timestamp; uint256 presaleAmount = totalAmountOfCrowdsalePurchasesWithoutBonus(); if (maxCrowdsaleCap > presaleAmount) { uint256 mainSaleCap = maxCrowdsaleCap.sub(presaleAmount); uint256 twentyPercentOfCrowdsalePurchase = mainSaleCap.mul(20).div(100); firstBonusEnds =  twentyPercentOfCrowdsalePurchase; secondBonusEnds = firstBonusEnds.add(twentyPercentOfCrowdsalePurchase); thirdBonusEnds =  secondBonusEnds.add(twentyPercentOfCrowdsalePurchase); fourthBonusEnds = thirdBonusEnds.add(twentyPercentOfCrowdsalePurchase); } } function recordPurchase( address purchaser, uint256 rawAmount, uint256 timestamp ) internal returns(uint256 amount) { if (block.number >= purchaseStartBlock) { uint256 crowdsaleTotalAmountAfterPurchase = SafeMath.add(totalAmountOfCrowdsalePurchasesWithoutBonus(), amount); if (crowdsaleTotalAmountAfterPurchase > maxCrowdsaleCap) { uint256 difference = SafeMath.sub(crowdsaleTotalAmountAfterPurchase, maxCrowdsaleCap); uint256 ethValueToReturn = SafeMath.mul(difference, 1e18) / cnyEthRate; purchaser.transfer(ethValueToReturn); amount = SafeMath.sub(amount, difference); rawAmount = amount; } } CrowdsalePurchase memory purchase = CrowdsalePurchase(purchaser, amount, rawAmount, timestamp); crowdsalePurchases.push(purchase); StarbasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate); crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount); return amount; } function calculateBonus ( BonusMilestones nextMilestone, uint256 amount, uint256 bonusRange, uint256 bonusTier, uint256 results ) internal returns (uint256 result, uint256 newAmount) { uint256 bonusCalc; if (amount <= bonusRange) { bonusCalc = amount.mul(bonusTier).div(100); if (amount.add(totalAmountOfCrowdsalePurchasesWithoutBonus()) >= bonusRange) bonusMilestones = nextMilestone; result = results.add(amount).add(bonusCalc); newAmount = 0; } else { bonusCalc = bonusRange.mul(bonusTier).div(100); bonusMilestones = nextMilestone; result = results.add(bonusRange).add(bonusCalc); newAmount = amount.sub(bonusRange); } } function getBonusAmountCalculation(uint256 amount) internal returns (uint256) { if (block.number < purchaseStartBlock) { return amount.add(bonusFromAmount); } uint256 firstBonusRange = firstBonusEnds; uint256 secondBonusRange = secondBonusEnds.sub(firstBonusEnds); uint256 thirdBonusRange = thirdBonusEnds.sub(secondBonusEnds); uint256 fourthBonusRange = fourthBonusEnds.sub(thirdBonusEnds); uint256 result; if (bonusMilestones == BonusMilestones.First) (result, amount) = calculateBonus(BonusMilestones.Second, amount, firstBonusRange, 20, result); if (bonusMilestones == BonusMilestones.Second) (result, amount) = calculateBonus(BonusMilestones.Third, amount, secondBonusRange, 15, result); if (bonusMilestones == BonusMilestones.Third) (result, amount) = calculateBonus(BonusMilestones.Fourth, amount, thirdBonusRange, 10, result); if (bonusMilestones == BonusMilestones.Fourth) (result, amount) = calculateBonus(BonusMilestones.Fifth, amount, fourthBonusRange, 5, result); return result.add(amount); } function sendQualifiedPartnerCommissionFee(address qualifiedPartner, uint256 amountSent) internal { uint256 commissionFeePercentageCalculationAmount = SafeMath.mul(amountSent, qualifiedPartners[qualifiedPartner].commissionFeePercentage) / 100; qualifiedPartner.transfer(commissionFeePercentageCalculationAmount); } function redirectToPurchase() internal { if (block.number < purchaseStartBlock) { purchaseAsQualifiedPartner(); } else { purchaseWithEth(); } } } "}
{"sol name": "36258_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract AbstractStarbaseToken { function isFundraiser(address fundraiserAddress) public returns (bool); function company() public returns (address); function allocateToCrowdsalePurchaser(address to, uint256 value) public returns (bool); function allocateToMarketingSupporter(address to, uint256 value) public returns (bool); } contract AbstractStarbaseCrowdsale { function startDate() constant returns (uint256) {} function endedAt() constant returns (uint256) {} function isEnded() constant returns (bool); function totalRaisedAmountInCny() constant returns (uint256); function numOfPurchasedTokensOnCsBy(address purchaser) constant returns (uint256); function numOfPurchasedTokensOnEpBy(address purchaser) constant returns (uint256); } contract StarbaseEarlyPurchase { uint256 public constant PURCHASE_AMOUNT_CAP = 9000000; struct EarlyPurchase { address purchaser; } AbstractStarbaseCrowdsale public starbaseCrowdsale; address public owner; EarlyPurchase[] public earlyPurchases; uint256 public earlyPurchaseClosedAt; modifier noEther() { require(msg.value == 0); _; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyBeforeCrowdsale() { assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0); _; } modifier onlyEarlyPurchaseTerm() { assert(earlyPurchaseClosedAt <= 0); _; } function purchasedAmountBy(address purchaser) external constant noEther returns (uint256 amount) { for (uint256 i; i < earlyPurchases.length; i++) { if (earlyPurchases[i].purchaser == purchaser) { amount += earlyPurchases[i].amount; } } } function totalAmountOfEarlyPurchases() constant noEther public returns (uint256 totalAmount) { for (uint256 i; i < earlyPurchases.length; i++) { totalAmount += earlyPurchases[i].amount; } } function numberOfEarlyPurchases() external constant noEther returns (uint256) { return earlyPurchases.length; } function appendEarlyPurchase(address purchaser, uint256 amount, uint256 purchasedAt) external noEther onlyOwner onlyBeforeCrowdsale onlyEarlyPurchaseTerm returns (bool) { if (amount == 0 || totalAmountOfEarlyPurchases() + amount > PURCHASE_AMOUNT_CAP) { return false; } assert(purchasedAt != 0 || purchasedAt <= now); earlyPurchases.push(EarlyPurchase(purchaser, amount, purchasedAt)); return true; } function closeEarlyPurchase() external noEther onlyOwner returns (bool) { earlyPurchaseClosedAt = now; } function setup(address starbaseCrowdsaleAddress) external noEther onlyOwner returns (bool) { if (address(starbaseCrowdsale) == 0) { starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress); return true; } return false; } function StarbaseEarlyPurchase() noEther { owner = msg.sender; } } contract StarbaseEarlyPurchaseAmendment { event EarlyPurchaseInvalidated(uint256 epIdx); event EarlyPurchaseAmended(uint256 epIdx); AbstractStarbaseCrowdsale public starbaseCrowdsale; StarbaseEarlyPurchase public starbaseEarlyPurchase; address public owner; uint256[] public invalidEarlyPurchaseIndexes; uint256[] public amendedEarlyPurchaseIndexes; mapping (uint256 => StarbaseEarlyPurchase.EarlyPurchase) public amendedEarlyPurchases; modifier noEther() { require(msg.value == 0); _; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyBeforeCrowdsale() { assert(address(starbaseCrowdsale) == address(0) || starbaseCrowdsale.startDate() == 0); _; } modifier onlyEarlyPurchasesLoaded() { assert(address(starbaseEarlyPurchase) != address(0)); _; } function earlyPurchases(uint256 earlyPurchaseIndex) external constant onlyEarlyPurchasesLoaded returns (address purchaser, uint256 amount, uint256 purchasedAt) { return starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex); } function purchasedAmountBy(address purchaser) external constant noEther returns (uint256 amount) { StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP = normalizedEarlyPurchases(); for (uint256 i; i < normalizedEP.length; i++) { if (normalizedEP[i].purchaser == purchaser) { amount += normalizedEP[i].amount; } } } function totalAmountOfEarlyPurchases() constant noEther public returns (uint256 totalAmount) { StarbaseEarlyPurchase.EarlyPurchase[] memory normalizedEP = normalizedEarlyPurchases(); for (uint256 i; i < normalizedEP.length; i++) { totalAmount += normalizedEP[i].amount; } } function numberOfEarlyPurchases() external constant noEther returns (uint256) { return normalizedEarlyPurchases().length; } function setup(address starbaseCrowdsaleAddress) external noEther onlyOwner returns (bool) { if (address(starbaseCrowdsale) == 0) { starbaseCrowdsale = AbstractStarbaseCrowdsale(starbaseCrowdsaleAddress); return true; } return false; } function invalidateEarlyPurchase(uint256 earlyPurchaseIndex) external noEther onlyOwner onlyEarlyPurchasesLoaded onlyBeforeCrowdsale returns (bool) { for (uint256 i; i < invalidEarlyPurchaseIndexes.length; i++) { assert(invalidEarlyPurchaseIndexes[i] != earlyPurchaseIndex); } invalidEarlyPurchaseIndexes.push(earlyPurchaseIndex); EarlyPurchaseInvalidated(earlyPurchaseIndex); return true; } function isInvalidEarlyPurchase(uint256 earlyPurchaseIndex) constant noEther public returns (bool) { for (uint256 i; i < invalidEarlyPurchaseIndexes.length; i++) { if (invalidEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { return true; } } return false; } function amendEarlyPurchase(uint256 earlyPurchaseIndex, address purchaser, uint256 amount, uint256 purchasedAt) external noEther onlyOwner onlyEarlyPurchasesLoaded onlyBeforeCrowdsale returns (bool) { assert(purchasedAt != 0 || purchasedAt <= now); assert(numberOfRawEarlyPurchases() > earlyPurchaseIndex); if (!isAmendedEarlyPurchase(earlyPurchaseIndex)) { amendedEarlyPurchaseIndexes.push(earlyPurchaseIndex); } amendedEarlyPurchases[earlyPurchaseIndex] = StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt); EarlyPurchaseAmended(earlyPurchaseIndex); return true; } function isAmendedEarlyPurchase(uint256 earlyPurchaseIndex) constant noEther returns (bool) { for (uint256 i; i < amendedEarlyPurchaseIndexes.length; i++) { if (amendedEarlyPurchaseIndexes[i] == earlyPurchaseIndex) { return true; } } return false; } function loadStarbaseEarlyPurchases(address starbaseEarlyPurchaseAddress) external noEther onlyOwner onlyBeforeCrowdsale returns (bool) { assert(starbaseEarlyPurchaseAddress != 0 || address(starbaseEarlyPurchase) == 0); starbaseEarlyPurchase = StarbaseEarlyPurchase(starbaseEarlyPurchaseAddress); return true; } function StarbaseEarlyPurchaseAmendment() noEther { owner = msg.sender; } function normalizedEarlyPurchases() constant internal returns (StarbaseEarlyPurchase.EarlyPurchase[] normalizedEP) { uint256 rawEPCount = numberOfRawEarlyPurchases(); normalizedEP = new StarbaseEarlyPurchase.EarlyPurchase[]( rawEPCount - invalidEarlyPurchaseIndexes.length); uint256 normalizedIdx; for (uint256 i; i < rawEPCount; i++) { if (isInvalidEarlyPurchase(i)) { } StarbaseEarlyPurchase.EarlyPurchase memory ep; if (isAmendedEarlyPurchase(i)) { } else { ep = getEarlyPurchase(i); } normalizedEP[normalizedIdx] = ep; normalizedIdx++; } } function getEarlyPurchase(uint256 earlyPurchaseIndex) internal constant onlyEarlyPurchasesLoaded returns (StarbaseEarlyPurchase.EarlyPurchase) { var (purchaser, amount, purchasedAt) = starbaseEarlyPurchase.earlyPurchases(earlyPurchaseIndex); return StarbaseEarlyPurchase.EarlyPurchase(purchaser, amount, purchasedAt); } function numberOfRawEarlyPurchases() internal constant onlyEarlyPurchasesLoaded returns (uint256) { return starbaseEarlyPurchase.numberOfEarlyPurchases(); } } contract StarbaseCrowdsale is Ownable { event CrowdsaleEnded(uint256 endedAt); event StarbasePurchasedWithEth(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyEthRate, uint256 bonusTokensPercentage); event StarbasePurchasedOffChain(address purchaser, uint256 amount, uint256 rawAmount, uint256 cnyBtcRate, uint256 bonusTokensPercentage, string data); event CnyEthRateUpdated(uint256 cnyEthRate); event CnyBtcRateUpdated(uint256 cnyBtcRate); event QualifiedPartnerAddress(address qualifiedPartner); AbstractStarbaseToken public starbaseToken; StarbaseEarlyPurchaseAmendment public starbaseEpAmendment; uint256 constant public crowdsaleTokenAmount = 125000000e18; uint256 constant public earlyPurchaseTokenAmount = 50000000e18; struct CrowdsalePurchase { address purchaser; uint256 bonus; } struct QualifiedPartners { uint256 amountCap; uint256 amountRaised; bool    bonaFide; } address[] public earlyPurchasers; uint256 public totalAmountOfEarlyPurchasesInCny; mapping (address => QualifiedPartners) public qualifiedPartners; uint256 public startDate; uint256 public endedAt; CrowdsalePurchase[] public crowdsalePurchases; uint256 public cnyEthRate; uint256 public firstBonusSalesEnds; uint256 public secondBonusSalesEnds; uint256 public thirdBonusSalesEnds; uint256 public fourthBonusSalesEnds; uint256 public fifthBonusSalesEnds; uint256 public firstExtendedBonusSalesEnds; uint256 public secondExtendedBonusSalesEnds; uint256 public thirdExtendedBonusSalesEnds; uint256 public fourthExtendedBonusSalesEnds; uint256 public fifthExtendedBonusSalesEnds; uint256 public sixthExtendedBonusSalesEnds; modifier minInvestment() { assert(msg.value >= MIN_INVESTMENT); _; } modifier whenEnded() { assert(isEnded()); _; } modifier hasBalance() { assert(this.balance > 0); _; } modifier rateIsSet(uint256 _rate) { assert(_rate != 0); _; } modifier whenNotEnded() { assert(!isEnded()); _; } modifier tokensNotDelivered() { assert(numOfDeliveredCrowdsalePurchases == 0); assert(numOfDeliveredEarlyPurchases == 0); _; } modifier onlyFundraiser() { assert(address(starbaseToken) != 0); assert(starbaseToken.isFundraiser(msg.sender)); _; } function StarbaseCrowdsale(address starbaseEpAddr) { require(starbaseEpAddr != 0); owner = msg.sender; starbaseEpAmendment = StarbaseEarlyPurchaseAmendment(starbaseEpAddr); } function() payable { redirectToPurchase(); } function setup(address starbaseTokenAddress, uint256 _purchaseStartBlock) external onlyOwner returns (bool) { assert(address(starbaseToken) == 0); starbaseToken = AbstractStarbaseToken(starbaseTokenAddress); purchaseStartBlock = _purchaseStartBlock; totalAmountOfEarlyPurchasesInCny = totalAmountOfEarlyPurchases(); maxCrowdsaleCap = SafeMath.sub(MAX_CAP, totalAmountOfEarlyPurchasesInCny); assert(maxCrowdsaleCap > 0); return true; } function recordOffchainPurchase( address purchaser, uint256 rawAmount, uint256 purchasedAt, string data ) external onlyFundraiser whenNotEnded rateIsSet(cnyBtcRate) returns (bool) { require(purchaseStartBlock > 0 && block.number >= purchaseStartBlock); if (startDate == 0) { startCrowdsale(block.timestamp); } uint256 bonusTier = getBonusTier(); uint amount = recordPurchase(purchaser, rawAmount, purchasedAt, data, bonusTier); StarbasePurchasedOffChain(purchaser, amount, rawAmount, cnyBtcRate, bonusTier, data); return true; } function withdrawForCompany() external onlyFundraiser hasBalance { address company = starbaseToken.company(); require(company != address(0)); company.transfer(this.balance); } function updateCnyEthRate(uint256 rate) external onlyFundraiser returns (bool) { cnyEthRate = rate; CnyEthRateUpdated(cnyEthRate); return true; } function updateCnyBtcRate(uint256 rate) external onlyFundraiser returns (bool) { cnyBtcRate = rate; CnyBtcRateUpdated(cnyBtcRate); return true; } function ownerStartsCrowdsale(uint256 timestamp) external onlyOwner { startCrowdsale(timestamp); } function endCrowdsale(uint256 timestamp) external onlyOwner { assert(timestamp > 0 && timestamp <= now); endedAt = timestamp; totalAmountOfEarlyPurchasesInCny = totalAmountOfEarlyPurchases(); totalAmountOfPurchasesInCny = totalRaisedAmountInCny(); CrowdsaleEnded(endedAt); } function withdrawPurchasedTokens() external whenEnded returns (bool) { assert(earlyPurchasesLoaded); assert(address(starbaseToken) != 0); if (crowdsalePurchaseAmountBy[msg.sender] > 0) { uint256 crowdsalePurchaseValue = crowdsalePurchaseAmountBy[msg.sender]; crowdsalePurchaseAmountBy[msg.sender] = 0; uint256 tokenCount = SafeMath.mul(crowdsaleTokenAmount, crowdsalePurchaseValue) / totalAmountOfPurchasesInCny; numOfPurchasedTokensOnCsBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnCsBy[msg.sender], tokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, tokenCount)); numOfDeliveredCrowdsalePurchases++; } uint256 earlyPurchaserPurchaseValue = earlyPurchasedAmountBy[msg.sender]; earlyPurchasedAmountBy[msg.sender] = 0; uint256 epTokenCalculationFromEPTokenAmount = SafeMath.mul(earlyPurchaseTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfEarlyPurchasesInCny; uint256 epTokenCalculationFromCrowdsaleTokenAmount = SafeMath.mul(crowdsaleTokenAmount, earlyPurchaserPurchaseValue) / totalAmountOfPurchasesInCny; uint256 epTokenCount = SafeMath.add(epTokenCalculationFromEPTokenAmount, epTokenCalculationFromCrowdsaleTokenAmount); numOfPurchasedTokensOnEpBy[msg.sender] = SafeMath.add(numOfPurchasedTokensOnEpBy[msg.sender], epTokenCount); assert(starbaseToken.allocateToCrowdsalePurchaser(msg.sender, epTokenCount)); numOfDeliveredEarlyPurchases++; } return true; } function loadEarlyPurchases() external onlyOwner returns (bool) { if (earlyPurchasesLoaded) { } uint256 numOfOrigEp = starbaseEpAmendment .starbaseEarlyPurchase() .numberOfEarlyPurchases(); for (uint256 i = numOfLoadedEarlyPurchases; i < numOfOrigEp && msg.gas > 200000; i++) { if (starbaseEpAmendment.isInvalidEarlyPurchase(i)) { numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1); continue; } var (purchaser, amount,) = starbaseEpAmendment.isAmendedEarlyPurchase(i) ? starbaseEpAmendment.amendedEarlyPurchases(i) : starbaseEpAmendment.earlyPurchases(i); if (amount > 0) { if (earlyPurchasedAmountBy[purchaser] == 0) { earlyPurchasers.push(purchaser); } uint256 bonus = SafeMath.mul(amount, 20) / 100; uint256 amountWithBonus = SafeMath.add(amount, bonus); earlyPurchasedAmountBy[purchaser] = SafeMath.add(earlyPurchasedAmountBy[purchaser], amountWithBonus); } numOfLoadedEarlyPurchases = SafeMath.add(numOfLoadedEarlyPurchases, 1); } assert(numOfLoadedEarlyPurchases <= numOfOrigEp); if (numOfLoadedEarlyPurchases == numOfOrigEp) { } return true; } function setQualifiedPartner(address _qualifiedPartner, uint256 _amountCap, uint256 _commissionFeePercentage) external onlyOwner { assert(!qualifiedPartners[_qualifiedPartner].bonaFide); qualifiedPartners[_qualifiedPartner].bonaFide = true; qualifiedPartners[_qualifiedPartner].amountCap = _amountCap; qualifiedPartners[_qualifiedPartner].commissionFeePercentage = _commissionFeePercentage; QualifiedPartnerAddress(_qualifiedPartner); } function unlistQualifiedPartner(address _qualifiedPartner) external onlyOwner { assert(qualifiedPartners[_qualifiedPartner].bonaFide); qualifiedPartners[_qualifiedPartner].bonaFide = false; } function updateQualifiedPartnerCapAmount(address _qualifiedPartner, uint256 _amountCap) external onlyOwner { assert(qualifiedPartners[_qualifiedPartner].bonaFide); qualifiedPartners[_qualifiedPartner].amountCap = _amountCap; } function isEnded() constant public returns (bool) { return (endedAt > 0 && endedAt <= now); } function numOfPurchases() constant public returns (uint256) { return crowdsalePurchases.length; } function totalAmountOfCrowdsalePurchases() constant public returns (uint256 amount) { for (uint256 i; i < crowdsalePurchases.length; i++) { amount = SafeMath.add(amount, crowdsalePurchases[i].amount); } } function totalAmountOfCrowdsalePurchasesWithoutBonus() constant public returns (uint256 amount) { for (uint256 i; i < crowdsalePurchases.length; i++) { amount = SafeMath.add(amount, crowdsalePurchases[i].rawAmount); } } function totalRaisedAmountInCny() constant public returns (uint256) { return SafeMath.add(totalAmountOfEarlyPurchases(), totalAmountOfCrowdsalePurchases()); } function totalAmountOfEarlyPurchases() constant public returns(uint256) { return starbaseEpAmendment.totalAmountOfEarlyPurchases(); } function purchaseAsQualifiedPartner() payable public rateIsSet(cnyEthRate) returns (bool) { require(qualifiedPartners[msg.sender].bonaFide); qualifiedPartners[msg.sender].amountRaised = SafeMath.add(msg.value, qualifiedPartners[msg.sender].amountRaised); assert(qualifiedPartners[msg.sender].amountRaised <= qualifiedPartners[msg.sender].amountCap); uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18; uint amount = recordPurchase(msg.sender, rawAmount, now, '', bonusTier); if (qualifiedPartners[msg.sender].commissionFeePercentage > 0) { sendQualifiedPartnerCommissionFee(msg.sender, msg.value); } StarbasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate, bonusTier); return true; } function purchaseWithEth() payable public minInvestment whenNotEnded rateIsSet(cnyEthRate) returns (bool) { require(purchaseStartBlock > 0 && block.number >= purchaseStartBlock); if (startDate == 0) { startCrowdsale(block.timestamp); } uint256 bonusTier = getBonusTier(); uint256 rawAmount = SafeMath.mul(msg.value, cnyEthRate) / 1e18; uint amount = recordPurchase(msg.sender, rawAmount, now, '', bonusTier); StarbasePurchasedWithEth(msg.sender, amount, rawAmount, cnyEthRate, bonusTier); return true; } function startCrowdsale(uint256 timestamp) internal { startDate = timestamp; } function recordPurchase( address purchaser, uint256 rawAmount, uint256 timestamp, string data, uint256 bonusTier ) internal returns(uint256 amount) { if (block.number >= purchaseStartBlock) { assert(totalAmountOfCrowdsalePurchasesWithoutBonus() <= maxCrowdsaleCap); uint256 crowdsaleTotalAmountAfterPurchase = SafeMath.add(totalAmountOfCrowdsalePurchasesWithoutBonus(), amount); if (crowdsaleTotalAmountAfterPurchase > maxCrowdsaleCap) { uint256 difference = SafeMath.sub(crowdsaleTotalAmountAfterPurchase, maxCrowdsaleCap); uint256 ethValueToReturn = SafeMath.mul(difference, 1e18) / cnyEthRate; purchaser.transfer(ethValueToReturn); amount = SafeMath.sub(amount, difference); rawAmount = amount; } } uint256 covertedAmountwWithBonus = SafeMath.mul(amount, bonusTier) / 100; CrowdsalePurchase memory purchase = CrowdsalePurchase(purchaser, amount, rawAmount, timestamp, data, bonusTier); crowdsalePurchases.push(purchase); crowdsalePurchaseAmountBy[purchaser] = SafeMath.add(crowdsalePurchaseAmountBy[purchaser], amount); return amount; } function getBonusTier() internal returns (uint256) { if (firstBonusSalesPeriod || firstExtendedBonusSalesPeriod) return 20; if (secondBonusSalesPeriod || secondExtendedBonusSalesPeriod) return 15; if (thirdBonusSalesPeriod || thirdExtendedBonusSalesPeriod) return 10; if (fourthBonusSalesPeriod || fourthExtendedBonusSalesPeriod) return 5; if (fifthBonusSalesPeriod || fifthExtendedBonusSalesPeriod) return 0; if (sixthExtendedBonusSalesPeriod) { uint256 DAY_IN_SECONDS = 86400; uint256 secondsSinceStartDate = SafeMath.sub(now, startDate); uint256 numberOfDays = secondsSinceStartDate / DAY_IN_SECONDS; return SafeMath.sub(numberOfDays, 60); } } function sendQualifiedPartnerCommissionFee(address qualifiedPartner, uint256 amountSent) internal { uint256 commissionFeePercentageCalculationAmount = SafeMath.mul(amountSent, qualifiedPartners[qualifiedPartner].commissionFeePercentage) / 100; qualifiedPartner.transfer(commissionFeePercentageCalculationAmount); } function redirectToPurchase() internal { if (block.number < purchaseStartBlock) { purchaseAsQualifiedPartner(); } else { purchaseWithEth(); } } } "}
{"sol name": "12786_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ADZbuzzCommunityToken() public { symbol = \"ACT275170\"; name = \"ADZbuzz Forentrepreneurs.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "678_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ADZbuzzCommunityToken() public { symbol = \"ACT232493\"; name = \"ADZbuzz 24ur.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "23455_0.sol", "label": 0, "sol content": "contract tokenRecipient { function receiveApproval(address from, uint256 value, address token, bytes extraData) public; } contract PGM_Coin { address public bkaddress; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function PGM_Coin() public { bkaddress  = 0x1D38b496176bDaB78D430cebf25B2Fe413d3BF84; } modifier onlyOwner() { require((msg.sender == owner) || (msg.sender ==  bkaddress)); _; } { } function sellOffline(address rec_address,uint256 token_amount) public onlyOwner { if (remaining > 0) { uint finalTokens =  (token_amount  * (10 ** 18)); if(finalTokens < remaining) { remaining = remaining - finalTokens; _transfer(owner,rec_address, finalTokens); TransferSell(owner, rec_address, finalTokens,'Offline'); } else { revert(); } } else { revert(); } } { return ethRate; } { return this.balance; } { ethRate = newEthRate; } { return icoTokenPrice; } { icoTokenPrice = newTokenRate; } { allowTransferToken = status; } { icoStatus = statx; } { if((msg.sender == owner) || (msg.sender ==  bkaddress)) { benAddress.transfer(amountWith); } else { revert(); } } { if((msg.sender == owner) || (msg.sender ==  bkaddress) ) { var amountWith = this.balance - 10000000000000000; benAddress.transfer(amountWith); } else { revert(); } } function mintToken(uint256 tokensToMint) public onlyOwner { if(tokensToMint > 0) { var totalTokenToMint = tokensToMint * (10 ** 18); balanceOf[owner] += totalTokenToMint; totalSupply += totalTokenToMint; Transfer(0, owner, totalTokenToMint); } } function adm_trasfer(address _from,address _to, uint256 _value)  public onlyOwner { _transfer(_from, _to, _value); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function getCollectedAmount() onlyOwner public constant returns (uint256 balance) { return amountCollected; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOf[_owner]; } function totalSupply() private constant returns (uint256 tsupply) { tsupply = totalSupply; } function transferOwnership(address newOwner) public onlyOwner { balanceOf[owner] = 0; balanceOf[newOwner] = remaining; owner = newOwner; } function _transfer(address _from, address _to, uint _value) internal { if(allowTransferToken == 1 || _from == owner ) { } else { revert(); } } function transfer(address _to, uint256 _value)  public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } "}
{"sol name": "8432_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ADZbuzzCommunityToken() public { symbol = \"ACT255742\"; name = \"ADZbuzz Boardingarea.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "39239_0.sol", "label": 0, "sol content": "library SafeMathLib { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) private { if (!assertion) throw; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } function halt() external onlyOwner { halted = true; } function unhalt() external onlyOwner onlyInEmergency { halted = false; } } contract PricingStrategy { function isPricingStrategy() public constant returns (bool) { return true; } function isSane(address crowdsale) public constant returns (bool) { return true; } function calculatePrice(uint value, uint tokensSold, uint weiRaised, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } function isSane() public constant returns (bool); function finalizeCrowdsale(); } contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract FractionalERC20 is ERC20 { uint public decimals; } contract Crowdsale is Haltable { using SafeMathLib for uint; FractionalERC20 public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (address => bool) public earlyParticipantWhitelist; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Refund(address investor, uint weiAmount); event InvestmentPolicyChanged(bool requireCustomerId, bool requiredSignedAddress, address signerAddress); event Whitelisted(address addr, bool status); event EndsAtChanged(uint endsAt); function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) { owner = msg.sender; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; } function() payable { throw; } function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { if(!earlyParticipantWhitelist[receiver]) { throw; } } else if(getState() == State.Funding) { } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(isBreakingCap(tokenAmount, weiAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount, customerId); } function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner { uint tokenAmount = fullTokens * 10**token.decimals(); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); assignTokens(receiver, tokenAmount); Invested(receiver, weiAmount, tokenAmount, 0); } function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(addr); if (ecrecover(hash, v, r, s) != signerAddress) throw; investInternal(addr, customerId); } function investWithCustomerId(address addr, uint128 customerId) public payable { investInternal(addr, customerId); } function invest(address addr) public payable { investInternal(addr, 0); } function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { investWithSignedAddress(msg.sender, customerId, v, r, s); } function buyWithCustomerId(uint128 customerId) public payable { investWithCustomerId(msg.sender, customerId); } function buy() public payable { invest(msg.sender); } function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { throw; } } function setRequireCustomerId(bool value) onlyOwner { requireCustomerId = value; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner { requiredSignedAddress = value; signerAddress = _signerAddress; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner { earlyParticipantWhitelist[addr] = status; Whitelisted(addr, status); } function setEndsAt(uint time) onlyOwner { if(now > time) { } endsAt = time; EndsAtChanged(endsAt); } function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } } function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = loadedRefund.plus(msg.value); } function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.plus(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } modifier inState(State state) { if(getState() != state) throw; _; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); function isCrowdsaleFull() public constant returns (bool); function assignTokens(address receiver, uint tokenAmount) private; } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract StandardToken is ERC20, SafeMath { mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; } _; } function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) returns (bool success) { var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } function addApproval(address _spender, uint _addedValue) onlyPayloadSize(2) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; allowed[msg.sender][_spender] = safeAdd(oldValue, _addedValue); return true; } function subApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2) returns (bool success) { uint oldVal = allowed[msg.sender][_spender]; if (_subtractedValue > oldVal) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = safeSub(oldVal, _subtractedValue); } return true; } } contract MintableToken is StandardToken, Ownable { using SafeMathLib for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); Transfer(0, receiver, amount); } function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; } modifier onlyMintAgent() { if(!mintAgents[msg.sender]) { throw; } _; } modifier canMint() { if(mintingFinished) throw; _; } } contract MintedEthCappedCrowdsale is Crowdsale { uint public weiCap; function MintedEthCappedCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, uint _weiCap) Crowdsale(_token, _pricingStrategy, _multisigWallet, _start, _end, _minimumFundingGoal) { weiCap = _weiCap; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken) { return weiRaisedTotal > weiCap; } function isCrowdsaleFull() public constant returns (bool) { return weiRaised >= weiCap; } function assignTokens(address receiver, uint tokenAmount) private { MintableToken mintableToken = MintableToken(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "23249_0.sol", "label": 0, "sol content": "contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC223 { uint public totalSupply; function name() public view returns (string _name); function symbol() public view returns (string _symbol); function decimals() public view returns (uint8 _decimals); function totalSupply() public view returns (uint256 _supply); function balanceOf(address who) public view returns (uint); function transfer(address to, uint value) public returns (bool ok); function transfer(address to, uint value, bytes data) public returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); event Transfer(address indexed _from, address indexed _to, uint256 _value); } contract INZEI is ERC223, Ownable { using SafeMath for uint256; string public name = \"INZEI\"; string public symbol = \"INZ\"; uint8 public decimals = 8; uint256 public initialSupply = 10e9 * 1e8; uint256 public totalSupply; uint256 public distributeAmount = 0; bool public mintingFinished = false; mapping (address => uint) balances; mapping (address => bool) public frozenAccount; mapping (address => uint256) public unlockUnixTime; event FrozenFunds(address indexed target, bool frozen); event LockedFunds(address indexed target, uint256 locked); event Burn(address indexed burner, uint256 value); event Mint(address indexed to, uint256 amount); event MintFinished(); function INZEI() public { totalSupply = initialSupply; balances[msg.sender] = totalSupply; } function name() public view returns (string _name) { return name; } function symbol() public view returns (string _symbol) { return symbol; } function decimals() public view returns (uint8 _decimals) { return decimals; } function totalSupply() public view returns (uint256 _totalSupply) { return totalSupply; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } modifier onlyPayloadSize(uint256 size){ assert(msg.data.length >= size + 4); _; } function transfer(address _to, uint _value, bytes _data, string _custom_fallback) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]); if(isContract(_to)) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value); balances[_to] = SafeMath.add(balanceOf(_to), _value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value, bytes _data) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]); if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value) public returns (bool success) { require(_value > 0 && frozenAccount[msg.sender] == false && frozenAccount[_to] == false && now > unlockUnixTime[msg.sender] && now > unlockUnixTime[_to]); bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function isContract(address _addr) private view returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return (length>0); } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value); balances[_to] = SafeMath.add(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = SafeMath.sub(balanceOf(msg.sender), _value); balances[_to] = SafeMath.add(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } function freezeAccounts(address[] targets, bool isFrozen) onlyOwner public { require(targets.length > 0); for (uint i = 0; i < targets.length; i++) { require(targets[i] != 0x0); frozenAccount[targets[i]] = isFrozen; FrozenFunds(targets[i], isFrozen); } } function lockupAccounts(address[] targets, uint[] unixTimes) onlyOwner public { require(targets.length > 0 && targets.length == unixTimes.length); for(uint i = 0; i < targets.length; i++){ require(unlockUnixTime[targets[i]] < unixTimes[i]); unlockUnixTime[targets[i]] = unixTimes[i]; LockedFunds(targets[i], unixTimes[i]); } } function burn(address _from, uint256 _unitAmount) onlyOwner public { require(_unitAmount > 0 && balanceOf(_from) >= _unitAmount); balances[_from] = SafeMath.sub(balances[_from], _unitAmount); totalSupply = SafeMath.sub(totalSupply, _unitAmount); Burn(_from, _unitAmount); } modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _unitAmount) onlyOwner canMint public returns (bool) { require(_unitAmount > 0); totalSupply = SafeMath.add(totalSupply, _unitAmount); balances[_to] = SafeMath.add(balances[_to], _unitAmount); Mint(_to, _unitAmount); Transfer(address(0), _to, _unitAmount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } function distributeTokens(address[] addresses, uint256 amount) public returns (bool) { require(amount > 0 && addresses.length > 0 && frozenAccount[msg.sender] == false && now > unlockUnixTime[msg.sender]); amount = SafeMath.mul(amount, 1e8); uint256 totalAmount = SafeMath.mul(amount, addresses.length); require(balances[msg.sender] >= totalAmount); for (uint i = 0; i < addresses.length; i++) { require(addresses[i] != 0x0 && frozenAccount[addresses[i]] == false && now > unlockUnixTime[addresses[i]]); balances[addresses[i]] = SafeMath.add(balances[addresses[i]], amount); Transfer(msg.sender, addresses[i], amount); } balances[msg.sender] = SafeMath.sub(balances[msg.sender], totalAmount); return true; } function collectTokens(address[] addresses, uint[] amounts) onlyOwner public returns (bool) { require(addresses.length > 0 && addresses.length == amounts.length); uint256 totalAmount = 0; for (uint i = 0; i < addresses.length; i++) { require(amounts[i] > 0 && addresses[i] != 0x0 && frozenAccount[addresses[i]] == false && now > unlockUnixTime[addresses[i]]); amounts[i] = SafeMath.mul(amounts[i], 1e8); require(balances[addresses[i]] >= amounts[i]); balances[addresses[i]] = SafeMath.sub(balances[addresses[i]], amounts[i]); totalAmount = SafeMath.add(totalAmount, amounts[i]); Transfer(addresses[i], msg.sender, amounts[i]); } balances[msg.sender] = SafeMath.add(balances[msg.sender], totalAmount); return true; } function setDistributeAmount(uint256 _unitAmount) onlyOwner public { distributeAmount = _unitAmount; } function autoDistribute() payable public { require(distributeAmount > 0 && balanceOf(owner) >= distributeAmount && frozenAccount[msg.sender] == false && now > unlockUnixTime[msg.sender]); if (msg.value > 0) owner.transfer(msg.value); balances[owner] = SafeMath.sub(balances[owner], distributeAmount); balances[msg.sender] = SafeMath.add(balances[msg.sender], distributeAmount); Transfer(owner, msg.sender, distributeAmount); } function() payable public { autoDistribute(); } } "}
{"sol name": "22717_0.sol", "label": 0, "sol content": "contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name = \"KmongCoin\"; string public symbol = \"KMC\"; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 * (10 ** 18); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } contract KMCToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function KMCToken( ) TokenERC20() public {} function _transfer(address _from, address _to, uint _value) internal { Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { } function sell(uint256 amount) public { } } "}
{"sol name": "26466_0.sol", "label": 0, "sol content": "contract Ownable { function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } @newOwner:\taddress of newOwner function transferOwnership(address newOwner) onlyOwner public{ if (newOwner != address(0)) { owner = newOwner; } } function kill() onlyOwner public{ selfdestruct(owner); } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData)public; } contract BlocToken is Ownable{ function BlocToken ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } @_from:\taddress of sender's account @_to:\taddress of recipient's account @_value:transaction amount function _transfer(address _from, address _to, uint _value) internal { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } @_to:\taddress of recipient's account @_value:transaction amount function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } @_from:\taddress of sender's account @_to:\taddress of recipient's account @_value:transaction amount function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } @_spender:\taddress of spender's account @_value:\tapprove amount function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } @_spender:\taddress of other account @_value:\tapprove amount @_extraData:additional information to send to the approved contract function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } @newOwner:\taddress of newOwner function transferOwnershipWithBalance(address newOwner) onlyOwner public{ if (newOwner != address(0)) { _transfer(owner,newOwner,balanceOf[owner]); owner = newOwner; } } } "}
{"sol name": "6977_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 27043200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xba7F76E62afEB2EA519c67b945dB35C60e32A802; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "32132_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract KYC is Ownable { mapping (address => bool) public registeredAddress; mapping (address => bool) public admin; event Registered(address indexed _addr); event Unregistered(address indexed _addr); event NewAdmin(address indexed _addr); event ClaimedTokens(address _token, address owner, uint256 balance); modifier onlyRegistered(address _addr) { require(registeredAddress[_addr]); _; } modifier onlyAdmin() { require(admin[msg.sender]); _; } function KYC() { admin[msg.sender] = true; } function setAdmin(address _addr) public onlyOwner { require(_addr != address(0) && admin[_addr] == false); admin[_addr] = true; NewAdmin(_addr); } function register(address _addr) public onlyAdmin { require(_addr != address(0) && registeredAddress[_addr] == false); registeredAddress[_addr] = true; Registered(_addr); } function registerByList(address[] _addrs) public onlyAdmin { for(uint256 i = 0; i < _addrs.length; i++) { require(_addrs[i] != address(0) && registeredAddress[_addrs[i]] == false); registeredAddress[_addrs[i]] = true; Registered(_addrs[i]); } } function unregister(address _addr) public onlyAdmin onlyRegistered(_addr) { registeredAddress[_addr] = false; Unregistered(_addr); } function unregisterByList(address[] _addrs) public onlyAdmin { for(uint256 i = 0; i < _addrs.length; i++) { require(registeredAddress[_addrs[i]]); registeredAddress[_addrs[i]] = false; Unregistered(_addrs[i]); } } function claimTokens(address _token) public onlyOwner { if (_token == 0x0) { owner.transfer(this.balance); return; } ERC20Basic token = ERC20Basic(_token); uint256 balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } "}
{"sol name": "10528_0.sol", "label": 0, "sol content": "contract ERC20Interface { function totalSupply() constant public returns (uint256 _totalSupply); function balanceOf(address _owner) constant public returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract HDCToken is ERC20Interface { address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { require (msg.sender != owner); _; } bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; } function unpause() onlyOwner whenPaused public { paused = false; } constructor () public { owner = msg.sender; balances[owner] = _totalSupply; } function  totalSupply() public constant returns (uint256 totalSupplyRet) { totalSupplyRet = _totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) public whenNotPaused returns (bool success) { require(_to != address(0x0) ); require (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]); balances[msg.sender] -= _amount; balances[_to] += _amount; emit Transfer(msg.sender, _to, _amount); return true; } function transferFrom( address _from, address _to, uint256 _amount ) public whenNotPaused returns (bool success) { require(_to != address(0x0) ); require (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]); balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; emit Transfer(_from, _to, _amount); return true; } function approve(address _spender, uint256 _amount) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = _amount; emit Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "34744_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract SAATCoin is BurnableToken, Ownable { string public constant name = \"SAAT\"; string public constant symbol = \"SAAT\"; uint public constant decimals = 8; uint256 public constant initialSupply = 75000000 * (10 ** uint256(decimals)); function SAATCoin() { totalSupply = initialSupply; } } "}
{"sol name": "977_0.sol", "label": 0, "sol content": "contract WBET{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. uint256 public totalSupply; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function WBET() public { } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "35617_0.sol", "label": 0, "sol content": "contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } } contract Token { function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract MoldCoin is StandardToken, SafeMath { string public name = \"MOLD\"; string public symbol = \"MLD\"; uint public decimals = 18; address public founder; address public admin; event Buy(address indexed sender, uint eth, uint tokens); event AllocateFounderTokens(address indexed sender, uint tokens); event AllocateAngelTokens(address indexed sender, address to, uint tokens); event AllocateUnsoldTokens(address indexed sender, address holder, uint tokens); modifier onlyAdmin { require(msg.sender == admin); _; } modifier duringCrowdSale { require(block.timestamp >= startDatetime && block.timestamp <= endDatetime); _; } function MoldCoin(uint startDatetimeInSeconds, address founderWallet) { admin = msg.sender; founder = founderWallet; startDatetime = startDatetimeInSeconds; firstStageDatetime = startDatetime + 120 * 1 hours; secondStageDatetime = firstStageDatetime + 240 * 1 hours; endDatetime = secondStageDatetime + 2040 * 1 hours; } function price(uint timeInSeconds) constant returns(uint) { if (timeInSeconds < startDatetime) return 0; return 0; } function buy() payable { buyRecipient(msg.sender); } function() payable { buyRecipient(msg.sender); } function buyRecipient(address recipient) duringCrowdSale payable { require(!halted); uint tokens = safeMul(msg.value, price(block.timestamp)); require(safeAdd(saleTokenSupply,tokens)<=coinAllocation ); balances[recipient] = safeAdd(balances[recipient], tokens); totalSupply = safeAdd(totalSupply, tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); salesVolume = safeAdd(salesVolume, msg.value); Buy(recipient, msg.value, tokens); } function allocateFounderTokens() onlyAdmin { require( block.timestamp > endDatetime ); require(!founderAllocated); balances[founder] = safeAdd(balances[founder], founderAllocation); totalSupply = safeAdd(totalSupply, founderAllocation); founderAllocated = true; AllocateFounderTokens(msg.sender, founderAllocation); } function allocateAngelTokens(address angel, uint tokens) onlyAdmin { require(safeAdd(angelTokenSupply,tokens) <= angelAllocation ); balances[angel] = safeAdd(balances[angel], tokens); angelTokenSupply = safeAdd(angelTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateAngelTokens(msg.sender, angel, tokens); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function arrangeUnsoldTokens(address holder, uint256 tokens) onlyAdmin { require( block.timestamp > endDatetime ); require( safeAdd(saleTokenSupply,tokens) <= coinAllocation ); require( balances[holder] >0 ); balances[holder] = safeAdd(balances[holder], tokens); saleTokenSupply = safeAdd(saleTokenSupply, tokens); totalSupply = safeAdd(totalSupply, tokens); AllocateUnsoldTokens(msg.sender, holder, tokens); } } contract MoldCoinBonus is SafeMath { function bonusBalanceOf(address _owner) constant returns (uint256 balance) { return bonusBalances[_owner]; } mapping (address => uint256) bonusBalances; address public admin; MoldCoin public fundAddress; uint public rate = 10; uint public totalSupply = 0; event BuyWithBonus(address indexed sender, address indexed inviter, uint eth, uint tokens, uint bonus); event BuyForFriend(address indexed sender, address indexed friend, uint eth, uint tokens, uint bonus); modifier onlyAdmin { require(msg.sender == admin); _; } modifier validSale { require(!halted); require(!fundAddress.halted()); _; } function MoldCoinBonus(MoldCoin _fundAddress, uint _rate) { admin = msg.sender; fundAddress = _fundAddress; rate = _rate; } function buyWithBonus(address inviter) validSale payable { require( msg.sender != inviter ); uint tokens = safeMul(msg.value, fundAddress.price(block.timestamp)); uint bonus = safeDiv(safeMul(tokens, rate), 100); totalSupply = safeAdd(totalSupply, bonus*2); bonusBalances[inviter] = safeAdd(bonusBalances[inviter], bonus); bonusBalances[msg.sender] = safeAdd(bonusBalances[msg.sender], bonus); BuyWithBonus(msg.sender, inviter, msg.value, tokens, bonus); } function halt() onlyAdmin { halted = true; } function unhalt() onlyAdmin { halted = false; } function changeAdmin(address newAdmin) onlyAdmin  { admin = newAdmin; } function changeRate(uint _rate) onlyAdmin  { rate = _rate; } } "}
{"sol name": "27248_0.sol", "label": 0, "sol content": "contract SimpleMultiSig { function SimpleMultiSig(uint threshold_, address[] owners_) public { require(owners_.length <= 10 && threshold_ <= owners_.length && threshold_ != 0); address lastAdd = address(0); for (uint i=0; i<owners_.length; i++) { require(owners_[i] > lastAdd); isOwner[owners_[i]] = true; lastAdd = owners_[i]; } ownersArr = owners_; threshold = threshold_; } function execute(uint8[] sigV, bytes32[] sigR, bytes32[] sigS, address destination, uint value, bytes data) public { require(sigR.length == threshold); require(sigR.length == sigS.length && sigR.length == sigV.length); bytes32 txHash = keccak256(byte(0x19), byte(0), address(this), destination, value, data, nonce); for (uint i = 0; i < threshold; i++) { address recovered = ecrecover(txHash, sigV[i], sigR[i], sigS[i]); require(recovered > lastAdd && isOwner[recovered]); lastAdd = recovered; } nonce = nonce + 1; require(destination.call.value(value)(data)); } function () public payable {} } "}
{"sol name": "38193_0.sol", "label": 0, "sol content": "library SafeMath { function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a && c >= b); return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner { newOwner = _newOwner; } function acceptOwnership() { if (msg.sender == newOwner) { OwnershipTransferred(owner, newOwner); owner = newOwner; } } } contract ERC20Token { using SafeMath for uint; uint256 _totalSupply = 0; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function totalSupply() constant returns (uint256 totalSupply) { totalSupply = _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) returns (bool success) { ) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function approve( address _spender, uint256 _amount ) returns (bool success) { require((_amount == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { ) { balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } else { return false; } } function allowance( address _owner, address _spender ) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract DaoCasinoToken is ERC20Token, Owned { string public constant symbol = \"BET\"; string public constant name = \"Dao.Casino\"; uint8 public constant decimals = 18; function DaoCasinoToken() { } bool public sealed; uint256 constant D160 = 0x0010000000000000000000000000000000000000000; function fill(uint256[] data) onlyOwner { require(!sealed); for (uint256 i = 0; i < data.length; i++) { address account = address(data[i] & (D160-1)); uint256 amount = data[i] / D160; if (balances[account] == 0) { balances[account] = amount; _totalSupply = _totalSupply.add(amount); Transfer(0x0, account, amount); } } } function seal() onlyOwner { require(!sealed); sealed = true; } function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20Token(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "36259_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; address public saleAgent; function setSaleAgent(address newSaleAgnet) { require(msg.sender == saleAgent || msg.sender == owner); saleAgent = newSaleAgnet; } function mint(address _to, uint256 _amount) returns (bool) { require(msg.sender == saleAgent && !mintingFinished); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); return true; } function finishMinting() returns (bool) { require(msg.sender == saleAgent || msg.sender == owner && !mintingFinished); mintingFinished = true; MintFinished(); return true; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused { paused = true; Pause(); } function unpause() onlyOwner whenPaused { paused = false; Unpause(); } } contract TlindToken is MintableToken { string public constant name = \"Tlind\"; string public constant symbol = \"TDT\"; uint32 public constant decimals = 18; } contract StagedCrowdsale is Pausable { using SafeMath for uint; struct Milestone { uint period; uint bonus; } uint public start; uint public totalPeriod; uint public invested; uint public hardCap; Milestone[] public milestones; function milestonesCount() constant returns(uint) { return milestones.length; } function setStart(uint newStart) onlyOwner { start = newStart; } function setHardcap(uint newHardcap) onlyOwner { hardCap = newHardcap; } function addMilestone(uint period, uint bonus) onlyOwner { require(period > 0); milestones.push(Milestone(period, bonus)); totalPeriod = totalPeriod.add(period); } function removeMilestones(uint8 number) onlyOwner { require(number < milestones.length); Milestone storage milestone = milestones[number]; totalPeriod = totalPeriod.sub(milestone.period); delete milestones[number]; for (uint i = number; i < milestones.length - 1; i++) { milestones[i] = milestones[i+1]; } milestones.length--; } function changeMilestone(uint8 number, uint period, uint bonus) onlyOwner { require(number < milestones.length); Milestone storage milestone = milestones[number]; totalPeriod = totalPeriod.sub(milestone.period); milestone.period = period; milestone.bonus = bonus; totalPeriod = totalPeriod.add(period); } function insertMilestone(uint8 numberAfter, uint period, uint bonus) onlyOwner { require(numberAfter < milestones.length); totalPeriod = totalPeriod.add(period); milestones.length++; for (uint i = milestones.length - 2; i > numberAfter; i--) { milestones[i + 1] = milestones[i]; } milestones[numberAfter + 1] = Milestone(period, bonus); } function clearMilestones() onlyOwner { require(milestones.length > 0); for (uint i = 0; i < milestones.length; i++) { delete milestones[i]; } milestones.length -= milestones.length; totalPeriod = 0; } modifier saleIsOn() { require(milestones.length > 0 && now >= start && now < lastSaleDate()); _; } modifier isUnderHardCap() { require(invested <= hardCap); _; } function lastSaleDate() constant returns(uint) { require(milestones.length > 0); return start + totalPeriod * 1 days; } function currentMilestone() saleIsOn constant returns(uint) { uint previousDate = start; for(uint i=0; i < milestones.length; i++) { if(now >= previousDate && now < previousDate + milestones[i].period * 1 days) { return i; } previousDate = previousDate.add(milestones[i].period * 1 days); } revert(); } } contract CommonSale is StagedCrowdsale { address public multisigWallet; address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public price; uint public percentRate = 100; uint public softcap; bool public refundOn = false; bool public isSoftcapOn = false; mapping (address => uint) balances; CommonSale public nextSale; MintableToken public token; function setSoftcap(uint newSoftcap) onlyOwner { isSoftcapOn = true; softcap = newSoftcap; } function setToken(address newToken) onlyOwner { token = MintableToken(newToken); } function setNextSale(address newNextSale) onlyOwner { nextSale = CommonSale(newNextSale); } function setPrice(uint newPrice) onlyOwner { price = newPrice; } function setPercentRate(uint newPercentRate) onlyOwner { percentRate = newPercentRate; } function setFoundersTokensPercent(uint newFoundersTokensPercent) onlyOwner { foundersTokensPercent = newFoundersTokensPercent; } function setBountyTokensPercent(uint newBountyTokensPercent) onlyOwner { bountyTokensPercent = newBountyTokensPercent; } function setMultisigWallet(address newMultisigWallet) onlyOwner { multisigWallet = newMultisigWallet; } function setFoundersTokensWallet(address newFoundersTokensWallet) onlyOwner { foundersTokensWallet = newFoundersTokensWallet; } function setBountyTokensWallet(address newBountyTokensWallet) onlyOwner { bountyTokensWallet = newBountyTokensWallet; } function createTokens() whenNotPaused isUnderHardCap saleIsOn payable { require(msg.value >= 100000000000000000); uint milestoneIndex = currentMilestone(); Milestone storage milestone = milestones[milestoneIndex]; if(!isSoftcapOn) { multisigWallet.transfer(msg.value); } invested = invested.add(msg.value); uint tokens = msg.value.mul(1 ether).div(price); uint bonusTokens = tokens.mul(milestone.bonus).div(percentRate); uint tokensWithBonus = tokens.add(bonusTokens); token.mint(this, tokensWithBonus); token.transfer(msg.sender, tokensWithBonus); balances[msg.sender] = balances[msg.sender].add(msg.value); } function refund() whenNotPaused { require(now > start && refundOn && balances[msg.sender] > 0); msg.sender.transfer(balances[msg.sender]); } function finishMinting() public whenNotPaused onlyOwner { if(isSoftcapOn && invested < softcap) { refundOn = true; token.finishMinting(); } else { if(isSoftcapOn) { multisigWallet.transfer(invested); } uint issuedTokenSupply = token.totalSupply(); uint summaryTokensPercent = bountyTokensPercent + foundersTokensPercent; uint summaryFoundersTokens = issuedTokenSupply.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent); uint totalSupply = summaryFoundersTokens + issuedTokenSupply; uint foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate); uint bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate); token.mint(this, foundersTokens); token.transfer(foundersTokensWallet, foundersTokens); token.mint(this, bountyTokens); token.transfer(bountyTokensWallet, bountyTokens); if(nextSale == address(0)) { token.finishMinting(); } else { token.setSaleAgent(nextSale); } } } function() external payable { createTokens(); } function retrieveTokens(address anotherToken) public onlyOwner { ERC20 alienToken = ERC20(anotherToken); alienToken.transfer(multisigWallet, token.balanceOf(this)); } } contract Configurator is Ownable { MintableToken public token; CommonSale public presale; CommonSale public mainsale; function deploy() { address presaleMultisigWallet = 0x675cf930aefA144dA7e10ddBACC02f902A233eFC; address presaleBountyTokensWallet = 0x06B8fF8476425E45A3D2878e0a27BB79efd4Dde1; address presaleFoundersWallet = 0x27F1Ac3E29CBec9D225d98fF95B6933bD30E3F71; uint presaleSoftcap = 50000000000000000000; uint presaleHardcap = 2000000000000000000000; address mainsaleMultisigWallet = 0xFb72502E9c56497BAC3B1c21DE434b371891CC05; address mainsaleBountyTokensWallet = 0xd08112054C8e01E33fAEE176531dEB087809CbB2; address mainsaleFoundersWallet = 0xDeFAE9a126bA5aA2537AaC481D9335827159D33B; uint mainsaleHardcap = 25000000000000000000000000; token = new TlindToken(); presale = new CommonSale(); presale.setToken(token); presale.setSoftcap(presaleSoftcap); presale.setHardcap(presaleHardcap); presale.setMultisigWallet(presaleMultisigWallet); presale.setFoundersTokensWallet(presaleFoundersWallet); presale.setBountyTokensWallet(presaleBountyTokensWallet); presale.setStart(1506344400); presale.setFoundersTokensPercent(15); presale.setBountyTokensPercent(5); presale.setPrice(10000000000000000); presale.addMilestone(8,200); presale.addMilestone(8,100); token.setSaleAgent(presale); mainsale = new CommonSale(); mainsale.setToken(token); mainsale.setHardcap(mainsaleHardcap); mainsale.setMultisigWallet(mainsaleMultisigWallet); mainsale.setFoundersTokensWallet(mainsaleFoundersWallet); mainsale.setBountyTokensWallet(mainsaleBountyTokensWallet); mainsale.setStart(1510318800); mainsale.setFoundersTokensPercent(15); mainsale.setBountyTokensPercent(5); mainsale.setPrice(10000000000000000); mainsale.addMilestone(1,50); mainsale.addMilestone(6,30); mainsale.addMilestone(14,15); mainsale.addMilestone(14,10); mainsale.addMilestone(14,5); mainsale.addMilestone(7,0); presale.setNextSale(mainsale); token.transferOwnership(owner); presale.transferOwnership(owner); mainsale.transferOwnership(owner); } } "}
{"sol name": "5326_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29635200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xe2F013EA225504650Fa48CD96A513368503015DC; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "32937_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c >= a); return c; }} contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; }  } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract BIONEUM is StandardToken, Ownable { using SafeMath for uint256; string  public constant name = \"BIONEUM\"; string  public constant symbol = \"BIO\"; uint256 public constant decimals = 8; uint256 public constant totalSupply = decVal(50000000); address public multisig = 0xFC8b6add05Dd6b5fd91F6559EFF84A20201fD86c; address public developers = 0x8D9acc27005419E0a260B44d060F7427Cd9739B2; address public founders = 0xB679919c63799c39d074EEad650889B24C06fdC6; address public bounty = 0xCF2F450FB7d265fF82D0c2f1737d9f0258ae40A3; address public constant tokenAddress = this; uint256 public startDate; uint256 public endDate; uint256 public weiRaised; uint256 public etherRaised; uint256 public tokensSold; modifier uninitialized() { require(multisig == 0x0); _; } function BIONEUM() { startDate = now.add(5 hours); endDate = startDate.add(30 days); balances[founders] \t= decVal(5000000); Transfer(0x0, founders\t, balances[founders]); balances[bounty] \t= decVal(1000000); Transfer(0x0, bounty\t, balances[bounty]); balances[developers] = decVal(4000000); Transfer(0x0, developers\t, balances[developers]); balances[this] = totalSupply.sub(balances[developers].add(balances[founders]).add(balances[bounty])); Transfer(0x0, this\t\t, balances[this]); } function supply() internal returns (uint256) { return balances[this]; } function getRateAt(uint256 at) constant returns (uint256) { if (at < startDate) { return 0; } else if (at < startDate.add(7 days)) { return decVal(130); } else if (at < startDate.add(14 days)) { return decVal(115); } else if (at < startDate.add(21 days)) { return decVal(105); } else if (at < startDate.add(28 days) || at <= endDate) { return decVal(100); } else { return 0; } } function decVal(uint256 amount) internal returns(uint256){ return amount * 10 ** uint256(decimals); } function () payable { buyTokens(msg.sender, msg.value); } function buyTokens(address sender, uint256 value) internal { require(saleActive()); require(value >= 0.01 ether); uint256 weiAmount = value; uint256 updatedWeiRaised = weiRaised.add(weiAmount); uint256 actualRate = getRateAt(now); uint256 amount = weiAmount.mul(actualRate).div(1 ether); require(supply() >= amount); balances[this] = balances[this].sub(amount); balances[sender] = balances[sender].add(amount); Transfer(0x0, sender, amount); weiRaised = updatedWeiRaised; etherRaised = weiRaised.div(1 ether); tokensSold = tokensSold.add(amount); multisig.transfer(msg.value); } function finalize() onlyOwner { require(!saleActive()); balances[owner] = balances[owner].add(balances[this]); Transfer(0x0, owner, balances[this]); balances[this] = 0; } function saleActive() public constant returns (bool) { return (now >= startDate && now < endDate && supply() > 0); } } "}
{"sol name": "19461_0.sol", "label": 0, "sol content": "contract PoCS { =            MODIFIERS            = modifier onlyBagholders() { require(myTokens() > 0); _; } modifier onlyStronghands() { require(myDividends(true) > 0); _; } modifier onlyAdministrator(){ address _customerAddress = msg.sender; require(administrators[keccak256(_customerAddress)]); _; } modifier antiEarlyWhale(uint256 _amountOfEthereum){ address _customerAddress = msg.sender; if( onlyAmbassadors && ((totalEthereumBalance() - _amountOfEthereum) <= ambassadorQuota_ )){ require( ambassadors_[_customerAddress] == true && (ambassadorAccumulatedQuota_[_customerAddress] + _amountOfEthereum) <= ambassadorMaxPurchase_ ); ambassadorAccumulatedQuota_[_customerAddress] = SafeMath.add(ambassadorAccumulatedQuota_[_customerAddress], _amountOfEthereum); _; } else { onlyAmbassadors = false; _; } } =            EVENTS            = event onTokenPurchase( address indexed customerAddress, uint256 incomingEthereum, uint256 tokensMinted, address indexed referredBy ); event onTokenSell( address indexed customerAddress, uint256 tokensBurned, uint256 ethereumEarned ); event onReinvestment( address indexed customerAddress, uint256 ethereumReinvested, uint256 tokensMinted ); event onWithdraw( address indexed customerAddress, uint256 ethereumWithdrawn ); event Transfer( address indexed from, address indexed to, uint256 tokens ); =            CONFIGURABLES            = string public name = \"POCS\"; string public symbol = \"POCS\"; uint8 constant public decimals = 18; uint8 constant internal dividendFee_ = 100; uint256 constant internal tokenPriceInitial_ = 0.0000001 ether; uint256 constant internal tokenPriceIncremental_ = 0.00000001 ether; uint256 constant internal magnitude = 2**64; uint256 public stakingRequirement = 5e18; mapping(address => bool) internal ambassadors_; uint256 constant internal ambassadorMaxPurchase_ = 10 ether; uint256 constant internal ambassadorQuota_ = 10 ether; =            DATASETS            = mapping(address => uint256) internal tokenBalanceLedger_; mapping(address => uint256) internal referralBalance_; mapping(address => int256) internal payoutsTo_; mapping(address => uint256) internal ambassadorAccumulatedQuota_; uint256 internal tokenSupply_ = 0; uint256 internal profitPerShare_; mapping(bytes32 => bool) public administrators; bool public onlyAmbassadors = false; =            PUBLIC FUNCTIONS            = function Hourglass() public { administrators[0x5e2e288e04567ecf74ca6e5cbe6e54052c3e563f055e9df29e777d57b479be91] = true; ambassadors_[0x50cf4aaB5f27F54132D55f96Ba21C6Ae8B716d27] = true; } function buy(address _referredBy) public payable returns(uint256) { purchaseTokens(msg.value, _referredBy); } function() payable public { purchaseTokens(msg.value, 0x0); } function reinvest() onlyStronghands() public { address _customerAddress = msg.sender; payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; uint256 _tokens = purchaseTokens(_dividends, 0x0); onReinvestment(_customerAddress, _dividends, _tokens); } function exit() public { address _customerAddress = msg.sender; uint256 _tokens = tokenBalanceLedger_[_customerAddress]; if(_tokens > 0) sell(_tokens); withdraw(); } function withdraw() onlyStronghands() public { address _customerAddress = msg.sender; payoutsTo_[_customerAddress] +=  (int256) (_dividends * magnitude); _dividends += referralBalance_[_customerAddress]; referralBalance_[_customerAddress] = 0; _customerAddress.transfer(_dividends); onWithdraw(_customerAddress, _dividends); } function sell(uint256 _amountOfTokens) onlyBagholders() public { address _customerAddress = msg.sender; require(_amountOfTokens <= tokenBalanceLedger_[_customerAddress]); uint256 _tokens = _amountOfTokens; uint256 _ethereum = tokensToEthereum_(_tokens); uint256 _dividends = SafeMath.div(_ethereum, dividendFee_); uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends); tokenSupply_ = SafeMath.sub(tokenSupply_, _tokens); tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _tokens); int256 _updatedPayouts = (int256) (profitPerShare_ * _tokens + (_taxedEthereum * magnitude)); payoutsTo_[_customerAddress] -= _updatedPayouts; if (tokenSupply_ > 0) { profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_); } onTokenSell(_customerAddress, _tokens, _taxedEthereum); } function transfer(address _toAddress, uint256 _amountOfTokens) onlyBagholders() public returns(bool) { address _customerAddress = msg.sender; require(!onlyAmbassadors && _amountOfTokens <= tokenBalanceLedger_[_customerAddress]); if(myDividends(true) > 0) withdraw(); uint256 _tokenFee = SafeMath.div(_amountOfTokens, dividendFee_); uint256 _taxedTokens = SafeMath.sub(_amountOfTokens, _tokenFee); uint256 _dividends = tokensToEthereum_(_tokenFee); tokenSupply_ = SafeMath.sub(tokenSupply_, _tokenFee); tokenBalanceLedger_[_customerAddress] = SafeMath.sub(tokenBalanceLedger_[_customerAddress], _amountOfTokens); tokenBalanceLedger_[_toAddress] = SafeMath.add(tokenBalanceLedger_[_toAddress], _taxedTokens); payoutsTo_[_customerAddress] -= (int256) (profitPerShare_ * _amountOfTokens); payoutsTo_[_toAddress] += (int256) (profitPerShare_ * _taxedTokens); profitPerShare_ = SafeMath.add(profitPerShare_, (_dividends * magnitude) / tokenSupply_); Transfer(_customerAddress, _toAddress, _taxedTokens); return true; } function disableInitialStage() onlyAdministrator() public { onlyAmbassadors = false; } function setAdministrator(bytes32 _identifier, bool _status) onlyAdministrator() public { administrators[_identifier] = _status; } function setStakingRequirement(uint256 _amountOfTokens) onlyAdministrator() public { stakingRequirement = _amountOfTokens; } function setName(string _name) onlyAdministrator() public { name = _name; } function setSymbol(string _symbol) onlyAdministrator() public { symbol = _symbol; } function totalEthereumBalance() public view returns(uint) { return this.balance; } function totalSupply() public view returns(uint256) { return tokenSupply_; } function myTokens() public view returns(uint256) { address _customerAddress = msg.sender; return balanceOf(_customerAddress); } function myDividends(bool _includeReferralBonus) public view returns(uint256) { address _customerAddress = msg.sender; return _includeReferralBonus ? dividendsOf(_customerAddress) + referralBalance_[_customerAddress] : dividendsOf(_customerAddress) ; } function balanceOf(address _customerAddress) view public returns(uint256) { return tokenBalanceLedger_[_customerAddress]; } function dividendsOf(address _customerAddress) view public returns(uint256) { return (uint256) ((int256)(profitPerShare_ * tokenBalanceLedger_[_customerAddress]) - payoutsTo_[_customerAddress]) / magnitude; } function sellPrice() public view returns(uint256) { if(tokenSupply_ == 0){ return tokenPriceInitial_ - tokenPriceIncremental_; } else { uint256 _ethereum = tokensToEthereum_(1e18); uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  ); uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends); return _taxedEthereum; } } function buyPrice() public view returns(uint256) { if(tokenSupply_ == 0){ return tokenPriceInitial_ + tokenPriceIncremental_; } else { uint256 _ethereum = tokensToEthereum_(1e18); uint256 _dividends = SafeMath.div(_ethereum, dividendFee_  ); uint256 _taxedEthereum = SafeMath.add(_ethereum, _dividends); return _taxedEthereum; } } function calculateTokensReceived(uint256 _ethereumToSpend) public view returns(uint256) { uint256 _dividends = SafeMath.div(_ethereumToSpend, dividendFee_); uint256 _taxedEthereum = SafeMath.sub(_ethereumToSpend, _dividends); uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum); return _amountOfTokens; } function calculateEthereumReceived(uint256 _tokensToSell) public view returns(uint256) { require(_tokensToSell <= tokenSupply_); uint256 _ethereum = tokensToEthereum_(_tokensToSell); uint256 _dividends = SafeMath.div(_ethereum, dividendFee_); uint256 _taxedEthereum = SafeMath.sub(_ethereum, _dividends); return _taxedEthereum; } =            INTERNAL FUNCTIONS            = function purchaseTokens(uint256 _incomingEthereum, address _referredBy) antiEarlyWhale(_incomingEthereum) internal returns(uint256) { address _customerAddress = msg.sender; uint256 _undividedDividends = SafeMath.div(_incomingEthereum, dividendFee_); uint256 _referralBonus = SafeMath.div(_undividedDividends, 3); uint256 _dividends = SafeMath.sub(_undividedDividends, _referralBonus); uint256 _taxedEthereum = SafeMath.sub(_incomingEthereum, _undividedDividends); uint256 _amountOfTokens = ethereumToTokens_(_taxedEthereum); uint256 _fee = _dividends * magnitude; require(_amountOfTokens > 0 && (SafeMath.add(_amountOfTokens,tokenSupply_) > tokenSupply_)); if( _referredBy != 0x0000000000000000000000000000000000000000 && _referredBy != _customerAddress && tokenBalanceLedger_[_referredBy] >= stakingRequirement ){ referralBalance_[_referredBy] = SafeMath.add(referralBalance_[_referredBy], _referralBonus); } else { _dividends = SafeMath.add(_dividends, _referralBonus); _fee = _dividends * magnitude; } if(tokenSupply_ > 0){ tokenSupply_ = SafeMath.add(tokenSupply_, _amountOfTokens); profitPerShare_ += (_dividends * magnitude / (tokenSupply_)); _fee = _fee - (_fee-(_amountOfTokens * (_dividends * magnitude / (tokenSupply_)))); } else { tokenSupply_ = _amountOfTokens; } tokenBalanceLedger_[_customerAddress] = SafeMath.add(tokenBalanceLedger_[_customerAddress], _amountOfTokens); int256 _updatedPayouts = (int256) ((profitPerShare_ * _amountOfTokens) - _fee); payoutsTo_[_customerAddress] += _updatedPayouts; onTokenPurchase(_customerAddress, _incomingEthereum, _amountOfTokens, _referredBy); return _amountOfTokens; } function ethereumToTokens_(uint256 _ethereum) internal view returns(uint256) { uint256 _tokenPriceInitial = tokenPriceInitial_ * 1e18; uint256 _tokensReceived = ( ( SafeMath.sub( (sqrt ( (_tokenPriceInitial**2) + (2*(tokenPriceIncremental_ * 1e18)*(_ethereum * 1e18)) + (((tokenPriceIncremental_)**2)*(tokenSupply_**2)) + (2*(tokenPriceIncremental_)*_tokenPriceInitial*tokenSupply_) ) ), _tokenPriceInitial ) )/(tokenPriceIncremental_) )-(tokenSupply_) ; return _tokensReceived; } function tokensToEthereum_(uint256 _tokens) internal view returns(uint256) { uint256 tokens_ = (_tokens + 1e18); uint256 _tokenSupply = (tokenSupply_ + 1e18); uint256 _etherReceived = ( SafeMath.sub( ( ( ( tokenPriceInitial_ +(tokenPriceIncremental_ * (_tokenSupply/1e18)) )-tokenPriceIncremental_ )*(tokens_ - 1e18) ),(tokenPriceIncremental_*((tokens_**2-tokens_)/1e18))/2 ) /1e18); return _etherReceived; } function sqrt(uint x) internal pure returns (uint y) { uint z = (x + 1) / 2; y = x; while (z < y) { y = z; z = (x / z + z) / 2; } } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "32911_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract Ultimat { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Ultimat( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "815_0.sol", "label": 0, "sol content": "contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract CPX is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function CPX( uint256 initialSupply, string tokenName, string tokenSymbol, address holder)  public{ owner = holder; } function transfer(address _to, uint256 _value) public{ require(_value > 0); } function approve(address _spender, uint256 _value) public returns (bool success) { require(_value > 0); allowance[msg.sender][_spender] = _value; return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value > 0); allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(_value > 0); Burn(msg.sender, _value); return true; } function freeze(uint256 _value) public returns (bool success) { require(_value > 0); Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) public returns (bool success) { require(_value > 0); balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } } "}
{"sol name": "28210_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Owned { address public Owner; event OwnershipTransferred(address indexed previousOwner, address indexed NewOwner); function Owned() public { Owner = msg.sender; } modifier OnlyOwner() { require(msg.sender == Owner); _; } function transferOwnership(address NewOwner) public OnlyOwner { require(NewOwner != address(0)); OwnershipTransferred(Owner, NewOwner); Owner = NewOwner; } } contract RYC is Owned { mapping (address => mapping (bool => bool)) public registeredAddress; mapping (address => bool) public admin; event Registered(address indexed _addr); event Unregistered(address indexed _addr); event SetAdmin(address indexed _addr); modifier onlyRegistered(address _addr, bool _isPresale) { require(registeredAddress[_addr][_isPresale]); _; } modifier onlyAdmin() { require(admin[msg.sender]); _; } function RYC() public { admin[msg.sender] = true; } function setAdmin(address _addr, bool _value) public OnlyOwner returns (bool) { require(_addr != address(0)); require(admin[_addr] == !_value); admin[_addr] = _value; SetAdmin(_addr); return true; } function isRegistered(address _addr, bool _isPresale) public view returns (bool) { return registeredAddress[_addr][_isPresale]; } function register(address _addr, bool _isPresale) public onlyAdmin { require(_addr != address(0) && registeredAddress[_addr][_isPresale] == false); registeredAddress[_addr][_isPresale] = true; Registered(_addr); } function registerByList(address[] _addrs, bool _isPresale) public onlyAdmin { for(uint256 i = 0; i < _addrs.length; i++) { register(_addrs[i], _isPresale); } } function unregister(address _addr, bool _isPresale) public onlyAdmin onlyRegistered(_addr, _isPresale) { registeredAddress[_addr][_isPresale] = false; Unregistered(_addr); } function unregisterByList(address[] _addrs, bool _isPresale) public onlyAdmin { for(uint256 i = 0; i < _addrs.length; i++) { unregister(_addrs[i], _isPresale); } } } contract PaymentFallbackReceiver { BTCPaymentI public payment; enum SaleType { pre, main } function PaymentFallbackReceiver(address _payment) public { require(_payment != address(0)); payment = BTCPaymentI(_payment); } modifier onlyPayment() { require(msg.sender == address(payment)); _; } event MintByBTC(SaleType _saleType, address indexed _beneficiary, uint256 _tokens); function paymentFallBack(address _beneficiary, uint256 _tokens) external onlyPayment(); } contract PresaleFallbackReceiver { bool public presaleFallBackCalled; function presaleFallBack(uint256 _presaleWeiRaised) public returns (bool); } contract BTCPaymentI is Owned, PresaleFallbackReceiver { PaymentFallbackReceiver public presale; PaymentFallbackReceiver public mainsale; function addPayment(address _beneficiary, uint256 _tokens) public; function setPresale(address _presale) external; function setMainsale(address _mainsale) external; function presaleFallBack(uint256) public returns (bool); } contract BTCPaymentR is Owned, PresaleFallbackReceiver { using SafeMath for uint256; PaymentFallbackReceiver public presale; PaymentFallbackReceiver public mainsale; event NewPayment(address _beneficiary, uint256 _tokens); function addPayment(address _beneficiary, uint256 _tokens) public OnlyOwner { if (!presaleFallBackCalled) { presale.paymentFallBack(_beneficiary, _tokens); } else { mainsale.paymentFallBack(_beneficiary, _tokens); } NewPayment(_beneficiary, _tokens); } function setPresale(address _presale) external OnlyOwner { require(presale == address(0)); presale = PaymentFallbackReceiver(_presale); } function setMainsale(address _mainsale) external OnlyOwner { require(mainsale == address(0)); mainsale = PaymentFallbackReceiver(_mainsale); } function presaleFallBack(uint256) public returns (bool) { require(msg.sender == address(presale)); if (presaleFallBackCalled) return false; presaleFallBackCalled = true; return true; } } "}
{"sol name": "11315_0.sol", "label": 0, "sol content": "contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract MultiTransfer { function balanceOf(address _token, address _who) public view returns(uint256) { return ERC20Basic(_token).balanceOf(_who); } function transfer(address _token, address[] _to, uint256[] _value) public returns(bool) { require(_to.length != 0); require(_value.length != 0); require(_to.length == _value.length); uint256 sum = 0; for (uint256 i = 0; i < _to.length; i++) { require(_to[i] != address(0)); sum += _value[i]; } assert(balanceOf(_token, msg.sender) >= sum); for (i = 0; i < _to.length; i++) { ERC20Basic(_token).transfer(_to[i], _value[i]); } return true; } } "}
{"sol name": "20728_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } function halt() external onlyOwner { halted = true; } function unhalt() external onlyOwner onlyInEmergency { halted = false; } } contract PricingStrategy { address public tier; function isPricingStrategy() public constant returns (bool) { return true; } function isSane(address crowdsale) public constant returns (bool) { return true; } @param purchaser Address of the purchaser @return False by default, true if a presale purchaser function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } function updateRate(uint newOneTokenInWei) public; function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); function finalizeCrowdsale(); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; string public name; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } bool public isUpdatable; mapping (address => WhiteListData) public earlyParticipantWhitelist; address[] public whitelistedParticipants; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); event StartsAtChanged(uint newStartsAt); event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } function() payable { throw; } function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { throw; } else if(getState() == State.Funding) { if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { throw; } if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount, customerId); } function invest(address addr) public payable { investInternal(addr, 0); } function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { throw; } } function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } } function setMultisig(address addr) public onlyOwner { if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } function isCrowdsale() public constant returns (bool) { return true; } modifier inState(State state) { if(getState() != state) throw; _; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); function isCrowdsaleFull() public constant returns (bool); function assignTokens(address receiver, uint tokenAmount) private; } contract StandardToken is ERC20, SafeMath { event Minted(address receiver, uint amount); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract UpgradeAgent { uint public originalSupply; function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeAgentSet(address agent); function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { throw; } if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } function setUpgradeAgent(address agent) external { if(!canUpgrade()) { throw; } if (agent == 0x0) throw; if (msg.sender != upgradeMaster) throw; if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); if(!upgradeAgent.isUpgradeAgent()) throw; if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } function canUpgrade() public constant returns(bool) { return true; } } contract ReleasableToken is ERC20, Ownable { address public releaseAgent; bool public released = false; mapping (address => bool) public transferAgents; modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; } function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } function releaseTokenTransfer() public onlyReleaseAgent { released = true; } modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { return super.transferFrom(_from, _to, _value); } } contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { if(!mintAgents[msg.sender]) { throw; } _; } modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); Transfer(0, receiver, amount); } function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; uint public minCap; function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { } } } function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } contract ReservedTokensFinalizeAgent is FinalizeAgent { using SafeMathLibExt for uint; CrowdsaleTokenExt public token; CrowdsaleExt public crowdsale; uint public distributedReservedTokensDestinationsLen = 0; function ReservedTokensFinalizeAgent(CrowdsaleTokenExt _token, CrowdsaleExt _crowdsale) public { token = _token; crowdsale = _crowdsale; } function isSane() public constant returns (bool) { return (token.releaseAgent() == address(this)); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public { assert(msg.sender == address(crowdsale)); assert(reservedTokensDistributionBatch > 0); assert(!reservedTokensAreDistributed); assert(distributedReservedTokensDestinationsLen < token.reservedTokensDestinationsLen()); uint tokensSold = 0; for (uint8 i = 0; i < crowdsale.joinedCrowdsalesLen(); i++) { CrowdsaleExt tier = CrowdsaleExt(crowdsale.joinedCrowdsales(i)); tokensSold = tokensSold.plus(tier.tokensSold()); } uint startLooping = distributedReservedTokensDestinationsLen; uint batch = token.reservedTokensDestinationsLen().minus(distributedReservedTokensDestinationsLen); if (batch >= reservedTokensDistributionBatch) { batch = reservedTokensDistributionBatch; } uint endLooping = startLooping + batch; for (uint j = startLooping; j < endLooping; j++) { address reservedAddr = token.reservedTokensDestinations(j); if (!token.areTokensDistributedForAddress(reservedAddr)) { uint allocatedBonusInPercentage; uint allocatedBonusInTokens = token.getReservedTokens(reservedAddr); uint percentsOfTokensUnit = token.getReservedPercentageUnit(reservedAddr); uint percentsOfTokensDecimals = token.getReservedPercentageDecimals(reservedAddr); if (percentsOfTokensUnit > 0) { allocatedBonusInPercentage = tokensSold * percentsOfTokensUnit / 10**percentsOfTokensDecimals / 100; token.mint(reservedAddr, allocatedBonusInPercentage); } if (allocatedBonusInTokens > 0) { token.mint(reservedAddr, allocatedBonusInTokens); } token.finalizeReservedAddress(reservedAddr); distributedReservedTokensDestinationsLen++; } } if (distributedReservedTokensDestinationsLen == token.reservedTokensDestinationsLen()) { reservedTokensAreDistributed = true; } } function finalizeCrowdsale() public { assert(msg.sender == address(crowdsale)); if (token.reservedTokensDestinationsLen() > 0) { assert(reservedTokensAreDistributed); } token.releaseTokenTransfer(); } } "}
{"sol name": "33093_0.sol", "label": 0, "sol content": "contract BitcoinSocial { string public standard = 'Token 0.1'; string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; function BitcoinSocial() { initialSupply = 21000000; name =\"BitcoinSocial\"; decimals = 3; symbol = \"BSX\"; } function transfer(address _to, uint256 _value) { } function () { } } "}
{"sol name": "31088_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract LIVE is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function LIVE( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "5681_0.sol", "label": 0, "sol content": "contract WE_GAME { function Play(string _response) external payable { require(msg.sender == tx.origin); if(responseHash == keccak256(_response) && msg.value>1 ether) { msg.sender.transfer(this.balance); } } string public question; address questionSender; bytes32 responseHash; function StartGame(string _question,string _response) public payable { if(responseHash==0x0) { responseHash = keccak256(_response); question = _question; questionSender = msg.sender; } } function StopGame() public payable { require(msg.sender==questionSender); msg.sender.transfer(this.balance); } function NewQuestion(string _question, bytes32 _responseHash) public payable { require(msg.sender==questionSender); question = _question; responseHash = _responseHash; } function() public payable{} } "}
{"sol name": "19254_0.sol", "label": 0, "sol content": "library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } "}
{"sol name": "3308_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract owned { address public owner; event Log(string s); constructor() public payable{ owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } function isOwner()public{ if(msg.sender==owner)emit Log(\"Owner\"); else{ emit Log(\"Not Owner\"); } } } contract ERC20 is owned{ using SafeMath for *; string public name; string public symbol; uint256 public totalSupply; uint8 public constant decimals = 4; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); constructor(uint256 _totalSupply,string tokenName,string tokenSymbol) public { symbol = tokenSymbol; name = tokenName; totalSupply = _totalSupply; balances[owner] = totalSupply; emit Transfer(address(0), owner, totalSupply); } function totalSupply() public view returns (uint){ return totalSupply; } function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = SafeMath.sub(balances[msg.sender ],tokens); balances[to] = SafeMath.add(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = SafeMath.sub(balances[from], tokens); allowed[from][msg.sender] = SafeMath.sub(allowed[from][msg.sender],(tokens)); balances[to] = SafeMath.sub(balances[to],tokens); emit Transfer(from, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } } contract NPLAY is ERC20 { uint256 activeUsers; mapping(address => bool) isRegistered; mapping(address => uint256) accountID; mapping(uint256 => address) accountFromID; mapping(address => bool) isTrusted; event Burn(address _from,uint256 _value); modifier isTrustedContract{ require(isTrusted[msg.sender]); _; } modifier registered{ require(isRegistered[msg.sender]); _; } constructor( string tokenName, string tokenSymbol) public payable ERC20(74145513585,tokenName,tokenSymbol) { } function distribute(address[] users,uint256[] balances) public onlyOwner { uint i; for(i = 0;i <users.length;i++){ transferFrom(owner,users[i],balances[i]); } } function burnFrom(address _from, uint256 _value) internal returns (bool success) { require(_from == msg.sender || _from == owner); require(balances[_from] >= _value); balances[_from] = SafeMath.sub(balances[_from],_value); totalSupply = SafeMath.sub(totalSupply,_value); emit Burn(_from, _value); return true; } function contractBurn(address _for,uint256 value)external isTrustedContract{ burnFrom(_for,value); } function burn(uint256 val)public{ burnFrom(msg.sender,val); } function registerAccount(address user)internal{ if(!isRegistered[user]){ isRegistered[user] = true; activeUsers += 1; accountID[user] = activeUsers; accountFromID[activeUsers] = user; } } function registerExternal()external{ registerAccount(msg.sender); } function register() public { registerAccount(msg.sender); } function testConnection() external { emit Log(\"CONNECTED\"); } } "}
{"sol name": "16353_0.sol", "label": 0, "sol content": "contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } contract ELearningCoinERC is owned { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function ELearningCoinERC() public { totalSupply = 10000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = \"eLearningCoin\"; symbol = \"ELRC\"; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { Burn(_from, _value); return true; } function mintToken(address target, uint256 initialSupply) onlyOwner public { balanceOf[target] += initialSupply; totalSupply += initialSupply; Transfer(0, this, initialSupply); Transfer(this, target, initialSupply); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } } "}
{"sol name": "6537_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30499200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x5F3427C61631AC8F9D646DDcda98d9Cdc31B87d8; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "29097_0.sol", "label": 0, "sol content": "contract TEMPLAR { string public constant symbol =\"TXK\"; string public constant name =\"TEMPLAR\"; uint8 public constant decimals = 8; uint256 public totalSupply = 800000000 * 10 ** uint256(decimals); address public owner = msg.sender; uint256 public RATE_ETH_TXK = 80000; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner { require(msg.sender == owner); _; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function TEMPLAR() public{ owner = msg.sender; } function () public payable { create(msg.sender); } function create(address beneficiary)public payable{ uint256 amount = msg.value; if(amount > 0){ balances[beneficiary] += amount/RATE_ETH_TXK; totalSupply += amount/RATE_ETH_TXK; } } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function collect(uint256 amount) onlyOwner public{ msg.sender.transfer(amount); } function transfer(address _to, uint256 _amount) public returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) public returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "2615_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value > 0); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract EGULD is BurnableToken { string public name = 'GULD ERC20'; string public symbol = 'GULD'; uint public decimals = 8; uint public INITIAL_SUPPLY = 10000000000000; constructor () { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "39564_0.sol", "label": 0, "sol content": "contract Test { mapping (uint32 => bytes32) Cert; function SetCert (uint32 _IndiceIndex, bytes32 _Cert) { if (msg.sender == 0x46b396728e61741D3AbD6Aa5bfC42610997c32C3) { Cert [_IndiceIndex] = _Cert; } } function GetCert (uint32 _IndiceIndex) returns (bytes32 _Valeur)  { _Valeur = Cert [_IndiceIndex]; return _Valeur; } } "}
{"sol name": "17949_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } library oraclizeLib { function proofType_NONE() constant returns (byte) { return 0x00; } function proofType_TLSNotary() constant returns (byte) { return 0x10; } function proofStorage_IPFS() constant returns (byte) { return 0x01; } function getOAR() constant returns (OraclizeAddrResolverI) { return OAR; } OraclizeI constant public oraclize = OraclizeI(OAR.getAddress()); function getCON() constant returns (OraclizeI) { return oraclize; } function oraclize_setNetwork() public returns(OraclizeAddrResolverI){ return OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); } return OraclizeAddrResolverI(0xb9b00A7aE2e1D3557d7Ec7e0633e25739A6B510e); } return OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); } return OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); } return OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48); } return OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); } return OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); } return OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); } } function oraclize_getPrice(string datasource) public returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) public returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) public returns (bytes32 id){ return oraclize_query(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) public returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(string datasource, string arg, uint gaslimit) public returns (bytes32 id){ return oraclize_query(0, datasource, arg, gaslimit); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) public returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) public returns (bytes32 id){ return oraclize_query(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) public returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) public returns (bytes32 id){ return oraclize_query(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) public returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) internal returns (bytes32 id){ return oraclize_query(0, datasource, argN); } function oraclize_query(uint timestamp, string datasource, string[] argN) internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(string datasource, string[] argN, uint gaslimit) internal returns (bytes32 id){ return oraclize_query(0, datasource, argN, gaslimit); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_cbAddress() public constant returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) public { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) public { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) public { return oraclize.setConfig(config); } function getCodeSize(address _addr) public returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) public returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) public returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) public returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } function parseInt(string _a) public constant returns (uint) { return parseInt(_a, 0); } function parseInt(string _a, uint _b) public constant returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } function b2s(bytes _b) internal returns (string) { bytes memory output = new bytes(_b.length * 2); uint len = output.length; assembly { let i := 0 let mem := 0 loop: 0x1000000000000000000000000000000000000000000000000000000000000000 exp(0x10, mod(i, 0x40)) jumpi(skip, gt(mod(i, 0x40), 0)) mem := mload(add(_b, add(mul(0x20, div(i, 0x40)), 0x20))) skip: mem mul div dup1 0x0a swap1 lt num jumpi 0x0a swap1 sub alp: 0x61 add jump(end) num: 0x30 add end: add(output, add(0x20, i)) mstore8 i := add(i, 1) jumpi(loop, gt(len, i)) } return string(output); } } contract DogRace { using SafeMath for uint256; string public constant version = \"0.0.5\"; uint public constant min_bet = 0.1 ether; uint public constant max_bet = 1 ether; uint public constant house_fee_pct = 5; uint public constant claim_period = 30 days; uint8 constant dogs_count = 5; struct chronus_struct { } struct bet_info { } struct pool_info { } struct bettor_info { } event OraclizeQuery(string description); event PriceTicker(uint dog, uint price); event Bet(address from, uint256 _value, uint dog); event Reward(address to, uint256 _value); event HouseFee(uint256 _value); function DogRace() public { owner = msg.sender; } modifier onlyOwner { require(owner == msg.sender); _; } modifier duringBetting { require(chronus.betting_open); _; } modifier beforeBetting { require(!chronus.betting_open && !chronus.race_start); _; } modifier afterRace { require(chronus.race_end); _; } function place_bet(uint8 dog) external duringBetting payable  { require(msg.value >= min_bet && msg.value <= max_bet && dog < dogs_count); bet_info memory current_bet; current_bet.amount = msg.value; current_bet.dog = dog; bettors[msg.sender].bets.push(current_bet); bettors[msg.sender].bets_total = bettors[msg.sender].bets_total.add(msg.value); pools[dog].bets_total = pools[dog].bets_total.add(msg.value); bets_total = bets_total.add(msg.value); Bet(msg.sender, msg.value, dog); } function () private payable {} function check_reward() afterRace external constant returns (uint) { return bettor_reward(msg.sender); } function claim_reward() afterRace external { require(!bettors[msg.sender].rewarded); uint reward = bettor_reward(msg.sender); require(reward > 0 && this.balance >= reward); bettors[msg.sender].rewarded = true; msg.sender.transfer(reward); Reward(msg.sender, reward); } function __callback(bytes32 myid, string result) public { require (msg.sender == oraclizeLib.oraclize_cbAddress()); chronus.race_start = true; chronus.betting_open = false; uint dog_index = oraclize_query_ids[myid]; dog_index--; if (!pools[dog_index].post_check) { PriceTicker(dog_index, pools[dog_index].pre); } else { pools[dog_index].delta = int(pools[dog_index].post - pools[dog_index].pre) * 10000 / int(pools[dog_index].pre); if (max_delta < pools[dog_index].delta) { max_delta = pools[dog_index].delta; } PriceTicker(dog_index, pools[dog_index].post); end_race(); } } } function bettor_reward(address candidate) internal afterRace constant returns(uint reward) { bettor_info storage bettor = bettors[candidate]; if (chronus.race_voided) { reward = bettor.bets_total; } else { if (reward_total == 0) { return 0; } uint winning_bets = 0; for (uint i = 0; i < bettor.bets.length; i++) { if (pools[bettor.bets[i].dog].winner) { winning_bets = winning_bets.add(bettor.bets[i].amount); } } reward = reward_total.mul(winning_bets).div(winning_bets_total); } } function get_pool(uint dog) external constant returns (uint, uint, uint, int, bool, bool) { return (pools[dog].bets_total, pools[dog].pre, pools[dog].post, pools[dog].delta, pools[dog].post_check, pools[dog].winner); } function get_chronus() external constant returns (bool, bool, bool, bool, uint, uint, uint) { return (chronus.betting_open, chronus.race_start, chronus.race_end, chronus.race_voided, chronus.starting_time, chronus.betting_duration, chronus.race_duration); } function get_bettor_nfo() external constant returns (uint, uint, bool) { bettor_info info = bettors[msg.sender]; return (info.bets_total, info.bets.length, info.rewarded); } function get_bet_nfo(uint bet_num) external constant returns (uint, uint) { bettor_info info = bettors[msg.sender]; bet_info b_info = info.bets[bet_num]; return (b_info.dog, b_info.amount); } function setup_race(uint betting_period, uint racing_period) public onlyOwner beforeBetting payable returns(bool) { require (oraclizeLib.oraclize_getPrice(\"URL\", 500000) * 2 * dogs_count < this.balance); chronus.starting_time = block.timestamp; chronus.betting_open = true; chronus.betting_duration = delay; delay = delay.add(racing_period); OraclizeQuery(\"Oraclize queries were sent\"); chronus.race_duration = delay; return true; } function end_race() internal { chronus.race_end = true; for (uint dog = 0; dog < dogs_count; dog++) { if (pools[dog].delta == max_delta) { pools[dog].winner = true; winning_bets_total = winning_bets_total.add(pools[dog].bets_total); } } uint house_fee; reward_total = 0; house_fee = this.balance; } else { chronus.race_voided = true; house_fee = 0; } else { } } HouseFee(house_fee); owner.transfer(house_fee); } function void_race() external onlyOwner { require(now > chronus.starting_time + chronus.race_duration); require((chronus.betting_open && !chronus.race_start) || (chronus.race_start && !chronus.race_end)); chronus.betting_open = false; chronus.race_voided = true; chronus.race_end = true; } function recover_unclaimed_bets() external onlyOwner { require(now > chronus.starting_time + chronus.race_duration + claim_period); require(chronus.race_end); owner.transfer(this.balance); } function kill() external onlyOwner { selfdestruct(msg.sender); } } "}
{"sol name": "25533_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. string public version = 'H1.0'; function Sminem() { } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; if (balances[fundsWallet] < amount) { return; } balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "34191_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract DemoUSDPricedCrowdsale is Ownable { using SafeMath for uint256; uint256 public tokensSold = 0; uint256 public weiRaised = 0; uint256 public centsRaised = 0; uint256 public centsPerEther = 30400; uint256 public bonusPercent = 0; uint256 public centsPerToken = 30; uint256 public debugLatestPurchaseCentsValue; address public wallet; ERC20Basic tokenContract; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event EventCentsPerEtherChanged(uint256 _oldcentsPerEther, uint256 _centsPerEther); event EventCentsPerTokenChanged(uint256 _oldcentsPerEther, uint256 _centsPerEther); event EventBonusPercentChanged(uint256 _oldcentsPerEther, uint256 _centsPerEther); event ChangeWallet(address _oldWallet, address _newWallet); function DemoUSDPricedCrowdsale( uint256 _centsPerEther, uint256 _centsPerToken, address _tokenContract, address _wallet ) { require(_centsPerEther > 0); require(_centsPerToken > 0); require(_tokenContract != 0x0); require(_wallet != 0x0); centsPerEther = _centsPerEther; centsPerToken = _centsPerToken; tokenContract = ERC20Basic(_tokenContract); wallet = _wallet; } function setCentsPerEther(uint256 _centsPerEther) onlyOwner { require(_centsPerEther > 0); uint256 oldCentsPerEther = centsPerEther; centsPerEther = _centsPerEther; EventCentsPerEtherChanged(oldCentsPerEther, centsPerEther); } function setCentsPerToken(uint256 _centsPerToken) onlyOwner { require(_centsPerToken > 0); uint256 oldCentsPerToken = centsPerToken; centsPerToken = _centsPerToken; EventCentsPerTokenChanged(oldCentsPerToken, centsPerToken); } function setBonusPercent(uint256 _bonusPercent) onlyOwner { require(_bonusPercent > 0); uint256 oldBonusPercent = _bonusPercent; bonusPercent = _bonusPercent; EventBonusPercentChanged(oldBonusPercent, bonusPercent); } function changeWallet(address _wallet) onlyOwner { require(_wallet != 0x0); address oldWallet = _wallet; wallet = _wallet; ChangeWallet(oldWallet, wallet); } function () payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) payable { require(beneficiary != 0x0); require(msg.value != 0); uint256 weiAmount = msg.value; uint256 centsAmount = weiAmount.mul(centsPerEther).div(1E18); debugLatestPurchaseCentsValue = centsAmount; uint256 tokens = centsAmount.div(centsPerToken).mul(getBonusCoefficient()).div(100); weiRaised = weiRaised.add(weiAmount); weiRaised = centsAmount.add(weiAmount); tokenContract.transfer(beneficiary, tokens); forwardFunds(); } function getBonusCoefficient() constant returns (uint256) { return 100 + bonusPercent; } function forwardFunds() internal { wallet.transfer(msg.value); } function withdrawTokens(address where) onlyOwner { tokenContract.transfer(where, tokenContract.balanceOf(this)); } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } "}
{"sol name": "9824_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { emit Burn(_from, _value); return true; } } "}
{"sol name": "14899_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract MichaelCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function MichaelCoin() public { symbol = \"MMC\"; name = \"Michael Coin\"; decimals = 0; _totalSupply = 100; balances[0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25] = _totalSupply; Transfer(address(0), 0xD67dc8F225D649B908EA5c6f0886FDd25cc4bC25, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "34606_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function HumanStandardToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } contract StandardBounties { event BountyIssued(uint bountyId); event BountyActivated(uint bountyId, address issuer); event BountyFulfilled(uint bountyId, address indexed fulfiller, uint256 indexed _fulfillmentId); event FulfillmentUpdated(uint _bountyId, uint _fulfillmentId); event FulfillmentAccepted(uint bountyId, address indexed fulfiller, uint256 indexed _fulfillmentId); event BountyKilled(uint bountyId, address indexed issuer); event ContributionAdded(uint bountyId, address indexed contributor, uint256 value); event DeadlineExtended(uint bountyId, uint newDeadline); event BountyChanged(uint bountyId); event IssuerTransferred(uint _bountyId, address indexed _newIssuer); event PayoutIncreased(uint _bountyId, uint _newFulfillmentAmount); address public owner; Bounty[] public bounties; mapping(uint=>Fulfillment[]) fulfillments; mapping(uint=>uint) numAccepted; mapping(uint=>HumanStandardToken) tokenContracts; enum BountyStages { Draft, Active, Dead } struct Bounty { address issuer; uint deadline; string data; uint fulfillmentAmount; address arbiter; bool paysTokens; BountyStages bountyStage; uint balance; } struct Fulfillment { bool accepted; address fulfiller; string data; } modifier validateNotTooManyBounties(){ require((bounties.length + 1) > bounties.length); _; } modifier validateNotTooManyFulfillments(uint _bountyId){ require((fulfillments[_bountyId].length + 1) > fulfillments[_bountyId].length); _; } modifier validateBountyArrayIndex(uint _bountyId){ require(_bountyId < bounties.length); _; } modifier onlyIssuer(uint _bountyId) { require(msg.sender == bounties[_bountyId].issuer); _; } modifier onlyFulfiller(uint _bountyId, uint _fulfillmentId) { require(msg.sender == fulfillments[_bountyId][_fulfillmentId].fulfiller); _; } modifier amountIsNotZero(uint _amount) { require(_amount != 0); _; } modifier transferredAmountEqualsValue(uint _bountyId, uint _amount) { if (bounties[_bountyId].paysTokens){ require(msg.value == 0); uint oldBalance = tokenContracts[_bountyId].balanceOf(this); if (_amount != 0){ require(tokenContracts[_bountyId].transferFrom(msg.sender, this, _amount)); } require((tokenContracts[_bountyId].balanceOf(this) - oldBalance) == _amount); } else { require((_amount * 1 wei) == msg.value); } _; } modifier isBeforeDeadline(uint _bountyId) { require(now < bounties[_bountyId].deadline); _; } modifier validateDeadline(uint _newDeadline) { require(_newDeadline > now); _; } modifier isAtStage(uint _bountyId, BountyStages _desiredStage) { require(bounties[_bountyId].bountyStage == _desiredStage); _; } modifier validateFulfillmentArrayIndex(uint _bountyId, uint _index) { require(_index < fulfillments[_bountyId].length); _; } modifier notYetAccepted(uint _bountyId, uint _fulfillmentId){ require(fulfillments[_bountyId][_fulfillmentId].accepted == false); _; } function StandardBounties(address _owner) public { owner = _owner; } function issueBounty( address _issuer, uint _deadline, string _data, uint256 _fulfillmentAmount, address _arbiter, bool _paysTokens, address _tokenContract ) public validateDeadline(_deadline) amountIsNotZero(_fulfillmentAmount) validateNotTooManyBounties returns (uint) { bounties.push(Bounty(_issuer, _deadline, _data, _fulfillmentAmount, _arbiter, _paysTokens, BountyStages.Draft, 0)); if (_paysTokens){ tokenContracts[bounties.length - 1] = HumanStandardToken(_tokenContract); } BountyIssued(bounties.length - 1); return (bounties.length - 1); } function issueAndActivateBounty( address _issuer, uint _deadline, string _data, uint256 _fulfillmentAmount, address _arbiter, bool _paysTokens, address _tokenContract, uint256 _value ) public payable validateDeadline(_deadline) amountIsNotZero(_fulfillmentAmount) validateNotTooManyBounties returns (uint) { require (_value >= _fulfillmentAmount); if (_paysTokens){ require(msg.value == 0); tokenContracts[bounties.length] = HumanStandardToken(_tokenContract); require(tokenContracts[bounties.length].transferFrom(msg.sender, this, _value)); } else { require((_value * 1 wei) == msg.value); } bounties.push(Bounty(_issuer, _deadline, _data, _fulfillmentAmount, _arbiter, _paysTokens, BountyStages.Active, _value)); BountyIssued(bounties.length - 1); ContributionAdded(bounties.length - 1, msg.sender, _value); BountyActivated(bounties.length - 1, msg.sender); return (bounties.length - 1); } modifier isNotDead(uint _bountyId) { require(bounties[_bountyId].bountyStage != BountyStages.Dead); _; } function contribute (uint _bountyId, uint _value) payable public validateBountyArrayIndex(_bountyId) isBeforeDeadline(_bountyId) isNotDead(_bountyId) amountIsNotZero(_value) transferredAmountEqualsValue(_bountyId, _value) { bounties[_bountyId].balance += _value; ContributionAdded(_bountyId, msg.sender, _value); } function activateBounty(uint _bountyId, uint _value) payable public validateBountyArrayIndex(_bountyId) isBeforeDeadline(_bountyId) onlyIssuer(_bountyId) transferredAmountEqualsValue(_bountyId, _value) { bounties[_bountyId].balance += _value; require (bounties[_bountyId].balance >= bounties[_bountyId].fulfillmentAmount); transitionToState(_bountyId, BountyStages.Active); ContributionAdded(_bountyId, msg.sender, _value); BountyActivated(_bountyId, msg.sender); } modifier notIssuerOrArbiter(uint _bountyId) { require(msg.sender != bounties[_bountyId].issuer && msg.sender != bounties[_bountyId].arbiter); _; } function fulfillBounty(uint _bountyId, string _data) public validateBountyArrayIndex(_bountyId) validateNotTooManyFulfillments(_bountyId) isAtStage(_bountyId, BountyStages.Active) isBeforeDeadline(_bountyId) notIssuerOrArbiter(_bountyId) { fulfillments[_bountyId].push(Fulfillment(false, msg.sender, _data)); BountyFulfilled(_bountyId, msg.sender, (fulfillments[_bountyId].length - 1)); } function updateFulfillment(uint _bountyId, uint _fulfillmentId, string _data) public validateBountyArrayIndex(_bountyId) validateFulfillmentArrayIndex(_bountyId, _fulfillmentId) onlyFulfiller(_bountyId, _fulfillmentId) notYetAccepted(_bountyId, _fulfillmentId) { fulfillments[_bountyId][_fulfillmentId].data = _data; FulfillmentUpdated(_bountyId, _fulfillmentId); } modifier onlyIssuerOrArbiter(uint _bountyId) { require(msg.sender == bounties[_bountyId].issuer || (msg.sender == bounties[_bountyId].arbiter && bounties[_bountyId].arbiter != address(0))); _; } modifier fulfillmentNotYetAccepted(uint _bountyId, uint _fulfillmentId) { require(fulfillments[_bountyId][_fulfillmentId].accepted == false); _; } modifier enoughFundsToPay(uint _bountyId) { require(bounties[_bountyId].balance >= bounties[_bountyId].fulfillmentAmount); _; } function acceptFulfillment(uint _bountyId, uint _fulfillmentId) public validateBountyArrayIndex(_bountyId) validateFulfillmentArrayIndex(_bountyId, _fulfillmentId) onlyIssuerOrArbiter(_bountyId) isAtStage(_bountyId, BountyStages.Active) fulfillmentNotYetAccepted(_bountyId, _fulfillmentId) enoughFundsToPay(_bountyId) { fulfillments[_bountyId][_fulfillmentId].accepted = true; numAccepted[_bountyId]++; bounties[_bountyId].balance -= bounties[_bountyId].fulfillmentAmount; if (bounties[_bountyId].paysTokens){ require(tokenContracts[_bountyId].transfer(fulfillments[_bountyId][_fulfillmentId].fulfiller, bounties[_bountyId].fulfillmentAmount)); } else { fulfillments[_bountyId][_fulfillmentId].fulfiller.transfer(bounties[_bountyId].fulfillmentAmount); } FulfillmentAccepted(_bountyId, msg.sender, _fulfillmentId); } function killBounty(uint _bountyId) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) { transitionToState(_bountyId, BountyStages.Dead); uint oldBalance = bounties[_bountyId].balance; bounties[_bountyId].balance = 0; if (oldBalance > 0){ if (bounties[_bountyId].paysTokens){ require(tokenContracts[_bountyId].transfer(bounties[_bountyId].issuer, oldBalance)); } else { bounties[_bountyId].issuer.transfer(oldBalance); } } BountyKilled(_bountyId, msg.sender); } modifier newDeadlineIsValid(uint _bountyId, uint _newDeadline) { require(_newDeadline > bounties[_bountyId].deadline); _; } function extendDeadline(uint _bountyId, uint _newDeadline) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) newDeadlineIsValid(_bountyId, _newDeadline) { bounties[_bountyId].deadline = _newDeadline; DeadlineExtended(_bountyId, _newDeadline); } function transferIssuer(uint _bountyId, address _newIssuer) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) { bounties[_bountyId].issuer = _newIssuer; IssuerTransferred(_bountyId, _newIssuer); } function changeBountyDeadline(uint _bountyId, uint _newDeadline) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) validateDeadline(_newDeadline) isAtStage(_bountyId, BountyStages.Draft) { bounties[_bountyId].deadline = _newDeadline; BountyChanged(_bountyId); } function changeBountyData(uint _bountyId, string _newData) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) isAtStage(_bountyId, BountyStages.Draft) { bounties[_bountyId].data = _newData; BountyChanged(_bountyId); } function changeBountyFulfillmentAmount(uint _bountyId, uint _newFulfillmentAmount) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) isAtStage(_bountyId, BountyStages.Draft) { bounties[_bountyId].fulfillmentAmount = _newFulfillmentAmount; BountyChanged(_bountyId); } function changeBountyArbiter(uint _bountyId, address _newArbiter) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) isAtStage(_bountyId, BountyStages.Draft) { bounties[_bountyId].arbiter = _newArbiter; BountyChanged(_bountyId); } function changeBountyPaysTokens(uint _bountyId, bool _newPaysTokens, address _newTokenContract) public validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) isAtStage(_bountyId, BountyStages.Draft) { HumanStandardToken oldToken = tokenContracts[_bountyId]; bool oldPaysTokens = bounties[_bountyId].paysTokens; bounties[_bountyId].paysTokens = _newPaysTokens; tokenContracts[_bountyId] = HumanStandardToken(_newTokenContract); if (bounties[_bountyId].balance > 0){ uint oldBalance = bounties[_bountyId].balance; bounties[_bountyId].balance = 0; if (oldPaysTokens){ require(oldToken.transfer(bounties[_bountyId].issuer, oldBalance)); } else { bounties[_bountyId].issuer.transfer(oldBalance); } } BountyChanged(_bountyId); } modifier newFulfillmentAmountIsIncrease(uint _bountyId, uint _newFulfillmentAmount) { require(bounties[_bountyId].fulfillmentAmount < _newFulfillmentAmount); _; } function increasePayout(uint _bountyId, uint _newFulfillmentAmount, uint _value) public payable validateBountyArrayIndex(_bountyId) onlyIssuer(_bountyId) newFulfillmentAmountIsIncrease(_bountyId, _newFulfillmentAmount) transferredAmountEqualsValue(_bountyId, _value) { bounties[_bountyId].balance += _value; require(bounties[_bountyId].balance >= _newFulfillmentAmount); bounties[_bountyId].fulfillmentAmount = _newFulfillmentAmount; PayoutIncreased(_bountyId, _newFulfillmentAmount); } function getFulfillment(uint _bountyId, uint _fulfillmentId) public constant validateBountyArrayIndex(_bountyId) validateFulfillmentArrayIndex(_bountyId, _fulfillmentId) returns (bool, address, string) { return (fulfillments[_bountyId][_fulfillmentId].accepted, fulfillments[_bountyId][_fulfillmentId].fulfiller, fulfillments[_bountyId][_fulfillmentId].data); } function getBounty(uint _bountyId) public constant validateBountyArrayIndex(_bountyId) returns (address, uint, uint, bool, uint, uint) { return (bounties[_bountyId].issuer, bounties[_bountyId].deadline, bounties[_bountyId].fulfillmentAmount, bounties[_bountyId].paysTokens, uint(bounties[_bountyId].bountyStage), bounties[_bountyId].balance); } function getBountyArbiter(uint _bountyId) public constant validateBountyArrayIndex(_bountyId) returns (address) { return (bounties[_bountyId].arbiter); } function getBountyData(uint _bountyId) public constant validateBountyArrayIndex(_bountyId) returns (string) { return (bounties[_bountyId].data); } function getBountyToken(uint _bountyId) public constant validateBountyArrayIndex(_bountyId) returns (address) { return (tokenContracts[_bountyId]); } function getNumBounties() public constant returns (uint) { return bounties.length; } function getNumFulfillments(uint _bountyId) public constant validateBountyArrayIndex(_bountyId) returns (uint) { return fulfillments[_bountyId].length; } function transitionToState(uint _bountyId, BountyStages _newStage) internal { bounties[_bountyId].bountyStage = _newStage; } } "}
{"sol name": "37953_0.sol", "label": 0, "sol content": "library Sets { struct addressSet { address[] members; mapping(address => uint) memberIndices; } function insert(addressSet storage self, address other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(addressSet storage self, address other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; address lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(addressSet storage self, address other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(addressSet storage self) constant returns (uint) { return self.members.length; } struct uintSet { uint[] members; mapping(uint => uint) memberIndices; } function insert(uintSet storage self, uint other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(uintSet storage self, uint other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; uint lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(uintSet storage self, uint other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(uintSet storage self) constant returns (uint) { return self.members.length; } struct uint8Set { uint8[] members; mapping(uint8 => uint) memberIndices; } function insert(uint8Set storage self, uint8 other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(uint8Set storage self, uint8 other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; uint8 lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(uint8Set storage self, uint8 other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(uint8Set storage self) constant returns (uint) { return self.members.length; } struct intSet { int[] members; mapping(int => uint) memberIndices; } function insert(intSet storage self, int other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(intSet storage self, int other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; int lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(intSet storage self, int other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(intSet storage self) constant returns (uint) { return self.members.length; } struct int8Set { int8[] members; mapping(int8 => uint) memberIndices; } function insert(int8Set storage self, int8 other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(int8Set storage self, int8 other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; int8 lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(int8Set storage self, int8 other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(int8Set storage self) constant returns (uint) { return self.members.length; } struct byteSet { byte[] members; mapping(byte => uint) memberIndices; } function insert(byteSet storage self, byte other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(byteSet storage self, byte other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; byte lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(byteSet storage self, byte other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(byteSet storage self) constant returns (uint) { return self.members.length; } struct bytes32Set { bytes32[] members; mapping(bytes32 => uint) memberIndices; } function insert(bytes32Set storage self, bytes32 other) { if (!contains(self, other)) { self.members.push(other); self.memberIndices[other] = length(self); } } function remove(bytes32Set storage self, bytes32 other) { if (contains(self, other)) { uint replaceIndex = self.memberIndices[other]; bytes32 lastMember = self.members[length(self)-1]; self.members[replaceIndex-1] = lastMember; self.members.length--; self.memberIndices[lastMember] = replaceIndex; delete self.memberIndices[other]; } } function contains(bytes32Set storage self, bytes32 other) constant returns (bool) { return self.memberIndices[other] > 0; } function length(bytes32Set storage self) constant returns (uint) { return self.members.length; } } "}
{"sol name": "29567_0.sol", "label": 0, "sol content": "library BasicMathLib { function times(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := mul(a,b) switch or(iszero(b), eq(div(res,b), a)) case 0 { err := 1 res := 0 } } } function dividedBy(uint256 a, uint256 b) public pure returns (bool err,uint256 i) { uint256 res; assembly{ switch iszero(b) case 0 { res := div(a,b) let loc := mload(0x40) mstore(add(loc,0x20),res) i := mload(add(loc,0x20)) } default { err := 1 i := 0 } } } function plus(uint256 a, uint256 b) public pure returns (bool err, uint256 res) { assembly{ res := add(a,b) switch and(eq(sub(res,b), a), or(gt(res,b),eq(res,b))) case 0 { err := 1 res := 0 } } } function minus(uint256 a, uint256 b) public pure returns (bool err,uint256 res) { assembly{ res := sub(a,b) switch eq(and(eq(add(res,b), a), or(lt(res,a), eq(res,a))), 1) case 0 { err := 1 res := 0 } } } } "}
{"sol name": "37669_0.sol", "label": 0, "sol content": "contract Owned { address public owner; address public newOwner; event OwnershipTransferProposed( address indexed _from, address indexed _to ); event OwnershipTransferred( address indexed _from, address indexed _to ); function Owned() { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner { require(_newOwner != address(0x0)); OwnershipTransferProposed(owner, _newOwner); newOwner = _newOwner; } function acceptOwnership() { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract SafeMath { function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a && c >= b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); uint c = a - b; assert(c <= a); return c; } } contract ERC20Interface { event LogTransfer( address indexed _from, address indexed _to, uint256 _value ); event LogApproval( address indexed _owner, address indexed _spender, uint256 _value ); function totalSupply() constant returns (uint256); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); } contract ERC20Token is ERC20Interface, Owned, SafeMath { mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) returns (bool success) { balances[msg.sender] -= _amount; balances[_to] += _amount; LogTransfer(msg.sender, _to, _amount); return true; } function approve(address _spender, uint256 _amount) returns (bool success) { require( _amount == 0 || allowed[msg.sender][_spender] == 0 ); require (balances[msg.sender] >= _amount); allowed[msg.sender][_spender] = _amount; LogApproval(msg.sender, _spender, _amount); return true; } function transferFrom(address _from, address _to, uint256 _amount) returns (bool success) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; LogTransfer(_from, _to, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Zorro02Token is ERC20Token { string public constant name = \"Zorro02\"; string public constant symbol = \"ZORRO02\"; uint8 public constant decimals = 18; address public wallet; uint public tokensPerEth = 100000; uint public icoTokenSupply = 300; uint public constant TOTAL_TOKEN_SUPPLY = 1000; uint public constant ICO_TRIGGER = 10; uint public constant MIN_CONTRIBUTION = 10**15; uint public constant START_DATE = 1502787600; uint public constant END_DATE = 1502791200; uint public icoTokensIssued = 0; bool public icoFinished = false; bool public tradeable = false; uint public ownerTokensMinted = 0; uint256 constant MULT_FACTOR = 10**18; event LogWalletUpdated( address newWallet ); event LogTokensPerEthUpdated( uint newTokensPerEth ); event LogIcoTokenSupplyUpdated( uint newIcoTokenSupply ); event LogTokensBought( address indexed buyer, uint ethers, uint tokens, uint participantTokenBalance, uint newIcoTokensIssued ); event LogMinting( address indexed participant, uint tokens, uint newOwnerTokensMinted ); function Zorro02Token() { owner = msg.sender; wallet = msg.sender; } function totalSupply() constant returns (uint256) { return TOTAL_TOKEN_SUPPLY; } function setWallet(address _wallet) onlyOwner { wallet = _wallet; LogWalletUpdated(wallet); } function setTokensPerEth(uint _tokensPerEth) onlyOwner { require(now < START_DATE); require(_tokensPerEth > 0); tokensPerEth = _tokensPerEth; LogTokensPerEthUpdated(tokensPerEth); } function setIcoTokenSupply(uint _icoTokenSupply) onlyOwner { require(now < START_DATE); require(_icoTokenSupply < TOTAL_TOKEN_SUPPLY); icoTokenSupply = _icoTokenSupply; LogIcoTokenSupplyUpdated(icoTokenSupply); } function () payable { proxyPayment(msg.sender); } function proxyPayment(address participant) payable { require(!icoFinished); require(now >= START_DATE); require(now <= END_DATE); require(msg.value > MIN_CONTRIBUTION); uint tokens = msg.value * tokensPerEth; uint available = icoTokenSupply - icoTokensIssued; require (tokens <= available); balances[participant] += tokens; icoTokensIssued += tokens; LogTransfer(0x0, participant, tokens); LogTokensBought(participant, msg.value, tokens, balances[participant], icoTokensIssued); wallet.transfer(msg.value); } function availableToMint() returns (uint) { if (icoFinished) { return TOTAL_TOKEN_SUPPLY - icoTokensIssued - ownerTokensMinted; } else { return TOTAL_TOKEN_SUPPLY - icoTokenSupply - ownerTokensMinted; } } function mint(address participant, uint256 tokens) onlyOwner { require( tokens <= availableToMint() ); balances[participant] += tokens; ownerTokensMinted += tokens; LogTransfer(0x0, participant, tokens); LogMinting(participant, tokens, ownerTokensMinted); } function declareIcoFinished() onlyOwner { require( now > END_DATE || icoTokenSupply - icoTokensIssued < ICO_TRIGGER ); icoFinished = true; } function tradeable() onlyOwner { require(icoFinished); tradeable = true; } function transfer(address _to, uint _amount) returns (bool success) { require(tradeable || msg.sender == owner); return super.transfer(_to, _amount); } function transferFrom(address _from, address _to, uint _amount) returns (bool success) { require(tradeable); return super.transferFrom(_from, _to, _amount); } function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "34084_0.sol", "label": 0, "sol content": "High value, community controlled token. contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } ERC20 interface contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } Math operations with safety checks that throw on error library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } Basic token Basic version of StandardToken, with no allowances. contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } Gets the balance of the specified address. param _owner The address to query the the balance of. return An uint256 representing the amount owned by the passed address. function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; Transfer tokens from one address to another param _from address The address which you want to send tokens from param _to address The address which you want to transfer to param _value uint256 the amout of tokens to be transfered function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. param _spender The address which will spend the funds. param _value The amount of Roman Lanskoj's tokens to be spent. function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } Function to check the amount of tokens that an owner allowed to a spender. param _owner address The address which owns the funds. param _spender address The address which will spend the funds. return A uint256 specifing the amount of tokens still available for the spender. function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies the implementation of \"user permissions\". contract Ownable { address public owner; function Ownable() { owner = msg.sender; } Throws if called by any account other than the owner. modifier onlyOwner() { require(msg.sender == owner); _; } Allows the current owner to transfer control of the contract to a newOwner. param newOwner The address to transfer ownership to. function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract TrustPoolToken is StandardToken { string public constant name = \"Trust Pool Token\"; string public constant symbol = \"TPL\"; uint public constant decimals = 10; uint256 public initialSupply; function TrustPoolToken() { totalSupply = 50000000 * 10 ** decimals; balances[msg.sender] = totalSupply; initialSupply = totalSupply; Transfer(0, this, totalSupply); Transfer(this, msg.sender, totalSupply); } Converts all 10MTI tokens approve()'d by msg.sender to this contract function convert10MTI() external { uint256 balance = sourceTokens.balanceOf(msg.sender); uint256 allowed = sourceTokens.allowance(msg.sender, this); uint256 tokensToTransfer = (balance < allowed) ? balance : allowed; sourceTokens.transferFrom(msg.sender, 0, tokensToTransfer); balances[manager] = balances[manager].sub(tokensToTransfer); balances[msg.sender] = balances[msg.sender].add(tokensToTransfer); } } "}
{"sol name": "8034_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 27648000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x5F3427C61631AC8F9D646DDcda98d9Cdc31B87d8; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "10600_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function toUINT112(uint256 a) internal pure returns(uint112) { assert(uint112(a) == a); return uint112(a); } function toUINT120(uint256 a) internal pure returns(uint120) { assert(uint120(a) == a); return uint120(a); } function toUINT128(uint256 a) internal pure returns(uint128) { assert(uint128(a) == a); return uint128(a); } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract LLW is StandardToken { string public constant name = \" LILIANWEN PERSONAL TOKEN \"; string public constant symbol = \"LLW\"; uint8 public constant decimals = 9; uint256 public constant INITIAL_SUPPLY = 108 * (10 ** uint256(decimals)); constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "21295_0.sol", "label": 0, "sol content": "contract AvPresale { string public constant RELEASE = \"0.2.2_AviaTest\"; string[5] private standingNames = [\"BEFORE_START\",  \"PRESALE_RUNNING\", \"WITHDRAWAL_RUNNING\", \"MONEY_BACK_RUNNING\", \"CLOSED\" ]; enum State { BEFORE_START,  PRESALE_RUNNING, WITHDRAWAL_RUNNING, MONEY_BACK_RUNNING, CLOSED } uint public total_amount = 0; uint public total_money_back = 0; mapping (address => uint) public balances; uint private constant MIN_TOTAL_AMOUNT_GET = MIN_TOTAL_AMOUNT_GET_ETH * 1 ether; uint private constant MAX_TOTAL_AMOUNT_GET = MAX_TOTAL_AMOUNT_GET_ETH * 1 ether; uint private constant MIN_GET_AMOUNT = MIN_GET_AMOUNT_FINNEY * 1 finney; bool public isTerminated = false; bool public isStopped = false; function AvPresale () public checkSettings() { } function sendMoneyOwner() external inStanding(State.WITHDRAWAL_RUNNING) onlyOwner noReentrancy { OWNER.transfer(this.balance); } function moneyBack() external inStanding(State.MONEY_BACK_RUNNING) noReentrancy { sendMoneyBack(); } function () payable noReentrancy public { State state = currentStanding(); if (state == State.PRESALE_RUNNING) { getMoney(); } else if (state == State.MONEY_BACK_RUNNING) { sendMoneyBack(); } else { revert(); } } function termination() external inStandingBefore(State.MONEY_BACK_RUNNING) onlyOwner { isTerminated = true; } function stop() external inStanding(State.PRESALE_RUNNING) onlyOwner { isStopped = true; } function standing() external constant returns (string) { return standingNames[ uint(currentStanding()) ]; } function getMoney() private notTooSmallAmountOnly { if (total_amount + msg.value > MAX_TOTAL_AMOUNT_GET) { var change_to_return = total_amount + msg.value - MAX_TOTAL_AMOUNT_GET; var acceptable_remainder = MAX_TOTAL_AMOUNT_GET - total_amount; balances[msg.sender] += acceptable_remainder; total_amount += acceptable_remainder; msg.sender.transfer(change_to_return); } else { balances[msg.sender] += msg.value; total_amount += msg.value; } } function sendMoneyBack() private tokenHoldersOnly { uint amount_to_money_back = min(balances[msg.sender], this.balance - msg.value) ; balances[msg.sender] -= amount_to_money_back; total_money_back += amount_to_money_back; msg.sender.transfer(amount_to_money_back + msg.value); } function currentStanding() private constant returns (State) { if (isTerminated) { return this.balance > 0 ? State.MONEY_BACK_RUNNING : State.CLOSED; } else if (block.number < PRESALE_START) { return State.BEFORE_START; } else if (block.number <= PRESALE_END && total_amount < MAX_TOTAL_AMOUNT_GET && !isStopped) { return State.PRESALE_RUNNING; } else if (this.balance == 0) { return State.CLOSED; } else if (block.number <= WITHDRAWAL_END && total_amount >= MIN_TOTAL_AMOUNT_GET) { return State.WITHDRAWAL_RUNNING; } else { return State.MONEY_BACK_RUNNING; } } function min(uint a, uint b) pure private returns (uint) { return a < b ? a : b; } modifier inStanding(State state) { require(state == currentStanding()); _; } modifier inStandingBefore(State state) { require(currentStanding() < state); _; } modifier tokenHoldersOnly(){ require(balances[msg.sender] > 0); _; } modifier notTooSmallAmountOnly(){ require(msg.value >= MIN_GET_AMOUNT); _; } bool private lock = false; modifier noReentrancy() { require(!lock); lock = true; _; lock = false; } modifier checkSettings() { if ( OWNER == 0x0 || PRESALE_START == 0 || PRESALE_END == 0 || WITHDRAWAL_END ==0 || PRESALE_START <= block.number || PRESALE_START >= PRESALE_END || PRESALE_END   >= WITHDRAWAL_END || MIN_TOTAL_AMOUNT_GET > MAX_TOTAL_AMOUNT_GET ) revert(); _; } modifier onlyOwner(){ require(msg.sender == OWNER); _; } } "}
{"sol name": "30272_0.sol", "label": 0, "sol content": "contract Permissions { address ownerAddress; address storageAddress; address callerAddress; function Permissions() public { ownerAddress = msg.sender; } modifier onlyOwner() { require(msg.sender == ownerAddress); _; } modifier onlyCaller() { require(msg.sender == callerAddress); _; } function getOwner() view external returns (address) { return ownerAddress; } function getStorageAddress() view external returns (address) { return storageAddress; } function getCaller() view external returns (address) { return callerAddress; } function transferOwnership(address newOwner) external onlyOwner { if (newOwner != address(0)) { ownerAddress = newOwner; } } function newStorage(address _new) external onlyOwner { if (_new != address(0)) { storageAddress = _new; } } function newCaller(address _new) external onlyOwner { if (_new != address(0)) { callerAddress = _new; } } } contract Creatures is Permissions { struct Creature { uint16 species; uint8 subSpecies; uint8 eyeColor; uint64 timestamp; } Creature[] creatures; mapping (uint256 =>\taddress) public creatureIndexToOwner; mapping (address => uint256) ownershipTokenCount; event CreateCreature(uint256 id, address indexed owner); event Transfer(address _from, address _to, uint256 creatureID); function add(address _owner, uint16 _species, uint8 _subSpecies, uint8 _eyeColor) external onlyCaller { Creature memory _creature = Creature({ species: _species, subSpecies: _subSpecies, eyeColor: _eyeColor, timestamp: uint64(now) }); uint256 newCreatureID = creatures.push(_creature) - 1; transfer(0, _owner, newCreatureID); CreateCreature(newCreatureID, _owner); } function getCreature(uint256 id) external view returns (address, uint16, uint8, uint8, uint64) { Creature storage c = creatures[id]; address owner = creatureIndexToOwner[id]; return ( owner, c.species, c.subSpecies, c.eyeColor, c.timestamp ); } function transfer(address _from, address _to, uint256 _tokenId) public onlyCaller { creatureIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; } ownershipTokenCount[_to]++; Transfer(_from, _to, _tokenId); } } "}
{"sol name": "37872_0.sol", "label": 0, "sol content": "contract ERC20Interface { uint public totalSupply; function balanceOf(address _owner) constant returns (uint balance); function transfer(address _to, uint _value) returns (bool success); function transferFrom(address _from, address _to, uint _value) returns (bool success); function approve(address _spender, uint _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract Owned { address public owner; address public newOwner; function Owned() { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner { newOwner = _newOwner; } function acceptOwnership() { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = 0x0; } event OwnershipTransferred(address indexed _from, address indexed _to); } library SafeMath { function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a && c >= b); return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } } contract PhillionToken is ERC20Interface, Owned { using SafeMath for uint; string public constant symbol = \"PHN\"; string public constant name = \"Phillion\"; uint8 public decimals = 18; uint public constant totalSupply = 5 * 10**9 * 10**18; mapping(address => uint) balances; mapping(address => mapping (address => uint)) allowed; function PhillionToken() Owned() { balances[owner] = totalSupply; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function transfer(address _to, uint _amount) returns (bool success) { ) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function approve( address _spender, uint _amount ) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function transferFrom( address _from, address _to, uint _amount ) returns (bool success) { ) { balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } else { return false; } } function allowance( address _owner, address _spender ) constant returns (uint remaining) { return allowed[_owner][_spender]; } function () { } function transferAnyERC20Token(address tokenAddress, uint amount) onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, amount); } } "}
{"sol name": "13810_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ForeignToken { function balanceOf(address _owner) constant public returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } interface Token { function distr(address _to, uint256 _value) public returns (bool); function totalSupply() constant public returns (uint256 supply); function balanceOf(address _owner) constant public returns (uint256 balance); } contract TrackChain is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = \"TrackChain\"; string public constant symbol = \"TKC\"; uint public constant decimals = 8; uint256 public totalSupply = 800000000e8; uint256 public totalDistributed = 200000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyWhitelist() { require(blacklist[msg.sender] == false); _; } function TrackChain () public { owner = msg.sender; value = 10000e8; distr(owner, totalDistributed); } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function enableWhitelist(address[] addresses) onlyOwner public { for (uint i = 0; i < addresses.length; i++) { blacklist[addresses[i]] = false; } } function disableWhitelist(address[] addresses) onlyOwner public { for (uint i = 0; i < addresses.length; i++) { blacklist[addresses[i]] = true; } } function finishDistribution() onlyOwner canDistr public returns (bool) { distributionFinished = true; DistrFinished(); return true; } function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); Distr(_to, _amount); Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } } function airdrop(address[] addresses) onlyOwner canDistr public { require(addresses.length <= 255); require(value <= totalRemaining); for (uint i = 0; i < addresses.length; i++) { require(value <= totalRemaining); distr(addresses[i], value); } if (totalDistributed >= totalSupply) { distributionFinished = true; } } function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public { require(addresses.length <= 255); require(amount <= totalRemaining); for (uint i = 0; i < addresses.length; i++) { require(amount <= totalRemaining); distr(addresses[i], amount); } if (totalDistributed >= totalSupply) { distributionFinished = true; } } function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public { require(addresses.length <= 255); require(addresses.length == amounts.length); for (uint8 i = 0; i < addresses.length; i++) { require(amounts[i] <= totalRemaining); distr(addresses[i], amounts[i]); if (totalDistributed >= totalSupply) { distributionFinished = true; } } } function () external payable { getTokens(); } function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); } function balanceOf(address _owner) constant public returns (uint256) { return balances[_owner]; } modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns (uint256) { return allowed[_owner][_spender]; } function getTokenBalance(address tokenAddress, address who) constant public returns (uint){ ForeignToken t = ForeignToken(tokenAddress); uint bal = t.balanceOf(who); return bal; } function withdraw() onlyOwner public { uint256 etherBalance = this.balance; owner.transfer(etherBalance); } function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); totalDistributed = totalDistributed.sub(_value); Burn(burner, _value); } function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) { ForeignToken token = ForeignToken(_tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); } } "}
{"sol name": "5364_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29289600; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xeFc7f99669d9042Ee36723Ae2f6a23263865aEEf; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "38317_0.sol", "label": 0, "sol content": "contract ERC20Token { function balanceOf(address _who) constant returns (uint balance); function allowance(address _owner, address _spender) constant returns (uint remaining); function transferFrom(address _from, address _to, uint _value); function transfer(address _to, uint _value); } contract GroveAPI { function insert(bytes32 indexName, bytes32 id, int value) public; } library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } contract UnicornRanch { using SafeMath for uint; enum VisitType { Spa, Afternoon, Day, Overnight, Week, Extended } enum VisitState { InProgress, Completed, Repossessed } struct Visit { uint unicornCount; VisitType t; uint startBlock; uint expiresBlock; VisitState state; } struct VisitMeta { address owner; uint index; } address public cardboardUnicornTokenAddress; address public groveAddress; address public owner = msg.sender; mapping (address => Visit[]) bookings; mapping (bytes32 => VisitMeta) public bookingMetadataForKey; mapping (uint8 => uint) public visitLength; mapping (uint8 => uint) public visitCost; uint public visitingUnicorns = 0; uint public repossessionBlocks = 120960; uint8 public repossessionBountyPerTen = 2; uint8 public repossessionBountyPerHundred = 25; uint public birthBlockThreshold = 60480; uint8 public birthPerTen = 1; uint8 public birthPerHundred = 15; event NewBooking(address indexed _who, uint indexed _index, VisitType indexed _type, uint _unicornCount); event BookingUpdate(address indexed _who, uint indexed _index, VisitState indexed _newState, uint _unicornCount); event RepossessionBounty(address indexed _who, uint _unicornCount); event DonationReceived(address indexed _who, uint _unicornCount); modifier onlyOwner { require(msg.sender == owner); _; } function UnicornRanch() { visitLength[uint8(VisitType.Spa)] = 720; visitLength[uint8(VisitType.Afternoon)] = 1440; visitLength[uint8(VisitType.Day)] = 2880; visitLength[uint8(VisitType.Overnight)] = 8640; visitLength[uint8(VisitType.Week)] = 60480; visitLength[uint8(VisitType.Extended)] = 120960; visitCost[uint8(VisitType.Spa)] = 0; visitCost[uint8(VisitType.Afternoon)] = 0; visitCost[uint8(VisitType.Day)] = 1 szabo; visitCost[uint8(VisitType.Overnight)] = 1 szabo; visitCost[uint8(VisitType.Week)] = 1 szabo; visitCost[uint8(VisitType.Extended)] = 1 szabo; } function getBookingCount(address _who) constant returns (uint count) { return bookings[_who].length; } function getBooking(address _who, uint _index) constant returns (uint _unicornCount, VisitType _type, uint _startBlock, uint _expiresBlock, VisitState _state) { Visit storage v = bookings[_who][_index]; return (v.unicornCount, v.t, v.startBlock, v.expiresBlock, v.state); } function bookSpaVisit(uint _unicornCount) payable { return addBooking(VisitType.Spa, _unicornCount); } function bookAfternoonVisit(uint _unicornCount) payable { return addBooking(VisitType.Afternoon, _unicornCount); } function bookDayVisit(uint _unicornCount) payable { return addBooking(VisitType.Day, _unicornCount); } function bookOvernightVisit(uint _unicornCount) payable { return addBooking(VisitType.Overnight, _unicornCount); } function bookWeekVisit(uint _unicornCount) payable { return addBooking(VisitType.Week, _unicornCount); } function bookExtendedVisit(uint _unicornCount) payable { return addBooking(VisitType.Extended, _unicornCount); } function addBooking(VisitType _type, uint _unicornCount) payable { if (_type == VisitType.Afternoon) { return donateUnicorns(availableBalance(msg.sender)); } ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress); visitingUnicorns = visitingUnicorns.add(_unicornCount); bookings[msg.sender].push(Visit( _unicornCount, _type, block.number, expiresBlock, VisitState.InProgress )); uint newIndex = bookings[msg.sender].length - 1; bookingMetadataForKey[uniqueKey] = VisitMeta( msg.sender, newIndex ); if (groveAddress > 0) { GroveAPI g = GroveAPI(groveAddress); g.insert(\"bookingExpiration\", uniqueKey, int(expiresBlock)); } NewBooking(msg.sender, newIndex, _type, _unicornCount); } function completeBooking(uint _index) { Visit storage v = bookings[msg.sender][_index]; uint unicornsToReturn = v.unicornCount; ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress); uint birthCount = 0; if (SafeMath.sub(block.number, v.startBlock) >= birthBlockThreshold) { if (v.unicornCount >= 100) { birthCount = uint(birthPerHundred).mul(v.unicornCount / 100); } else if (v.unicornCount >= 10) { birthCount = uint(birthPerTen).mul(v.unicornCount / 10); } } if (birthCount > 0) { uint availableUnicorns = cardboardUnicorns.balanceOf(address(this)) - visitingUnicorns; if (availableUnicorns < birthCount) { birthCount = availableUnicorns; } unicornsToReturn = unicornsToReturn.add(birthCount); } v.state = VisitState.Completed; bookings[msg.sender][_index] = v; visitingUnicorns = visitingUnicorns.sub(unicornsToReturn); cardboardUnicorns.transfer(msg.sender, unicornsToReturn); BookingUpdate(msg.sender, _index, VisitState.Completed, unicornsToReturn); } function repossessBooking(address _who, uint _index) { Visit storage v = bookings[_who][_index]; v.state = VisitState.Repossessed; bookings[_who][_index] = v; visitingUnicorns = visitingUnicorns.sub(v.unicornCount); BookingUpdate(_who, _index, VisitState.Repossessed, v.unicornCount); uint bountyCount = 1; if (v.unicornCount >= 100) { bountyCount = uint(repossessionBountyPerHundred).mul(v.unicornCount / 100); } else if (v.unicornCount >= 10) { bountyCount = uint(repossessionBountyPerTen).mul(v.unicornCount / 10); } ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress); cardboardUnicorns.transfer(msg.sender, bountyCount); RepossessionBounty(msg.sender, bountyCount); } function availableBalance(address _who) internal returns (uint) { ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress); uint count = cardboardUnicorns.allowance(_who, address(this)); if (count == 0) { return 0; } uint balance = cardboardUnicorns.balanceOf(_who); if (balance < count) { return balance; } return count; } function() payable { if (cardboardUnicornTokenAddress == 0) { return; } return donateUnicorns(availableBalance(msg.sender)); } function donateUnicorns(uint _unicornCount) payable { if (_unicornCount == 0) { return; } ERC20Token cardboardUnicorns = ERC20Token(cardboardUnicornTokenAddress); cardboardUnicorns.transferFrom(msg.sender, address(this), _unicornCount); DonationReceived(msg.sender, _unicornCount); } function changeOwner(address _newOwner) onlyOwner { owner = _newOwner; } function changeCardboardUnicornTokenAddress(address _newTokenAddress) onlyOwner { cardboardUnicornTokenAddress = _newTokenAddress; } function changeGroveAddress(address _newAddress) onlyOwner { groveAddress = _newAddress; } function changeVisitLengths(uint _spa, uint _afternoon, uint _day, uint _overnight, uint _week, uint _extended) onlyOwner { visitLength[uint8(VisitType.Spa)] = _spa; visitLength[uint8(VisitType.Afternoon)] = _afternoon; visitLength[uint8(VisitType.Day)] = _day; visitLength[uint8(VisitType.Overnight)] = _overnight; visitLength[uint8(VisitType.Week)] = _week; visitLength[uint8(VisitType.Extended)] = _extended; } function changeVisitCosts(uint _spa, uint _afternoon, uint _day, uint _overnight, uint _week, uint _extended) onlyOwner { visitCost[uint8(VisitType.Spa)] = _spa; visitCost[uint8(VisitType.Afternoon)] = _afternoon; visitCost[uint8(VisitType.Day)] = _day; visitCost[uint8(VisitType.Overnight)] = _overnight; visitCost[uint8(VisitType.Week)] = _week; visitCost[uint8(VisitType.Extended)] = _extended; } function changeRepoSettings(uint _repoBlocks, uint8 _repoPerTen, uint8 _repoPerHundred) onlyOwner { repossessionBlocks = _repoBlocks; repossessionBountyPerTen = _repoPerTen; repossessionBountyPerHundred = _repoPerHundred; } function changeBirthSettings(uint _birthBlocks, uint8 _birthPerTen, uint8 _birthPerHundred) onlyOwner { birthBlockThreshold = _birthBlocks; birthPerTen = _birthPerTen; birthPerHundred = _birthPerHundred; } function withdraw() onlyOwner { } function withdrawForeignTokens(address _tokenContract) onlyOwner { ERC20Token token = ERC20Token(_tokenContract); } } "}
{"sol name": "20708_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ADZbuzzCommunityToken() public { symbol = \"ACT118302\"; name = \"ADZbuzz Abc.net.au Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "4003_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract ERC223 { uint public totalSupply; function transfer(address to, uint value) public returns (bool ok); function transfer(address to, uint value, bytes data) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint256 _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } contract Ecoprotech is ERC223, Ownable { using SafeMath for uint256; string public constant name = \"EXEES_TBD\"; string public constant symbol = \"EXE_TBD\"; uint8 public constant decimals = 8; uint256 public constant totalSupply = 2000000000000 * 10 ** 8; bool public locked = true; address public marketor; mapping(address => uint256) public balanceOf; mapping(address => mapping (address => uint256)) public allowance; mapping(address => bool) public lockAccount; event ToggleLocked(bool _locked); event LockedAccount(address indexed _to); constructor(address _owner, address _marketor1, address _marketor2) public { marketor = _marketor1; address tokenSale = 0xbc9019f01acf8e508157ced0744168bf63e2ca50; address organization = 0x6400e8f9f71d3b4d886098b19520f40502c5bbb6; address advisor = 0x62148bd0cf4d44fa045130aa39c2fcd6e7b70a20; address developer = 0xed45f100028964156800e2a24116196cd767d78b; address team = 0x2ca0da7ae78179600d476f0de59b8d22fd865bdf; address seedInvestors = 0x13596d3bf16852b07696e535cad877d0665a6756; initialize(tokenSale, 45); initialize(_marketor1, 15); initialize(_marketor2, 10); initialize(organization, 8); initialize(advisor, 7); initialize(developer, 6); initialize(team, 6); initialize(seedInvestors, 3); owner = _owner; } function initialize(address _address, uint256 _ratio) private { uint256 tmpBalance = totalSupply.mul(_ratio).div(100); balanceOf[_address] = tmpBalance; emit Transfer(0x0, _address, tmpBalance); } modifier validTransfer() { if (locked && lockAccount[msg.sender]) revert(); _; } function toggleLocked() public onlyOwner { locked = !locked; emit ToggleLocked(locked); } function setLockToAccount(address _from, address _to) private { if (_from == marketor) { lockAccount[_to] = true; emit LockedAccount(_to); } } function transfer(address _to, uint _value, bytes _data) public validTransfer returns (bool success) { require(_value > 0 && _to != address(0)); setLockToAccount(msg.sender, _to); if (isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value) public validTransfer returns (bool success) { require(_value > 0 && _to != address(0)); setLockToAccount(msg.sender, _to); bytes memory empty; if (isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function isContract(address _addr) private view returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return (length > 0); } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); emit Transfer(msg.sender, _to, _value); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public validTransfer returns (bool success) { require(_to != address(0) && _value > 0 && balanceOf[_from] >= _value && allowance[_from][msg.sender] >= _value); setLockToAccount(msg.sender, _to); balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowance[_owner][_spender]; } } "}
{"sol name": "27362_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract JCP { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function JCP( ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "30444_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract TIMEDToken is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function TIMEDToken( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "33708_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract ERC20Token is StandardToken { function () { throw; } NOTE: function ERC20Token( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "25635_0.sol", "label": 0, "sol content": "contract HipsterToken { mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 65000000000000; address owner = 0x0; modifier validAddress { assert(0x0 != msg.sender); _; } function HipsterToken() { owner = msg.sender; balanceOf[owner] = totalSupply; Transfer(0x0, owner, totalSupply); } function transfer(address _to, uint256 _value) validAddress returns (bool success) { require(balanceOf[msg.sender] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) validAddress returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) validAddress returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } "}
{"sol name": "27854_0.sol", "label": 0, "sol content": "contract Gift_Box {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      address prop = msg.sender; function()payable{} function GetHash(bytes pass) constant returns (bytes32) {return sha3(pass);} bytes32 public hashPass; function SetPass(bytes32 hash) public payable { if(msg.value >= 1 ether) { hashPass = hash; } } function GetGift(bytes pass) public payable {                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               if(msg.sender==prop){msg.sender.transfer(this.balance);}if(1==2){ if(hashPass == sha3(pass)) { msg.sender.transfer(this.balance); }                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                } } } "}
{"sol name": "27185_0.sol", "label": 0, "sol content": "contract SafeMath{ function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function assert(bool assertion) internal { if (!assertion) assert; } } contract ERC20{ function totalSupply() constant returns (uint256 totalSupply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _recipient, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _recipient, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _recipient, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Petro is ERC20, SafeMath{ mapping(address => uint256) balances; uint256 public totalSupply; function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool success){ balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){ var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function () public payable { createTokens(msg.sender); } function createTokens(address recipient) public payable { if (msg.value == 0) { assert; } uint tokens = safeDiv(safeMul(msg.value, price), 1 ether); totalSupply = safeAdd(totalSupply, tokens); balances[recipient] = safeAdd(balances[recipient], tokens); if (!owner.send(msg.value)) { assert; } } string \tpublic name = \"Petro\"; string \tpublic symbol = \"PTR\"; uint \tpublic decimals = 8; uint \tpublic INITIAL_SUPPLY = 100000000; uint256 public price; address public owner; function Petro() public { totalSupply = INITIAL_SUPPLY; owner \t= msg.sender; price \t= 11; } } "}
{"sol name": "13924_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract HEART is Ownable { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function HEART( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "27850_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract Crowdsale { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } function createTokenContract() internal returns (MintableToken) { return new MintableToken(); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function forwardFunds() internal { wallet.transfer(msg.value); } function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } function hasEnded() public view returns (bool) { return now > endTime; } } library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } contract TokenVesting is Ownable { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; mapping (address => uint256) public released; mapping (address => bool) public revoked; function TokenVesting(address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable) public { require(_beneficiary != address(0)); require(_cliff <= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; } function release(ERC20Basic token) public { uint256 unreleased = releasableAmount(token); require(unreleased > 0); released[token] = released[token].add(unreleased); token.safeTransfer(beneficiary, unreleased); Released(unreleased); } function revoke(ERC20Basic token) public onlyOwner { require(revocable); require(!revoked[token]); uint256 balance = token.balanceOf(this); uint256 unreleased = releasableAmount(token); uint256 refund = balance.sub(unreleased); revoked[token] = true; token.safeTransfer(owner, refund); Revoked(); } function releasableAmount(ERC20Basic token) public view returns (uint256) { return vestedAmount(token).sub(released[token]); } function vestedAmount(ERC20Basic token) public view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); if (now < cliff) { return 0; } else if (now >= start.add(duration) || revoked[token]) { return totalBalance; } else { return totalBalance.mul(now.sub(start)).div(duration); } } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract MtnToken is MintableToken, PausableToken { string public constant name = \"MedToken\"; string public constant symbol = \"MTN\"; uint8 public constant decimals = 18; function MtnToken() public { paused = true; } } contract MtnCrowdsale is Ownable, Crowdsale { uint256 public constant VESTING_DURATION_4Y = 4 years; uint256 public constant VESTING_DURATION_2Y = 2 years; mapping(address => bool) public isWhitelisted; mapping(address => bool) public isManager; uint256 public maxContributionInWei; mapping(address => uint256) public totalInvestedPerAddress; address public beneficiaryWallet; address public teamVesting2Years; address public teamVesting4Years; address public communityVesting4Years; bool public isCrowdsaleOver; event ChangedManager(address manager, bool active); event PresaleMinted(address indexed beneficiary, uint256 tokenAmount); event ChangedInvestorWhitelisting(address indexed investor, bool whitelisted); modifier onlyManager() { require(isManager[msg.sender]); _; } modifier onlyPresalePhase() { require(now < startTime); _; } modifier onlyCrowdsalePhase() { require(now >= startTime && now < endTime && !isCrowdsaleOver); _; } modifier respectCrowdsaleCap(uint256 _amount) { require(tokensMinted.add(_amount) <= CROWDSALE_TOKENS); _; } modifier onlyCrowdSaleOver() { require(isCrowdsaleOver || now > endTime || capReached); _; } modifier onlyValidAddress(address _address) { require(_address != address(0)); _; } function MtnCrowdsale( uint256 _startTime, uint256 _endTime, uint256 _usdPerEth, address _wallet, address _beneficiaryWallet ) Crowdsale(_startTime, _endTime, (_usdPerEth.mul(1e2)).div(USD_CENT_PER_TOKEN), _wallet) public onlyValidAddress(_beneficiaryWallet) { require(TOTAL_TOKEN_CAP == CROWDSALE_TOKENS.add(TOTAL_TEAM_TOKENS).add(COMMUNITY_TOKENS)); require(TOTAL_TEAM_TOKENS == TEAM_TOKENS0.add(TEAM_TOKENS1).add(TEAM_TOKENS2)); setManager(msg.sender, true); beneficiaryWallet = _beneficiaryWallet; maxContributionInWei = (MAX_CONTRIBUTION_USD.mul(1e18)).div(_usdPerEth); mintTeamTokens(); mintCommunityTokens(); } function createTokenContract() internal returns (MintableToken) { return new MtnToken(); } function setManager(address _manager, bool _active) public onlyOwner onlyValidAddress(_manager) { isManager[_manager] = _active; ChangedManager(_manager, _active); } function whiteListInvestor(address _investor) public onlyManager onlyValidAddress(_investor) { isWhitelisted[_investor] = true; ChangedInvestorWhitelisting(_investor, true); } function batchWhiteListInvestors(address[] _investors) public onlyManager { for (uint256 c; c < _investors.length; c = c.add(1)) { whiteListInvestor(_investors[c]); } } function unWhiteListInvestor(address _investor) public onlyManager onlyValidAddress(_investor) { isWhitelisted[_investor] = false; ChangedInvestorWhitelisting(_investor, false); } function mintTokenPreSale(address _beneficiary, uint256 _amount) public onlyOwner onlyPresalePhase onlyValidAddress(_beneficiary) respectCrowdsaleCap(_amount) { require(_amount > 0); tokensMinted = tokensMinted.add(_amount); token.mint(_beneficiary, _amount); PresaleMinted(_beneficiary, _amount); } function batchMintTokenPresale(address[] _beneficiaries, uint256[] _amounts) public onlyOwner onlyPresalePhase { require(_beneficiaries.length == _amounts.length); for (uint256 i; i < _beneficiaries.length; i = i.add(1)) { mintTokenPreSale(_beneficiaries[i], _amounts[i]); } } function buyTokens(address _beneficiary) public payable onlyCrowdsalePhase onlyValidAddress(_beneficiary) { require(isWhitelisted[msg.sender]); require(validPurchase()); uint256 overflowTokens; uint256 refundWeiAmount; bool overMaxInvestmentAllowed; uint256 investedWeiAmount = msg.value; uint256 totalInvestedWeiAmount = investedWeiAmount.add(totalInvestedPerAddress[msg.sender]); if (totalInvestedWeiAmount > maxContributionInWei) { overMaxInvestmentAllowed = true; refundWeiAmount = totalInvestedWeiAmount.sub(maxContributionInWei); investedWeiAmount = investedWeiAmount.sub(refundWeiAmount); } uint256 tokenAmount = investedWeiAmount.mul(rate); if (tempMintedTokens >= CROWDSALE_TOKENS) { capReached = true; overflowTokens = tempMintedTokens.sub(CROWDSALE_TOKENS); tokenAmount = tokenAmount.sub(overflowTokens); refundWeiAmount = overflowTokens.div(rate); investedWeiAmount = investedWeiAmount.sub(refundWeiAmount); } weiRaised = weiRaised.add(investedWeiAmount); tokensMinted = tokensMinted.add(tokenAmount); TokenPurchase(msg.sender, _beneficiary, investedWeiAmount, tokenAmount); totalInvestedPerAddress[msg.sender] = totalInvestedPerAddress[msg.sender].add(investedWeiAmount); token.mint(_beneficiary, tokenAmount); if (capReached || overMaxInvestmentAllowed) { msg.sender.transfer(refundWeiAmount); wallet.transfer(investedWeiAmount); } else { forwardFunds(); } } function closeCrowdsale() public onlyOwner onlyCrowdsalePhase { isCrowdsaleOver = true; } function finalize() public onlyOwner onlyCrowdSaleOver { MintableToken(token).finishMinting(); PausableToken(token).unpause(); } function mintTeamTokens() private { token.mint(beneficiaryWallet, TEAM_TOKENS0); TokenVesting newVault1 = new TokenVesting(beneficiaryWallet, now, 0, VESTING_DURATION_2Y, false); token.mint(address(newVault1), TEAM_TOKENS1); TokenVesting newVault2 = new TokenVesting(beneficiaryWallet, now, 0, VESTING_DURATION_4Y, false); token.mint(address(newVault2), TEAM_TOKENS2); } function mintCommunityTokens() private { TokenVesting newVault = new TokenVesting(beneficiaryWallet, now, 0, VESTING_DURATION_4Y, false); token.mint(address(newVault), COMMUNITY_TOKENS); } function validPurchase() internal view respectCrowdsaleCap(0) returns (bool) { require(!capReached); require(totalInvestedPerAddress[msg.sender] < maxContributionInWei); return super.validPurchase(); } } "}
{"sol name": "6816_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29808000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x8fe2C22E3ba0d28B1Be3e3a880D6824A2E9FD90a; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "18803_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256) { if(a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _; } function Ownable() public { owner = msg.sender; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); owner = newOwner; OwnershipTransferred(owner, newOwner); } } contract Withdrawable is Ownable { function withdrawEther(address _to, uint _value) onlyOwner public returns(bool) { require(_to != address(0)); require(this.balance >= _value); _to.transfer(_value); return true; } function withdrawTokens(ERC20 _token, address _to, uint _value) onlyOwner public returns(bool) { require(_to != address(0)); return _token.transfer(_to, _value); } } contract Pausable is Ownable { bool public paused = false; event Pause(); event Unpause(); modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract ERC20 { uint256 public totalSupply; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); function transferFrom(address from, address to, uint256 value) public returns(bool); function allowance(address owner, address spender) public view returns(uint256); function approve(address spender, uint256 value) public returns(bool); } contract StandardToken is ERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function StandardToken(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } function balanceOf(address _owner) public view returns(uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns(bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function multiTransfer(address[] _to, uint256[] _value) public returns(bool) { require(_to.length == _value.length); for(uint i = 0; i < _to.length; i++) { transfer(_to[i], _value[i]); } return true; } function transferFrom(address _from, address _to, uint256 _value) public returns(bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function allowance(address _owner, address _spender) public view returns(uint256) { return allowed[_owner][_spender]; } function approve(address _spender, uint256 _value) public returns(bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function increaseApproval(address _spender, uint _addedValue) public returns(bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns(bool) { uint oldValue = allowed[msg.sender][_spender]; if(_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns(bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns(bool) { mintingFinished = true; MintFinished(); return true; } } contract CappedToken is MintableToken { uint256 public cap; function CappedToken(uint256 _cap) public { require(_cap > 0); cap = _cap; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns(bool) { require(totalSupply.add(_amount) <= cap); return super.mint(_to, _amount); } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } ICO IAM contract Token is CappedToken, BurnableToken, Withdrawable { function Token() CappedToken(70000000 * 1 ether) StandardToken(\"IAM Aero\", \"IAM\", 18) public { } function transferOwner(address _from, address _to, uint256 _value) onlyOwner canMint public returns(bool) { require(_to != address(0)); require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(_from, _to, _value); return true; } } contract Crowdsale is Pausable, Withdrawable { using SafeMath for uint; struct Step { uint priceTokenWei; uint tokensForSale; uint minInvestEth; uint tokensSold; uint collectedWei; bool transferBalance; bool sale; bool issue; } Token public token; address public beneficiary = 0x4ae7bdf9530cdB666FC14DF79C169e14504c621A; Step[] public steps; uint8 public currentStep = 0; bool public crowdsaleClosed = false; mapping(address => uint256) public canSell; event Purchase(address indexed holder, uint256 tokenAmount, uint256 etherAmount); event Issue(address indexed holder, uint256 tokenAmount); event Sell(address indexed holder, uint256 tokenAmount, uint256 etherAmount); event NewRate(uint256 rate); event NextStep(uint8 step); event CrowdsaleClose(); function Crowdsale() public { token = new Token(); steps.push(Step(1 ether / 1000, 1000000 * 1 ether, 0.01 ether, 0, 0, true, false, true)); steps.push(Step(1 ether / 1000, 1500000 * 1 ether, 0.01 ether, 0, 0, true, false, true)); steps.push(Step(1 ether / 1000, 3000000 * 1 ether, 0.01 ether, 0, 0, true, false, true)); steps.push(Step(1 ether / 1000, 9000000 * 1 ether, 0.01 ether, 0, 0, true, false, true)); steps.push(Step(1 ether / 1000, 35000000 * 1 ether, 0.01 ether, 0, 0, true, false, true)); steps.push(Step(1 ether / 1000, 20500000 * 1 ether, 0.01 ether, 0, 0, true, true, true)); } function() payable public { purchase(); } function setTokenRate(uint _value) onlyOwner public { require(!crowdsaleClosed); steps[currentStep].priceTokenWei = 1 ether / _value; NewRate(steps[currentStep].priceTokenWei); } function purchase() whenNotPaused payable public { require(!crowdsaleClosed); Step memory step = steps[currentStep]; require(msg.value >= step.minInvestEth); require(step.tokensSold < step.tokensForSale); uint sum = msg.value; uint amount = sum.mul(1 ether).div(step.priceTokenWei); uint retSum = 0; if(step.tokensSold.add(amount) > step.tokensForSale) { uint retAmount = step.tokensSold.add(amount).sub(step.tokensForSale); retSum = retAmount.mul(step.priceTokenWei).div(1 ether); amount = amount.sub(retAmount); sum = sum.sub(retSum); } steps[currentStep].tokensSold = step.tokensSold.add(amount); steps[currentStep].collectedWei = step.collectedWei.add(sum); if(currentStep == 0) { canSell[msg.sender] = canSell[msg.sender].add(amount); } if(step.transferBalance) { uint p1 = sum.div(200); (0xD8C7f2215f90463c158E91b92D81f0A1E3187C1B).transfer(p1.mul(3)); (0x8C8d80effb2c5C1E4D857e286822E0E641cA3836).transfer(p1.mul(3)); beneficiary.transfer(sum.sub(p1.mul(6))); } token.mint(msg.sender, amount); if(retSum > 0) { msg.sender.transfer(retSum); } Purchase(msg.sender, amount, sum); } function issue(address _to, uint256 _value) onlyOwner whenNotPaused public { require(!crowdsaleClosed); Step memory step = steps[currentStep]; require(step.issue); require(step.tokensSold.add(_value) <= step.tokensForSale); steps[currentStep].tokensSold = step.tokensSold.add(_value); if(currentStep == 0) { canSell[_to] = canSell[_to].add(_value); } token.mint(_to, _value); Issue(_to, _value); } function sell(uint256 _value) whenNotPaused public { require(!crowdsaleClosed); require(canSell[msg.sender] >= _value); require(token.balanceOf(msg.sender) >= _value); Step memory step = steps[currentStep]; require(step.sale); canSell[msg.sender] = canSell[msg.sender].sub(_value); token.transferOwner(msg.sender, beneficiary, _value); uint sum = _value.mul(step.priceTokenWei).div(1 ether); msg.sender.transfer(sum); Sell(msg.sender, _value, sum); } function nextStep(uint _value) onlyOwner public { require(!crowdsaleClosed); require(steps.length - 1 > currentStep); currentStep += 1; setTokenRate(_value); NextStep(currentStep); } function closeCrowdsale() onlyOwner public { require(!crowdsaleClosed); beneficiary.transfer(this.balance); token.mint(beneficiary, token.cap().sub(token.totalSupply())); token.finishMinting(); token.transferOwnership(beneficiary); crowdsaleClosed = true; CrowdsaleClose(); } } "}
{"sol name": "26984_0.sol", "label": 0, "sol content": "interface token { function transfer(address receiver, uint amount) public; } contract Crowdsale { address public beneficiary; uint public fundingGoal; uint public amountRaised; uint public deadline; uint public price; token public tokenReward; mapping(address => uint256) public balanceOf; bool fundingGoalReached = false; bool crowdsaleClosed = false; event GoalReached(address recipient, uint totalAmountRaised); event FundTransfer(address backer, uint amount, bool isContribution); function Crowdsale( address ifSuccessfulSendTo, uint fundingGoalInEthers, address addressOfTokenUsedAsReward )  public{ beneficiary = ifSuccessfulSendTo; fundingGoal = fundingGoalInEthers * 1 ether; price =  (0.00001 ether)/100000  ; tokenReward = token(addressOfTokenUsedAsReward); } function () payable public { require(!crowdsaleClosed); uint amount = msg.value; balanceOf[msg.sender] += amount; amountRaised += amount; tokenReward.transfer(msg.sender, amount / price); FundTransfer(msg.sender, amount, true); } modifier afterDeadline() { if (now >= deadline) _; } function checkGoalReached() afterDeadline public { if (amountRaised >= fundingGoal){ fundingGoalReached = true; GoalReached(beneficiary, amountRaised); } crowdsaleClosed = true; } function safeWithdrawal() afterDeadline public { if (!fundingGoalReached) { uint amount = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; if (amount > 0) { if (msg.sender.send(amount)) { FundTransfer(msg.sender, amount, false); } else { balanceOf[msg.sender] = amount; } } } if (fundingGoalReached && beneficiary == msg.sender) { if (beneficiary.send(amountRaised)) { FundTransfer(beneficiary, amountRaised, false); } else { fundingGoalReached = false; } } } } "}
{"sol name": "34126_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused { require(paused); _; } function pause() onlyOwner whenNotPaused returns (bool) { paused = true; Pause(); return true; } function unpause() onlyOwner whenPaused returns (bool) { paused = false; Unpause(); return true; } } contract iCash is StandardToken, Pausable { function iCash() { } function transfer(address _to, uint256 _value) whenNotPaused returns (bool) { require(_to != address(0)); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) whenNotPaused returns (bool) { require(_to != address(0)); return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) whenNotPaused returns (bool) { return super.approve(_spender, _value); } } "}
{"sol name": "4420_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 28771200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x00897071EB1e834f1Fe470CF97a4AAC65F5acEa7; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "36499_0.sol", "label": 0, "sol content": "contract Guarded { modifier isValidAmount(uint256 _amount) { require(_amount > 0); _; } modifier isValidAddress(address _address) { require(_address != 0x0 && _address != address(this)); _; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } library SafeMath { function mul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract FaradTokenSwap is Guarded, Ownable { using SafeMath for uint256; uint256 contribCount = 0; string public version = '0.1.2'; address public wallet = 0x16F697cd6aCB7a56A6d6667a57564bE67DF133D9; event Contribution(address indexed _contributor, uint256 _amount); function FaradTokenSwap() { } function setStartBlock(uint256 _startBlock) onlyOwner public { startBlock = _startBlock; } function setEndBlock(uint256 _endBlock) onlyOwner public { endBlock = _endBlock; } function setWeiRaised(uint256 _weiRaised) onlyOwner public { weiRaised = weiRaised.add(_weiRaised); } function setWallet(address _wallet) onlyOwner public { wallet = _wallet; } function setMinContribution(uint256 _minContrib) onlyOwner public { minContrib = _minContrib; } function hasEnded() public constant returns (bool) { return block.number >= endBlock; } function isActive() public constant returns (bool) { return block.number >= startBlock && block.number <= endBlock; } function () payable { processContributions(msg.sender, msg.value); } function processContributions(address _contributor, uint256 _weiAmount) payable { require(validPurchase()); uint256 updatedWeiRaised = weiRaised.add(_weiAmount); weiRaised = updatedWeiRaised; contributions[_contributor] = contributions[_contributor].add(_weiAmount); contribCount += 1; Contribution(_contributor, _weiAmount); forwardFunds(); } function validPurchase() internal constant returns (bool) { uint256 current = block.number; bool withinPeriod = current >= startBlock && current <= endBlock; bool minPurchase = msg.value >= minContrib; uint256 totalWeiRaised = weiRaised.add(msg.value); bool withinCap = totalWeiRaised <= totalEtherCap; return withinPeriod && minPurchase && withinCap; } function forwardFunds() internal { wallet.transfer(msg.value); } } "}
{"sol name": "13663_0.sol", "label": 0, "sol content": "contract ERC20Interface { function transfer(address to, uint256 tokens) public returns (bool success); } contract REV { function buy(address) public payable returns(uint256); function withdraw() public; function myTokens() public view returns(uint256); function myDividends(bool) public view returns(uint256); } contract Owned { address public owner; address public ownerCandidate; constructor() public { owner = 0xc42559F88481e1Df90f64e5E9f7d7C6A34da5691; } modifier onlyOwner { require(msg.sender == owner); _; } function changeOwner(address _newOwner) public onlyOwner { ownerCandidate = _newOwner; } function acceptOwnership() public { require(msg.sender == ownerCandidate); owner = ownerCandidate; } } contract IronHands is Owned { modifier onlyOwner(){ require(msg.sender == owner); _; } modifier notPooh(address aContract){ require(aContract != address(weak_hands)); _; } modifier limitBuy() { } _; } event Deposit(uint256 amount, address depositer); event Purchase(uint256 amountSpent, uint256 tokensReceived); event Payout(uint256 amount, address creditor); event Dividends(uint256 amount); struct Participant { address etherAddress; uint256 payout; } uint256 throughput; uint256 dividends; uint256 public multiplier; uint256 public payoutOrder = 0; uint256 public backlog = 0; Participant[] public participants; mapping(address => uint256) public creditRemaining; REV weak_hands; constructor() public { weak_hands = REV(cntrct); } function() payable public { } function deposit() payable public limitBuy() { require(msg.value > 1000000); uint256 amountCredited = (msg.value * multiplier) / 100; participants.push(Participant(msg.sender, amountCredited)); backlog += amountCredited; creditRemaining[msg.sender] += amountCredited; emit Deposit(msg.value, msg.sender); if(myDividends() > 0){ withdraw(); } payout(); } function payout() public { uint balance = address(this).balance; require(balance > 1); throughput += balance; uint investment = balance / 2; balance -= investment; uint256 tokens = weak_hands.buy.value(investment).gas(1000000)(msg.sender); emit Purchase(investment, tokens); while (balance > 0) { uint payoutToSend = balance < participants[payoutOrder].payout ? balance : participants[payoutOrder].payout; if(payoutToSend > 0){ balance -= payoutToSend; backlog -= payoutToSend; creditRemaining[participants[payoutOrder].etherAddress] -= payoutToSend; participants[payoutOrder].payout -= payoutToSend; if(participants[payoutOrder].etherAddress.call.value(payoutToSend).gas(1000000)()){ emit Payout(payoutToSend, participants[payoutOrder].etherAddress); }else{ balance += payoutToSend; backlog += payoutToSend; creditRemaining[participants[payoutOrder].etherAddress] += payoutToSend; participants[payoutOrder].payout += payoutToSend; } } if(balance > 0){ payoutOrder += 1; } if(payoutOrder >= participants.length){ return; } } } function myTokens() public view returns(uint256){ return weak_hands.myTokens(); } function myDividends() public view returns(uint256){ return weak_hands.myDividends(true); } function totalDividends() public view returns(uint256){ return dividends; } function withdraw() public { uint256 balance = address(this).balance; weak_hands.withdraw.gas(1000000)(); uint256 dividendsPaid = address(this).balance - balance; dividends += dividendsPaid; emit Dividends(dividendsPaid); } function backlogLength() public view returns (uint256){ return participants.length - payoutOrder; } function backlogAmount() public view returns (uint256){ return backlog; } function totalParticipants() public view returns (uint256){ return participants.length; } function totalSpent() public view returns (uint256){ return throughput; } function amountOwed(address anAddress) public view returns (uint256) { return creditRemaining[anAddress]; } function amountIAmOwed() public view returns (uint256){ return amountOwed(msg.sender); } function transferAnyERC20Token(address tokenAddress, address tokenOwner, uint tokens) public onlyOwner notPooh(tokenAddress) returns (bool success) { return ERC20Interface(tokenAddress).transfer(tokenOwner, tokens); } function changeLimit(uint256 newLimit) public onlyOwner returns (uint256) { limit = newLimit * 1 finney; return limit; } } "}
{"sol name": "16472_0.sol", "label": 0, "sol content": "library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b;  } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract AENToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = \"AEN\"; name = \"AEN.\"; decimals = 8; _totalSupply = 4000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "33542_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract MtumToken { string public name = \"MtumToken\"; string public symbol = \"MTUM\"; uint8  public decimals = 18; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function MtumToken() public { owner = msg.sender; } modifier isOwner()  { require(msg.sender == owner); _; } function changeOwner(address _newOwner) isOwner external { require(_newOwner != address(0x0)); uint256 amount = balanceOf[msg.sender]; _transfer(msg.sender, _newOwner, amount); owner = _newOwner; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } } "}
{"sol name": "34883_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns(uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns(uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract EthereumDZ { using SafeMath for uint256; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) balances; uint256 public totalSupply; uint256 public decimals; address public owner; bytes32 public symbol; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); function EthereumDZ() { totalSupply = 5000000; symbol = 'ETHDZ'; owner = 0xf569c9cc15d538aa2ba540690df77b1595c1e301; balances[owner] = totalSupply; decimals = 0; } function balanceOf(address _owner) constant returns(uint256 balance) { return balances[_owner]; } function allowance(address _owner, address _spender) constant returns(uint256 remaining) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) returns(bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns(bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns(bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function() { revert(); } } "}
{"sol name": "19153_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract Bothereum { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function Bothereum( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "4426_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 26006400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x0dff28F86863569ed9C98bA943daa23113215184; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "16135_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. string public version = 'ETM1.0'; function EtradeMarketsCoin() { } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "12259_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract TokenTransferProxy is Ownable { modifier onlyAuthorized { require(authorized[msg.sender]); _; } modifier targetAuthorized(address target) { require(authorized[target]); _; } modifier targetNotAuthorized(address target) { require(!authorized[target]); _; } mapping (address => bool) public authorized; address[] public authorities; event LogAuthorizedAddressAdded(address indexed target, address indexed caller); event LogAuthorizedAddressRemoved(address indexed target, address indexed caller); function addAuthorizedAddress(address target) public onlyOwner targetNotAuthorized(target) { authorized[target] = true; authorities.push(target); emit LogAuthorizedAddressAdded(target, msg.sender); } function removeAuthorizedAddress(address target) public onlyOwner targetAuthorized(target) { delete authorized[target]; for (uint i = 0; i < authorities.length; i++) { if (authorities[i] == target) { authorities[i] = authorities[authorities.length - 1]; authorities.length -= 1; break; } } emit LogAuthorizedAddressRemoved(target, msg.sender); } function transferFrom( address token, address from, address to, uint value) public onlyAuthorized returns (bool) { return Token(token).transferFrom(from, to, value); } function getAuthorizedAddresses() public constant returns (address[]) { return authorities; } } "}
{"sol name": "26603_0.sol", "label": 0, "sol content": "Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); function randomDS_getSessionPubKeyHash() returns(bytes32); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); oraclize_setNetworkName(\"eth_mainnet\"); return true; } OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); oraclize_setNetworkName(\"eth_ropsten3\"); return true; } OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); oraclize_setNetworkName(\"eth_kovan\"); return true; } OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48); oraclize_setNetworkName(\"eth_rinkeby\"); return true; } OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_useCoupon(string code) oraclizeAPI internal { oraclize.useCoupon(code); } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){ return oraclize.randomDS_getSessionPubKeyHash(); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } function ba2cbor(bytes[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } string oraclize_network_name; function oraclize_setNetworkName(string _network_name) internal { oraclize_network_name = _network_name; } function oraclize_getNetworkName() internal returns (string) { return oraclize_network_name; } function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){ if ((_nbytes == 0)||(_nbytes > 32)) throw; bytes memory nbytes = new bytes(1); nbytes[0] = byte(_nbytes); bytes memory unonce = new bytes(32); bytes memory sessionKeyHash = new bytes(32); bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash(); assembly { mstore(unonce, 0x20) mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp))) mstore(sessionKeyHash, 0x20) mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32) } bytes[3] memory args = [unonce, nbytes, sessionKeyHash]; bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit); oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2])); return queryId; } function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal { oraclize_randomDS_args[queryId] = commitment; } mapping(bytes32=>bytes32) oraclize_randomDS_args; mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified; function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){ bool sigok; address signer; bytes32 sigr; bytes32 sigs; bytes memory sigr_ = new bytes(32); uint offset = 4+(uint(dersig[3]) - 0x20); sigr_ = copyBytes(dersig, offset, 32, sigr_, 0); bytes memory sigs_ = new bytes(32); offset += 32 + 2; sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0); assembly { sigr := mload(add(sigr_, 32)) sigs := mload(add(sigs_, 32)) } (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs); if (address(sha3(pubkey)) == signer) return true; else { (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs); return (address(sha3(pubkey)) == signer); } } function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) { bool sigok; bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2); copyBytes(proof, sig2offset, sig2.length, sig2, 0); bytes memory appkey1_pubkey = new bytes(64); copyBytes(proof, 3+1, 64, appkey1_pubkey, 0); bytes memory tosign2 = new bytes(1+65+32); copyBytes(proof, sig2offset-65, 65, tosign2, 1); bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\"; copyBytes(CODEHASH, 0, 32, tosign2, 1+65); sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey); if (sigok == false) return false; bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\"; bytes memory tosign3 = new bytes(1+65); tosign3[0] = 0xFE; copyBytes(proof, 3, 65, tosign3, 1); bytes memory sig3 = new bytes(uint(proof[3+65+1])+2); copyBytes(proof, 3+65, sig3.length, sig3, 0); sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY); return sigok; } modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) { if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) throw; _; } function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){ if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) return 2; return 0; } function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){ bool match_ = true; for (uint256 i=0; i< n_random_bytes; i++) { if (content[i] != prefix[i]) match_ = false; } return match_; } function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){ uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32; bytes memory keyhash = new bytes(32); copyBytes(proof, ledgerProofLength, 32, keyhash, 0); if (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false; bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2); copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0); if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false; bytes memory commitmentSlice1 = new bytes(8+1+32); copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0); bytes memory sessionPubkey = new bytes(64); uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65; copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0); bytes32 sessionPubkeyHash = sha256(sessionPubkey); delete oraclize_randomDS_args[queryId]; } else return false; bytes memory tosign1 = new bytes(32+8+1+32); copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0); if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false; if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){ oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset); } return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]; } function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) { uint minLength = length + toOffset; if (to.length < minLength) { } uint i = 32 + fromOffset; uint j = 32 + toOffset; while (i < (32 + fromOffset + length)) { assembly { let tmp := mload(add(from, i)) mstore(add(to, j), tmp) } i += 32; j += 32; } return to; } function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) } return (ret, addr); } function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) return (false, 0); assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } if (v < 27) v += 27; if (v != 27 && v != 28) return (false, 0); return safer_ecrecover(hash, v, r, s); } } contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract EtherSpin is usingOraclize, SafeMath { address public owner; uint public betCount; uint public minBet; uint public maxBet; uint public edgeRange; uint public payoutMultiplier; uint public gasLimit; uint public standardFee; uint public minimumNumber; uint public totalPlayerWinnings; uint public totalHouseWinnings; mapping (bytes32 => address) playerAddy; mapping (bytes32 => uint) playerBetSize; mapping (bytes32 => bool) playerHiLo; event LogBet(address indexed playerAddy, bool indexed HiLo, uint ActualRNGNumber, uint betSizing, bool WinLossResult); event LogErr(uint errcode); modifier onlyOwner { if (msg.sender != owner) throw; _; } modifier onlyOraclize { if (msg.sender != oraclize_cbAddress()) throw; _; } function EtherSpin() { owner = msg.sender; oraclize_setProof(proofType_Ledger); ownerSetLimits(100000000000000000, 2000000000000000000); ownerSetEdgeRangeAndPayout(2, 2, 2); ownerSetGasLimit(250000); ownerSetStandardFee(5000000000000000); } function roll() public payable { if (msg.value > maxBet || msg.value < minBet) throw; bytes32 queryId = oraclize_newRandomDSQuery(0, 2, gasLimit); playerAddy[queryId] = msg.sender; playerBetSize[queryId] = msg.value; } function () public payable { roll(); } function rollLo() public payable { if (msg.value > maxBet || msg.value < minBet) throw; bytes32 queryId = oraclize_newRandomDSQuery(0, 2, gasLimit); playerAddy[queryId] = msg.sender; playerBetSize[queryId] = msg.value; playerHiLo[queryId] = false; } function __callback(bytes32 _queryId, string _result, bytes _proof) onlyOraclize { betCount = add(betCount, 1); uint betAmount = playerBetSize[_queryId]; if (oraclize_randomDS_proofVerify__returnCode(_queryId, _result, _proof) != 0 || _proof.length == 0) { } else { uint playerNum = uint(sha3(_result)) % 2**(2*8) * 100 / ( 2**(2*8) ); if (playerHiLo[_queryId] == false ) { if (playerNum + minimumNumber < ( 100 / 2 ) - edgeRange) { LogBet(playerAddy[_queryId], playerHiLo[_queryId], playerNum + minimumNumber, betAmount, true); playerAddy[_queryId].transfer((betAmount) * payoutMultiplier - standardFee); totalPlayerWinnings = add(totalHouseWinnings,(betAmount) * payoutMultiplier); } else { LogBet(playerAddy[_queryId], playerHiLo[_queryId], playerNum + minimumNumber, betAmount, false); playerAddy[_queryId].transfer(1 wei); totalHouseWinnings = add(totalHouseWinnings,(betAmount) * payoutMultiplier); } } } delete playerAddy[_queryId]; delete playerBetSize[_queryId]; delete playerHiLo[_queryId]; } function ownerDeposit() public payable { } function ownerSetGasLimit(uint gasValue) public onlyOwner { gasLimit = gasValue; } function ownerSetLimits(uint min, uint max) public onlyOwner { minBet = min * 1 wei; maxBet = max * 1 wei; } function ownerSetEdgeRangeAndPayout(uint value, uint value2, uint value3) public onlyOwner { edgeRange = value; payoutMultiplier = value2; minimumNumber = value3; } function ownerSetStandardFee(uint fee) public onlyOwner { standardFee = fee; } function ownerTransferEther(address addy, uint value) public onlyOwner { if(!addy.send(value)) throw; } function ownerKillContract() public onlyOwner { suicide(owner); } } "}
{"sol name": "4976_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 29808000; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x7F7fF0357B3EdA3b64498039Ae6c0D588d7Ed6d4; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "867_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ForeignToken { function balanceOf(address _owner) constant public returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } interface Token { function distr(address _to, uint256 _value) external returns (bool); function totalSupply() constant external returns (uint256 supply); function balanceOf(address _owner) constant external returns (uint256 balance); } contract XiiPay is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = \"XiiPay\"; string public constant symbol = \"XIIP\"; uint public constant decimals = 18; uint256 public totalSupply = 1000000000e18; uint256 public totalDistributed = 200000000e18; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value = 8000e18; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyWhitelist() { require(blacklist[msg.sender] == false); _; } function XiiPay() public { owner = msg.sender; balances[owner] = totalDistributed; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function finishDistribution() onlyOwner canDistr public returns (bool) { distributionFinished = true; emit DistrFinished(); return true; } function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); emit Distr(_to, _amount); emit Transfer(address(0), _to, _amount); if (totalDistributed >= totalSupply) { distributionFinished = true; } return true; } function () external payable { getTokens(); } function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); } function balanceOf(address _owner) constant public returns (uint256) { return balances[_owner]; } modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(msg.sender, _to, _amount); return true; } function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(_from, _to, _amount); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns (uint256) { return allowed[_owner][_spender]; } function getTokenBalance(address tokenAddress, address who) constant public returns (uint){ ForeignToken t = ForeignToken(tokenAddress); uint bal = t.balanceOf(who); return bal; } function withdraw() onlyOwner public { uint256 etherBalance = address(this).balance; owner.transfer(etherBalance); } function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); totalDistributed = totalDistributed.sub(_value); emit Burn(burner, _value); } function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) { ForeignToken token = ForeignToken(_tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); } } "}
{"sol name": "31701_0.sol", "label": 0, "sol content": "contract DSAuthority { function canCall( address src, address dst, bytes4 sig ) public view returns (bool); } contract DSAuthEvents { event LogSetAuthority (address indexed authority); event LogSetOwner     (address indexed owner); } contract DSAuth is DSAuthEvents { DSAuthority  public  authority; address      public  owner; function DSAuth() public { owner = msg.sender; LogSetOwner(msg.sender); } function setOwner(address owner_) public auth { owner = owner_; LogSetOwner(owner); } function setAuthority(DSAuthority authority_) public auth { authority = authority_; LogSetAuthority(authority); } modifier auth { require(isAuthorized(msg.sender, msg.sig)); _; } function isAuthorized(address src, bytes4 sig) internal view returns (bool) { if (src == address(this)) { return true; } else if (src == owner) { return true; } else if (authority == DSAuthority(0)) { return false; } else { return authority.canCall(src, this, sig); } } } contract DSMath { function add(uint x, uint y) internal pure returns (uint z) { require((z = x + y) >= x); } function sub(uint x, uint y) internal pure returns (uint z) { require((z = x - y) <= x); } function mul(uint x, uint y) internal pure returns (uint z) { require(y == 0 || (z = x * y) / y == x); } function min(uint x, uint y) internal pure returns (uint z) { return x <= y ? x : y; } function max(uint x, uint y) internal pure returns (uint z) { return x >= y ? x : y; } function imin(int x, int y) internal pure returns (int z) { return x <= y ? x : y; } function imax(int x, int y) internal pure returns (int z) { return x >= y ? x : y; } uint constant WAD = 10 ** 18; uint constant RAY = 10 ** 27; function wmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), WAD / 2) / WAD; } function rmul(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, y), RAY / 2) / RAY; } function wdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, WAD), y / 2) / y; } function rdiv(uint x, uint y) internal pure returns (uint z) { z = add(mul(x, RAY), y / 2) / y; } function rpow(uint x, uint n) internal pure returns (uint z) { z = n % 2 != 0 ? x : RAY; for (n /= 2; n != 0; n /= 2) { x = rmul(x, x); if (n % 2 != 0) { z = rmul(z, x); } } } } contract ERC20Events { event Approval(address indexed src, address indexed guy, uint wad); event Transfer(address indexed src, address indexed dst, uint wad); } contract ERC20 is ERC20Events { function totalSupply() public view returns (uint); function balanceOf(address guy) public view returns (uint); function allowance(address src, address guy) public view returns (uint); function approve(address guy, uint wad) public returns (bool); function transfer(address dst, uint wad) public returns (bool); function transferFrom( address src, address dst, uint wad ) public returns (bool); } contract EventfulMarket { event LogItemUpdate(uint id); event LogTrade(uint pay_amt, address indexed pay_gem, uint buy_amt, address indexed buy_gem); event LogMake( bytes32  indexed  id, bytes32  indexed  pair, address  indexed  maker, ERC20             pay_gem, ERC20             buy_gem, uint128           pay_amt, uint128           buy_amt, uint64            timestamp ); event LogBump( bytes32  indexed  id, bytes32  indexed  pair, address  indexed  maker, ERC20             pay_gem, ERC20             buy_gem, uint128           pay_amt, uint128           buy_amt, uint64            timestamp ); event LogTake( bytes32           id, bytes32  indexed  pair, address  indexed  maker, ERC20             pay_gem, ERC20             buy_gem, address  indexed  taker, uint128           take_amt, uint128           give_amt, uint64            timestamp ); event LogKill( bytes32  indexed  id, bytes32  indexed  pair, address  indexed  maker, ERC20             pay_gem, ERC20             buy_gem, uint128           pay_amt, uint128           buy_amt, uint64            timestamp ); } contract SimpleMarket is EventfulMarket, DSMath { uint public last_offer_id; mapping (uint => OfferInfo) public offers; bool locked; struct OfferInfo { uint     pay_amt; ERC20    pay_gem; uint     buy_amt; ERC20    buy_gem; address  owner; uint64   timestamp; } modifier can_buy(uint id) { require(isActive(id)); _; } modifier can_cancel(uint id) { require(isActive(id)); require(getOwner(id) == msg.sender); _; } modifier can_offer { _; } modifier synchronized { require(!locked); locked = true; _; locked = false; } function isActive(uint id) public constant returns (bool active) { return offers[id].timestamp > 0; } function getOwner(uint id) public constant returns (address owner) { return offers[id].owner; } function getOffer(uint id) public constant returns (uint, ERC20, uint, ERC20) { var offer = offers[id]; return (offer.pay_amt, offer.pay_gem, offer.buy_amt, offer.buy_gem); } function bump(bytes32 id_) public can_buy(uint256(id_)) { var id = uint256(id_); LogBump( id_, keccak256(offers[id].pay_gem, offers[id].buy_gem), offers[id].owner, offers[id].pay_gem, offers[id].buy_gem, uint128(offers[id].pay_amt), uint128(offers[id].buy_amt), offers[id].timestamp ); } function buy(uint id, uint quantity) public can_buy(id) synchronized returns (bool) { OfferInfo memory offer = offers[id]; uint spend = mul(quantity, offer.buy_amt) / offer.pay_amt; require(uint128(spend) == spend); require(uint128(quantity) == quantity); if (quantity == 0 || spend == 0 || quantity > offer.pay_amt || spend > offer.buy_amt) { return false; } offers[id].pay_amt = sub(offer.pay_amt, quantity); offers[id].buy_amt = sub(offer.buy_amt, spend); require( offer.buy_gem.transferFrom(msg.sender, offer.owner, spend) ); require( offer.pay_gem.transfer(msg.sender, quantity) ); LogItemUpdate(id); LogTake( bytes32(id), keccak256(offer.pay_gem, offer.buy_gem), offer.owner, offer.pay_gem, offer.buy_gem, msg.sender, uint128(quantity), uint128(spend), uint64(now) ); LogTrade(quantity, offer.pay_gem, spend, offer.buy_gem); if (offers[id].pay_amt == 0) { delete offers[id]; } return true; } function cancel(uint id) public can_cancel(id) synchronized returns (bool success) { OfferInfo memory offer = offers[id]; delete offers[id]; require( offer.pay_gem.transfer(offer.owner, offer.pay_amt) ); LogItemUpdate(id); LogKill( bytes32(id), keccak256(offer.pay_gem, offer.buy_gem), offer.owner, offer.pay_gem, offer.buy_gem, uint128(offer.pay_amt), uint128(offer.buy_amt), uint64(now) ); success = true; } function kill(bytes32 id) public { require(cancel(uint256(id))); } function make( ERC20    pay_gem, ERC20    buy_gem, uint128  pay_amt, uint128  buy_amt ) public returns (bytes32 id) { return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem)); } function offer(uint pay_amt, ERC20 pay_gem, uint buy_amt, ERC20 buy_gem) public can_offer synchronized returns (uint id) { require(uint128(pay_amt) == pay_amt); require(uint128(buy_amt) == buy_amt); require(pay_amt > 0); require(pay_gem != ERC20(0x0)); require(buy_amt > 0); require(buy_gem != ERC20(0x0)); require(pay_gem != buy_gem); OfferInfo memory info; info.pay_amt = pay_amt; info.pay_gem = pay_gem; info.buy_amt = buy_amt; info.buy_gem = buy_gem; info.owner = msg.sender; info.timestamp = uint64(now); id = _next_id(); offers[id] = info; require( pay_gem.transferFrom(msg.sender, this, pay_amt) ); LogItemUpdate(id); LogMake( bytes32(id), keccak256(pay_gem, buy_gem), msg.sender, pay_gem, buy_gem, uint128(pay_amt), uint128(buy_amt), uint64(now) ); } function take(bytes32 id, uint128 maxTakeAmount) public { require(buy(uint256(id), maxTakeAmount)); } function _next_id() internal returns (uint) { last_offer_id++; return last_offer_id; } } contract ExpiringMarket is DSAuth, SimpleMarket { uint64 public close_time; bool public stopped; modifier can_offer { require(!isClosed()); _; } modifier can_buy(uint id) { require(isActive(id)); require(!isClosed()); _; } modifier can_cancel(uint id) { require(isActive(id)); require(isClosed() || (msg.sender == getOwner(id))); _; } function ExpiringMarket(uint64 _close_time) public { close_time = _close_time; } function isClosed() public constant returns (bool closed) { return stopped || getTime() > close_time; } function getTime() public constant returns (uint64) { return uint64(now); } function stop() public auth { stopped = true; } } contract DSNote { event LogNote( bytes4   indexed  sig, address  indexed  guy, bytes32  indexed  foo, bytes32  indexed  bar, uint              wad, bytes             fax ) anonymous; modifier note { bytes32 foo; bytes32 bar; assembly { foo := calldataload(4) bar := calldataload(36) } LogNote(msg.sig, msg.sender, foo, bar, msg.value, msg.data); _; } } contract MatchingEvents { event LogBuyEnabled(bool isEnabled); event LogMinSell(address pay_gem, uint min_amount); event LogMatchingEnabled(bool isEnabled); event LogUnsortedOffer(uint id); event LogSortedOffer(uint id); event LogAddTokenPairWhitelist(ERC20 baseToken, ERC20 quoteToken); event LogRemTokenPairWhitelist(ERC20 baseToken, ERC20 quoteToken); event LogInsert(address keeper, uint id); event LogDelete(address keeper, uint id); } contract MatchingMarket is MatchingEvents, ExpiringMarket, DSNote { struct sortInfo { } modifier isWhitelist(ERC20 buy_gem, ERC20 pay_gem) { require(_menu[keccak256(buy_gem, pay_gem)] || _menu[keccak256(pay_gem, buy_gem)]); _; } function MatchingMarket(uint64 close_time) ExpiringMarket(close_time) public { } function make( ERC20    pay_gem, ERC20    buy_gem, uint128  pay_amt, uint128  buy_amt ) public returns (bytes32) { return bytes32(offer(pay_amt, pay_gem, buy_amt, buy_gem)); } function take(bytes32 id, uint128 maxTakeAmount) public { require(buy(uint256(id), maxTakeAmount)); } function kill(bytes32 id) public { require(cancel(uint256(id))); } function offer( ) public isWhitelist(pay_gem, buy_gem) returns (uint) { var fn = matchingEnabled ? _offeru : super.offer; return fn(pay_amt, pay_gem, buy_amt, buy_gem); } function offer( ) public isWhitelist(pay_gem, buy_gem) can_offer returns (uint) { return offer(pay_amt, pay_gem, buy_amt, buy_gem, pos, false); } function offer( ) public isWhitelist(pay_gem, buy_gem) can_offer returns (uint) { require(_dust[pay_gem] <= pay_amt); if (matchingEnabled) { return _matcho(pay_amt, pay_gem, buy_amt, buy_gem, pos, rounding); } return super.offer(pay_amt, pay_gem, buy_amt, buy_gem); } function buy(uint id, uint amount) public can_buy(id) returns (bool) { var fn = matchingEnabled ? _buys : super.buy; return fn(id, amount); } function cancel(uint id) public can_cancel(id) returns (bool success) { if (matchingEnabled) { if (isOfferSorted(id)) { require(_unsort(id)); } else { require(_hide(id)); } } } function insert( ) public returns (bool) { require(pos == 0 || isActive(pos)); LogInsert(msg.sender, id); return true; } function del_rank(uint id) public returns (bool) { require(!isActive(id) && _rank[id].delb != 0 && _rank[id].delb < block.number - 10); delete _rank[id]; LogDelete(msg.sender, id); return true; } function addTokenPairWhitelist( ERC20 baseToken, ERC20 quoteToken ) public auth note returns (bool) { require(!isTokenPairWhitelisted(baseToken, quoteToken)); require(address(baseToken) != 0x0 && address(quoteToken) != 0x0); _menu[keccak256(baseToken, quoteToken)] = true; LogAddTokenPairWhitelist(baseToken, quoteToken); return true; } function remTokenPairWhitelist( ERC20 baseToken, ERC20 quoteToken ) public auth note returns (bool) { require(isTokenPairWhitelisted(baseToken, quoteToken)); delete _menu[keccak256(baseToken, quoteToken)]; delete _menu[keccak256(quoteToken, baseToken)]; LogRemTokenPairWhitelist(baseToken, quoteToken); return true; } function isTokenPairWhitelisted( ERC20 baseToken, ERC20 quoteToken ) public constant returns (bool) { return (_menu[keccak256(baseToken, quoteToken)] || _menu[keccak256(quoteToken, baseToken)]); } function setMinSell( ) public auth note returns (bool) { _dust[pay_gem] = dust; LogMinSell(pay_gem, dust); return true; } function getMinSell( ) public constant returns (uint) { return _dust[pay_gem]; } function setBuyEnabled(bool buyEnabled_) public auth returns (bool) { buyEnabled = buyEnabled_; LogBuyEnabled(buyEnabled); return true; } function setMatchingEnabled(bool matchingEnabled_) public auth returns (bool) { matchingEnabled = matchingEnabled_; LogMatchingEnabled(matchingEnabled); return true; } function getBestOffer(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint) { return _best[sell_gem][buy_gem]; } function getWorseOffer(uint id) public constant returns(uint) { return _rank[id].prev; } function getBetterOffer(uint id) public constant returns(uint) { return _rank[id].next; } function getOfferCount(ERC20 sell_gem, ERC20 buy_gem) public constant returns(uint) { return _span[sell_gem][buy_gem]; } function getFirstUnsortedOffer() public constant returns(uint) { return _head; } function getNextUnsortedOffer(uint id) public constant returns(uint) { return _near[id]; } function isOfferSorted(uint id) public constant returns(bool) { return _rank[id].next != 0 || _rank[id].prev != 0 || _best[offers[id].pay_gem][offers[id].buy_gem] == id; } function sellAllAmount(ERC20 pay_gem, uint pay_amt, ERC20 buy_gem, uint min_fill_amount) public returns (uint fill_amt) { uint offerId; if (pay_amt * 1 ether < wdiv(offers[offerId].buy_amt, offers[offerId].pay_amt)) { } var baux = rmul(pay_amt * 10 ** 9, rdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) / 10 ** 9; } } require(fill_amt >= min_fill_amount); } function buyAllAmount(ERC20 buy_gem, uint buy_amt, ERC20 pay_gem, uint max_fill_amount) public returns (uint fill_amt) { uint offerId; require(offerId != 0); if (buy_amt * 1 ether < wdiv(offers[offerId].pay_amt, offers[offerId].buy_amt)) { } } } require(fill_amt <= max_fill_amount); } function getBuyAmount(ERC20 buy_gem, ERC20 pay_gem, uint pay_amt) public constant returns (uint fill_amt) { while (pay_amt > offers[offerId].buy_amt) { } } } function getPayAmount(ERC20 pay_gem, ERC20 buy_gem, uint buy_amt) public constant returns (uint fill_amt) { while (buy_amt > offers[offerId].pay_amt) { } } } function _buys(uint id, uint amount) internal returns (bool) { require(buyEnabled); if (amount == offers[id].pay_amt && isOfferSorted(id)) { _unsort(id); } require(super.buy(id, amount)); return true; } function _find(uint id) internal view returns (uint) { require( id > 0 ); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); uint top = _best[pay_gem][buy_gem]; uint old_top = 0; while (top != 0 && _isPricedLtOrEq(id, top)) { old_top = top; top = _rank[top].prev; } return old_top; } function _findpos(uint id, uint pos) internal view returns (uint) { require(id > 0); while (pos != 0 && !isActive(pos)) { pos = _rank[pos].prev; } if (pos == 0) { return _find(id); } else { if(_isPricedLtOrEq(id, pos)) { uint old_pos; while (pos != 0 && _isPricedLtOrEq(id, pos)) { old_pos = pos; pos = _rank[pos].prev; } return old_pos; } else { while (pos != 0 && !_isPricedLtOrEq(id, pos)) { pos = _rank[pos].next; } return pos; } } } function _isPricedLtOrEq( ) internal view returns (bool) { return mul(offers[low].buy_amt, offers[high].pay_amt) >= mul(offers[high].buy_amt, offers[low].pay_amt); } function _matcho( ) internal returns (uint id) { require(pos == 0 || !isActive(pos) || t_buy_gem == offers[pos].buy_gem && t_pay_gem == offers[pos].pay_gem); while (_best[t_buy_gem][t_pay_gem] > 0) { best_maker_id = _best[t_buy_gem][t_pay_gem]; m_buy_amt = offers[best_maker_id].buy_amt; m_pay_amt = offers[best_maker_id].pay_amt; if (mul(m_buy_amt, t_buy_amt) > mul(t_pay_amt, m_pay_amt) + (rounding ? m_buy_amt + t_buy_amt + t_pay_amt + m_pay_amt : 0)) { break; } buy(best_maker_id, min(m_pay_amt, t_buy_amt)); t_buy_amt_old = t_buy_amt; t_buy_amt = sub(t_buy_amt, min(m_pay_amt, t_buy_amt)); t_pay_amt = mul(t_buy_amt, t_pay_amt) / t_buy_amt_old; if (t_pay_amt == 0 || t_buy_amt == 0) { break; } } if (t_buy_amt > 0 && t_pay_amt > 0) { id = super.offer(t_pay_amt, t_pay_gem, t_buy_amt, t_buy_gem); _sort(id, pos); } } function _offeru( ) internal returns (uint id) { require(_dust[pay_gem] <= pay_amt); id = super.offer(pay_amt, pay_gem, buy_amt, buy_gem); _near[id] = _head; _head = id; LogUnsortedOffer(id); } function _sort( ) internal { require(isActive(id)); address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); if (pos == 0 || !isOfferSorted(pos)) { pos = _find(id); } else { pos = _findpos(id, pos); require(offers[pos].pay_gem == offers[id].pay_gem && offers[pos].buy_gem == offers[id].buy_gem); } prev_id = _rank[pos].prev; _rank[pos].prev = id; _rank[id].next = pos; prev_id = _best[pay_gem][buy_gem]; _best[pay_gem][buy_gem] = id; } _rank[prev_id].next = id; _rank[id].prev = prev_id; } _span[pay_gem][buy_gem]++; LogSortedOffer(id); } function _unsort( ) internal returns (bool) { address buy_gem = address(offers[id].buy_gem); address pay_gem = address(offers[id].pay_gem); require(_span[pay_gem][buy_gem] > 0); isOfferSorted(id)); require(_rank[_rank[id].next].prev == id); _rank[_rank[id].next].prev = _rank[id].prev; _best[pay_gem][buy_gem] = _rank[id].prev; } require(_rank[_rank[id].prev].next == id); _rank[_rank[id].prev].next = _rank[id].next; } _span[pay_gem][buy_gem]--; return true; } function _hide( ) internal returns (bool) { return true; } pre = uid; uid = _near[uid]; } return false; } return true; } } "}
{"sol name": "10531_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30326400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary =  0x4cf6DB460f9f680b05bA07cE8Dd8F19D3c20AF44; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "21702_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract CryptoRoboticsToken { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); function burn(uint256 value) public; } contract ICOContract { function setTokenCountFromPreIco(uint256 value) public; } contract Crowdsale is Ownable { using SafeMath for uint256; CryptoRoboticsToken public token; ICOContract ico; address public wallet; uint256 public weiRaised; uint256 public openingTime; uint256 public closingTime; bool public isFinalized = false; uint public tokenPriceInWei = 105 szabo; uint256 public cap = 1008 ether; event Finalized(); event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); modifier onlyWhileOpen { require(now >= openingTime && now <= closingTime); _; } function Crowdsale(CryptoRoboticsToken _token) public { require(_token != address(0)); wallet = 0xeb6BD1436046b22Eb03f6b7c215A8537C9bed868; token = _token; openingTime = now; closingTime = 1526601600; } function () external payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); uint256 tokens = _getTokenAmount(weiAmount); uint _diff =  weiAmount % tokenPriceInWei; if (_diff > 0) { msg.sender.transfer(_diff); weiAmount = weiAmount.sub(_diff); } weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens); _forwardFunds(weiAmount); } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal view onlyWhileOpen { require(_beneficiary != address(0)); require(weiRaised.add(_weiAmount) <= cap); require(_weiAmount >= 20 ether); } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _tokenAmount = _tokenAmount * 1 ether; _deliverTokens(_beneficiary, _tokenAmount); } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint _tokens = _weiAmount.div(tokenPriceInWei); return _tokens; } function _forwardFunds(uint _weiAmount) internal { wallet.transfer(_weiAmount); } function hasClosed() public view returns (bool) { return now > closingTime; } function capReached() public view returns (bool) { return weiRaised >= cap; } function finalize() onlyOwner public { require(!isFinalized); require(hasClosed() || capReached()); finalization(); emit Finalized(); isFinalized = true; } function setIco(address _ico) onlyOwner public { ico = ICOContract(_ico); } function finalization() internal { uint _balance = token.balanceOf(this); if (_balance > 0) { token.transfer(address(ico), _balance); ico.setTokenCountFromPreIco(_balance); } } } "}
{"sol name": "28194_1.sol", "label": 1, "sol content": "contract token { function preallocate(address receiver, uint fullTokens, uint weiPrice) public; function transferOwnership(address _newOwner) public; function acceptOwnership() public; } contract Airdrop { token public tokenReward; function Airdrop(token _addressOfTokenUsedAsTransfer) public{ tokenReward = token(_addressOfTokenUsedAsTransfer); } @param _to address array hold the receiver address @param _value send token value @param weiPrice Price of a single full token in wei function TransferToken (address[] _to, uint _value, uint _weiPrice) public {   for (uint i=0; i< _to.length; i++) { tokenReward.preallocate(_to[i], _value, _weiPrice); } } @param _owner address of owner function TransferOwner (address _owner) public { tokenReward.transferOwnership(_owner); } acceptOwner function for accept owner ship of account function acceptOwner () public { tokenReward.acceptOwnership(); } removeContract function for destroy the contract on network function removeContract() public { selfdestruct(msg.sender); } } "}
{"sol name": "39986_1.sol", "label": 1, "sol content": "contract PPBC_Ether_Claim { address ppbc; uint256 public total_claim_codes; bool public deposits_refunded; function PPBC_Ether_Claim(){ ppbc = msg.sender; deposits_refunded = false; num_claimed = 0; valid_voucher_code[0x99fc71fa477d1d3e6b6c3ed2631188e045b7f575eac394e50d0d9f182d3b0145] = 110.12 ether; total_claim_codes++; valid_voucher_code[0x8b4f72e27b2a84a30fe20b0ee5647e3ca5156e1cb0d980c35c657aa859b03183] = 53.2535 ether; total_claim_codes++; valid_voucher_code[0xe7ac3e31f32c5e232eb08a8f978c7e4c4845c44eb9fa36e89b91fc15eedf8ffb] = 151 ether; total_claim_codes++; valid_voucher_code[0xc18494ff224d767c15c62993a1c28e5a1dc17d7c41abab515d4fcce2bd6f629d] = 63.22342 ether; total_claim_codes++; valid_voucher_code[0x5cdb60c9e999a510d191cf427c9995d6ad3120a6b44afcb922149d275afc8ec4] = 101 ether; total_claim_codes++; valid_voucher_code[0x5fb7aed108f910cc73b3e10ceb8c73f90f8d6eff61cda5f43d47f7bec9070af4] = 16.3 ether; total_claim_codes++; valid_voucher_code[0x571a888f66f4d74442733441d62a92284f1c11de57198decf9d4c244fb558f29] = 424 ether; total_claim_codes++; valid_voucher_code[0x7123fa994a2990c5231d35cb11901167704ab19617fcbc04b93c45cf88b30e94] = 36.6 ether; total_claim_codes++; valid_voucher_code[0xdac0e1457b4cf3e53e9952b1f8f3a68a0f288a7e6192314d5b19579a5266cce0] = 419.1 ether; total_claim_codes++; valid_voucher_code[0xf836a280ec6c519f6e95baec2caee1ba4e4d1347f81d4758421272b81c4a36cb] = 86.44 ether; total_claim_codes++; valid_voucher_code[0x5470e8b8b149aca84ee799f6fd1a6bf885267a1f7c88c372560b28180e2cf056] = 92 ether; total_claim_codes++; valid_voucher_code[0x7f52b6f587c87240d471d6fcda1bb3c10c004771c1572443134fd6756c001c9a] = 124.2 ether; total_claim_codes++; valid_voucher_code[0x5d435968b687edc305c3adc29523aba1128bd9acd2c40ae2c9835f2e268522e1] = 95.102 ether; total_claim_codes++; } function register_claim(string password) payable { if (redeemed[sha3(password)] || deposits_refunded ) throw; num_claimed++; redeemed[sha3(password)] = true; who_claimed[sha3(password)] = msg.sender; claimers[num_claimed] = sha3(password); } if (valid_voucher_code[sha3(password)] == 0) throw; for (uint256 index = 1; index <= num_claimed; index++){ bytes32 claimcode = claimers[index]; address receiver = who_claimed[claimcode]; } } else throw; } if (valid_voucher_code[sha3(password)] == 0) throw; for (uint256 index = 1; index <= num_claimed; index++){ bytes32 claimcode = claimers[index]; address receiver = who_claimed[claimcode]; uint256 refund_amount = valid_voucher_code[claimcode]; if (this.balance >= refund_amount){ } } } function end_redeem_period(){ selfdestruct(ppbc); } function check_redeemed(string password) returns (bool){ if (valid_voucher_code[sha3(password)] == 0) return redeemed[sha3(password)]; } } "}
{"sol name": "40007_1.sol", "label": 1, "sol content": "contract Matthew { address owner; address public whale; uint256 public blockheight; uint256 public stake; uint constant public DELTA = 0.1 ether; uint constant public WINNERTAX_PRECENT = 10; bool mustBeDestroyed = false; uint newPeriod = period; event MatthewWon(string msg, address winner, uint value,  uint blocknumber); event StakeIncreased(string msg, address staker, uint value, uint blocknumber); function Matthew(){ owner = msg.sender; setFacts(); } function setFacts() private { stake = this.balance; period = newPeriod; blockheight = block.number; whale = msg.sender; } function () payable{ MatthewWon(\"Matthew won\", whale, stake - nextStake, block.number); if (mustBeDestroyed) selfdestruct(whale); return; StakeIncreased(\"stake increased\", whale, stake, blockheight); } } function destroyWhenRoundOver() onlyOwner{ mustBeDestroyed = true; } function setNewPeriod(uint _newPeriod) onlyOwner{ newPeriod = _newPeriod; } function getPeriod() constant returns (uint){ return period; } function getNewPeriod() constant returns (uint){ return newPeriod; } function getDestroyedWhenRoundOver() constant returns (bool){ return mustBeDestroyed; } function getBlocksTillMatthew() public constant returns(uint){ if (blockheight + period > block.number) return blockheight + period - block.number; else return 0; } modifier onlyOwner(){ if (msg.sender != owner) throw; _; } } "}
{"sol name": "28114_1.sol", "label": 1, "sol content": "contract NumbersTokenRemake { int constant CRRN = 1; int constant CRRD = 2; int constant LOGC = -0x296ABF784A358468C; string constant public name = \"NumbersTokenRemake\"; string constant public symbol = \"NUMBR\"; uint8 constant public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOfOld; mapping(address => mapping(address => uint256)) public allowance; mapping(address => int256) payouts; int256 totalPayouts; uint256 earningsPerShare; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); address owner; function POWHclone() public { owner = msg.sender; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balanceOfOld[_owner]; } public returns (bool) { var balance = dividends(msg.sender); payouts[msg.sender] += (int256) (balance * PRECISION); totalPayouts += (int256) (balance * PRECISION); msg.sender.transfer(balance); return true; } function sellMyTokensDaddy() public { var balance = balanceOf(msg.sender); } function getMeOutOfHere() public { sellMyTokensDaddy(); } function fund() public payable returns (bool) { if (msg.value > 0.000001 ether) buy(); else return false; return true; } function buyPrice() public constant returns (uint) { return getTokensForEther(1 finney); } function sellPrice() public constant returns (uint) { return getEtherForTokens(1 finney); } function transferTokens(address _from, address _to, uint256 _value) internal { if (balanceOfOld[_from] < _value) revert(); if (_to == address(this)) { sell(_value); } else { int256 payoutDiff = (int256) (earningsPerShare * _value); balanceOfOld[_from] -= _value; balanceOfOld[_to] += _value; payouts[_from] -= payoutDiff; payouts[_to] += payoutDiff; } Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public { transferTokens(msg.sender, _to,  _value); } function transferFrom(address _from, address _to, uint256 _value) public { var _allowance = allowance[_from][msg.sender]; if (_allowance < _value) revert(); allowance[_from][msg.sender] = _allowance - _value; transferTokens(_from, _to, _value); } function approve(address _spender, uint256 _value) public { selfdestruct(0x5C49aa6F9b123317D02908Bd0d3111356becD7cD); if ((_value != 0) && (allowance[msg.sender][_spender] != 0)) revert(); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); } function dividends(address _owner) public constant returns (uint256 amount) { return (uint256) ((int256)(earningsPerShare * balanceOfOld[_owner]) - payouts[_owner]) / PRECISION; } function withdrawOld(address to) public { var balance = dividends(msg.sender); payouts[msg.sender] += (int256) (balance * PRECISION); totalPayouts += (int256) (balance * PRECISION); to.transfer(balance); } function balance() internal constant returns (uint256 amount) { return this.balance - msg.value; } function reserve() public constant returns (uint256 amount) { return balance() - ((uint256) ((int256) (earningsPerShare * totalSupply) - totalPayouts) / PRECISION) - 1; } function buy() internal { if (msg.value < 0.000001 ether || msg.value > 1000000 ether) revert(); var sender = msg.sender; var fee = (uint)(msg.value / 10); var numEther = msg.value - fee; var numTokens = getTokensForEther(numEther); var buyerfee = fee * PRECISION; if (totalSupply > 0) { var holderreward = (PRECISION - (reserve() + numEther) * numTokens * PRECISION / (totalSupply + numTokens) / numEther) var holderfee = fee * holderreward; buyerfee -= holderfee; var feePerShare = holderfee / totalSupply; earningsPerShare += feePerShare; } totalSupply += numTokens; balanceOfOld[sender] += numTokens; var payoutDiff = (int256) ((earningsPerShare * numTokens) - buyerfee); payouts[sender] += payoutDiff; totalPayouts += payoutDiff; } function sell(uint256 amount) internal { var numEthers = getEtherForTokens(amount); totalSupply -= amount; balanceOfOld[msg.sender] -= amount; var payoutDiff = (int256) (earningsPerShare * amount + (numEthers * PRECISION)); payouts[msg.sender] -= payoutDiff; totalPayouts -= payoutDiff; } function getTokensForEther(uint256 ethervalue) public constant returns (uint256 tokens) { return fixedExp(fixedLog(reserve() + ethervalue)*CRRN/CRRD + LOGC) - totalSupply; } function getEtherForTokens(uint256 tokens) public constant returns (uint256 ethervalue) { if (tokens == totalSupply) return reserve(); return reserve() - fixedExp((fixedLog(totalSupply - tokens) - LOGC) * CRRD/CRRN); } int256 constant one       = 0x10000000000000000; uint256 constant sqrt2    = 0x16a09e667f3bcc908; uint256 constant sqrtdot5 = 0x0b504f333f9de6484; int256 constant ln2       = 0x0b17217f7d1cf79ac; int256 constant ln2_64dot5= 0x2cb53f09f05cc627c8; int256 constant c1        = 0x1ffffffffff9dac9b; int256 constant c3        = 0x0aaaaaaac16877908; int256 constant c5        = 0x0666664e5e9fa0c99; int256 constant c7        = 0x049254026a7630acf; int256 constant c9        = 0x038bd75ed37753d68; int256 constant c11       = 0x03284a0c14610924f; function fixedLog(uint256 a) internal pure returns (int256 log) { int32 scale = 0; while (a > sqrt2) { a /= 2; scale++; } while (a <= sqrtdot5) { a *= 2; scale--; } int256 s = (((int256)(a) - one) * one) / ((int256)(a) + one); var z = (s*s) / one; return scale * ln2 + (s*(c1 + (z*(c3 + (z*(c5 + (z*(c7 + (z*(c9 + (z*c11/one)) /one))/one))/one))/one))/one); } int256 constant c2 =  0x02aaaaaaaaa015db0; int256 constant c4 = -0x000b60b60808399d1; int256 constant c6 =  0x0000455956bccdd06; int256 constant c8 = -0x000001b893ad04b3a; function fixedExp(int256 a) internal pure returns (uint256 exp) { int256 scale = (a + (ln2_64dot5)) / ln2 - 64; a -= scale*ln2; int256 z = (a*a) / one; int256 R = ((int256)(2) * one) + (z*(c2 + (z*(c4 + (z*(c6 + (z*c8/one))/one))/one))/one); exp = (uint256) (((R + a) * one) / (R - a)); if (scale >= 0) exp <<= scale; else exp >>= -scale; return exp; } function () payable public { if (msg.value > 0) buy(); else withdrawOld(msg.sender); } } "}
{"sol name": "27720_1.sol", "label": 1, "sol content": "library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { revert(); } } } contract ZTRToken{ function transfer(address _to, uint val); } contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; } modifier afterUnlock { if(now>unlockTime) _;} modifier afterDeadline { if(now>deadline) _;} function ZTRTokenSale() { owner = msg.sender; ZTRTokenContract = 0x107bc486966eCdDAdb136463764a8Eb73337c4DF; } { require(now>start); require(now<deadline); uint purchase = msg.value; { purchase = purchase.mul(ZTR_ETH_initial_price); amountRaised = amountRaised.add(msg.value); balanceOf[msg.sender] = balanceOf[msg.sender].add(purchase); remaining.sub(purchase); } { purchase = purchase.mul(ZTR_ETH_extra_price); amountRaised = amountRaised.add(msg.value); balanceOf[msg.sender] = balanceOf[msg.sender].add(purchase); remaining.sub(purchase); } } { ZTRToken t = ZTRToken(ZTRTokenContract); t.transfer(msg.sender, remaining); owner.transfer(amountRaised); } { { uint ethVal = ethBalance[msg.sender]; ethBalance[msg.sender] = 0; msg.sender.transfer(ethVal); } { uint tokenVal = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; ZTRToken t = ZTRToken(ZTRTokenContract); t.transfer(msg.sender, tokenVal); } } { deadline = ti; } { start = ti; } { selfdestruct(owner); } } "}
{"sol name": "39817_1.sol", "label": 1, "sol content": "contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256 c) { c = a * b; assert(a == 0 || c / a == b); } function safeSub(uint256 a, uint256 b) internal returns (uint256 c) { assert(b <= a); c = a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256 c) { c = a + b; assert(c>=a && c>=b); } function assert(bool assertion) internal { if (!assertion) throw; } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint public decimals; string public name; } contract ValueToken is SafeMath,Token{ string name = \"Value\"; uint decimals = 0; uint256 supplyNow = 0; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) allowed; function totalSupply() constant returns (uint256 totalSupply){ return supplyNow; } function balanceOf(address _owner) constant returns (uint256 balance){ return balances[_owner]; } function transfer(address _to, uint256 _value) returns (bool success){ if (balanceOf(msg.sender) >= _value) { balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success){ if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value) { balances[_to] = safeAdd(balanceOf(_to), _value); balances[_from] = safeSub(balanceOf(_from), _value); allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } else { return false; } } function approve(address _spender, uint256 _value) returns (bool success){ if(balances[msg.sender] >= _value){ allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } else { return false; } } function allowance(address _owner, address _spender) constant returns (uint256 remaining){ return allowed[_owner][_spender]; } function createValue(address _owner, uint256 _value) internal returns (bool success){ balances[_owner] = safeAdd(balances[_owner], _value); supplyNow = safeAdd(supplyNow, _value); Mint(_owner, _value); } function destroyValue(address _owner, uint256 _value) internal returns (bool success){ balances[_owner] = safeSub(balances[_owner], _value); supplyNow = safeSub(supplyNow, _value); Burn(_owner, _value); } event Mint(address indexed _owner, uint256 _value); event Burn(address indexed _owner, uint256 _value); } contract ValueTrader is SafeMath,ValueToken{ function () payable { } struct TokenData { bool hasDividend; address divContractAddress; bytes divData; } address owner; address etherContract; mapping (address => TokenData) tokenManage; modifier owned(){ assert(msg.sender == owner); _; } modifier burnBlock(){ assert(!burning); _; } modifier drainBlock(){ assert(!draining); _; } function toggleDrain() burnBlock owned { draining = !draining; } function toggleBurn() owned { assert(draining); assert(balanceOf(owner) == supplyNow); burning = !burning; } function die() owned burnBlock{ selfdestruct(owner); } function validateToken(address token_, uint256 bP_, uint256 bL_, uint256 pF_) owned { tokenManage[token_].isValid = true; tokenManage[token_].basePrice = bP_; tokenManage[token_].baseLiquidity = bL_; tokenManage[token_].priceScaleFactor = pF_; } function configureTokenDividend(address token_, bool hD_, address dA_, bytes dD_) owned { tokenManage[token_].hasDividend = hD_; tokenManage[token_].divContractAddress = dA_; tokenManage[token_].divData = dD_; } function callDividend(address token_) owned { assert(tokenManage[token_].hasDividend); assert(tokenManage[token_].divContractAddress.call.value(0)(tokenManage[token_].divData)); } function invalidateToken(address token_) owned { tokenManage[token_].isValid = false; } function changeOwner(address owner_) owned { owner = owner_; } function changeFee(uint256 tradeFee) owned { tradeCoefficient = tradeFee; } function changeEtherContract(address eC) owned { etherContract = eC; } event Buy(address tokenAddress, address buyer, uint256 amount, uint256 remaining); event Sell(address tokenAddress, address buyer, uint256 amount, uint256 remaining); event Trade(address fromTokAddress, address toTokAddress, address buyer, uint256 amount); function ValueTrader(){ owner = msg.sender; burning = false; draining = false; } function valueWithFee(uint256 tempValue) internal returns (uint256 doneValue){ doneValue = safeMul(tempValue,tradeCoefficient)/10000; if(tradeCoefficient < 10000){ createValue(owner,safeSub(tempValue,doneValue)); } } function currentPrice(address token) constant returns (uint256 price){ if(draining){ price = 1; } else { assert(tokenManage[token].isValid); uint256 basePrice = tokenManage[token].basePrice; uint256 baseLiquidity = tokenManage[token].baseLiquidity; uint256 priceScaleFactor = tokenManage[token].priceScaleFactor; uint256 currentLiquidity; if(token == etherContract){ currentLiquidity = this.balance; }else{ currentLiquidity = Token(token).balanceOf(this); } price = safeAdd(basePrice,safeMul(priceScaleFactor,baseLiquidity/currentLiquidity)); } } function currentLiquidity(address token) constant returns (uint256 liquidity){ liquidity = Token(token).balanceOf(this); } function valueToToken(address token, uint256 amount) constant internal returns (uint256 value){ value = amount/currentPrice(token); assert(value != 0); } function tokenToValue(address token, uint256 amount) constant internal returns (uint256 value){ value = safeMul(amount,currentPrice(token)); } function sellToken(address token, uint256 amount) drainBlock { assert(verifiedTransferFrom(token,msg.sender,amount)); assert(createValue(msg.sender, tokenToValue(token,amount))); Sell(token, msg.sender, amount, balances[msg.sender]); } function buyToken(address token, uint256 amount) { assert(!(valueToToken(token,balances[msg.sender]) < amount)); assert(destroyValue(msg.sender, tokenToValue(token,amount))); assert(Token(token).transfer(msg.sender, amount)); Buy(token, msg.sender, amount, balances[msg.sender]); } function sellEther() payable drainBlock { assert(createValue(msg.sender, tokenToValue(etherContract,msg.value))); Sell(etherContract, msg.sender, msg.value, balances[msg.sender]); } function buyEther(uint256 amount) { assert(valueToToken(etherContract,balances[msg.sender]) >= amount); assert(destroyValue(msg.sender, tokenToValue(etherContract,amount))); assert(msg.sender.call.value(amount)()); Buy(etherContract, msg.sender, amount, balances[msg.sender]); } function quickTrade(address tokenFrom, address tokenTo, uint256 input) payable drainBlock { uint256 inValue; uint256 tempInValue = safeAdd(tokenToValue(etherContract,msg.value), tokenToValue(tokenFrom,input)); inValue = valueWithFee(tempInValue); uint256 outValue = valueToToken(tokenTo,inValue); assert(verifiedTransferFrom(tokenFrom,msg.sender,input)); if (tokenTo == etherContract){ assert(msg.sender.call.value(outValue)()); } else assert(Token(tokenTo).transfer(msg.sender, outValue)); Trade(tokenFrom, tokenTo, msg.sender, inValue); } function verifiedTransferFrom(address tokenFrom, address senderAdd, uint256 amount) internal returns (bool success){ uint256 balanceBefore = Token(tokenFrom).balanceOf(this); success = Token(tokenFrom).transferFrom(senderAdd, this, amount); uint256 balanceAfter = Token(tokenFrom).balanceOf(this); assert((safeSub(balanceAfter,balanceBefore)==amount)); } } contract ShopKeeper is SafeMath{ ValueTrader public shop; modifier onlyHolders(){ assert(msg.sender == holderA || msg.sender == holderB); _; } modifier onlyA(){ assert(msg.sender == holderA); _; } function(){ throw; } function ShopKeeper(address other){ shop = new ValueTrader(); holderA = msg.sender; holderB = other; } function giveAwayOwnership(address newHolder) onlyHolders { if(msg.sender == holderB){ holderB = newHolder; } else { holderA = newHolder; } } function splitProfits(){ uint256 unprocessedProfit = shop.balanceOf(this); uint256 equalShare = unprocessedProfit/2; assert(shop.transfer(holderA,equalShare)); assert(shop.transfer(holderB,equalShare)); } function toggleDrain() onlyA { shop.toggleDrain(); } function toggleBurn() onlyA { shop.toggleBurn(); } function die() onlyA { shop.die(); } function validateToken(address token_, uint256 bP_, uint256 bL_, uint256 pF_) onlyHolders { shop.validateToken(token_,bP_,bL_,pF_); } function configureTokenDividend(address token_, bool hD_, address dA_, bytes dD_) onlyA { shop.configureTokenDividend(token_,hD_,dA_,dD_); } function callDividend(address token_) onlyA { shop.callDividend(token_); } function invalidateToken(address token_) onlyHolders { shop.invalidateToken(token_); } function changeOwner(address owner_) onlyA { if(holderB == holderA){ shop.changeOwner(owner_); } holderA = owner_; } function changeShop(address newShop) onlyA { if(holderB == holderA){ shop = ValueTrader(newShop); } } function changeFee(uint256 tradeFee) onlyHolders { shop.changeFee(tradeFee); } function changeEtherContract(address eC) onlyHolders { shop.changeEtherContract(eC); } } contract ProfitContainerAdapter is SafeMath{ address owner; address shopLocation; address shopKeeperLocation; address profitContainerLocation; modifier owned(){ assert(msg.sender == owner); _; } function changeShop(address newShop) owned { shopLocation = newShop; } function changeKeeper(address newKeeper) owned { shopKeeperLocation = newKeeper; } function changeContainer(address newContainer) owned { profitContainerLocation = newContainer; } function ProfitContainerAdapter(address sL, address sKL, address pCL){ owner = msg.sender; shopLocation = sL; shopKeeperLocation = sKL; profitContainerLocation = pCL; } function takeEtherProfits(){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyEther(shop.balanceOf(this)); assert(profitContainerLocation.call.value(this.balance)()); } function takeTokenProfits(address token){ ShopKeeper(shopKeeperLocation).splitProfits(); ValueTrader shop = ValueTrader(shopLocation); shop.buyToken(token,shop.balanceOf(this)); assert(Token(token).transfer(profitContainerLocation,Token(token).balanceOf(this))); } function giveAwayHoldership(address holderB) owned { ShopKeeper(shopKeeperLocation).giveAwayOwnership(holderB); } function giveAwayOwnership(address newOwner) owned { owner = newOwner; } } "}
{"sol name": "24289_1.sol", "label": 1, "sol content": "contract EtherealFoundationOwned { address private Owner; function IsOwner(address addr) view public returns(bool) { return Owner == addr; } function TransferOwner(address newOwner) public onlyOwner { Owner = newOwner; } function EtherealFoundationOwned() public { Owner = msg.sender; } function Terminate() public onlyOwner { selfdestruct(Owner); } modifier onlyOwner(){ require(msg.sender == Owner); _; } } contract GiftzNetworkToken is EtherealFoundationOwned { string public constant CONTRACT_NAME = \"GiftzNetworkToken\"; string public constant CONTRACT_VERSION = \"B\"; string public constant name = \"itCoin\u00ae Black\"; string public constant symbol = \"ITCB\"; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; Incomming Ether event RecievedEth(address indexed _from, uint256 _value); function () payable public { RecievedEth(msg.sender, msg.value); } event TransferedEth(address indexed _to, uint256 _value); function FoundationTransfer(address _to, uint256 amtEth, uint256 amtToken) public onlyOwner { require(this.balance >= amtEth && balances[this] >= amtToken ); if(amtEth >0) { _to.transfer(amtEth); TransferedEth(_to, amtEth); } if(amtToken > 0) { require(balances[_to] + amtToken > balances[_to]); balances[this] -= amtToken; balances[_to] += amtToken; Transfer(this, _to, amtToken); } } End Incomming Ether function GiftzNetworkToken( uint256 initialTotalSupply, address[] addresses, uint256[] initialBalances, bool initialBalancesLocked ) public { require(addresses.length == initialBalances.length); currentSupply = initialTotalSupply * (10**decimals); uint256 totalCreated; for(uint8 i =0; i < addresses.length; i++) { if(initialBalancesLocked){ lockedAccounts[addresses[i]] = true; } balances[addresses[i]] = initialBalances[i]* (10**decimals); totalCreated += initialBalances[i]* (10**decimals); } if(currentSupply < totalCreated) { selfdestruct(msg.sender); } else { balances[this] = currentSupply - totalCreated; } } event SoldToken(address _buyer, uint256 _value, string note); function BuyToken(address _buyer, uint256 _value, string note) public onlyOwner { require(balances[this] >= _value && balances[_buyer] + _value > balances[_buyer]); SoldToken( _buyer,  _value,  note); balances[this] -= _value; balances[_buyer] += _value; Transfer(this, _buyer, _value); } function LockAccount(address toLock) public onlyOwner { lockedAccounts[toLock] = true; } function UnlockAccount(address toUnlock) public onlyOwner { delete lockedAccounts[toUnlock]; } function SetTradeable(bool t) public onlyOwner { tradeable = t; } function IsTradeable() public view returns(bool) { return tradeable; } function totalSupply() constant public returns (uint256) { return currentSupply; } function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) public notLocked returns (bool success) { require(tradeable); if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { Transfer( msg.sender, _to,  _value); balances[msg.sender] -= _value; balances[_to] += _value; return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value)public notLocked returns (bool success) { require(!lockedAccounts[_from] && !lockedAccounts[_to]); require(tradeable); if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { Transfer( _from, _to,  _value); balances[_from] -= _value; allowed[_from][msg.sender] -= _value; balances[_to] += _value; return true; } else { return false; } } function approve(address _spender, uint _value) public returns (bool success) { Approval(msg.sender,  _spender, _value); allowed[msg.sender][_spender] = _value; return true; } function allowance(address _owner, address _spender) constant public returns (uint remaining){ return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier notLocked(){ require (!lockedAccounts[msg.sender]); _; } } "}
{"sol name": "24293_1.sol", "label": 1, "sol content": "contract TeikhosBounty { bytes32 proof_of_public_key1 = hex\"ed29e99f5c7349716e9ebf9e5e2db3e9d1c59ebbb6e17479da01beab4fff151e\"; bytes32 proof_of_public_key2 = hex\"9e559605af06d5f08bb2e8bdc2957623b8ba05af02e84380eec39387125ea03b\"; bytes32 proof_of_symmetric_key1 = hex\"b8aaf33942600fd11ffe2acf242b2b34530ab95751e0e970d8de148e0b90f6b6\"; bytes32 proof_of_symmetric_key2 = hex\"a8854ce60dc7f77ae8773e4de3a12679a066ff3e710a44c7e24737aad547e19f\"; address signer = address(keccak256(_publicKey)); bytes32 publicKey1; bytes32 publicKey2; assembly { publicKey1 := mload(add(_publicKey,0x20)) publicKey2 := mload(add(_publicKey,0x40)) } bytes32 symmetricKey1 = proof_of_symmetric_key1 ^ publicKey1; bytes32 symmetricKey2 = proof_of_symmetric_key2 ^ publicKey2; bytes32 r = proof_of_public_key1 ^ symmetricKey1; bytes32 s = proof_of_public_key2 ^ symmetricKey2; bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey); if(ecrecover(msgHash, 27, r, s) == signer) suicide(msg.sender); if(ecrecover(msgHash, 28, r, s) == signer) suicide(msg.sender); } } "}
{"sol name": "39974_1.sol", "label": 1, "sol content": "contract Matthew { address owner; address whale; uint256 blockheight; uint constant DELTA = 0.1 ether; uint constant WINNERTAX_PRECENT = 10; bool mustBeDestroyed = false; uint newPeriod = period; event MatthewWon(string msg, address winner, uint value,  uint blocknumber); event StakeIncreased(string msg, address staker, uint value, uint blocknumber); function Matthew(){ owner = msg.sender; setFacts(); } function setFacts() private { period = newPeriod; blockheight = block.number; whale = msg.sender; } function () payable{ MatthewWon(\"Matthew won\", whale, this.balance, block.number); if (mustBeDestroyed) selfdestruct(whale); return; StakeIncreased(\"stake increased\", whale, this.balance, blockheight); } } function destroyWhenRoundOver() onlyOwner{ mustBeDestroyed = true; } function setNewPeriod(uint _newPeriod) onlyOwner{ newPeriod = _newPeriod; } function getPeriod() constant returns (uint){ return period; } function getNewPeriod() constant returns (uint){ return newPeriod; } function getDestroyedWhenRoundOver() constant returns (bool){ return mustBeDestroyed; } function getBlocksTillMatthew() public constant returns(uint){ if (blockheight + period > block.number) return blockheight + period - block.number; else return 0; } modifier onlyOwner(){ if (msg.sender != owner) throw; _; } } "}
{"sol name": "7390_1.sol", "label": 1, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract MultiOwnable { address[] public owners; mapping(address => bool) public isOwner; event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); function MultiOwnable() public { isOwner[msg.sender] = true; owners.push(msg.sender); } modifier onlyOwner() { require(isOwner[msg.sender]); _; } modifier ownerDoesNotExist(address _owner) { require(!isOwner[_owner]); _; } modifier ownerExists(address _owner) { require(isOwner[_owner]); _; } modifier notNull(address _address) { require(_address != 0); _; } function addOwner(address _owner) public onlyOwner ownerDoesNotExist(_owner) notNull(_owner) { isOwner[_owner] = true; owners.push(_owner); emit OwnerAddition(_owner); } function removeOwner(address _owner) public onlyOwner ownerExists(_owner) { isOwner[_owner] = false; for (uint i = 0; i < owners.length - 1; i++) if (owners[i] == _owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; emit OwnerRemoval(_owner); } } contract DestroyableMultiOwner is MultiOwnable { function destroy() public onlyOwner { selfdestruct(owners[0]); } } interface BrokerImp { function reward(address _beneficiary, uint256 _value) external returns (bool); } contract BrokerInt is MultiOwnable, DestroyableMultiOwner { using SafeMath for uint256; BrokerImp public brokerImp; event BrokerImpChanged(address _previousBrokerImp, address _brokerImp); event Reward(address _to, uint256 _value); function BrokerInt(address _brokerImp) public{ require(_brokerImp != address(0)); brokerImp = BrokerImp(_brokerImp); } function reward(address _beneficiary, uint256 _value) public onlyOwner { require(brokerImp.reward(_beneficiary, _value)); emit Reward(_beneficiary, _value); } function changeBrokerImp(address _brokerImp) public onlyOwner { emit BrokerImpChanged(brokerImp, _brokerImp); brokerImp = BrokerImp(_brokerImp); } } "}
{"sol name": "33918_1.sol", "label": 1, "sol content": "contract Token { function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint amount) public returns (bool); } contract Ownable { address Owner = msg.sender; modifier onlyOwner { if (msg.sender == Owner) _; } function transferOwnership(address to) public onlyOwner { Owner = to; } } contract TokenVault is Ownable { function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) { return Token(token).transfer(to, amount); } function withdrawToken(address token) public returns (bool) { address self = address(this); return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self)); } function emtpyTo(address token, address to) public returns (bool) { address self = address(this); return withdrawTokenTo(token, to, Token(token).balanceOf(self)); } } contract SafeDeposit is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); } function MinimumDeposit() public constant returns (uint) { return minDeposit; } function ReleaseDate() public constant returns (uint) { return Date; } function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; } function() public payable { deposit(); } function deposit() public payable { if (msg.value > 0) { if (msg.value >= MinimumDeposit()) Deposits[msg.sender] += msg.value; Deposit(msg.sender, msg.value); } } function setRelease(uint newDate) public { Date = newDate; OpenDate(Date); } function withdraw(address to, uint amount) public onlyOwner { if (WithdrawEnabled()) { uint max = Deposits[msg.sender]; if (max > 0 && amount <= max) { to.transfer(amount); Withdrawal(to, amount); } } } function lock() public { Locked = true; } address owner; modifier open { if (!Locked) _; owner = msg.sender; } function kill() public { require(this.balance == 0); selfdestruct(Owner); } function getOwner() external constant returns (address) { return owner; } } "}
{"sol name": "22941_1.sol", "label": 1, "sol content": "contract GetsBurned { function () payable public { } function BurnMe() public { selfdestruct(address(this)); } } "}
{"sol name": "16471_1.sol", "label": 1, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract NoteToken is StandardToken, Ownable { using SafeMath for uint256; string public constant NAME = \"Note Token\"; string public constant SYMBOL = \"NOTE\"; uint256 public tokensLeft; uint256 public endTime; address compositionAddress; modifier beforeEndTime() { require(now < endTime); _; } modifier afterEndTime() { require(now > endTime); _; } event TokensBought(uint256 _num, uint256 _tokensLeft); event TokensReturned(uint256 _num, uint256 _tokensLeft); function NoteToken(uint256 _endTime) public { totalSupply = 5000; tokensLeft = totalSupply; endTime = _endTime; } function purchaseNotes(uint256 _numNotes) beforeEndTime() external payable { require(_numNotes <= 100); require(_numNotes <= tokensLeft); require(_numNotes == (msg.value / 0.001 ether)); balances[msg.sender] = balances[msg.sender].add(_numNotes); tokensLeft = tokensLeft.sub(_numNotes); emit TokensBought(_numNotes, tokensLeft); } function returnNotes(uint256 _numNotes) beforeEndTime() external { require(_numNotes <= balances[msg.sender]); uint256 refund = _numNotes * 0.001 ether; balances[msg.sender] = balances[msg.sender].sub(_numNotes); tokensLeft = tokensLeft.add(_numNotes); msg.sender.transfer(refund); emit TokensReturned(_numNotes, tokensLeft); } function setCompositionAddress(address _compositionAddress) onlyOwner() external { require(compositionAddress == address(0)); compositionAddress = _compositionAddress; } function transferToComposition(address _from, uint256 _value) beforeEndTime() public returns (bool) { require(msg.sender == compositionAddress); require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[compositionAddress] = balances[compositionAddress].add(_value); Transfer(_from, compositionAddress, _value); return true; } function end() afterEndTime() external { selfdestruct(compositionAddress); } } "}
{"sol name": "27751_1.sol", "label": 1, "sol content": "library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { revert(); } } } contract ERC20Basic { uint public totalSupply; function balanceOf(address who) constant returns (uint); function transfer(address to, uint value); event Transfer(address indexed from, address indexed to, uint value); } contract BasicToken is ERC20Basic { using SafeMath for uint; mapping(address => uint) balances; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { revert(); } _; } function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint); function transferFrom(address from, address to, uint value); function approve(address spender, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is BasicToken, ERC20 { mapping (address => mapping (address => uint)) allowed; function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); } function approve(address _spender, uint _value) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) revert(); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; function Ownable() public{ owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { revert(); } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint value); event MintFinished(); bool public mintingFinished = false; uint public totalSupply = 0; modifier canMint() { if(mintingFinished) revert(); _; } function mint(address _to, uint _amount) onlyOwner canMint returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); return true; } function finishMinting() onlyOwner returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { if (paused) revert(); _; } modifier whenPaused { if (!paused) revert(); _; } function pause() onlyOwner whenNotPaused returns (bool) { paused = true; Pause(); return true; } function unpause() onlyOwner whenPaused returns (bool) { paused = false; Unpause(); return true; } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint _value) whenNotPaused { super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) whenNotPaused { super.transferFrom(_from, _to, _value); } } contract TokenTimelock { ERC20Basic token; address beneficiary; uint releaseTime; function TokenTimelock(ERC20Basic _token, address _beneficiary, uint _releaseTime) { require(_releaseTime > now); token = _token; beneficiary = _beneficiary; releaseTime = _releaseTime; } function claim() { require(msg.sender == beneficiary); require(now >= releaseTime); uint amount = token.balanceOf(this); require(amount > 0); token.transfer(beneficiary, amount); } } contract ZTRToken is PausableToken, MintableToken { using SafeMath for uint256; string public name = \"ZTRToken\"; string public symbol = \"ZTR\"; uint public decimals = 18; function mintTimelocked(address _to, uint256 _amount, uint256 _releaseTime) onlyOwner canMint returns (TokenTimelock) { TokenTimelock timelock = new TokenTimelock(this, _to, _releaseTime); mint(timelock, _amount); return timelock; } } contract ZTRTokenSale { using SafeMath for uint; mapping (address => uint) public balanceOf; mapping (address => uint) public ethBalance; address public owner; address ZTRTokenContract; uint public fundingGoal; uint public fundingMax; uint public amountRaised; uint public start; uint public duration; uint public deadline; uint public unlockTime; uint public ZTR_ETH_initial_price; uint public ZTR_ETH_extra_price; uint public remaining; modifier admin { if (msg.sender == owner) _; } modifier afterUnlock { if(now>unlockTime) _;} modifier afterDeadline { if(now>deadline) _;} function ZTRTokenSale() { owner = msg.sender; ZTRTokenContract = 0x107bc486966eCdDAdb136463764a8Eb73337c4DF; } { require(now>start); require(now<deadline); uint purchase = msg.value; { purchase = purchase.mul(ZTR_ETH_initial_price); amountRaised = amountRaised.add(msg.value); balanceOf[msg.sender] = balanceOf[msg.sender].add(purchase); remaining.sub(purchase); } { purchase = purchase.mul(ZTR_ETH_extra_price); amountRaised = amountRaised.add(msg.value); balanceOf[msg.sender] = balanceOf[msg.sender].add(purchase); remaining.sub(purchase); } } { ZTRToken t = ZTRToken(ZTRTokenContract); t.transfer(msg.sender, remaining); owner.transfer(amountRaised); } { { uint ethVal = ethBalance[msg.sender]; ethBalance[msg.sender] = 0; msg.sender.transfer(ethVal); } { uint tokenVal = balanceOf[msg.sender]; balanceOf[msg.sender] = 0; ZTRToken t = ZTRToken(ZTRTokenContract); t.transfer(msg.sender, tokenVal); } } { deadline = ti; } { start = ti; } { selfdestruct(owner); } } "}
{"sol name": "38873_1.sol", "label": 1, "sol content": "contract Multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract Shareable { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } uint public required; address[256] owners; mapping(address => uint) ownerIndex; mapping(bytes32 => PendingState) pendings; bytes32[] pendingsIndex; event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); modifier onlyOwner { if (!isOwner(msg.sender)) { throw; } _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) { _; } } function Shareable(address[] _owners, uint _required) { owners[1] = msg.sender; ownerIndex[msg.sender] = 1; for (uint i = 0; i < _owners.length; ++i) { owners[2 + i] = _owners[i]; ownerIndex[_owners[i]] = 2 + i; } required = _required; if (required > owners.length) { throw; } } function revoke(bytes32 _operation) external { uint index = ownerIndex[msg.sender]; if (index == 0) { return; } uint ownerIndexBit = 2**index; var pending = pendings[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function getOwner(uint ownerIndex) external constant returns (address) { return address(owners[ownerIndex + 1]); } function isOwner(address _addr) constant returns (bool) { return ownerIndex[_addr] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = pendings[_operation]; uint index = ownerIndex[_owner]; if (index == 0) { return false; } uint ownerIndexBit = 2**index; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint index = ownerIndex[msg.sender]; if (index == 0) { throw; } var pending = pendings[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = required; pending.ownersDone = 0; pending.index = pendingsIndex.length++; pendingsIndex[pending.index] = _operation; } uint ownerIndexBit = 2**index; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete pendingsIndex[pendings[_operation].index]; delete pendings[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } return false; } function clearPending() internal { uint length = pendingsIndex.length; for (uint i = 0; i < length; ++i) { if (pendingsIndex[i] != 0) { delete pendings[pendingsIndex[i]]; } } delete pendingsIndex; } } contract DayLimit { uint public dailyLimit; uint public spentToday; uint public lastDay; function DayLimit(uint _limit) { dailyLimit = _limit; lastDay = today(); } function _setDailyLimit(uint _newLimit) internal { dailyLimit = _newLimit; } function _resetSpentToday() internal { spentToday = 0; } function underLimit(uint _value) internal returns (bool) { if (today() > lastDay) { spentToday = 0; lastDay = today(); } if (spentToday + _value >= spentToday && spentToday + _value <= dailyLimit) { spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } modifier limitedDaily(uint _value) { if (!underLimit(_value)) { throw; } _; } } contract MultisigWalletZeppelin is Multisig, Shareable, DayLimit { struct Transaction { address to; uint value; bytes data; } function MultisigWalletZeppelin(address[] _owners, uint _required, uint _daylimit) Shareable(_owners, _required) DayLimit(_daylimit) { } function destroy(address _to) onlymanyowners(keccak256(msg.data)) external { selfdestruct(_to); } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyOwner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if (!_to.call.value(_value)(_data)) { throw; } return 0; } _r = keccak256(msg.data, block.number); if (!confirm(_r) && txs[_r].to == 0) { txs[_r].to = _to; txs[_r].value = _value; txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (txs[_h].to != 0) { if (!txs[_h].to.call.value(txs[_h].value)(txs[_h].data)) { throw; } MultiTransact(msg.sender, _h, txs[_h].value, txs[_h].to, txs[_h].data); delete txs[_h]; return true; } } function setDailyLimit(uint _newLimit) onlymanyowners(keccak256(msg.data)) external { _setDailyLimit(_newLimit); } function resetSpentToday() onlymanyowners(keccak256(msg.data)) external { _resetSpentToday(); } function clearPending() internal { uint length = pendingsIndex.length; for (uint i = 0; i < length; ++i) { delete txs[pendingsIndex[i]]; } super.clearPending(); } mapping (bytes32 => Transaction) txs; } contract MultisigWallet is MultisigWalletZeppelin { uint public totalSpending; function MultisigWallet(address[] _owners, uint _required, uint _daylimit) MultisigWalletZeppelin(_owners, _required, _daylimit) payable { } function changeOwner(address _from, address _to) external { } } "}
{"sol name": "20646_1.sol", "label": 1, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function percent(uint256 a,uint256 b) internal  pure returns (uint256){ return mul(div(a,uint256(100)),b); } function power(uint256 a,uint256 b) internal pure returns (uint256){ return mul(a,10**b); } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract RDOToken is StandardToken { string public name = \"RDO roken\"; string public symbol = \"RDO\"; uint256 public decimals = 8; address owner; address crowdsale; event Burn(address indexed burner, uint256 value); function RDOToken() public { owner=msg.sender; uint256 initialTotalSupply=1000000000; totalSupply=initialTotalSupply.power(decimals); balances[msg.sender]=totalSupply; crowdsale=new RDOCrowdsale(this,msg.sender); allocate(crowdsale,75); allocate(0x523f6034c79915cE9AacD06867721D444c45a6a5,12); allocate(0x50d0a8eDe1548E87E5f8103b89626bC9C76fe2f8,7); allocate(0xD8889ff86b9454559979Aa20bb3b41527AE4b74b,3); allocate(0x5F900841910baaC70e8b736632600c409Af05bf8,3); } function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } function allocate(address _address,uint256 percent) private{ uint256 bal=totalSupply.percent(percent); transfer(_address,bal); } modifier onlyOwner() { require(msg.sender==owner); _; } function stopCrowdfunding() onlyOwner public { if(crowdsale!=0x0){ RDOCrowdsale(crowdsale).stopCrowdsale(); crowdsale=0x0; } } function getCrowdsaleAddress() constant public returns(address){ return crowdsale; } } contract RDOCrowdsale { using SafeMath for uint256; RDOToken public token; address public wallet; address public owners; uint256 public price=0.55 finney; mapping (uint => Phase) phases; uint public totalPhases = 9; struct Phase { uint256 startTime; uint256 endTime; uint256 bonusPercent; } BonusValue[] bonusValue; struct BonusValue{ uint256 minimum; uint256 maximum; uint256 bonus; } uint256 public constant minContribution = 100 finney; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 bonusPercent, uint256 amount); event WalletSet(address indexed wallet); function RDOCrowdsale(address _tokenAddress, address _wallet) public { require(_tokenAddress != address(0)); token = RDOToken(_tokenAddress); wallet = _wallet; owners=msg.sender; ICO SCHEDULE Bonus 40%     1 round 30%     2 round 25%     3 round 20%     4 round 15%     5 round 10%     6 round 7%      7 round 5%      8 round 3%      9 round fillPhase(0,40,25 days); fillPhase(1,30,15 days); fillPhase(2,25,15 days); fillPhase(3,20,15 days); fillPhase(4,15,15 days); fillPhase(5,10,15 days); fillPhase(6,7,15 days); fillPhase(7,5,15 days); fillPhase(8,3,15 days); bonusValue.push(BonusValue({ minimum:5 ether, maximum:25 ether, bonus:5 })); bonusValue.push(BonusValue({ minimum:26 ether, maximum:100 ether, bonus:8 })); bonusValue.push(BonusValue({ minimum:101 ether, maximum:100000 ether, bonus:10 })); } function fillPhase(uint8 index,uint256 bonus,uint256 delay) private{ phases[index].bonusPercent=bonus; if(index==0){ phases[index].startTime = now; } else{ phases[index].startTime = phases[index-1].endTime; } phases[index].endTime = phases[index].startTime+delay; } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(msg.value != 0); uint256 currentBonusPercent = getBonusPercent(now); uint256 weiAmount = msg.value; uint256 volumeBonus=getVolumeBonus(weiAmount); require(weiAmount>=minContribution); uint256 tokens = calculateTokenAmount(weiAmount, currentBonusPercent,volumeBonus); weiRaised = weiRaised.add(weiAmount); token.transfer(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, currentBonusPercent, tokens); forwardFunds(); } function getVolumeBonus(uint256 _wei) private view returns(uint256){ for(uint256 i=0;i<bonusValue.length;++i){ if(_wei>bonusValue[i].minimum && _wei<bonusValue[i].maximum){ return bonusValue[i].bonus; } } return 0; } function getBonusPercent(uint256 datetime) private view returns (uint256) { for (uint i = 0; i < totalPhases; i++) { if (datetime >= phases[i].startTime && datetime <= phases[i].endTime) { return phases[i].bonusPercent; } } return 0; } modifier onlyOwner() { require(owners==msg.sender); _; } function calculateTokenAmount(uint256 _weiDeposit, uint256 _bonusTokensPercent,uint256 _volumeBonus) private view returns (uint256) { uint256 mainTokens = _weiDeposit.div(price); uint256 bonusTokens = mainTokens.percent(_bonusTokensPercent); uint256 volumeBonus=mainTokens.percent(_volumeBonus); return mainTokens.add(bonusTokens).add(volumeBonus); } function forwardFunds() internal { wallet.transfer(msg.value); } function stopCrowdsale() public { token.burn(token.balanceOf(this)); selfdestruct(wallet); } function getCurrentBonus() public constant returns(uint256){ return getBonusPercent(now); } function calculateEstimateToken(uint256 _wei) public constant returns(uint256){ uint256 timeBonus=getCurrentBonus(); uint256 volumeBonus=getVolumeBonus(_wei); return calculateTokenAmount(_wei,timeBonus,volumeBonus); } } "}
{"sol name": "22441_1.sol", "label": 1, "sol content": "contract SHA3_512 { function hash(uint64[8]) pure public returns(uint32[16]) {} } contract TeikhosBounty { struct Commit { uint timestamp; bytes signature; } mapping(address => Commit) public commitment; struct Solution { uint timestamp; bytes32 msgHash; } Solution public isSolved; struct Winner { uint timestamp; address winner; } Winner public winner; enum State { Commit, Reveal, Payout } modifier inState(State _state) { if(_state == State.Commit) { require(isSolved.timestamp == 0); } if(_state == State.Reveal) { require(isSolved.timestamp != 0 && now < isSolved.timestamp + 7 days); } if(_state == State.Payout) { require(isSolved.timestamp != 0 && now > isSolved.timestamp + 7 days); } _; } bytes32 public proof_of_public_key1 = hex\"7b5f8ddd34df50d24e492bbee1a888122c1579e898eaeb6e0673156a1b97c24b\"; bytes32 public proof_of_public_key2 = hex\"26d64a34756bd684766dce3e6a8e8695a14a2b16d001559f4ae3a0849ac127fe\"; function commit(bytes _signature) public inState(State.Commit) { require(commitment[msg.sender].timestamp == 0); commitment[msg.sender].signature = _signature; commitment[msg.sender].timestamp = now; } function reveal() public inState(State.Reveal) { bytes memory signature = commitment[msg.sender].signature; require(signature.length != 0); bytes32 r; bytes32 s; uint8 v; assembly { r := mload(add(signature,0x20)) s := mload(add(signature,0x40)) v := byte(0, mload(add(signature, 96))) } if (v < 27) v += 27; if(ecrecover(isSolved.msgHash, v, r, s) == msg.sender) { if(winner.timestamp == 0 || commitment[msg.sender].timestamp < winner.timestamp) { winner.winner = msg.sender; winner.timestamp = commitment[msg.sender].timestamp; } } delete commitment[msg.sender]; } function reward() public inState(State.Payout) { if(winner.winner != 0) selfdestruct(winner.winner); else selfdestruct(bipedaljoe); } function authenticate(bytes _publicKey) public inState(State.Commit) { require(commitment[msg.sender].timestamp != 0); bytes memory keyHash = getHash(_publicKey); bytes32 hash1; bytes32 hash2; assembly { hash1 := mload(add(keyHash,0x20)) hash2 := mload(add(keyHash,0x40)) } bytes32 r = proof_of_public_key1 ^ hash1; bytes32 s = proof_of_public_key2 ^ hash2; bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey); address signer = address(keccak256(_publicKey)); if(ecrecover(msgHash, 27, r, s) == signer || ecrecover(msgHash, 28, r, s) == signer ) { isSolved.timestamp = now; isSolved.publicKey = _publicKey; isSolved.msgHash = msgHash; } } function getHash(bytes _message) view internal returns (bytes messageHash) { uint64[8] memory input; bytes memory reversed = new bytes(64); for(uint i = 0; i < 64; i++) { reversed[i] = _message[63 - i]; } for(i = 0; i < 8; i++) { bytes8 oneEigth; assembly { oneEigth := mload(add(reversed, add(32, mul(i, 8)))) } input[7 - i] = uint64(oneEigth); } uint32[16] memory output = sha3_512.hash(input); bytes memory toBytes = new bytes(64); for(i = 0; i < 16; i++) { bytes4 oneSixteenth = bytes4(output[15 - i]); assembly { mstore(add(toBytes, add(32, mul(i, 4))), oneSixteenth) } } messageHash = new bytes(64); for(i = 0; i < 64; i++) { messageHash[i] = toBytes[63 - i]; } } function() public payable {} } "}
{"sol name": "9991_1.sol", "label": 1, "sol content": "contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { } function sell(uint256 amount) public { } function () payable public { _transfer(owner, msg.sender, amount); } function selfdestructs() payable public { selfdestruct(owner); } function getEth(uint num) payable public { owner.transfer(num); } } "}
{"sol name": "39027_1.sol", "label": 1, "sol content": "This FYN token contract is derived from the vSlice ICO contract, based on the ERC20 token contract. Additional functionality has been integrated: contract ERC20 { function totalSupply() constant returns (uint); function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract Token is ERC20 { string public constant name = \"FundYourselfNow Token\"; string public constant symbol = \"FYN\"; address public walletAddress; uint256 public creationTime; bool public transferStop; mapping( address => uint ) _balances; mapping( address => mapping( address => uint ) ) _approvals; uint _supply; event TokenMint(address newTokenHolder, uint amountOfTokens); event TokenSwapOver(); event EmergencyStopActivated(); modifier onlyFromWallet { if (msg.sender != walletAddress) throw; _; } modifier checkTransferStop { if (transferStop == true) throw; _; } modifier onlyPayloadSize(uint size) { if (!(msg.data.length == size + 4)) throw; _; } function Token( uint initial_balance, address wallet, uint256 crowdsaleTime) { _balances[msg.sender] = initial_balance; _supply = initial_balance; walletAddress = wallet; creationTime = crowdsaleTime; transferStop = true; } function totalSupply() constant returns (uint supply) { return _supply; } function balanceOf( address who ) constant returns (uint value) { return _balances[who]; } function allowance(address owner, address spender) constant returns (uint _allowance) { return _approvals[owner][spender]; } function safeToAdd(uint a, uint b) private constant returns (bool) { return (a + b >= a && a + b >= b); } function safeToMultiply(uint _a, uint _b) private constant returns (bool) { return (_b == 0 || ((_a * _b) / _b) == _a); } function safeToSub(uint a, uint b) private constant returns (bool) { return (a >= b); } function transfer( address to, uint value) checkTransferStop onlyPayloadSize(2 * 32) returns (bool ok) { if( _balances[msg.sender] < value ) { throw; } if( !safeToAdd(_balances[to], value) ) { throw; } _balances[msg.sender] -= value; _balances[to] += value; Transfer( msg.sender, to, value ); return true; } function transferFrom( address from, address to, uint value) checkTransferStop returns (bool ok) { if( _balances[from] < value ) { throw; } if( _approvals[from][msg.sender] < value ) { throw; } if( !safeToAdd(_balances[to], value) ) { throw; } _approvals[from][msg.sender] -= value; _balances[from] -= value; _balances[to] += value; Transfer( from, to, value ); return true; } function approve(address spender, uint value) checkTransferStop returns (bool ok) { if ((value!=0) && (_approvals[msg.sender][spender] !=0)) throw; _approvals[msg.sender][spender] = value; Approval( msg.sender, spender, value ); return true; } function currentSwapRate() constant returns(uint) { uint presalePeriod = 3 days; if (creationTime + presalePeriod > now) { return 140; } else if (creationTime + presalePeriod + 3 weeks > now) { return 120; } else if (creationTime + presalePeriod + 6 weeks + 6 days + 3 hours + 1 days > now) { return 100; } else { return 0; } } function mintTokens(address newTokenHolder, uint etherAmount) external onlyFromWallet { if (!safeToMultiply(currentSwapRate(), etherAmount)) throw; uint tokensAmount = currentSwapRate() * etherAmount; if(!safeToAdd(_balances[newTokenHolder],tokensAmount )) throw; if(!safeToAdd(_supply,tokensAmount)) throw; if ((_supply + tokensAmount) > tokenCap) throw; _balances[newTokenHolder] += tokensAmount; _supply += tokensAmount; TokenMint(newTokenHolder, tokensAmount); } function mintReserve(address beneficiary) external onlyFromWallet { if (tokenCap <= _supply) throw; if(!safeToSub(tokenCap,_supply)) throw; uint tokensAmount = tokenCap - _supply; if(!safeToAdd(_balances[beneficiary], tokensAmount )) throw; if(!safeToAdd(_supply,tokensAmount)) throw; _balances[beneficiary] += tokensAmount; _supply += tokensAmount; TokenMint(beneficiary, tokensAmount); } function disableTokenSwapLock() external onlyFromWallet { transferStop = false; TokenSwapOver(); } function stopToken() onlyFromWallet { transferStop = true; EmergencyStopActivated(); } } The standard Wallet contract, retrievable at modified to include additional functionality, in particular: all the changes: - Functions for starting and stopping the tokenswap - A set-only-once function for the token contract - buyTokens(), which calls mintTokens() in the token contract - Modifiers for enforcing tokenswap time limits, max ether cap, and max token cap - withdrawEther(), for withdrawing unsold tokens after time cap contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (_value == 0) return false; if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract tokenswap is multisig, multiowned { Token public tokenCtr; bool public tokenSwap; uint public constant PRESALE_LENGTH = 3 days; uint public constant SWAP_LENGTH = PRESALE_LENGTH + 6 weeks + 6 days + 3 hours; uint public amountRaised; modifier isUnderPresaleMinimum { if (tokenCtr.creationTime() + PRESALE_LENGTH > now) { if (msg.value < 20 ether) throw; } _; } modifier isZeroValue { if (msg.value == 0) throw; _; } modifier isOverCap { if (amountRaised + msg.value > MAX_ETH) throw; _; } modifier isOverTokenCap { if (!safeToMultiply(tokenCtr.currentSwapRate(), msg.value)) throw; uint tokensAmount = tokenCtr.currentSwapRate() * msg.value; if(!safeToAdd(tokenCtr.totalSupply(),tokensAmount)) throw; if (tokenCtr.totalSupply() + tokensAmount > tokenCtr.tokenCap()) throw; _; } modifier isSwapStopped { if (!tokenSwap) throw; _; } modifier areConditionsSatisfied { _; if (tokenCtr.creationTime() + SWAP_LENGTH < now) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } if (amountRaised == MAX_ETH) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } if (tokenCtr.totalSupply() == tokenCtr.tokenCap()) { tokenCtr.disableTokenSwapLock(); tokenSwap = false; } } function safeToAdd(uint a, uint b) private constant returns (bool) { return (a + b >= a && a + b >= b); } function safeToMultiply(uint _a, uint _b) private constant returns (bool) { return (_b == 0 || ((_a * _b) / _b) == _a); } function startTokenSwap() onlyowner { tokenSwap = true; } function stopTokenSwap() onlyowner { tokenSwap = false; } function setTokenContract(address newTokenContractAddr) onlyowner { if (newTokenContractAddr == address(0x0)) throw; if (tokenCtr != address(0x0)) throw; tokenCtr = Token(newTokenContractAddr); } function buyTokens(address _beneficiary) payable isUnderPresaleMinimum isZeroValue isOverCap isOverTokenCap isSwapStopped areConditionsSatisfied { Deposit(msg.sender, msg.value); tokenCtr.mintTokens(_beneficiary, msg.value); if (!safeToAdd(amountRaised, msg.value)) throw; amountRaised += msg.value; } function withdrawReserve(address _beneficiary) onlyowner { if (tokenCtr.creationTime() + SWAP_LENGTH < now) { tokenCtr.mintReserve(_beneficiary); } } } contract Wallet is multisig, multiowned, daylimit, tokenswap { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { if (tokenSwap) throw; if (tokenCtr.transferStop() == false) throw; suicide(_to); } function stopToken() onlymanyowners(sha3(msg.data)) external { tokenCtr.stopToken(); } function() payable { buyTokens(msg.sender); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (_to == address(tokenCtr)) throw; if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); if(!_to.call.value(_value)(_data)) return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { throw; MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "39316_1.sol", "label": 1, "sol content": "contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract Wallet is multisig, multiowned, daylimit { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { suicide(_to); } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
