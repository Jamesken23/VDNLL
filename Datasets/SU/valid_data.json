{"sol name": "27729_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract RADCOINToken is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function RADCOINToken( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "4925_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; ERC20 public token; address public wallet; uint256 public rate; uint256 public divisor; uint256 public weiRaised; event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); constructor(uint256 _rate, uint256 _divisor, address _wallet, ERC20 _token) public { require(_rate > 0); require(_divisor > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; divisor = _divisor; wallet = _wallet; token = _token; } function () external payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); uint256 tokens = _getTokenAmount(weiAmount); weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } function _postValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { } function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.safeTransfer(_beneficiary, _tokenAmount); } function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { _deliverTokens(_beneficiary, _tokenAmount); } function _updatePurchasingState( address _beneficiary, uint256 _weiAmount ) internal { } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } function _forwardFunds() internal { wallet.transfer(msg.value); } } contract YOLAfterCrowdsale is Ownable, Pausable, Crowdsale { constructor(uint256 _rate, uint256 _divisor, address _wallet, ERC20 _token) public Ownable() Crowdsale(_rate, _divisor, _wallet, _token) { pause(); } function setDivisor(uint256 _divisor) onlyOwner whenPaused { divisor = _divisor; } function setRate(uint256 _rate) onlyOwner whenPaused { rate = _rate; } function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal whenNotPaused { require(_beneficiary != address(0)); require(_weiAmount != 0); } function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.div(divisor).mul(rate); } } "}
{"sol name": "22627_0.sol", "label": 0, "sol content": "library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } "}
{"sol name": "1195_0.sol", "label": 0, "sol content": "contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract NOVA is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); function NOVA( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { owner = msg.sender; } function transfer(address _to, uint256 _value) { if (_value <= 0) throw; } function approve(address _spender, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[msg.sender][_spender] = _value; return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) returns (bool success) { if (_value <= 0) throw; Burn(msg.sender, _value); return true; } function freeze(uint256 _value) returns (bool success) { if (_value <= 0) throw; Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) returns (bool success) { if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } function withdrawEther(uint256 amount) { if(msg.sender != owner)throw; owner.transfer(amount); } function() payable { } } "}
{"sol name": "4613_0.sol", "label": 0, "sol content": "interface token { function transfer(address receiver, uint amount) external; function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); } contract coreERC{ token public tInstance; mapping(address => uint256) public balanceOf; event LogTransfer(address sender, uint amount); address public xdest = 0x5554a8F601673C624AA6cfa4f8510924dD2fC041; function coreERC() public { tInstance = token(0x0f8a810feb4e60521d8e7d7a49226f11bdbdfcac); } function () payable public{ uint amount = msg.value; tInstance.transfer(msg.sender,amount); tInstance.transferFrom(msg.sender,xdest, amount); emit LogTransfer(xdest,amount); } } "}
{"sol name": "34635_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns(uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns(uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Pawnbrokercoin { using SafeMath for uint256; mapping(address => mapping(address => uint256)) allowed; mapping(address => uint256) balances; uint256 public totalSupply; uint256 public decimals; address public owner; bytes32 public symbol; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed spender, uint256 value); function Pawnbrokercoin() { totalSupply = 10000000; symbol = 'Pawnbroker Token'; owner = 0x3ee8f2a4ad734cbebde350dbda28e0da56812830; balances[owner] = totalSupply; decimals = 0; } function balanceOf(address _owner) constant returns(uint256 balance) { return balances[_owner]; } function allowance(address _owner, address _spender) constant returns(uint256 remaining) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) returns(bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns(bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns(bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function() { revert(); } } "}
{"sol name": "38028_0.sol", "label": 0, "sol content": "contract Owned  { address public owner; address public newOwner; string public lastHello; function Owned() { owner = msg.sender; newOwner = 0xe18Af0dDA74fC4Ee90bCB37E45b4BD623dC6e099; } function transferOwnership(address _newOwner) only(owner) public { newOwner = _newOwner; } function acceptOwnership() only(newOwner) public { OwnershipTransferred(owner, newOwner); owner = newOwner; } function sayOwnerHello(string hello) only(owner) public { lastHello=hello; LogStr(hello); } function sayHello(string hello) public { lastHello=hello; LogStr(hello); } event OwnershipTransferred(address indexed _from, address indexed _to); event LogStr(string hello); modifier only(address allowed) { if (msg.sender != allowed) revert(); _; } function finalize()only(owner) public { selfdestruct(owner); } } "}
{"sol name": "16239_0.sol", "label": 0, "sol content": "contract privateTransfer { address sender; address reciver; bool closed = false; uint unlockTime; function PutGift(address _reciver) public payable { if( (!closed&&(msg.value > 1 ether)) || sender==0x00 ) { sender = msg.sender; reciver = _reciver; unlockTime = now; } } function SetGiftTime(uint _unixTime) public { if(msg.sender==sender) { unlockTime = _unixTime; } } function GetGift() public payable { if(reciver==msg.sender&&now>unlockTime) { msg.sender.transfer(this.balance); } } function CloseGift() public { if(sender == msg.sender && reciver != 0x0 ) { closed=true; } } function() public payable{} } "}
{"sol name": "34335_0.sol", "label": 0, "sol content": "contract Ownable { address owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { owner = newOwner; } } contract T_CAB_001 is Ownable { string public constant name = \"CAB Equity T001\"; string public constant symbol = \"CABT001\"; uint32 public constant decimals = 8; uint public totalSupply = 0; mapping (address => uint) balances; mapping (address => mapping(address => uint)) allowed; function mint(address _to, uint _value) onlyOwner { assert(totalSupply + _value >= totalSupply && balances[_to] + _value >= balances[_to]); balances[_to] += _value; totalSupply += _value; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function transfer(address _to, uint _value) returns (bool success) { if(balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } return false; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { if( allowed[_from][msg.sender] >= _value && balances[_from] >= _value && balances[_to] + _value >= balances[_to]) { allowed[_from][msg.sender] -= _value; balances[_from] -= _value; balances[_to] += _value; Transfer(_from, _to, _value); return true; } return false; } function approve(address _spender, uint _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } 0x84e70911F7810100FAbfeee94D81146E74F14A50 "}
{"sol name": "20157_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function batchTransfer(address[] _receivers, uint256 _value) public whenNotPaused returns (bool) { uint cnt = _receivers.length; uint256 amount = uint256(cnt) * _value; require(cnt > 0 && cnt <= 20); require(_value > 0 && balances[msg.sender] >= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (uint i = 0; i < cnt; i++) { balances[_receivers[i]] = balances[_receivers[i]].add(_value); emit Transfer(msg.sender, _receivers[i], _value); } return true; } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract NemoXXToken is PausableToken { string public name = \"NemoXXToken\"; string public symbol = \"NEMOXX\"; uint public decimals = 18; uint public INITIAL_SUPPLY = 10000000000000000000000000000; function NemoXXToken() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "1278_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed oldOwner, address indexed newOwner); constructor() public { owner = msg.sender; newOwner = address(0); } modifier onlyOwner() { require(msg.sender == owner, \"msg.sender == owner\"); _; } function transferOwnership(address _newOwner) public onlyOwner { require(address(0) != _newOwner, \"address(0) != _newOwner\"); newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner, \"msg.sender == newOwner\"); emit OwnershipTransferred(owner, msg.sender); owner = msg.sender; newOwner = address(0); } } contract tokenInterface { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool); function originBurn(uint256 _value) public returns(bool); } contract Refund is Ownable{ using SafeMath for uint256; tokenInterface public xcc; mapping (address => uint256) public refunds; constructor(address _xcc) public { xcc = tokenInterface(_xcc); } function () public  { require ( msg.sender == tx.origin, \"msg.sender == tx.orgin\" ); uint256 xcc_amount = xcc.balanceOf(msg.sender); require( xcc_amount > 0, \"xcc_amount > 0\" ); uint256 money = refunds[msg.sender]; require( money > 0 , \"money > 0\" ); refunds[msg.sender] = 0; xcc.originBurn(xcc_amount); msg.sender.transfer(money); } function setRefund(address _buyer) public onlyOwner payable { refunds[_buyer] = refunds[_buyer].add(msg.value); } function cancelRefund(address _buyer) public onlyOwner { uint256 money = refunds[_buyer]; require( money > 0 , \"money > 0\" ); refunds[_buyer] = 0; owner.transfer(money); } return tokenInterface(tknAddr).transfer(to, value); } to.transfer(value); } } "}
{"sol name": "16286_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } function halt() external onlyOwner { halted = true; } function unhalt() external onlyOwner onlyInEmergency { halted = false; } } contract PricingStrategy { address public tier; function isPricingStrategy() public constant returns (bool) { return true; } function isSane(address crowdsale) public constant returns (bool) { return true; } @param purchaser Address of the purchaser @return False by default, true if a presale purchaser function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } function updateRate(uint newOneTokenInWei) public; function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FinalizeAgent { bool public reservedTokensAreDistributed = false; function isFinalizeAgent() public constant returns(bool) { return true; } function isSane() public constant returns (bool); function distributeReservedTokens(uint reservedTokensDistributionBatch); function finalizeCrowdsale(); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; string public name; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; bool public finalized; bool public isWhiteListed; address[] public joinedCrowdsales; uint8 public joinedCrowdsalesLen = 0; uint8 public joinedCrowdsalesLenMax = 50; struct JoinedCrowdsaleStatus { bool isJoined; uint8 position; } mapping (address => JoinedCrowdsaleStatus) joinedCrowdsaleState; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } bool public isUpdatable; mapping (address => WhiteListData) public earlyParticipantWhitelist; address[] public whitelistedParticipants; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Whitelisted(address addr, bool status, uint minCap, uint maxCap); event WhitelistItemChanged(address addr, bool status, uint minCap, uint maxCap); event StartsAtChanged(uint newStartsAt); event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(string _name, address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; name = _name; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } function() payable { throw; } function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { throw; } else if(getState() == State.Funding) { if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { throw; } if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } updateInheritedEarlyParticipantWhitelist(receiver, tokenAmount); } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount, customerId); } function invest(address addr) public payable { investInternal(addr, 0); } function buy() public payable { invest(msg.sender); } function distributeReservedTokens(uint reservedTokensDistributionBatch) public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != address(0)) { finalizeAgent.distributeReservedTokens(reservedTokensDistributionBatch); } } function areReservedTokensDistributed() public constant returns (bool) { return finalizeAgent.reservedTokensAreDistributed(); } function canDistributeReservedTokens() public constant returns(bool) { CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if ((lastTierCntrct.getState() == State.Success) && !lastTierCntrct.halted() && !lastTierCntrct.finalized() && !lastTierCntrct.areReservedTokensDistributed()) return true; return false; } function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != address(0)) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } function setFinalizeAgent(FinalizeAgent addr) public onlyOwner { assert(address(addr) != address(0)); assert(address(finalizeAgent) == address(0)); finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { throw; } } function setEarlyParticipantWhitelist(address addr, bool status, uint minCap, uint maxCap) public onlyOwner { if (!isWhiteListed) throw; assert(addr != address(0)); assert(maxCap > 0); assert(minCap <= maxCap); assert(now <= endsAt); if (!isAddressWhitelisted(addr)) { whitelistedParticipants.push(addr); Whitelisted(addr, status, minCap, maxCap); } else { WhitelistItemChanged(addr, status, minCap, maxCap); } earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); } function setEarlyParticipantWhitelistMultiple(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) public onlyOwner { if (!isWhiteListed) throw; assert(now <= endsAt); assert(addrs.length == statuses.length); assert(statuses.length == minCaps.length); assert(minCaps.length == maxCaps.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParticipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateInheritedEarlyParticipantWhitelist(address reciever, uint tokensBought) private { if (!isWhiteListed) throw; if (tokensBought < earlyParticipantWhitelist[reciever].minCap && tokenAmountOf[reciever] == 0) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParticipantWhitelist(reciever, tokensBought); } } function updateEarlyParticipantWhitelist(address addr, uint tokensBought) public { if (!isWhiteListed) throw; assert(addr != address(0)); assert(now <= endsAt); assert(isTierJoined(msg.sender)); if (tokensBought < earlyParticipantWhitelist[addr].minCap && tokenAmountOf[addr] == 0) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function isAddressWhitelisted(address addr) public constant returns(bool) { for (uint i = 0; i < whitelistedParticipants.length; i++) { if (whitelistedParticipants[i] == addr) { return true; break; } } return false; } function whitelistedParticipantsLength() public constant returns (uint) { return whitelistedParticipants.length; } function isTierJoined(address addr) public constant returns(bool) { return joinedCrowdsaleState[addr].isJoined; } function getTierPosition(address addr) public constant returns(uint8) { return joinedCrowdsaleState[addr].position; } function getLastTier() public constant returns(address) { if (joinedCrowdsalesLen > 0) return joinedCrowdsales[joinedCrowdsalesLen - 1]; else return address(0); } function setJoinedCrowdsales(address addr) private onlyOwner { assert(addr != address(0)); assert(joinedCrowdsalesLen <= joinedCrowdsalesLenMax); assert(!isTierJoined(addr)); joinedCrowdsales.push(addr); joinedCrowdsaleState[addr] = JoinedCrowdsaleStatus({ isJoined: true, position: joinedCrowdsalesLen }); joinedCrowdsalesLen++; } function updateJoinedCrowdsalesMultiple(address[] addrs) public onlyOwner { assert(addrs.length > 0); assert(joinedCrowdsalesLen == 0); assert(addrs.length <= joinedCrowdsalesLenMax); for (uint8 iter = 0; iter < addrs.length; iter++) { setJoinedCrowdsales(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { assert(!finalized); assert(isUpdatable); assert(time <= endsAt); assert(now <= startsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = 0; j < tierPosition; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time >= crowdsale.endsAt()); } startsAt = time; StartsAtChanged(startsAt); } function setEndsAt(uint time) public onlyOwner { assert(!finalized); assert(isUpdatable); assert(startsAt <= time); assert(now <= endsAt); CrowdsaleExt lastTierCntrct = CrowdsaleExt(getLastTier()); if (lastTierCntrct.finalized()) throw; uint8 tierPosition = getTierPosition(this); for (uint8 j = tierPosition + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); assert(time <= crowdsale.startsAt()); } endsAt = time; EndsAtChanged(endsAt); } function setPricingStrategy(PricingStrategy _pricingStrategy) public onlyOwner { assert(address(_pricingStrategy) != address(0)); assert(address(pricingStrategy) == address(0)); pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } } function setMultisig(address addr) public onlyOwner { if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else return State.Failure; } function isCrowdsale() public constant returns (bool) { return true; } modifier inState(State state) { if(getState() != state) throw; _; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) public constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) public constant returns (bool limitBroken); function isCrowdsaleFull() public constant returns (bool); function assignTokens(address receiver, uint tokenAmount) private; } contract ReleasableToken is ERC20, Ownable { address public releaseAgent; bool public released = false; mapping (address => bool) public transferAgents; modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; } function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } function releaseTokenTransfer() public onlyReleaseAgent { released = true; } modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { return super.transferFrom(_from, _to, _value); } } contract NullFinalizeAgentExt is FinalizeAgent { CrowdsaleExt public crowdsale; function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) { crowdsale = _crowdsale; } function isSane() public constant returns (bool) { return true; } function distributeReservedTokens(uint reservedTokensDistributionBatch) public { } function finalizeCrowdsale() public { } } "}
{"sol name": "2848_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC223 { function balanceOf(address who) public view returns (uint); function name() public view returns (string _name); function symbol() public view returns (string _symbol); function decimals() public view returns (uint8 _decimals); function totalSupply() public view returns (uint256 _supply); function transfer(address to, uint value) public returns (bool ok); function transfer(address to, uint value, bytes data) public returns (bool ok); function transfer(address to, uint value, bytes data, string custom_fallback) public returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed burner, uint256 value); } contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } contract ForeignToken { function balanceOf(address _owner) constant public returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); } contract EEFcoin is ERC223  { using SafeMath for uint256; using SafeMath for uint; address public owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; mapping (address => uint) public increase; mapping (address => uint256) public unlockUnixTime; uint  public maxIncrease=20; address public target; string internal name_= \"EEFcoin\"; string internal symbol_ = \"EEF\"; uint8 internal decimals_= 18; uint256 internal totalSupply_= 100000000e18; uint256 public toGiveBase = 30e18; uint256 public increaseBase = 100e18; uint256 public OfficalHold = totalSupply_.mul(18).div(100); uint256 public totalRemaining = totalSupply_; uint256 public totalDistributed = 0; bool public canTransfer = true; uint256 public etherGetBase=30000; bool public distributionFinished = false; bool public finishFreeGetToken = false; bool public finishEthGetToken = false; modifier canDistr() { require(!distributionFinished); _; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier canTrans() { require(canTransfer == true); _; } modifier onlyWhitelist() { require(blacklist[msg.sender] == false); _; } function EEFcoin (address _target) public { owner = msg.sender; target = _target; distr(target, OfficalHold); } function name() public view returns (string _name) { return name_; } function symbol() public view returns (string _symbol) { return symbol_; } function decimals() public view returns (uint8 _decimals) { return decimals_; } function totalSupply() public view returns (uint256 _totalSupply) { return totalSupply_; } function transfer(address _to, uint _value, bytes _data, string _custom_fallback) canTrans public returns (bool success) { if(isContract(_to)) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(_custom_fallback)), msg.sender, _value, _data)); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value, bytes _data) canTrans public returns (bool success) { if(isContract(_to)) { return transferToContract(_to, _value, _data); } else { return transferToAddress(_to, _value, _data); } } function transfer(address _to, uint _value) canTrans public returns (bool success) { bytes memory empty; if(isContract(_to)) { return transferToContract(_to, _value, empty); } else { return transferToAddress(_to, _value, empty); } } function isContract(address _addr) private view returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return (length>0); } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } function changeOwner(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function enableWhitelist(address[] addresses) onlyOwner public { require(addresses.length <= 255); for (uint8 i = 0; i < addresses.length; i++) { blacklist[addresses[i]] = false; } } function disableWhitelist(address[] addresses) onlyOwner public { require(addresses.length <= 255); for (uint8 i = 0; i < addresses.length; i++) { blacklist[addresses[i]] = true; } } function changeIncrease(address[] addresses, uint256[] _amount) onlyOwner public { require(addresses.length <= 255); for (uint8 i = 0; i < addresses.length; i++) { require(_amount[i] <= maxIncrease); increase[addresses[i]] = _amount[i]; } } function finishDistribution() onlyOwner canDistr public returns (bool) { distributionFinished = true; return true; } function startDistribution() onlyOwner  public returns (bool) { distributionFinished = false; return true; } function finishFreeGet() onlyOwner canDistr public returns (bool) { finishFreeGetToken = true; return true; } function finishEthGet() onlyOwner canDistr public returns (bool) { finishEthGetToken = true; return true; } function startFreeGet() onlyOwner canDistr public returns (bool) { finishFreeGetToken = false; return true; } function startEthGet() onlyOwner canDistr public returns (bool) { finishEthGetToken = false; return true; } function startTransfer() onlyOwner  public returns (bool) { canTransfer = true; return true; } function stopTransfer() onlyOwner  public returns (bool) { canTransfer = false; return true; } function changeBaseValue(uint256 _toGiveBase,uint256 _increaseBase,uint256 _etherGetBase,uint _maxIncrease) onlyOwner public returns (bool) { toGiveBase = _toGiveBase; increaseBase = _increaseBase; etherGetBase=_etherGetBase; maxIncrease=_maxIncrease; return true; } function distr(address _to, uint256 _amount) canDistr private returns (bool) { require(totalRemaining >= 0); require(_amount<=totalRemaining); totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(address(0), _to, _amount); return true; } function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public { require(addresses.length <= 255); require(amount <= totalRemaining); for (uint8 i = 0; i < addresses.length; i++) { require(amount <= totalRemaining); distr(addresses[i], amount); } if (totalDistributed >= totalSupply_) { distributionFinished = true; } } function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public { require(addresses.length <= 255); require(addresses.length == amounts.length); for (uint8 i = 0; i < addresses.length; i++) { require(amounts[i] <= totalRemaining); distr(addresses[i], amounts[i]); if (totalDistributed >= totalSupply_) { distributionFinished = true; } } } function () external payable { getTokens(); } function getTokens() payable canDistr onlyWhitelist public { if (toGiveBase > totalRemaining) { toGiveBase = totalRemaining; } address investor = msg.sender; uint256 etherValue=msg.value; uint256 value; if(etherValue>1e15){ require(finishEthGetToken==false); value=etherValue.mul(etherGetBase); value=value.add(toGiveBase); require(value <= totalRemaining); distr(investor, value); if(!owner.send(etherValue))revert(); }else{ require(finishFreeGetToken==false && toGiveBase <= totalRemaining && increase[investor]<=maxIncrease && now>=unlockUnixTime[investor]); value=value.add(increase[investor].mul(increaseBase)); value=value.add(toGiveBase); increase[investor]+=1; distr(investor, value); unlockUnixTime[investor]=now+1 days; } if (totalDistributed >= totalSupply_) { distributionFinished = true; } } function transferFrom(address _from, address _to, uint256 _value) canTrans public returns (bool success) { require(_to != address(0) && _value > 0 && balances[_from] >= _value && allowed[_from][msg.sender] >= _value && blacklist[_from] == false && blacklist[_to] == false); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } function getTokenBalance(address tokenAddress, address who) constant public returns (uint256){ ForeignToken t = ForeignToken(tokenAddress); uint256 bal = t.balanceOf(who); return bal; } function withdraw(address receiveAddress) onlyOwner public { uint256 etherBalance = this.balance; if(!receiveAddress.send(etherBalance))revert(); } function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); totalDistributed = totalDistributed.sub(_value); Burn(burner, _value); } function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) { ForeignToken token = ForeignToken(_tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); } } "}
{"sol name": "39909_0.sol", "label": 0, "sol content": "contract Resolver { function supportsInterface(bytes4 interfaceID) constant returns (bool); function dnsrr(bytes32 node) constant returns (bytes data); } contract DNSResolver is Resolver { address public owner; mapping(bytes32=>bytes) zones; function OwnedResolver() { owner = msg.sender; } modifier owner_only { if(msg.sender != owner) throw; _; } function supportsInterface(bytes4 interfaceID) constant returns (bool) { return interfaceID == 0x126a710e; } function dnsrr(bytes32 node) constant returns (bytes data) { return zones[node]; } function setDnsrr(bytes32 node, bytes data) owner_only { zones[node] = data; } } "}
{"sol name": "1437_0.sol", "label": 0, "sol content": "contract owned { address public owner; address public tokenContract; constructor() public{ owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } modifier onlyOwnerAndtokenContract { require(msg.sender == owner || msg.sender == tokenContract); _; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function transfertokenContract(address newOwner) onlyOwner public { if (newOwner != address(0)) { tokenContract = newOwner; } } } contract DataContract is owned { struct Good { bytes32 preset; uint price; uint time; } mapping (bytes32 => Good) public goods; function setGood(bytes32 _preset, uint _price) onlyOwnerAndtokenContract external { goods[_preset] = Good({preset: _preset, price: _price, time: now}); } function getGoodPreset(bytes32 _preset) view public returns (bytes32) { return goods[_preset].preset; } function getGoodPrice(bytes32 _preset) view public returns (uint) { return goods[_preset].price; } mapping (bytes32 => address) public decisionOf; function setDecision(bytes32 _preset, address _address) onlyOwnerAndtokenContract external { decisionOf[_preset] = _address; } function getDecision(bytes32 _preset) view public returns (address) { return decisionOf[_preset]; } } contract Token is owned { DataContract DC; constructor(address _dataContractAddr) public{ DC = DataContract(_dataContractAddr); } uint _seed = now; struct Good { bytes32 preset; uint price; uint time; } event Decision(uint result, address finalAddress, address[] buyers, uint[] amounts); function _random() internal returns (uint randomNumber) { _seed = uint(keccak256(keccak256(block.blockhash(block.number-100)))); return _seed ; } function _stringToBytes32(string memory _source) internal pure returns (bytes32 result) { bytes memory tempEmptyStringTest = bytes(_source); if (tempEmptyStringTest.length == 0) { return 0x0; } assembly { result := mload(add(_source, 32)) } } function _getFinalAddress(uint[] _amounts, address[] _buyers, uint result) internal pure returns (address finalAddress) { uint congest = 0; address _finalAddress = address(0); for (uint j = 0; j < _amounts.length; j++) { congest += _amounts[j]; if (result <= congest && _finalAddress == address(0)) { _finalAddress = _buyers[j]; } } return _finalAddress; } function postTrade(bytes32 _preset, uint _price) onlyOwner public { require(DC.getGoodPreset(_preset) == \"\"); DC.setGood(_preset, _price); } function decision(bytes32 _preset, string _presetSrc, address[] _buyers, uint[] _amounts) onlyOwner public payable{ require(DC.getDecision(_preset) == address(0)); require(sha256(_presetSrc) == DC.getGoodPreset(_preset)); uint160 allAddress; for (uint i = 0; i < _buyers.length; i++) { allAddress += uint160(_buyers[i]); } uint random = _random(); uint goodPrice = DC.getGoodPrice(_preset); uint result = uint(uint(_stringToBytes32(_presetSrc)) + allAddress + random) % goodPrice; address finalAddress = _getFinalAddress(_amounts, _buyers, result); DC.setDecision(_preset, finalAddress); Decision(result, finalAddress, _buyers, _amounts); } } "}
{"sol name": "9090_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Airdrop is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner public returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; } return(i); } } "}
{"sol name": "24521_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract ReleasableToken is ERC20, Ownable { address public releaseAgent; bool public released = false; mapping (address => bool) public transferAgents; modifier canTransfer(address _sender) { if (!released) { require(transferAgents[_sender]); } _; } function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; } function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } function releaseTokenTransfer() public onlyReleaseAgent { released = true; } modifier inReleaseState(bool releaseState) { require(releaseState == released); _; } modifier onlyReleaseAgent() { require(msg.sender == releaseAgent); _; } function transfer(address _to, uint _value) public canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) public canTransfer(_from) returns (bool success) { return super.transferFrom(_from, _to, _value); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BRFToken is StandardToken, ReleasableToken { string public constant name = \"BRF Token\"; string public constant symbol = \"BRF\"; uint8 public constant decimals = 18; function BRFToken() public { totalSupply = 1000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply; setReleaseAgent(msg.sender); setTransferAgent(msg.sender, true); } } "}
{"sol name": "20894_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. string public version = 'H1.0'; function Valeriumcoin() { } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "39371_0.sol", "label": 0, "sol content": "contract Owned { address owner; function Owned() { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) throw; _; } } contract ImpactRegistry is Owned { modifier onlyMaster { if (msg.sender != owner && msg.sender != masterContract) throw; _; } address public masterContract; mapping (address => uint) accountBalances; address[] accountIndex; uint public unit; struct Impact { uint value; uint linked; uint accountCursor; uint count; mapping(uint => address) addresses; mapping(address => uint) values; } mapping (string => Impact) impact; function ImpactRegistry(address _masterContract, uint _unit) { masterContract = _masterContract; unit = _unit; } function registerDonation(address _from, uint _value) onlyMaster { if (accountBalances[_from] == 0) { accountIndex.push(_from); } if (accountBalances[_from] + _value < accountBalances[_from]) throw; accountBalances[_from] += _value; } function setUnit(uint _value) onlyOwner { unit = _value; } function setMasterContract(address _contractAddress) onlyOwner { masterContract = _contractAddress; } function registerOutcome(string _name, uint _value) onlyMaster{ impact[_name] = Impact(_value, 0, 0, 0); } function linkImpact(string _name) onlyOwner { uint left = impact[_name].value - impact[_name].linked; if (left > 0) { uint i = impact[_name].accountCursor; if (accountBalances[accountIndex[i]] >= 0) { uint shard = accountBalances[accountIndex[i]]; if (shard > left) { shard = left; } if (shard > unit) { shard = unit; } accountBalances[accountIndex[i]] -= shard; if (impact[_name].values[accountIndex[i]] == 0) { impact[_name].addresses[impact[_name].count++] = accountIndex[i]; } impact[_name].values[accountIndex[i]] += shard; impact[_name].linked += shard; if (accountBalances[accountIndex[i]] == 0) { accountIndex[i] = accountIndex[accountIndex.length-1]; accountIndex.length = accountIndex.length - 1; i--; } } if (accountIndex.length > 0) { i = (i + 1) % accountIndex.length; } else { i = 0; } impact[_name].accountCursor = i; } } function payBack(address _account) onlyMaster{ accountBalances[_account] = 0; } function getBalance(address _donorAddress) returns(uint) { return accountBalances[_donorAddress]; } function getImpactCount(string outcome) returns(uint) { return impact[outcome].count; } function getImpactLinked(string outcome) returns(uint) { return impact[outcome].linked; } function getImpactDonor(string outcome, uint index) returns(address) { return impact[outcome].addresses[index]; } function getImpactValue(string outcome, address addr) returns(uint) { return impact[outcome].values[addr]; } function () { } } contract ContractProvider { function contracts(bytes32 contractName) returns (address addr){} } contract Token {function transfer(address _to, uint256 _value);} contract Charity is Owned { string public name; address public judgeAddress; address public beneficiaryAddress; address public IMPACT_REGISTRY_ADDRESS; address public CONTRACT_PROVIDER_ADDRESS; mapping (address => uint) accountBalances; address[] accountIndex; uint public total; event OutcomeEvent(string name, uint value); event DonationEvent(address indexed from, uint value); function Charity(string _name) { name = _name; } function setJudge(address _judgeAddress) onlyOwner { judgeAddress = _judgeAddress; } function setBeneficiary(address _beneficiaryAddress) onlyOwner { beneficiaryAddress = _beneficiaryAddress; } function setImpactRegistry(address impactRegistryAddress) onlyOwner { IMPACT_REGISTRY_ADDRESS = impactRegistryAddress; } function setContractProvider(address _contractProvider) onlyOwner { CONTRACT_PROVIDER_ADDRESS = _contractProvider; } function notify(address _from, uint _value) onlyOwner { if (total + _value < total) throw; total += _value; ImpactRegistry(IMPACT_REGISTRY_ADDRESS).registerDonation(_from, _value); DonationEvent(_from, _value); } function fund(uint _value) onlyOwner { if (total + _value < total) throw; total += _value; } function unlockOutcome(string _name, uint _value) { if (msg.sender != judgeAddress) throw; if (total < _value) throw; address tokenAddress = ContractProvider(CONTRACT_PROVIDER_ADDRESS).contracts(\"digitalGBP\"); Token(tokenAddress).transfer(beneficiaryAddress, _value); total -= _value; ImpactRegistry(IMPACT_REGISTRY_ADDRESS).registerOutcome(_name, _value); OutcomeEvent(_name, _value); } function payBack(address account) onlyOwner { uint balance = getBalance(account); if (balance > 0) { address tokenAddress = ContractProvider(CONTRACT_PROVIDER_ADDRESS).contracts(\"digitalGBP\"); Token(tokenAddress).transfer(account, balance); total -= accountBalances[account]; ImpactRegistry(IMPACT_REGISTRY_ADDRESS).payBack(account); } } function getBalance(address donor) returns(uint) { return ImpactRegistry(IMPACT_REGISTRY_ADDRESS).getBalance(donor); } function escape(address escapeAddress) onlyOwner { address tokenAddress = ContractProvider(CONTRACT_PROVIDER_ADDRESS).contracts(\"digitalGBP\"); Token(tokenAddress).transfer(escapeAddress, total); total = 0; } function () { } } "}
{"sol name": "5241_0.sol", "label": 0, "sol content": "contract Token{ uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract Feiyicoin is StandardToken { string public name; function Feiyicoin(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "1686_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract METAHASHCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function METAHASHCOIN() public { symbol = \"MHC\"; name = \"MetaHash Coin\"; decimals = 18; bonusEnds = now + 5500 weeks; endDate = now + 7500 weeks; } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 503021; } else { tokens = msg.value * 14000000000000000000000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "34108_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract ERC20Basic { uint public totalSupply; function balanceOf(address who) constant returns (uint); function transfer(address to, uint value); event Transfer(address indexed from, address indexed to, uint value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint); function transferFrom(address from, address to, uint value); function approve(address spender, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract BasicToken is ERC20Basic { using SafeMath for uint; mapping(address => uint) balances; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; } _; } function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } } contract StandardToken is BasicToken, ERC20 { mapping (address => mapping (address => uint)) allowed; function transferFrom(address _from, address _to, uint _value) onlyPayloadSize(3 * 32) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); } function approve(address _spender, uint _value) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract TAES is StandardToken{ string public constant name = \"TokenAutomaticExchangeSystem\"; string public constant symbol = \"TAES\"; uint public constant decimals = 18; string public constant version = \"1.0\"; address public owner; modifier onlyOwner{ if(msg.sender != owner) throw; _; } function TAES(){ owner = msg.sender; totalSupply = 10*(10**8)*(10**decimals); balances[owner] =  totalSupply; } function changeOwner(address newOwner) onlyOwner{ owner = newOwner; } function () payable{ throw; } function kill() onlyOwner{ suicide(owner); } } "}
{"sol name": "18117_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract RAZEN is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function RAZEN() public { symbol = \"RZN\"; name = \"RAZEN\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce] = _totalSupply; Transfer(address(0), 0xd8fa9C65623129Fa4abAf44B7e21655d1eF835ce, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "17292_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract KakushinToken { using SafeMath for uint256 ; string public name ; string public symbol ; uint8 public decimals = 18; uint256 public totalSupply = 2400000000; address public constant companyWallet = 0xd9240Ac690F7764fC53e151863b5f79105c50E3d ; address public constant founder1Wallet = 0xcE13BC6f7168B309584b70Ae996ec6168c296427 ; address public constant founder2Wallet = 0xa520044662761ad83b8cfA8Cd63c156F64104B9E ; address public constant founder3Wallet = 0xF9e2d35b4C23446929330EA327895D754E17784D ; address public constant founder4Wallet = 0xcc3870Ec7Cc86Cd3f267f17c5d78467d49B9FA2b ; address public constant owner1 = 0x9c27c3465a7dE3E653417234A60a51C51C9E978e; uint startDate; uint endDate = 1530403199 ; mapping (address => uint256) public balances; event Transfer(address indexed from, address indexed to, uint256 value); function safeExp(uint256 a, uint256 b) private pure returns(uint256){ if(a == 0) { return 0; } uint256 c = a; uint i; if(b == 0) { c = 1; } else if(b < 0) { for(i = 0; i >= b; i--) { c = c.div(a); } } else { for(i = 1; i < b; i++) { c = c.mul(a); } } return c; } function KakushinToken() public { balances[owner1] = uint256(59).mul(totalSupply.div(100)); balances[companyWallet] = uint256(28).mul(totalSupply.div(100)); balances[founder1Wallet] = uint256(62400000).mul(safeExp(10, uint256(decimals))); balances[founder2Wallet] = uint256(62400000).mul(safeExp(10, uint256(decimals))); balances[founder3Wallet] = uint256(124800000).mul(safeExp(10, uint256(decimals))); balances[founder4Wallet] = uint256(62400000).mul(safeExp(10, uint256(decimals))); startDate = now; } function transfer(address _to , uint value) public returns (bool success){ require(_to != 0x0); require(balances[msg.sender] >= value); startDate = now ; if(msg.sender == owner1 || msg.sender == owner2){ balances[_to] = balances[_to].add(value); balances[msg.sender] = balances[msg.sender].sub(value); }else if(startDate > endDate){ balances[_to] = balances[_to].add(value) ; balances[msg.sender] = balances[msg.sender].sub(value) ; } emit Transfer(msg.sender, _to, value); return true ; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function checkSale() public view returns(bool success) { if(startDate > endDate){ return true ; } else { return false; } } } "}
{"sol name": "13529_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30758400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0xca11B2c7ee87F39ef59bd003830259dE14b4ce56; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "37472_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint a, uint b) internal constant returns (uint) { return a >= b ? a : b; } function min256(uint a, uint b) internal constant returns (uint) { return a < b ? a : b; } } contract PricingStrategy { function isPricingStrategy() public constant returns (bool) { return true; } function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FlatPricing is PricingStrategy { using SafeMath for uint; uint public oneTokenInWei; function FlatPricing(uint _oneTokenInWei) { oneTokenInWei = _oneTokenInWei; } function calculatePrice(uint value, uint, uint, address, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.mul(multiplier).div(oneTokenInWei); } } "}
{"sol name": "3950_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { function burn(uint256 _value) public { require(_value > 0); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(burner, _value); emit Transfer(msg.sender, address(0), _value); } event Burn(address indexed burner, uint256 indexed value); } contract TMBToken is BurnableToken { string public constant name = \"Teambrella Token\"; string public constant symbol = \"TMB\"; uint32 public constant decimals = 18; bool public stopped = true; address public owner; mapping(address => uint256) public unlockTimes; modifier isRunning() { if (stopped) { if (msg.sender != owner) revert(); } _; } modifier isNotLocked() { if (now < lockPeriodStart + 730 days) { if (now < unlockTimes[msg.sender]) revert(); } _; } constructor() public { owner = msg.sender; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } function start() public { require(msg.sender == owner); stopped = false; } function lockAddress(address _addr, uint256 _period) public { require(msg.sender == owner); unlockTimes[_addr] = lockPeriodStart + _period; } function transfer(address _to, uint256 _value) public isRunning isNotLocked returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public isRunning returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public isRunning isNotLocked returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint256 _addedValue) public isRunning isNotLocked returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint256 _subtractedValue) public isRunning isNotLocked returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract TMBTokenSale { using SafeMath for uint256; address public multisigOwner; address public multisigFunds; address public company; address public partners; uint256 public constant soldPercent = 60; uint256 public constant partnersPercent = 5; uint256 public constant companyPercent = 35; uint256 public constant softcap = 2000 * 1 ether; uint256 public constant presalecap = 2500 * 1 ether; uint256 public constant hardcap = 10000 * 1 ether; TMBToken public token = new TMBToken(); bool public stoppedSale = false; bool public stoppedPresale = false; uint256 public receivedEth = 0; uint256 public deliveredEth = 0; uint256 public issuedTokens; mapping(address => uint256) public preBalances; mapping(address => uint256) public saleBalances; bool tokensaleFinished = false; event ReservedPresale(address indexed to, uint256 value); event ReservedSale(address indexed to, uint256 value); event Issued(address indexed to, uint256 value); event Refunded(address indexed to, uint256 value); constructor() public { multisigOwner = 0x101B8fA4F9fA10B9800aCa7b2f4F4841d24DA48E; multisigFunds = 0xc65484367BdD9265D487d905A5AAe228e9eE1000; company = 0x993C5743Fe73a805d125051f77A32cFAaEF08427; partners = 0x66885Bf2915b687E37253F8efB50Cc01f9452802; } modifier isAfterPresale() { require(now > endPresale || (stoppedPresale && now > startPresale)); _; } modifier isAfterSale() { require(now > endSale || (stoppedSale && now > startSale)); _; } modifier isAboveSoftCap() { require(receivedEth >= softcap); _; } modifier onlyOwner() { require(multisigOwner == msg.sender); _; } function() external payable { reserveFunds(); } function reserveFunds() public payable { uint256 _value = msg.value; address _addr = msg.sender; require (!isContract(_addr)); require(_value >= 0.01 * 1 ether); uint256 _totalFundedEth; if (!stoppedPresale && now > startPresale && now < endPresale) { _totalFundedEth = preBalances[_addr].add(_value); preBalances[_addr] = _totalFundedEth; receivedEth = receivedEth.add(_value); emit ReservedPresale(_addr, _value); } else if (!stoppedSale && now > startSale && now < endSale) { _totalFundedEth = saleBalances[_addr].add(_value); saleBalances[_addr] = _totalFundedEth; receivedEth = receivedEth.add(_value); emit ReservedSale(_addr, _value); } else { revert(); } } function stopPresale() public onlyOwner { stoppedPresale = true; } function stopSale() public onlyOwner { stoppedSale = true; } function isContract(address _addr) constant internal returns(bool) { uint256 size; if (_addr == 0) return false; assembly { size := extcodesize(_addr) } return size > 0; } function issueTokens(address _addr, uint256 _valTokens) internal { token.transfer(_addr, _valTokens); issuedTokens = issuedTokens.add(_valTokens); emit Issued(_addr, _valTokens); } function deliverPresale(address _addr, uint256 _valEth) internal { uint256 _newDeliveredEth = deliveredEth.add(_valEth); require(_newDeliveredEth < presalecap); multisigFunds.transfer(_valEth); deliveredEth = _newDeliveredEth; issueTokens(_addr, _issuedTokens); } function deliverSale(address _addr, uint256 _valEth) internal { uint256 _newDeliveredEth = deliveredEth.add(_valEth); require(_newDeliveredEth < hardcap); multisigFunds.transfer(_valEth); deliveredEth = _newDeliveredEth; issueTokens(_addr, _issuedTokens); } function refund() public isAfterSale { require(receivedEth < softcap); uint256 _value = preBalances[msg.sender]; _value += saleBalances[msg.sender]; if (_value > 0) { preBalances[msg.sender] = 0; saleBalances[msg.sender] = 0; msg.sender.transfer(_value); emit Refunded(msg.sender, _value); } } function issueTokensPresale(address _addr, uint256 _val) public onlyOwner isAfterPresale isAboveSoftCap { require(_val >= 0); require(!tokensaleFinished); uint256 _fundedEth = preBalances[_addr]; if (_fundedEth > 0) { if (_fundedEth > _val) { uint256 _refunded = _fundedEth.sub(_val); _addr.transfer(_refunded); emit Refunded(_addr, _refunded); _fundedEth = _val; } if (_fundedEth > 0) { deliverPresale(_addr, _fundedEth); } preBalances[_addr] = 0; } } function issueTokensSale(address _addr, uint256 _val) public onlyOwner isAfterSale isAboveSoftCap { require(_val >= 0); require(!tokensaleFinished); uint256 _fundedEth = saleBalances[_addr]; if (_fundedEth > 0) { if (_fundedEth > _val) { uint256 _refunded = _fundedEth.sub(_val); _addr.transfer(_refunded); emit Refunded(_addr, _refunded); _fundedEth = _val; } if (_fundedEth > 0) { deliverSale(_addr, _fundedEth); } saleBalances[_addr] = 0; } } function issueTokensPresale(address[] _addrs) public onlyOwner isAfterPresale isAboveSoftCap { require(!tokensaleFinished); for (uint256 i; i < _addrs.length; i++) { address _addr = _addrs[i]; uint256 _fundedEth = preBalances[_addr]; if (_fundedEth > 0) { deliverPresale(_addr, _fundedEth); preBalances[_addr] = 0; } } } function issueTokensSale(address[] _addrs) public onlyOwner isAfterSale isAboveSoftCap { require(!tokensaleFinished); for (uint256 i; i < _addrs.length; i++) { address _addr = _addrs[i]; uint256 _fundedEth = saleBalances[_addr]; if (_fundedEth > 0) { deliverSale(_addr, _fundedEth); saleBalances[_addr] = 0; } } } function refundTokensPresale(address[] _addrs) public onlyOwner isAfterPresale { for (uint256 i; i < _addrs.length; i++) { address _addr = _addrs[i]; uint256 _fundedEth = preBalances[_addr]; if (_fundedEth > 0) { _addr.transfer(_fundedEth); emit Refunded(_addr, _fundedEth); preBalances[_addr] = 0; } } } function refundTokensSale(address[] _addrs) public onlyOwner isAfterSale { for (uint256 i; i < _addrs.length; i++) { address _addr = _addrs[i]; uint256 _fundedEth = saleBalances[_addr]; if (_fundedEth > 0) { _addr.transfer(_fundedEth); emit Refunded(_addr, _fundedEth); saleBalances[_addr] = 0; } } } function lockAddress(address _addr, uint256 _period) public onlyOwner { token.lockAddress(_addr, _period); } function finalize() public onlyOwner isAfterSale isAboveSoftCap { require(!tokensaleFinished); tokensaleFinished = true; uint256 _soldTokens = issuedTokens; uint256 _partnersTokens = _soldTokens * partnersPercent / soldPercent; issueTokens(partners, _partnersTokens); uint256 _companyTokens = _soldTokens * companyPercent / soldPercent; issueTokens(company, _companyTokens); token.lockAddress(company, 730 days); token.burn(_tokensToBurn); token.start(); } } "}
{"sol name": "13770_0.sol", "label": 0, "sol content": "contract PlumberCollector{ uint256 public STARTING_POOH=300; uint256 PSN=10000; uint256 PSNH=5000; bool public initialized=false; address public ceoAddress; mapping (address => uint256) public hatcheryPlumber; mapping (address => uint256) public claimedPoohs; mapping (address => uint256) public lastHatch; mapping (address => address) public referrals; uint256 public marketPoohs; constructor() public { ceoAddress=msg.sender; } function hatchPoohs(address ref) public { require(initialized); if(referrals[msg.sender]==0 && referrals[msg.sender]!=msg.sender) { referrals[msg.sender]=ref; } uint256 poohsUsed=getMyPoohs(); uint256 newPlumber=SafeMath.div(poohsUsed,POOH_TO_CALL_1PLUMBER); hatcheryPlumber[msg.sender]=SafeMath.add(hatcheryPlumber[msg.sender],newPlumber); claimedPoohs[msg.sender]=0; lastHatch[msg.sender]=now; claimedPoohs[referrals[msg.sender]]=SafeMath.add(claimedPoohs[referrals[msg.sender]],SafeMath.div(poohsUsed,5)); marketPoohs=SafeMath.add(marketPoohs,SafeMath.div(poohsUsed,10)); } function sellPoohs() public{ require(initialized); uint256 hasPoohs=getMyPoohs(); uint256 poohValue=calculatePoohSell(hasPoohs); uint256 fee=devFee(poohValue); hatcheryPlumber[msg.sender] = SafeMath.div(hatcheryPlumber[msg.sender],2); claimedPoohs[msg.sender]=0; lastHatch[msg.sender]=now; marketPoohs=SafeMath.add(marketPoohs,hasPoohs); ceoAddress.transfer(fee); msg.sender.transfer(SafeMath.sub(poohValue,fee)); } function buyPoohs() public payable { require(initialized); uint256 poohsBought=calculatePoohBuy(msg.value,SafeMath.sub(address(this).balance,msg.value)); poohsBought=SafeMath.sub(poohsBought,devFee(poohsBought)); ceoAddress.transfer(devFee(msg.value)); claimedPoohs[msg.sender]=SafeMath.add(claimedPoohs[msg.sender],poohsBought); } function calculateTrade(uint256 rt,uint256 rs, uint256 bs) public view returns(uint256) { return SafeMath.div(SafeMath.mul(PSN,bs),SafeMath.add(PSNH,SafeMath.div(SafeMath.add(SafeMath.mul(PSN,rs),SafeMath.mul(PSNH,rt)),rt))); } function calculatePoohSell(uint256 poohs) public view returns(uint256) { return calculateTrade(poohs,marketPoohs,address(this).balance); } function calculatePoohBuy(uint256 eth,uint256 contractBalance) public view returns(uint256) { return calculateTrade(eth,contractBalance,marketPoohs); } function calculatePoohBuySimple(uint256 eth) public view returns(uint256) { return calculatePoohBuy(eth, address(this).balance); } function devFee(uint256 amount) public pure returns(uint256) { return SafeMath.div(amount,20); } function seedMarket(uint256 poohs) public payable { require(marketPoohs==0); initialized=true; marketPoohs=poohs; } function getFreePlumber() public payable { require(initialized); require(hatcheryPlumber[msg.sender]==0); lastHatch[msg.sender]=now; hatcheryPlumber[msg.sender]=STARTING_POOH; } function getBalance() public view returns(uint256) { return address(this).balance; } function getMyPlumbers() public view returns(uint256) { return hatcheryPlumber[msg.sender]; } function getMyPoohs() public view returns(uint256) { return SafeMath.add(claimedPoohs[msg.sender],getPoohsSinceLastHatch(msg.sender)); } function getPoohsSinceLastHatch(address adr) public view returns(uint256) { uint256 secondsPassed=min(POOH_TO_CALL_1PLUMBER,SafeMath.sub(now,lastHatch[adr])); return SafeMath.mul(secondsPassed,hatcheryPlumber[adr]); } function min(uint256 a, uint256 b) private pure returns (uint256) { return a < b ? a : b; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "26745_0.sol", "label": 0, "sol content": "contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } } contract RRToken is owned, TokenERC20 { uint256 initialSupply = 100000000; string tokenName = 'DICI'; string tokenSymbol = 'DICI'; function RRToken() TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } } "}
{"sol name": "1978_0.sol", "label": 0, "sol content": "contract TimeCard { string public suicaId; uint[] public timeList; uint[] public workTimeList; constructor(string mySuicaId) public { suicaId = mySuicaId; } function setTimeStamp(string mySuicaId, uint timeStamp) public { require(keccak256(abi.encodePacked(suicaId)) == keccak256(abi.encodePacked(mySuicaId))); timeList.push(timeStamp); if((timeList.length % 2 ) == 0 ) { uint startTime = timeList[timeList.length -2]; uint endTime = timeList[timeList.length -1]; uint workTime = getWorkTime(startTime, endTime); workTimeList.push(workTime); } } function getWorkTime(uint startTime, uint endTime) internal pure returns(uint){ uint workTime = endTime - startTime; return workTime; } } "}
{"sol name": "6539_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30499200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x30E8FEb4a13caB8B702dA658503C887184166B4a; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "14906_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract Decabes is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Decabes() public { symbol = \"DEC\"; name = \"Decabes\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x5130ADAD8C86AF52743988293F484428a7C2402a] = _totalSupply; Transfer(address(0), 0x5130ADAD8C86AF52743988293F484428a7C2402a, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "6904_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30067200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x4b02B9142cCaf0Bc445Dd39a8f6865aD3278a87e; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "33993_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() internal { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); } library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } } contract TokenTimelock is Ownable{ using SafeERC20 for ERC20Basic; function TokenTimelock(ERC20Basic _token, uint64 _releaseTime) public { require(_releaseTime > now); token = _token; owner = msg.sender; releaseTime = _releaseTime; } function claim() public onlyOwner { require(now >= releaseTime); uint256 amount = token.balanceOf(this); require(amount > 0); token.safeTransfer(owner, amount); } } "}
{"sol name": "37154_0.sol", "label": 0, "sol content": "contract Ethraffle { struct Contestant { address addr; uint raffleId; } event RaffleResult( uint indexed raffleId, uint winningNumber, address winningAddress, address seed1, address seed2, uint seed3, bytes32 randHash ); event TicketPurchase( uint indexed raffleId, address contestant, uint number ); event TicketRefund( uint indexed raffleId, address contestant, uint number ); uint public constant prize = 0.01 ether; uint public constant fee = 0.01 ether; uint public constant totalTickets = 6; uint public constant pricePerTicket = (prize + fee) / totalTickets; address feeAddress; bool public paused = false; uint public raffleId = 1; uint nextTicket = 0; mapping (uint => Contestant) contestants; uint[] gaps; function Ethraffle() public { feeAddress = msg.sender; } function () payable public { buyTickets(); } function buyTickets() payable public { if (paused) { msg.sender.transfer(msg.value); return; } uint moneySent = msg.value; while (moneySent >= pricePerTicket && nextTicket < totalTickets) { uint currTicket = 0; if (gaps.length > 0) { currTicket = gaps[gaps.length-1]; gaps.length--; } else { currTicket = nextTicket++; } contestants[currTicket] = Contestant(msg.sender, raffleId); TicketPurchase(raffleId, msg.sender, currTicket); moneySent -= pricePerTicket; } if (nextTicket == totalTickets) { chooseWinner(); } if (moneySent > 0) { msg.sender.transfer(moneySent); } } function chooseWinner() private { address seed1 = contestants[uint(block.coinbase) % totalTickets].addr; address seed2 = contestants[uint(msg.sender) % totalTickets].addr; uint seed3 = block.difficulty; bytes32 randHash = keccak256(seed1, seed2, seed3); uint winningNumber = uint(randHash) % totalTickets; address winningAddress = contestants[winningNumber].addr; RaffleResult(raffleId, winningNumber, winningAddress, seed1, seed2, seed3, randHash); raffleId++; nextTicket = 0; winningAddress.transfer(prize); feeAddress.transfer(fee); } function getRefund() public { uint refund = 0; for (uint i = 0; i < totalTickets; i++) { if (msg.sender == contestants[i].addr && raffleId == contestants[i].raffleId) { refund += pricePerTicket; contestants[i] = Contestant(address(0), 0); gaps.push(i); TicketRefund(raffleId, msg.sender, i); } } if (refund > 0) { msg.sender.transfer(refund); } } function endRaffle() public { if (msg.sender == feeAddress) { paused = true; for (uint i = 0; i < totalTickets; i++) { if (raffleId == contestants[i].raffleId) { TicketRefund(raffleId, contestants[i].addr, i); contestants[i].addr.transfer(pricePerTicket); } } RaffleResult(raffleId, totalTickets, address(0), address(0), address(0), 0, 0); raffleId++; nextTicket = 0; gaps.length = 0; } } function togglePause() public { if (msg.sender == feeAddress) { paused = !paused; } } function kill() public { if (msg.sender == feeAddress) { selfdestruct(feeAddress); } } } "}
{"sol name": "3577_0.sol", "label": 0, "sol content": "contract F3Devents { event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract modularShort is F3Devents {} contract F3DGo is modularShort { using SafeMath for *; using NameFilter for string; using F3DKeysCalcShort for uint256; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0x82e0C3626622d9a8234BFBaf6DD0f8d070C2609D); address private admin = 0xacb257873b064b956BD9be84dc347C55F7b2ae8C; address private coin_base = 0x345A756a49DF0eD24002857dd25DAb6a5F4E83FF; string constant public name = \"F3DGo\"; string constant public symbol = \"F3DGo\"; constructor() public { } modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } function() isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { F3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); buyCore(_pID, _affID, _team, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; if (_affCode == 0 || _affCode == _pID) { _affCode = plyr_[_pID].laff; } else if (_affCode != plyr_[_pID].laff) { plyr_[_pID].laff = _affCode; } _team = verifyTeam(_team); reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == address(0) || _affCode == msg.sender) { _affID = plyr_[_pID].laff; } else { _affID = pIDxAddr_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { F3Ddatasets.EventReturns memory _eventData_; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _affID; if (_affCode == '' || _affCode == plyr_[_pID].name) { _affID = plyr_[_pID].laff; } else { _affID = pIDxName_[_affCode]; if (_affID != plyr_[_pID].laff) { plyr_[_pID].laff = _affID; } } _team = verifyTeam(_team); reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function withdraw() isActivated() isHuman() public { uint256 _rID = rID_; uint256 _now = now; uint256 _pID = pIDxAddr_[msg.sender]; uint256 _eth; if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { F3Ddatasets.EventReturns memory _eventData_; round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } else { _eth = withdrawEarnings(_pID); if (_eth > 0) plyr_[_pID].addr.transfer(_eth); emit F3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; emit F3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function getBuyPrice() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); } function getTimeLeft() public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { uint256 _rID = rID_; if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].gen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; return ( ); } function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( ); } function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { core(_rID, _pID, msg.value, _affID, _team, _eventData_); } else { if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F3Ddatasets.EventReturns memory _eventData_) private { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); core(_rID, _pID, _eth, _affID, _team, _eventData_); } else if (_now > round_[_rID].end && round_[_rID].ended == false) { round_[_rID].ended = true; _eventData_ = endRound(_eventData_); _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; emit F3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private { if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000) { uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } if (_eth > 1000000000) { uint256 _keys = (round_[_rID].eth).keysRec(_eth); if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; _eventData_.compressedData = _eventData_.compressedData + 100; } if (_eth >= 100000000000000000) { airDropTracker_++; if (airdrop() == true) { uint256 _prize; if (_eth >= 10000000000000000000) { _prize = ((airDropPot_).mul(75)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } else if (_eth >= 1000000000000000000 && _eth < 10000000000000000000) { _prize = ((airDropPot_).mul(50)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 200000000000000000000000000000000; } else if (_eth >= 100000000000000000 && _eth < 1000000000000000000) { _prize = ((airDropPot_).mul(25)) / 100; plyr_[_pID].win = (plyr_[_pID].win).add(_prize); airDropPot_ = (airDropPot_).sub(_prize); _eventData_.compressedData += 300000000000000000000000000000000; } _eventData_.compressedData += 10000000000000000000000000000000; _eventData_.compressedData += _prize * 1000000000000000000000000000000000; airDropTracker_ = 0; } } _eventData_.compressedData = _eventData_.compressedData + (airDropTracker_ * 1000); plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, _team, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); endTx(_pID, _team, _eth, _keys, _eventData_); } } function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); return ( (_eth).keys() ); } function iWantXKeys(uint256 _keys) public view returns(uint256) { uint256 _rID = rID_; uint256 _now = now; if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); return ( (_keys).eth() ); } function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } function determinePID(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; if (_pID == 0) { _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } function managePlayer(uint256 _pID, F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); plyr_[_pID].lrnd = rID_; _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } function endRound(F3Ddatasets.EventReturns memory _eventData_) private returns (F3Ddatasets.EventReturns) { uint256 _rID = rID_; uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; uint256 _pot = round_[_rID].pot; uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } plyr_[_winPID].win = _win.add(plyr_[_winPID].win); _com = _com.add(_p3d.sub(_p3d / 2)); coin_base.transfer(_com); _res = _res.add(_p3d / 2); round_[_rID].mask = _ppt.add(round_[_rID].mask); _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } function updateTimer(uint256 _keys, uint256 _rID) private { uint256 _now = now; uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); if((seed - ((seed / 1000) * 1000)) < airDropTracker_) return(true); else return(false); } function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _p1 = _eth / 100; uint256 _com = _eth / 50; _com = _com.add(_p1); uint256 _p3d; if (!address(coin_base).call.value(_com)()) { _p3d = _com; _com = 0; } uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F3Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _p3d = _p3d.add(_aff); } _p3d = _p3d.add((_eth.mul(fees_[_team].p3d)) / (100)); if (_p3d > 0) { uint256 _potAmount = _p3d / 2; coin_base.transfer(_p3d.sub(_potAmount)); round_[_rID].pot = round_[_rID].pot.add(_potAmount); _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } function potSwap() external payable { uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F3Devents.onPotSwapDeposit(_rID, msg.value); } function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private returns(F3Ddatasets.EventReturns) { uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; uint256 _air = (_eth / 100); airDropPot_ = airDropPot_.add(_air); _eth = _eth.sub(((_eth.mul(14)) / 100).add((_eth.mul(fees_[_team].p3d)) / 100)); uint256 _pot = _eth.sub(_gen); uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } function withdrawEarnings(uint256 _pID) private returns(uint256) { updateGenVault(_pID, plyr_[_pID].lrnd); uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit F3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } bool public activated_ = false; function activate() public { require(msg.sender == admin, \"only admin can activate\"); require(activated_ == false, \"FOMO Short already activated\"); activated_ = true; rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } library F3Ddatasets { struct EventReturns { uint256 compressedData; uint256 compressedIDs; } struct Player { } struct PlayerRounds { } struct Round { } struct TeamFee { } struct PotSplit { } } library F3DKeysCalcShort { using SafeMath for *; function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } bool _hasNonNumber; for (uint256 i = 0; i < _length; i++) { if (_temp[i] > 0x40 && _temp[i] < 0x5b) { _temp[i] = byte(uint(_temp[i]) + 32); if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( _temp[i] == 0x20 || (_temp[i] > 0x60 && _temp[i] < 0x7b) || (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "39950_0.sol", "label": 0, "sol content": "MillionEther smart contract - decentralized advertising platform. This program is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version. This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License for more details. You should have received a copy of the GNU General Public License contract MillionEther { address private admin; uint private numUsers = 0; struct User { address referal; uint8 handshakes; uint balance; uint32 activationTime; bool banned; uint userID; bool refunded; uint investments; } mapping(address => User) private users; mapping(uint => address) private userAddrs; uint16 private blocksSold = 0; uint private numNewStatus = 0; struct Block { address landlord; uint imageID; uint sellPrice; } Block[101][101] private blocks; uint private numImages = 0; struct Image { uint8 fromX; uint8 fromY; uint8 toX; uint8 toY; string imageSourceUrl; string adUrl; string adText; } mapping(uint => Image) private images; uint public charityBalance = 0; address public charityAddress; uint8 private refund_percent = 0; bool private setting_stopped = false; bool private setting_refundMode = false; uint32 private setting_delay = 3600; uint private setting_imagePlacementPriceInWei = 0; event NewUser(uint ID, address newUser, address invitedBy, uint32 activationTime); event NewAreaStatus (uint ID, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint price); event NewImage(uint ID, uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, string imageSourceUrl, string adUrl, string adText); function MillionEther () { admin = msg.sender; users[admin].referal = admin; users[admin].handshakes = 0; users[admin].activationTime = uint32(now); users[admin].userID = 0; userAddrs[0] = admin; userAddrs[numUsers] = admin; } modifier onlyAdmin { if (msg.sender != admin) throw; _; } modifier onlyWhenInvitedBy (address someUser) { _; } modifier onlySignedIn { _; } modifier onlyForSale (uint8 _x, uint8 _y) { if (blocks[_x][_y].landlord != address(0x0) && blocks[_x][_y].sellPrice == 0) throw; _; } modifier onlyWithin100x100Area (uint8 _fromX, uint8 _fromY, uint8 _toX, uint8 _toY) { if ((_fromX < 1) || (_fromY < 1)  || (_toX > 100) || (_toY > 100)) throw; _; } modifier onlyByLandlord (uint8 _x, uint8 _y) { if (msg.sender != admin) { if (blocks[_x][_y].landlord != msg.sender) throw; } _; } modifier noBannedUsers { if (users[msg.sender].banned == true) throw; _; } modifier stopInEmergency { if (msg.sender != admin) { if (setting_stopped) throw; } _; } modifier onlyInRefundMode { if (!setting_refundMode) throw; _; } function getActivationTime (uint _currentLevel, uint _setting_delay) private constant returns (uint32) { return uint32(now + _setting_delay * (2**(_currentLevel-1))); } function signIn (address referal) public stopInEmergency () onlyWhenInvitedBy (referal) returns (uint) { numUsers++; uint8 currentLevel = users[referal].handshakes + 1; users[msg.sender].referal = referal; users[msg.sender].handshakes = currentLevel; users[msg.sender].activationTime = getActivationTime (currentLevel, setting_delay); users[msg.sender].refunded = false; users[msg.sender].userID = numUsers; userAddrs[numUsers] = msg.sender; NewUser(numUsers, msg.sender, referal, users[msg.sender].activationTime); return numUsers; } function getBlockPrice (uint8 fromX, uint8 fromY, uint blocksSold) private constant returns (uint) { if (blocks[fromX][fromY].landlord == address(0x0)) { return 1 ether * (2 ** (blocksSold/1000)); } else { return blocks[fromX][fromY].sellPrice; } } function buyBlock (uint8 x, uint8 y) private onlyForSale (x, y) returns (uint) { uint blockPrice; blockPrice = getBlockPrice(x, y, blocksSold); if (blocks[x][y].landlord == address(0x0)) { blocksSold += 1; totalWeiInvested += blockPrice; } else { users[blocks[x][y].landlord].balance += blockPrice; } blocks[x][y].landlord = msg.sender; return blockPrice; } function buyBlocks (uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) public payable stopInEmergency () onlySignedIn () onlyWithin100x100Area (fromX, fromY, toX, toY) returns (uint) { uint previousWeiInvested = totalWeiInvested; uint buyerBalance = users[msg.sender].balance + msg.value; uint purchasePrice; for (uint8 ix=fromX; ix<=toX; ix++) { for (uint8 iy=fromY; iy<=toY; iy++) { purchasePrice = buyBlock (ix,iy); if (buyerBalance < purchasePrice) throw; buyerBalance -= purchasePrice; } } users[msg.sender].balance = buyerBalance; users[msg.sender].investments += totalWeiInvested - previousWeiInvested; payOut (totalWeiInvested - previousWeiInvested, users[msg.sender].referal); numNewStatus += 1; NewAreaStatus (numNewStatus, fromX, fromY, toX, toY, 0); return purchasePrice; } function sellBlock (uint8 x, uint8 y, uint sellPrice) private onlyByLandlord (x, y) { blocks[x][y].sellPrice = sellPrice; } function sellBlocks (uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, uint priceForEachBlockInWei) public stopInEmergency () onlyWithin100x100Area (fromX, fromY, toX, toY) returns (bool) { if (priceForEachBlockInWei == 0) throw; for (uint8 ix=fromX; ix<=toX; ix++) { for (uint8 iy=fromY; iy<=toY; iy++) { sellBlock (ix, iy, priceForEachBlockInWei); } } numNewStatus += 1; NewAreaStatus (numNewStatus, fromX, fromY, toX, toY, priceForEachBlockInWei); return true; } function chargeForImagePlacement () private { uint buyerBalance = users[msg.sender].balance + msg.value; if (buyerBalance < setting_imagePlacementPriceInWei) throw; buyerBalance -= setting_imagePlacementPriceInWei; users[admin].balance += setting_imagePlacementPriceInWei; users[msg.sender].balance = buyerBalance; } function assignImageID (uint8 x, uint8 y, uint _imageID) private onlyByLandlord (x, y) { blocks[x][y].imageID = _imageID; } function placeImage (uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, string imageSourceUrl, string adUrl, string adText) public payable stopInEmergency () noBannedUsers () onlyWithin100x100Area (fromX, fromY, toX, toY) returns (uint) { chargeForImagePlacement(); numImages++; for (uint8 ix=fromX; ix<=toX; ix++) { for (uint8 iy=fromY; iy<=toY; iy++) { assignImageID (ix, iy, numImages); } } images[numImages].fromX = fromX; images[numImages].fromY = fromY; images[numImages].toX = toX; images[numImages].toY = toY; images[numImages].imageSourceUrl = imageSourceUrl; images[numImages].adUrl = adUrl; images[numImages].adText = adText; NewImage(numImages, fromX, fromY, toX, toY, imageSourceUrl, adUrl, adText); return numImages; } function payOut (uint _amount, address referal) private { address iUser = referal; address nextUser; uint totalPayed = 0; nextUser = users[iUser].referal; iUser = nextUser; } } function goesToCharity (uint amount) private { if (charityAddress == address(0x0)) { charityBalance += amount; } else { users[charityAddress].balance += amount; } } function withdrawAll () public stopInEmergency () { uint withdrawAmount = users[msg.sender].balance; users[msg.sender].balance = 0; if (!msg.sender.send(withdrawAmount)) { users[msg.sender].balance = withdrawAmount; } } function getUserInfo (address userAddress) public constant returns ( address referal, uint8 handshakes, uint balance, uint32 activationTime, bool banned, uint userID, bool refunded, uint investments ) { referal = users[userAddress].referal; handshakes = users[userAddress].handshakes; balance = users[userAddress].balance; activationTime = users[userAddress].activationTime; banned = users[userAddress].banned; userID = users[userAddress].userID; refunded = users[userAddress].refunded; investments = users[userAddress].investments; } function getUserAddressByID (uint userID) public constant returns (address userAddress) { return userAddrs[userID]; } function getMyInfo() public constant returns(uint balance, uint32 activationTime) { return (users[msg.sender].balance, users[msg.sender].activationTime); } function getBlockInfo(uint8 x, uint8 y) public constant returns (address landlord, uint imageID, uint sellPrice) { return (blocks[x][y].landlord, blocks[x][y].imageID, blocks[x][y].sellPrice); } function getAreaPrice (uint8 fromX, uint8 fromY, uint8 toX, uint8 toY) public constant onlyWithin100x100Area (fromX, fromY, toX, toY) returns (uint) { uint blockPrice; uint totalPrice = 0; uint16 iblocksSold = blocksSold; for (uint8 ix=fromX; ix<=toX; ix++) { for (uint8 iy=fromY; iy<=toY; iy++) { blockPrice = getBlockPrice(ix,iy,iblocksSold); if (blocks[ix][iy].landlord == address(0x0)) { iblocksSold += 1; } if (blockPrice == 0) { } totalPrice += blockPrice; } } return totalPrice; } function getImageInfo(uint imageID) public constant returns (uint8 fromX, uint8 fromY, uint8 toX, uint8 toY, string imageSourceUrl, string adUrl, string adText) { Image i = images[imageID]; return (i.fromX, i.fromY, i.toX, i.toY, i.imageSourceUrl, i.adUrl, i.adText); } function getStateInfo () public constant returns ( uint _numUsers, uint16 _blocksSold, uint _totalWeiInvested, uint _numImages, uint _setting_imagePlacementPriceInWei, uint _numNewStatus, uint32 _setting_delay ){ return (numUsers, blocksSold, totalWeiInvested, numImages, setting_imagePlacementPriceInWei, numNewStatus, setting_delay); } function adminContractSecurity (address violator, bool banViolator, bool pauseContract, bool refundInvestments) public onlyAdmin () { if (violator != address(0x0)) { users[violator].banned = banViolator; } setting_stopped = pauseContract; if (refundInvestments) { setting_refundMode = refundInvestments; refund_percent = uint8((this.balance*100)/totalWeiInvested); } } function adminContractSettings (uint32 newDelayInSeconds, address newCharityAddress, uint newImagePlacementPriceInWei) public onlyAdmin () { if (newDelayInSeconds > 0) setting_delay = newDelayInSeconds; if (newCharityAddress != address(0x0)) { if (users[newCharityAddress].referal == address(0x0)) throw; charityAddress = newCharityAddress; users[charityAddress].balance += charityBalance; charityBalance = 0; } setting_imagePlacementPriceInWei = newImagePlacementPriceInWei; } function emergencyRefund () public onlyInRefundMode () { if (!users[msg.sender].refunded) { uint totalInvested = users[msg.sender].investments; uint availableForRefund = (totalInvested*refund_percent)/100; users[msg.sender].investments -= availableForRefund; users[msg.sender].refunded = true; if (!msg.sender.send(availableForRefund)) { users[msg.sender].investments = totalInvested; users[msg.sender].refunded = false; } } } function () { throw; } } "}
{"sol name": "20463_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract WsloanCoin { string public name; string public symbol; uint8 public decimals = 2; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "525_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused { require(paused); _; } function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract ROE is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ROE() public { symbol = \"ROE\"; name = \"NeoWorld Rare Ore E\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "37937_0.sol", "label": 0, "sol content": "contract HerCoin { string public standard = 'Token 0.1'; string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; function Token() { initialSupply = 20000000; name =\"hercoin\"; decimals = 4; symbol = \"HER\"; } function transfer(address _to, uint256 _value) { } function () { } } "}
{"sol name": "33877_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Crowdsale { using SafeMath for uint256; address public tokenAddr; TestTokenA public testTokenA; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(address _tokenAddress, uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != 0x0); require(_tokenAddress != 0x0); tokenAddr = _tokenAddress; startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } function () payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != 0x0); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); testTokenA = TestTokenA(tokenAddr); testTokenA.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function forwardFunds() internal { wallet.transfer(msg.value); } function validPurchase() internal constant returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } function hasEnded() public constant returns (bool) { return now > endTime; } } contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) { require(_cap > 0); cap = _cap; } function validPurchase() internal constant returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } function finalization() internal { } } contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) { require(_wallet != 0x0); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; RefundVault public vault; function RefundableCrowdsale(uint256 _goal) { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; } function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public constant returns (bool) { return weiRaised >= goal; } } contract Destructible is Ownable { function Destructible() payable { } function destroy() onlyOwner public { selfdestruct(owner); } function destroyAndSend(address _recipient) onlyOwner public { selfdestruct(_recipient); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(0x0, _to, _amount); return true; } function finishMinting() onlyOwner public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract TestTokenA is MintableToken { string public constant name = \"TestTokenA\"; string public constant symbol = \"ZNX\"; uint8 public constant decimals = 18; function TestTokenA() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; } } contract TestTokenAPreICO is CappedCrowdsale, RefundableCrowdsale, Destructible, Pausable { function TestTokenAPreICO(address _tokenAddress, uint256 _startTime, uint256 _endTime, uint256 _rate, uint256 _goal, uint256 _cap, address _wallet) CappedCrowdsale(_cap) FinalizableCrowdsale() RefundableCrowdsale(_goal) Crowdsale(_tokenAddress, _startTime, _endTime, _rate, _wallet) { require(_goal <= _cap); } } "}
{"sol name": "8352_0.sol", "label": 0, "sol content": "contract Outer { Inner1 public myInner1 = new Inner1(); function callSomeFunctionViaOuter() public { myInner1.callSomeFunctionViaInner1(); } } contract Inner1 { Inner2 public myInner2 = new Inner2(); function callSomeFunctionViaInner1() public { myInner2.doSomething(); } } contract Inner2 { uint256 someValue; event SetValue(uint256 val); function doSomething() public { someValue = block.timestamp; emit SetValue(someValue); } } "}
{"sol name": "34925_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract LogiETHToken { string public name; string public symbol; uint8 public decimals = 10; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function LogiETHToken( ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "32526_0.sol", "label": 0, "sol content": "contract Token { string public symbol = \"\"; string public name = \"\"; uint8 public constant decimals = 18; uint256 _totalSupply = 0; address owner = 0; bool setupDone = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token(address adr) { owner = adr; } function SetupToken(string tokenName, string tokenSymbol, uint256 tokenSupply) { if (msg.sender == owner && setupDone == false) { symbol = tokenSymbol; name = tokenName; _totalSupply = tokenSupply * 1000000000000000000; balances[owner] = _totalSupply; setupDone = true; } } function totalSupply() constant returns (uint256 totalSupply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "20450_0.sol", "label": 0, "sol content": "Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); function randomDS_getSessionPubKeyHash() returns(bytes32); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); oraclize_setNetworkName(\"eth_mainnet\"); return true; } OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); oraclize_setNetworkName(\"eth_ropsten3\"); return true; } OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); oraclize_setNetworkName(\"eth_kovan\"); return true; } OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48); oraclize_setNetworkName(\"eth_rinkeby\"); return true; } OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_useCoupon(string code) oraclizeAPI internal { oraclize.useCoupon(code); } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){ return oraclize.randomDS_getSessionPubKeyHash(); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } function ba2cbor(bytes[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } string oraclize_network_name; function oraclize_setNetworkName(string _network_name) internal { oraclize_network_name = _network_name; } function oraclize_getNetworkName() internal returns (string) { return oraclize_network_name; } function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){ if ((_nbytes == 0)||(_nbytes > 32)) throw; bytes memory nbytes = new bytes(1); nbytes[0] = byte(_nbytes); bytes memory unonce = new bytes(32); bytes memory sessionKeyHash = new bytes(32); bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash(); assembly { mstore(unonce, 0x20) mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp))) mstore(sessionKeyHash, 0x20) mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32) } bytes[3] memory args = [unonce, nbytes, sessionKeyHash]; bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit); oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2])); return queryId; } function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal { oraclize_randomDS_args[queryId] = commitment; } mapping(bytes32=>bytes32) oraclize_randomDS_args; mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified; function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){ bool sigok; address signer; bytes32 sigr; bytes32 sigs; bytes memory sigr_ = new bytes(32); uint offset = 4+(uint(dersig[3]) - 0x20); sigr_ = copyBytes(dersig, offset, 32, sigr_, 0); bytes memory sigs_ = new bytes(32); offset += 32 + 2; sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0); assembly { sigr := mload(add(sigr_, 32)) sigs := mload(add(sigs_, 32)) } (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs); if (address(sha3(pubkey)) == signer) return true; else { (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs); return (address(sha3(pubkey)) == signer); } } function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) { bool sigok; bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2); copyBytes(proof, sig2offset, sig2.length, sig2, 0); bytes memory appkey1_pubkey = new bytes(64); copyBytes(proof, 3+1, 64, appkey1_pubkey, 0); bytes memory tosign2 = new bytes(1+65+32); copyBytes(proof, sig2offset-65, 65, tosign2, 1); bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\"; copyBytes(CODEHASH, 0, 32, tosign2, 1+65); sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey); if (sigok == false) return false; bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\"; bytes memory tosign3 = new bytes(1+65); tosign3[0] = 0xFE; copyBytes(proof, 3, 65, tosign3, 1); bytes memory sig3 = new bytes(uint(proof[3+65+1])+2); copyBytes(proof, 3+65, sig3.length, sig3, 0); sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY); return sigok; } modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) { if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) throw; _; } function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){ if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) return 2; return 0; } function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){ bool match_ = true; for (uint256 i=0; i< n_random_bytes; i++) { if (content[i] != prefix[i]) match_ = false; } return match_; } function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){ uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32; bytes memory keyhash = new bytes(32); copyBytes(proof, ledgerProofLength, 32, keyhash, 0); if (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false; bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2); copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0); if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false; bytes memory commitmentSlice1 = new bytes(8+1+32); copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0); bytes memory sessionPubkey = new bytes(64); uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65; copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0); bytes32 sessionPubkeyHash = sha256(sessionPubkey); delete oraclize_randomDS_args[queryId]; } else return false; bytes memory tosign1 = new bytes(32+8+1+32); copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0); if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false; if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){ oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset); } return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]; } function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) { uint minLength = length + toOffset; if (to.length < minLength) { } uint i = 32 + fromOffset; uint j = 32 + toOffset; while (i < (32 + fromOffset + length)) { assembly { let tmp := mload(add(from, i)) mstore(add(to, j), tmp) } i += 32; j += 32; } return to; } function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) } return (ret, addr); } function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) return (false, 0); assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } if (v < 27) v += 27; if (v != 27 && v != 28) return (false, 0); return safer_ecrecover(hash, v, r, s); } } contract DukevsKansas is usingOraclize { address public OWNERS = 0xC3eD2d481B9d75835EC04174b019A7eAF2Faf78A; uint public constant MIN_BET = 0.01 ether; uint public constant BETTING_OPENS = 1522388049; uint public ORACLIZE_GAS = 200000; bool public completed; bool public canceled; bool public ownersPayed; uint public ownerPayout; bool public returnedToOwners; uint public winnerDeterminedDate; uint public numCollected = 0; uint public oraclizeFees; uint public collectionFees; struct Better { uint betAmount; uint betOption; bool withdrawn; } mapping(address => Better) betterInfo; address[] public betters; uint[2] public totalAmountsBet; uint[2] public numberOfBets; uint public totalBetAmount; uint public winningOption = 2; event BetMade(); modifier canDetermineWinner() { require (winningOption == 2 && !completed && !canceled && now > BETTING_CLOSES && now >= EXPECTED_END); _; } modifier canEmptyRemainings() { require(canceled || completed); uint numRequiredToCollect = canceled ? (numberOfBets[0] + numberOfBets[1]) : numberOfBets[winningOption]; require ((now >= RETURN_DATE && !canceled) || (numCollected == numRequiredToCollect)); _; } modifier collectionsEnabled() { require (canceled || (winningOption != 2 && completed && now > BETTING_CLOSES)); _; } modifier canPayOwners() { require (!canceled && winningOption != 2 && completed && !ownersPayed && now > BETTING_CLOSES); _; } modifier bettingIsClosed() { require (now >= BETTING_CLOSES); _; } modifier onlyOwnerLevel() { require( OWNERS == msg.sender ); _; } function DukevsKansas() public payable { oraclize_setCustomGasPrice(1000000000); } function changeGasLimitAndPrice(uint gas, uint price) public onlyOwnerLevel { ORACLIZE_GAS = gas; oraclize_setCustomGasPrice(price); } function setExpectedStart(uint _EXPECTED_START) public onlyOwnerLevel { EXPECTED_START = _EXPECTED_START; BETTING_CLOSES = EXPECTED_START - 60; } function setExpectedEnd(uint _EXPECTED_END) payable public onlyOwnerLevel { require(_EXPECTED_END > EXPECTED_START); EXPECTED_END = _EXPECTED_END; CANCELATION_DATE = EXPECTED_END + 60 * 60 * 24; RETURN_DATE = EXPECTED_END + 60 * 60 * 24 * 30; } function callOracle(uint timeOrDelay, uint gas) private { makeOraclizeQuery(timeOrDelay, \"nested\", \"[computation] ['Qmcvcsedtxi1PUqtsS45R8Vp7p6FcpMkJeJsfG6B2ocXNH', '58f3db47-235e-4c4d-94eb-206c09a7e2e4', '${[decrypt] BO5VvsPJ5cakMpeSRxgtaKQcnW+3QwufK9vRQt5B8BqDJ0mevSVmDm/T/UNj1yXXH7LJyYqWBRXuGWjbl9RW3dPyBLfFQRogfupGbNvfmBXXBAp8tXm+dKtCKaYqeFZA3lPwo7NLlEcK}']\", gas); } function makeOraclizeQuery(uint timeOrDelay, string datasource, string query, uint gas) private returns(bytes32) { oraclizeFees += oraclize_getPrice(datasource, gas); return oraclize_query(timeOrDelay, datasource, query, gas); } function determineWinner(uint gas, uint gasPrice) payable public onlyOwnerLevel canDetermineWinner { ORACLIZE_GAS = gas; oraclize_setCustomGasPrice(gasPrice); callOracle(0, ORACLIZE_GAS); } function __callback(bytes32 queryId, string result, bytes proof) public canDetermineWinner { require(msg.sender == oraclize_cbAddress()); uint winner = parseInt(result); if (winner != 0 && winner != 1) { if (now < CANCELATION_DATE) { callOracle(PING_ORACLE_INTERVAL, ORACLIZE_GAS); } else { cancel(); } } else { setWinner(winner); } } function setWinner(uint winner) private { completed = true; canceled = false; winningOption = winner; winnerDeterminedDate = now; payOwners(); } function getUserBet(address addr) public constant returns(uint[]) { uint[] memory bets = new uint[](2); bets[betterInfo[addr].betOption] = betterInfo[addr].betAmount; return bets; } function userHasWithdrawn(address addr) public constant returns(bool) { return betterInfo[addr].withdrawn; } function collectionsAvailable() public constant returns(bool) { } function canBet() public constant returns(bool) { return (now >= BETTING_OPENS && now < BETTING_CLOSES && !canceled && !completed); } function bet(uint option) public payable { require(canBet() == true); require(msg.value >= MIN_BET); require(betterInfo[msg.sender].betAmount == 0 || betterInfo[msg.sender].betOption == option); if (betterInfo[msg.sender].betAmount == 0) { betterInfo[msg.sender].betOption = option; numberOfBets[option]++; betters.push(msg.sender); } betterInfo[msg.sender].betAmount += msg.value; totalBetAmount += msg.value; totalAmountsBet[option] += msg.value; } function emptyRemainingsToOwners() private canEmptyRemainings { OWNERS.transfer(this.balance); returnedToOwners = true; } function returnToOwners() public onlyOwnerLevel canEmptyRemainings { emptyRemainingsToOwners(); } function payOwners() private canPayOwners { if (COMMISSION == 0) { ownersPayed = true; ownerPayout = 0; collectionFees = oraclizeFees / numberOfBets[winningOption]; return; } uint losingChunk = totalAmountsBet[1 - winningOption]; OWNERS.transfer(ownerPayout); ownersPayed = true; } function cancelBet() payable public onlyOwnerLevel { cancel(); } function cancel() private { canceled = true; completed = false; } function() payable public { } function collect() public collectionsEnabled { address better = msg.sender; require(betterInfo[better].betAmount > 0); require(!betterInfo[better].withdrawn); require(canceled != completed); require(canceled || (completed && betterInfo[better].betOption == winningOption)); require(now >= (winnerDeterminedDate + 600)); uint payout = 0; if (!canceled) { uint losingChunk = totalAmountsBet[1 - winningOption]; payout = betterInfo[better].betAmount + (betterInfo[better].betAmount * (losingChunk - ownerPayout - collectionFees) / totalAmountsBet[winningOption]); } else { payout = betterInfo[better].betAmount; } if (payout > 0) { better.transfer(payout); betterInfo[better].withdrawn = true; numCollected++; } } } "}
{"sol name": "22671_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract AIC { string public name; string public symbol; uint8 public decimals = 4; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function AIC() public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } "}
{"sol name": "4910_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ValueCyberToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ValueCyberToken() public { symbol = \"VCT\"; name = \"ValueCyberToken\"; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x5f20Fc8e1Dd8F82899e413fEFA021Fb59ef24A8A] = _totalSupply; Transfer(address(0), 0x5f20Fc8e1Dd8F82899e413fEFA021Fb59ef24A8A, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "24107_0.sol", "label": 0, "sol content": "contract Base { modifier only(address allowed) { require(msg.sender == allowed); _; } uint constant internal L00 = 2 ** 0; uint constant internal L01 = 2 ** 1; uint constant internal L02 = 2 ** 2; uint constant internal L03 = 2 ** 3; uint constant internal L04 = 2 ** 4; uint constant internal L05 = 2 ** 5; uint private bitlocks = 0; modifier noAnyReentrancy { var _locks = bitlocks; require(_locks == 0); bitlocks = uint(-1); _; bitlocks = _locks; } } contract IToken { function mint(address _to, uint _amount); function start(); function getTotalSupply() returns(uint); function balanceOf(address _owner) returns(uint); function transfer(address _to, uint _amount) returns (bool success); function transferFrom(address _from, address _to, uint _value) returns (bool success); } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Owned is Base { address public owner; address newOwner; function Owned() { owner = msg.sender; } function transferOwnership(address _newOwner) only(owner) { newOwner = _newOwner; } function acceptOwnership() only(newOwner) { OwnershipTransferred(owner, newOwner); owner = newOwner; } event OwnershipTransferred(address indexed _from, address indexed _to); } contract Crowdsale is Owned { using SafeMath for uint; enum State { INIT, PRESALE, PREICO, PREICO_FINISHED, ICO_FIRST, ICO_SECOND, ICO_THIRD, STOPPED, CLOSED, EMERGENCY_STOP} uint public constant MAX_SALE_SUPPLY = 24 * (10**25); uint public constant DECIMALS = (10**18); State public currentState = State.INIT; IToken public token; uint public totalSaleSupply = 0; uint public totalFunds = 0; uint public currentPrice; address public beneficiary; mapping(address => uint) balances; uint public foundersAmount = 160000000 * DECIMALS; uint public maxPreICOSupply = 48 * (10**24); uint public maxICOFirstSupply = 84 * (10**24); uint public maxICOSecondSupply = 48 * (10**24); uint public maxICOThirdSupply = 24 * (10**24); uint public currentRoundSupply = 0; modifier inState(State _state){ require(currentState == _state); _; } modifier salesRunning(){ require(currentState == State.PREICO || currentState == State.ICO_FIRST || currentState == State.ICO_SECOND || currentState == State.ICO_THIRD); _; } modifier minAmount(){ require(msg.value >= 0.2 ether); _; } event Transfer(address indexed _to, uint _value); function Crowdsale(address _foundersWallet, address _beneficiary){ beneficiary = _beneficiary; foundersWallet = _foundersWallet; } function initialize(IToken _token) public only(owner) inState(State.INIT) { require(_token != address(0)); token = _token; currentPrice = tokenPrice; _mint(foundersWallet, foundersAmount); } function setBonus(uint _bonus) public only(owner) { bonus = _bonus; } function setPrice(uint _tokenPrice) public only(owner) { currentPrice = _tokenPrice; } function setState(State _newState) public only(owner) { require( currentState == State.INIT && _newState == State.PRESALE || currentState == State.PRESALE && _newState == State.PREICO || currentState == State.PREICO && _newState == State.PREICO_FINISHED || currentState == State.PREICO_FINISHED && _newState == State.ICO_FIRST || currentState == State.ICO_FIRST && _newState == State.STOPPED || currentState == State.STOPPED && _newState == State.ICO_SECOND || currentState == State.ICO_SECOND && _newState == State.STOPPED || currentState == State.STOPPED && _newState == State.ICO_THIRD || currentState == State.ICO_THIRD && _newState == State.CLOSED || _newState == State.EMERGENCY_STOP ); currentState = _newState; if(_newState == State.PREICO || _newState == State.ICO_FIRST || _newState == State.ICO_SECOND || _newState == State.ICO_THIRD){ currentRoundSupply = 0; } if(_newState == State.CLOSED){ _finish(); } } function setStateWithBonus(State _newState, uint _bonus) public only(owner) { require( currentState == State.INIT && _newState == State.PRESALE || currentState == State.PRESALE && _newState == State.PREICO || currentState == State.PREICO && _newState == State.PREICO_FINISHED || currentState == State.PREICO_FINISHED && _newState == State.ICO_FIRST || currentState == State.ICO_FIRST && _newState == State.STOPPED || currentState == State.STOPPED && _newState == State.ICO_SECOND || currentState == State.ICO_SECOND && _newState == State.STOPPED || currentState == State.STOPPED && _newState == State.ICO_THIRD || currentState == State.ICO_THIRD && _newState == State.CLOSED || _newState == State.EMERGENCY_STOP ); currentState = _newState; bonus = _bonus; if(_newState == State.CLOSED){ _finish(); } } function mintPresale(address _to, uint _amount) public only(owner) inState(State.PRESALE) { require(totalSaleSupply.add(_amount) <= MAX_SALE_SUPPLY); totalSaleSupply = totalSaleSupply.add(_amount); _mint(_to, _amount); } function () public payable salesRunning minAmount { _receiveFunds(); } function _receiveFunds() internal { require(msg.value != 0); uint transferTokens = msg.value.mul(DECIMALS).div(currentPrice); require(totalSaleSupply.add(transferTokens) <= MAX_SALE_SUPPLY); uint bonusTokens = transferTokens.mul(bonus).div(bonusBase); transferTokens = transferTokens.add(bonusTokens); _checkMaxRoundSupply(transferTokens); totalSaleSupply = totalSaleSupply.add(transferTokens); balances[msg.sender] = balances[msg.sender].add(msg.value); totalFunds = totalFunds.add(msg.value); _mint(msg.sender, transferTokens); beneficiary.transfer(msg.value); Transfer(msg.sender, transferTokens); } function _mint(address _to, uint _amount) noAnyReentrancy internal { token.mint(_to, _amount); } function _checkMaxRoundSupply(uint _amountTokens) internal { if (currentState == State.PREICO) { require(currentRoundSupply.add(_amountTokens) <= maxPreICOSupply); } else if (currentState == State.ICO_FIRST) { require(currentRoundSupply.add(_amountTokens) <= maxICOFirstSupply); } else if (currentState == State.ICO_SECOND) { require(currentRoundSupply.add(_amountTokens) <= maxICOSecondSupply); } else if (currentState == State.ICO_THIRD) { require(currentRoundSupply.add(_amountTokens) <= maxICOThirdSupply); } } function _finish() noAnyReentrancy internal { token.start(); } } "}
{"sol name": "34073_0.sol", "label": 0, "sol content": "contract SafeMath { function safeMul(uint256 a, uint256 b) internal constant returns (uint256 ) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal constant returns (uint256 ) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal constant returns (uint256 ) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal constant returns (uint256 ) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20 { function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is ERC20, SafeMath { mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) returns (bool) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } else return false; } function transferFrom(address _from, address _to, uint256 _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } else return false; } function approve(address _spender, uint256 _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; address public pendingOwner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { pendingOwner = newOwner; } function claimOwnership() { if (msg.sender == pendingOwner) { owner = pendingOwner; pendingOwner = 0; } } } contract MultiOwnable { mapping (address => bool) ownerMap; address[] public owners; event OwnerAdded(address indexed _newOwner); event OwnerRemoved(address indexed _oldOwner); modifier onlyOwner() { require(isOwner(msg.sender)); _; } function MultiOwnable() { address owner = msg.sender; ownerMap[owner] = true; owners.push(owner); } function ownerCount() public constant returns (uint256) { return owners.length; } function isOwner(address owner) public constant returns (bool) { return ownerMap[owner]; } function addOwner(address owner) onlyOwner returns (bool) { if (!isOwner(owner) && owner != 0) { ownerMap[owner] = true; owners.push(owner); OwnerAdded(owner); return true; } else return false; } function removeOwner(address owner) onlyOwner returns (bool) { if (isOwner(owner)) { ownerMap[owner] = false; for (uint i = 0; i < owners.length - 1; i++) { if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } } owners.length -= 1; OwnerRemoved(owner); return true; } else return false; } } contract Pausable is Ownable { bool public paused; modifier ifNotPaused { require(!paused); _; } modifier ifPaused { require(paused); _; } function pause() external onlyOwner { paused = true; } function resume() external onlyOwner ifPaused { paused = false; } } contract TokenSpender { function receiveApproval(address _from, uint256 _value); } contract CommonBsToken is StandardToken, MultiOwnable { bool public locked; string public name; string public symbol; uint256 public totalSupply; uint8 public decimals = 18; string public version = 'v0.1'; address public creator; address public seller; uint256 public tokensSold; uint256 public totalSales; event Sell(address indexed _seller, address indexed _buyer, uint256 _value); event SellerChanged(address indexed _oldSeller, address indexed _newSeller); modifier onlyUnlocked() { if (!isOwner(msg.sender) && locked) throw; _; } function CommonBsToken(string _name, string _symbol, uint256 _totalSupplyNoDecimals, address _seller) MultiOwnable() { locked = true; creator = msg.sender; seller = _seller; name = _name; symbol = _symbol; totalSupply = _totalSupplyNoDecimals * 1e18; balances[seller] = totalSupply; Transfer(0x0, seller, totalSupply); } function changeSeller(address newSeller) onlyOwner returns (bool) { require(newSeller != 0x0 && seller != newSeller); address oldSeller = seller; uint256 unsoldTokens = balances[oldSeller]; balances[oldSeller] = 0; balances[newSeller] = safeAdd(balances[newSeller], unsoldTokens); Transfer(oldSeller, newSeller, unsoldTokens); seller = newSeller; SellerChanged(oldSeller, newSeller); return true; } function sellNoDecimals(address _to, uint256 _value) returns (bool) { return sell(_to, _value * 1e18); } function sell(address _to, uint256 _value) onlyOwner returns (bool) { if (balances[seller] >= _value && _value > 0) { balances[seller] = safeSub(balances[seller], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(seller, _to, _value); tokensSold = safeAdd(tokensSold, _value); totalSales = safeAdd(totalSales, 1); Sell(seller, _to, _value); return true; } else return false; } function transfer(address _to, uint256 _value) onlyUnlocked returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) onlyUnlocked returns (bool) { return super.transferFrom(_from, _to, _value); } function lock() onlyOwner { locked = true; } function unlock() onlyOwner { locked = false; } function burn(uint256 _value) returns (bool) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] = safeSub(balances[msg.sender], _value) ; totalSupply = safeSub(totalSupply, _value); Transfer(msg.sender, 0x0, _value); return true; } else return false; } function approveAndCall(address _spender, uint256 _value) { TokenSpender spender = TokenSpender(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value); } } } contract CommonBsPresale is SafeMath, Ownable, Pausable { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR } struct Backer { } mapping(address => Backer) public backers; mapping(uint8 => mapping(bytes32 => uint256)) public externalTxs; uint256 public maxCapWei      = 50000 ether; uint public tokensPerWeiBonus333 = 1333; uint public tokensPerWeiBonus250 = 1250; uint public tokensPerWeiBonus111 = 1111; event BeneficiaryChanged(address indexed _oldAddress, address indexed _newAddress); event NotifierChanged(address indexed _oldAddress, address indexed _newAddress); event EthReceived(address indexed _buyer, uint256 _amountWei); event ExternalSale(Currency _currency, bytes32 _txIdSha3, address indexed _buyer, uint256 _amountWei, uint256 _tokensE18); modifier respectTimeFrame() { require(isSaleOn()); _; } modifier canNotify() { require(msg.sender == owner || msg.sender == notifier); _; } function CommonBsPresale(address _token, address _beneficiary) { token = CommonBsToken(_token); owner = msg.sender; notifier = owner; beneficiary = _beneficiary; } function getNow() public constant returns (uint) { return now; } function setSaleEnabled(bool _enabled) public onlyOwner { saleEnabled = _enabled; } function setBeneficiary(address _beneficiary) public onlyOwner { BeneficiaryChanged(beneficiary, _beneficiary); beneficiary = _beneficiary; } function setNotifier(address _notifier) public onlyOwner { NotifierChanged(notifier, _notifier); notifier = _notifier; } function() public payable { if (saleEnabled) sellTokensForEth(msg.sender, msg.value); } function sellTokensForEth(address _buyer, uint256 _amountWei) internal ifNotPaused respectTimeFrame { totalInWei = safeAdd(totalInWei, _amountWei); weiReceived = safeAdd(weiReceived, _amountWei); uint256 tokensE18 = weiToTokens(_amountWei); require(tokensE18 >= minTokensToBuy); totalTokensSold = safeAdd(totalTokensSold, tokensE18); totalEthSales++; Backer backer = backers[_buyer]; backer.tokensSent = safeAdd(backer.tokensSent, tokensE18); EthReceived(_buyer, _amountWei); } function weiToTokens(uint256 _amountWei) public constant returns (uint256) { return weiToTokensAtTime(_amountWei, getNow()); } function weiToTokensAtTime(uint256 _amountWei, uint _time) public constant returns (uint256) { uint256 rate = tokensPerWei; if (startTime <= _time && _time < bonusEndTime333) rate = tokensPerWeiBonus333; else if (bonusEndTime333 <= _time && _time < bonusEndTime250) rate = tokensPerWeiBonus250; else if (bonusEndTime250 <= _time && _time < endTime) rate = tokensPerWeiBonus111; return safeMul(_amountWei, rate); } function externalSales( uint8[] _currencies, bytes32[] _txIdSha3, address[] _buyers, uint256[] _amountsWei, uint256[] _tokensE18 ) public ifNotPaused canNotify { require(_currencies.length > 0); require(_currencies.length == _txIdSha3.length); require(_currencies.length == _buyers.length); require(_currencies.length == _amountsWei.length); require(_currencies.length == _tokensE18.length); for (uint i = 0; i < _txIdSha3.length; i++) { _externalSaleSha3( Currency(_currencies[i]), _txIdSha3[i], _buyers[i], _amountsWei[i], _tokensE18[i] ); } } function _externalSaleSha3( Currency _currency, address _buyer, uint256 _amountWei, uint256 _tokensE18 ) internal { require(_buyer > 0 && _amountWei > 0 && _tokensE18 > 0); var txsByCur = externalTxs[uint8(_currency)]; require(txsByCur[_txIdSha3] == 0); totalInWei = safeAdd(totalInWei, _amountWei); totalTokensSold = safeAdd(totalTokensSold, _tokensE18); totalExternalSales++; txsByCur[_txIdSha3] = _tokensE18; ExternalSale(_currency, _txIdSha3, _buyer, _amountWei, _tokensE18); } function btcId() public constant returns (uint8) { return uint8(Currency.BTC); } function ltcId() public constant returns (uint8) { return uint8(Currency.LTC); } function zecId() public constant returns (uint8) { return uint8(Currency.ZEC); } function dashId() public constant returns (uint8) { return uint8(Currency.DASH); } function wavesId() public constant returns (uint8) { return uint8(Currency.WAVES); } function usdId() public constant returns (uint8) { return uint8(Currency.USD); } function eurId() public constant returns (uint8) { return uint8(Currency.EUR); } function _tokensByTx(Currency _currency, string _txId) internal constant returns (uint256) { return tokensByTx(uint8(_currency), _txId); } function tokensByTx(uint8 _currency, string _txId) public constant returns (uint256) { return externalTxs[_currency][keccak256(_txId)]; } function tokensByBtcTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.BTC, _txId); } function tokensByLtcTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.LTC, _txId); } function tokensByZecTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.ZEC, _txId); } function tokensByDashTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.DASH, _txId); } function tokensByWavesTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.WAVES, _txId); } function tokensByUsdTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.USD, _txId); } function tokensByEurTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.EUR, _txId); } function totalSales() public constant returns (uint256) { return safeAdd(totalEthSales, totalExternalSales); } function isMaxCapReached() public constant returns (bool) { return totalInWei >= maxCapWei; } function isSaleOn() public constant returns (bool) { uint _now = getNow(); return startTime <= _now && _now <= endTime; } function isSaleOver() public constant returns (bool) { return getNow() > endTime; } function isFinalized() public constant returns (bool) { return finalizedTime > 0; } function finalize() public onlyOwner { require(isMaxCapReached() || isSaleOver()); beneficiary.transfer(this.balance); finalizedTime = getNow(); } } contract JobeumPresale is CommonBsPresale { function JobeumPresale() CommonBsPresale( ) {} } "}
{"sol name": "9753_0.sol", "label": 0, "sol content": "contract ABEToken { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply = 50000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = \"ABE TOKEN\"; symbol = \"ABE\"; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } } "}
{"sol name": "13859_0.sol", "label": 0, "sol content": "contract Admin { address public\tadmin; bool\tpublic\tpause; modifier assertAdmin() { if ( msg.sender != admin ) { revert(); } _; } function setAdmin( address _admin ) assertAdmin public { admin = _admin; } function setPause (bool state) assertAdmin public { pause = state; } function setVersion(string _version) assertAdmin public { version = _version; } function setNextVersionAddress(address _nextVersionAddress) assertAdmin public{ nextVersionAddress = _nextVersionAddress; } function setOrderEnd() assertAdmin public { orderEnd = true; } function setFeeAccount( address _feeAccount ) assertAdmin public { feeAccount = _feeAccount; } function setFeeTake( uint _feeTake ) assertAdmin public { feeTake = _feeTake; } } contract SafeMath { function safeMul( uint a, uint b ) pure internal returns ( uint ) { uint \tc; c = a * b; assert( a == 0 || c / a == b ); return c; } function safeSub( uint a, uint b ) pure internal returns ( uint ) { assert( b <= a ); return a - b; } function safeAdd( uint a, uint b ) pure internal returns ( uint ) { uint \tc; c = a + b; assert( c >= a && c >= b ); return c; } } contract Token { function transfer( address _to, uint256 _value ) public returns ( bool success ); function transferFrom( address _from, address _to, uint256 _value ) public returns ( bool success ); event Transfer( address indexed _from, address indexed _to, uint256 _value ); } contract Exchange is SafeMath, Admin { mapping( address => mapping( address => uint )) public tokens; mapping( address => mapping( bytes32 => bool )) public orders; mapping( bytes32 => mapping( address => uint )) public ordersBalance; event Deposit( address token, address user, uint amount, uint balance ); event Withdraw( address token, address user, uint amount, uint balance ); event Order( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event OrderCancel( address user, address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ); event Trade( address makeAddress, address tokenMake, uint amountGiveMake, address takeAddress, address tokenTake, uint quantityTake, uint feeTakeXfer, uint balanceOrder ); event HashOutput(bytes32 hash); constructor( address _admin, address _feeAccount, uint _feeTake, string _version) public { admin = _admin; feeAccount = _feeAccount; feeTake = _feeTake; orderEnd = false; version = _version; pause = false; } function \tdepositEth() payable public { assertQuantity( msg.value ); tokens[0][msg.sender] = safeAdd( tokens[0][msg.sender], msg.value ); emit Deposit( 0, msg.sender, msg.value, tokens[0][msg.sender] ); } function \twithdrawEth( uint amount ) public { assertQuantity( amount ); tokens[0][msg.sender] = safeSub( tokens[0][msg.sender], amount ); msg.sender.transfer( amount ); emit Withdraw( 0, msg.sender, amount, tokens[0][msg.sender] ); } function \tdepositToken( address token, uint amount ) public { assertToken( token ); assertQuantity( amount ); tokens[token][msg.sender] = safeAdd( tokens[token][msg.sender], amount ); if ( Token( token ).transferFrom( msg.sender, this, amount ) == false ) { revert(); } emit\tDeposit( token, msg.sender, amount , tokens[token][msg.sender] ); } function \twithdrawToken( address token, uint amount ) public { assertToken( token ); assertQuantity( amount ); if ( Token( token ).transfer( msg.sender, amount ) == false ) { revert(); } emit Withdraw( token, msg.sender, amount, tokens[token][msg.sender] ); } function \torder( address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ) public { bytes32 \thash; assertQuantity( amountTake ); assertQuantity( amountMake ); assertCompareBalance( amountMake, tokens[tokenMake][msg.sender] ); if ( orderEnd == true ) revert(); hash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce ); orders[msg.sender][hash] = true; tokens[tokenMake][msg.sender] = safeSub( tokens[tokenMake][msg.sender], amountMake ); ordersBalance[hash][msg.sender] = amountMake; emit HashOutput(hash); emit Order( msg.sender, tokenTake, amountTake, tokenMake, amountMake, nonce ); } function \torderCancel( address tokenTake, uint amountTake, address tokenMake, uint amountMake, uint nonce ) public { bytes32 \thash; assertQuantity( amountTake ); assertQuantity( amountMake ); hash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce ); orders[msg.sender][hash] = false; tokens[tokenMake][msg.sender] = safeAdd( tokens[tokenMake][msg.sender], ordersBalance[hash][msg.sender]); ordersBalance[hash][msg.sender] = 0; emit OrderCancel( msg.sender, tokenTake, amountTake, tokenMake, amountMake, nonce ); } function \ttrade( address tokenTake, address tokenMake, uint amountTake, uint amountMake, uint nonce, address makeAddress, uint quantityTake ) public { bytes32 \thash; uint \t\tamountGiveMake; assertPause(); assertQuantity( quantityTake ); hash = keccak256( this, tokenTake, tokenMake, amountTake, amountMake, nonce ); assertOrders( makeAddress, hash ); amountGiveMake = safeMul( amountMake, quantityTake ) / amountTake; assertCompareBalance ( amountGiveMake, ordersBalance[hash][makeAddress] ); tradeBalances( tokenTake, tokenMake, amountTake, amountMake, makeAddress, quantityTake, hash); emit HashOutput(hash); } function \ttradeBalances( address tokenGet, address tokenGive, uint amountGet, uint amountGive, address user, uint amount, bytes32 hash) private { uint \t\tfeeTakeXfer; uint \t\tamountGiveMake; feeTakeXfer = safeMul( amount, feeTake ) / ( 1 ether ); amountGiveMake = safeMul( amountGive, amount ) / amountGet; tokens[tokenGet][msg.sender] = safeSub( tokens[tokenGet][msg.sender], safeAdd( amount, feeTakeXfer ) ); tokens[tokenGet][user] = safeAdd( tokens[tokenGet][user], amount ); tokens[tokenGet][feeAccount] = safeAdd( tokens[tokenGet][feeAccount], feeTakeXfer ); ordersBalance[hash][user] = safeSub( ordersBalance[hash][user], safeMul( amountGive, amount ) / amountGet ); tokens[tokenGive][msg.sender] = safeAdd( tokens[tokenGive][msg.sender], safeMul( amountGive, amount ) / amountGet ); emit Trade( user, tokenGive, amountGiveMake, msg.sender, tokenGet, amount, feeTakeXfer, ordersBalance[hash][user] ); emit HashOutput(hash); } function \tassertQuantity( uint amount ) pure private { if ( amount == 0 ) { revert(); } } function\tassertPause() view private { if ( pause == true ) { revert(); } } function \tassertToken( address token ) pure private { if ( token == 0 ) { revert(); } } function \tassertOrders( address makeAddress, bytes32 hash ) view private { if ( orders[makeAddress][hash] == false ) { revert(); } } function \tassertCompareBalance( uint a, uint b ) pure private { if ( a > b ) { revert(); } } } "}
{"sol name": "37036_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } } contract ERC223 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function name() constant returns (string _name); function symbol() constant returns (string _symbol); function decimals() constant returns (uint8 _decimals); function totalSupply() constant returns (uint256 _supply); function transfer(address to, uint value) returns (bool ok); function transfer(address to, uint value, bytes data) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } contract ContractReceiver { function tokenFallback(address _from, uint _value, bytes _data); } contract SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeAdd(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x > MAX_UINT256 - y) throw; return x + y; } function safeSub(uint256 x, uint256 y) constant internal returns (uint256 z) { if (x < y) throw; return x - y; } function safeMul(uint256 x, uint256 y) constant internal returns (uint256 z) { if (y == 0) return 0; if (x > MAX_UINT256 / y) throw; return x * y; } } contract ERC223Token_STA is ERC223, SafeMath, Ownable { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint) balances; uint256 block; address minerAddress; } function ERC223Token_STA() { decimals = 8; multiplier = 10**uint256(decimals); } function claimMiningReward() { if (minedTokenCount * multiplier >= maxSupply) throw; if (minedTokenCount > 0) { for (uint256 i = 0; i < minedTokenCount; i++) { if (minedTokens[i].block == block.number) throw; } } totalSupply += 1 * multiplier; minedTokens[minedTokenCount] = Miner(block.number, block.coinbase); minedTokenCount += 1; MessageClaimMiningReward(block.coinbase, block.number, 1 * multiplier); } function selfDestroy() onlyOwner { suicide(this); } function name() constant returns (string _name) { return name; } function symbol() constant returns (string _symbol) { return symbol; } function decimals() constant returns (uint8 _decimals) { return decimals; } function totalSupply() constant returns (uint256 _totalSupply) { return totalSupply; } function minedTokenCount() constant returns (uint256 _minedTokenCount) { return minedTokenCount; } function icoAddress() constant returns (address _icoAddress) { return icoAddress; } function transfer(address _to, uint _value, bytes _data) returns (bool success) { if(isContract(_to)) { transferToContract(_to, _value, _data); } else { transferToAddress(_to, _value, _data); } return true; } function transfer(address _to, uint _value) returns (bool success) { bytes memory empty; if(isContract(_to)) { transferToContract(_to, _value, empty); } else { transferToAddress(_to, _value, empty); } return true; } function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } if(length>0) { return true; } else { return false; } } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function burn(address _address, uint256 _value) returns (bool success) { if (icoAddress == address(0)) throw; totalSupply -= _value; Burn(_address, _value); return true; } function setIcoAddress(address _address) onlyOwner { if (icoAddress == address(0)) { icoAddress = _address; } else throw; } } contract ERC223Token_STB is ERC223, SafeMath, Ownable { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping(address => uint) balances; uint256 public maxSupply; uint256 public icoEndBlock; address public icoAddress; function ERC223Token_STB() { } function maxSupply() constant returns (uint256 _maxSupply) { return maxSupply; } function name() constant returns (string _name) { return name; } function symbol() constant returns (string _symbol) { return symbol; } function decimals() constant returns (uint8 _decimals) { return decimals; } function totalSupply() constant returns (uint256 _totalSupply) { return totalSupply; } function icoAddress() constant returns (address _icoAddress) { return icoAddress; } function transfer(address _to, uint _value, bytes _data) returns (bool success) { if(isContract(_to)) { transferToContract(_to, _value, _data); } else { transferToAddress(_to, _value, _data); } return true; } function transfer(address _to, uint _value) returns (bool success) { bytes memory empty; if(isContract(_to)) { transferToContract(_to, _value, empty); } else { transferToAddress(_to, _value, empty); } return true; } function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } if(length>0) { return true; } else { return false; } } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); Transfer(msg.sender, _to, _value, _data); return true; } function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) throw; balances[msg.sender] = safeSub(balanceOf(msg.sender), _value); balances[_to] = safeAdd(balanceOf(_to), _value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); Transfer(msg.sender, _to, _value, _data); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function setIcoAddress(address _address) onlyOwner { if (icoAddress == address(0)) { icoAddress = _address; } else throw; } function mint(address _receiver, uint256 _amount) { if (icoAddress == address(0)) throw; if (safeAdd(totalSupply, _amount) > maxSupply) throw; totalSupply = safeAdd(totalSupply, _amount); balances[_receiver] = safeAdd(balances[_receiver], _amount); Transfer(0, _receiver, _amount, new bytes(0)); } suicide(this); } } contract StableICO is Ownable, SafeMath { address donorAddress; uint256 ethAmount; uint256 block; bool exchangedOrRefunded; uint256 stbAmount; } address minerAddress; uint256 staAmount; uint256 block; bool exchanged; uint256 stbAmount; } event Transfer(address indexed from, address indexed to, uint256 value); event MessageExchangeEthStb(address from, uint256 eth, uint256 stb); event MessageExchangeStaStb(address from, uint256 sta, uint256 stb); event MessageReceiveEth(address from, uint256 eth, uint256 block); event MessageReceiveSta(address from, uint256 sta, uint256 block); event MessageRefundEth(address donor_address, uint256 eth); function StableICO() { } function claimMiningReward() public onlyOwner { sta.claimMiningReward(); } function tokenFallback(address _from, uint256 _value, bytes _data) { if (block.number < icoStartBlock) throw; if (msg.sender == address(sta)) { receivedSta[minerNum] = Miner(_from, _value, block.number, false, 0); minerNum += 1; receivedStaAmount = safeAdd(receivedStaAmount, _value); MessageReceiveSta(_from, _value, block.number); } else throw; } else if(msg.sender == address(stb)) { MessageReceiveStb(_from, _value, block.number, _data); } else { } } function () payable { if (block.number < icoStartBlock) { if (msg.sender == owner) { ownersEth = safeAdd(ownersEth, msg.value); } else { totalFunded = safeAdd(totalFunded, msg.value); donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0); donationNum += 1; MessageReceiveEth(msg.sender, msg.value, block.number); } } else if (block.number >= icoStartBlock && block.number <= icoEndBlock) { if (msg.sender != owner) { totalFunded = safeAdd(totalFunded, msg.value); donations[donationNum] = Donor(msg.sender, msg.value, block.number, false, 0); donationNum += 1; MessageReceiveEth(msg.sender, msg.value, block.number); } else ownersEth = safeAdd(ownersEth, msg.value); } else if (block.number > icoEndBlock) { if (!isIcoFinished) { isIcoFinished = true; if (totalFunded >= crowdfundingTarget) { isIcoSucceeded = true; exchangeStaStb(0, minerNum); exchangeEthStb(0, donationNum); drawdown(); } else { refund(0, donationNum); } } else { ownersEth = safeAdd(ownersEth, msg.value); } } else { } } function exchangeStaStb(uint256 _from, uint256 _to) private { if (!isIcoSucceeded) throw; uint256 _sta2stb = 10**4; uint256 _wei2stb = 10**14; if (!isStbMintedForStaEx) { oneStaIsStb = _mintAmount / 100; stb.mint(address(this), _mintAmount); isStbMintedForStaEx = true; } uint256 _toBurn = 0; for (uint256 i = _from; i < _to; i++) { stb.transfer(receivedSta[i].minerAddress, receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4); receivedSta[i].exchanged = true; receivedSta[i].stbAmount = receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4; _toBurn += receivedSta[i].staAmount; MessageExchangeStaStb(receivedSta[i].minerAddress, receivedSta[i].staAmount, receivedSta[i].staAmount/_sta2stb * oneStaIsStb / 10**4); } } function exchangeEthStb(uint256 _from, uint256 _to) private { if (!isIcoSucceeded) throw; uint _pb = (icoEndBlock - icoStartBlock)/4; uint _bonus; uint256 _mintAmount = 0; for (uint256 i = _from; i < _to; i++) { _mintAmount += 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); } stb.mint(address(this), _mintAmount); for (i = _from; i < _to; i++) { stb.transfer(donations[i].donorAddress, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100) ); donations[i].exchangedOrRefunded = true; donations[i].stbAmount = 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100); MessageExchangeEthStb(donations[i].donorAddress, donations[i].ethAmount, 10 * ( (100 + _bonus) * (donations[i].ethAmount / _wei2stb) / 100)); } } function drawdown() private { if (!isIcoSucceeded || isDonatedEthTransferred) throw; beneficiary.transfer(totalFunded); isDonatedEthTransferred = true; } function refund(uint256 _from, uint256 _to) private { if (!isIcoFinished || isIcoSucceeded) throw; if (_from >= _to) return; for (uint256 i = _from; i < _to; i++) { if (donations[i].exchangedOrRefunded) continue; donations[i].donorAddress.transfer(donations[i].ethAmount); donations[i].exchangedOrRefunded = true; MessageRefundEth(donations[i].donorAddress, donations[i].ethAmount); } } function transferEthToOwner(uint256 _amount) public onlyOwner { if (!isIcoFinished || _amount <= 0 || _amount > ownersEth) throw; owner.transfer(_amount); ownersEth -= _amount; } function transferStbToOwner(uint256 _amount) public onlyOwner { if (!isIcoFinished || _amount <= 0) throw; stb.transfer(owner, _amount); } function backup_finishIcoVars() public onlyOwner { if (block.number <= icoEndBlock || isIcoFinished) throw; isIcoFinished = true; if (totalFunded >= crowdfundingTarget) isIcoSucceeded = true; } function backup_exchangeStaStb(uint256 _from, uint256 _to) public onlyOwner { exchangeStaStb(_from, _to); } function backup_exchangeEthStb(uint256 _from, uint256 _to) public onlyOwner { exchangeEthStb(_from, _to); } function backup_drawdown() public onlyOwner { drawdown(); } function backup_drawdown_amount(uint256 _amount) public onlyOwner { if (!isIcoSucceeded) throw; beneficiary.transfer(_amount); } function backup_refund(uint256 _from, uint256 _to) public onlyOwner { refund(_from, _to); } suicide(this); } } "}
{"sol name": "12684_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract GerritCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function GerritCoin() public { symbol = \"G\u00a2\"; name = \"Gerrit Coin\"; decimals = 1; _totalSupply = 1000000000; balances[0x14d45c2fB482a78Ce0AF9D8F1C7a0c18af9357D5] = _totalSupply; Transfer(address(0), 0x14d45c2fB482a78Ce0AF9D8F1C7a0c18af9357D5, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "19116_0.sol", "label": 0, "sol content": "Copyright (c) 2015-2016 Oraclize SRL Copyright (c) 2016 Oraclize LTD Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) payable returns (bytes32 _id); function getPrice(string _datasource) returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) returns (uint _dsprice); function useCoupon(string _coupon); function setProofType(byte _proofType); function setConfig(bytes32 _config); function setCustomGasPrice(uint _gasPrice); function randomDS_getSessionPubKeyHash() returns(bytes32); } contract OraclizeAddrResolverI { function getAddress() returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); oraclize.useCoupon(code); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); oraclize_setNetworkName(\"eth_mainnet\"); return true; } OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); oraclize_setNetworkName(\"eth_ropsten3\"); return true; } OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); oraclize_setNetworkName(\"eth_kovan\"); return true; } OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48); oraclize_setNetworkName(\"eth_rinkeby\"); return true; } OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) { } function oraclize_useCoupon(string code) oraclizeAPI internal { oraclize.useCoupon(code); } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_setConfig(bytes32 config) oraclizeAPI internal { return oraclize.setConfig(config); } function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){ return oraclize.randomDS_getSessionPubKeyHash(); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } function parseInt(string _a) internal returns (uint) { return parseInt(_a, 0); } function parseInt(string _a, uint _b) internal returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } function ba2cbor(bytes[] arr) internal returns (bytes) { uint arrlen = arr.length; uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } string oraclize_network_name; function oraclize_setNetworkName(string _network_name) internal { oraclize_network_name = _network_name; } function oraclize_getNetworkName() internal returns (string) { return oraclize_network_name; } function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){ if ((_nbytes == 0)||(_nbytes > 32)) throw; bytes memory nbytes = new bytes(1); nbytes[0] = byte(_nbytes); bytes memory unonce = new bytes(32); bytes memory sessionKeyHash = new bytes(32); bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash(); assembly { mstore(unonce, 0x20) mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp))) mstore(sessionKeyHash, 0x20) mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32) } bytes[3] memory args = [unonce, nbytes, sessionKeyHash]; bytes32 queryId = oraclize_query(_delay, \"random\", args, _customGasLimit); oraclize_randomDS_setCommitment(queryId, sha3(bytes8(_delay), args[1], sha256(args[0]), args[2])); return queryId; } function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal { oraclize_randomDS_args[queryId] = commitment; } mapping(bytes32=>bytes32) oraclize_randomDS_args; mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified; function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){ bool sigok; address signer; bytes32 sigr; bytes32 sigs; bytes memory sigr_ = new bytes(32); uint offset = 4+(uint(dersig[3]) - 0x20); sigr_ = copyBytes(dersig, offset, 32, sigr_, 0); bytes memory sigs_ = new bytes(32); offset += 32 + 2; sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0); assembly { sigr := mload(add(sigr_, 32)) sigs := mload(add(sigs_, 32)) } (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs); if (address(sha3(pubkey)) == signer) return true; else { (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs); return (address(sha3(pubkey)) == signer); } } function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) { bool sigok; bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2); copyBytes(proof, sig2offset, sig2.length, sig2, 0); bytes memory appkey1_pubkey = new bytes(64); copyBytes(proof, 3+1, 64, appkey1_pubkey, 0); bytes memory tosign2 = new bytes(1+65+32); copyBytes(proof, sig2offset-65, 65, tosign2, 1); bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\"; copyBytes(CODEHASH, 0, 32, tosign2, 1+65); sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey); if (sigok == false) return false; bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\"; bytes memory tosign3 = new bytes(1+65); tosign3[0] = 0xFE; copyBytes(proof, 3, 65, tosign3, 1); bytes memory sig3 = new bytes(uint(proof[3+65+1])+2); copyBytes(proof, 3+65, sig3.length, sig3, 0); sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY); return sigok; } modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) { if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) throw; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) throw; _; } function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){ if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) return 2; return 0; } function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal returns (bool){ bool match_ = true; for (uint256 i=0; i< n_random_bytes; i++) { if (content[i] != prefix[i]) match_ = false; } return match_; } function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){ uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32; bytes memory keyhash = new bytes(32); copyBytes(proof, ledgerProofLength, 32, keyhash, 0); if (!(sha3(keyhash) == sha3(sha256(context_name, queryId)))) return false; bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2); copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0); if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false; bytes memory commitmentSlice1 = new bytes(8+1+32); copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0); bytes memory sessionPubkey = new bytes(64); uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65; copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0); bytes32 sessionPubkeyHash = sha256(sessionPubkey); delete oraclize_randomDS_args[queryId]; } else return false; bytes memory tosign1 = new bytes(32+8+1+32); copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0); if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false; if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){ oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset); } return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]; } function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal returns (bytes) { uint minLength = length + toOffset; if (to.length < minLength) { } uint i = 32 + fromOffset; uint j = 32 + toOffset; while (i < (32 + fromOffset + length)) { assembly { let tmp := mload(add(from, i)) mstore(add(to, j), tmp) } i += 32; j += 32; } return to; } function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) } return (ret, addr); } function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) return (false, 0); assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) v := byte(0, mload(add(sig, 96))) } if (v < 27) v += 27; if (v != 27 && v != 28) return (false, 0); return safer_ecrecover(hash, v, r, s); } } contract LiverpoolvsManCity is usingOraclize { address public OWNERS = 0xC3eD2d481B9d75835EC04174b019A7eAF2Faf78A; uint public constant MIN_BET = 0.01 ether; uint public constant BETTING_OPENS = 1522660968; uint public ORACLIZE_GAS = 200000; bool public completed; bool public canceled; bool public ownersPayed; uint public ownerPayout; bool public returnedToOwners; uint public winnerDeterminedDate; uint public numCollected = 0; bytes32 public oraclizeQueryId; uint public oraclizeFees; uint public collectionFees; struct Better { uint betAmount; uint betOption; bool withdrawn; } mapping(address => Better) betterInfo; address[] public betters; uint[2] public totalAmountsBet; uint[2] public numberOfBets; uint public totalBetAmount; uint public winningOption = 2; event BetMade(); modifier canDetermineWinner() { require (winningOption == 2 && !completed && !canceled && now > BETTING_CLOSES && now >= EXPECTED_END); _; } modifier canEmptyRemainings() { require(canceled || completed); uint numRequiredToCollect = canceled ? (numberOfBets[0] + numberOfBets[1]) : numberOfBets[winningOption]; require ((now >= RETURN_DATE && !canceled) || (numCollected == numRequiredToCollect)); _; } modifier collectionsEnabled() { require (canceled || (winningOption != 2 && completed && now > BETTING_CLOSES)); _; } modifier canPayOwners() { require (!canceled && winningOption != 2 && completed && !ownersPayed && now > BETTING_CLOSES); _; } modifier bettingIsClosed() { require (now >= BETTING_CLOSES); _; } modifier onlyOwnerLevel() { require( OWNERS == msg.sender ); _; } function LiverpoolvsManCity() public payable { oraclize_setCustomGasPrice(1000000000); } function changeGasLimitAndPrice(uint gas, uint price) public onlyOwnerLevel { ORACLIZE_GAS = gas; oraclize_setCustomGasPrice(price); } function setExpectedTimes(uint _EXPECTED_START, uint _EXPECTED_END) public onlyOwnerLevel { setExpectedStart(_EXPECTED_START); setExpectedEnd(_EXPECTED_END); } function setExpectedStart(uint _EXPECTED_START) public onlyOwnerLevel { EXPECTED_START = _EXPECTED_START; BETTING_CLOSES = EXPECTED_START - 60; } function setExpectedEnd(uint _EXPECTED_END) payable public onlyOwnerLevel { require(_EXPECTED_END > EXPECTED_START); EXPECTED_END = _EXPECTED_END; CANCELATION_DATE = EXPECTED_END + 60 * 60 * 24; RETURN_DATE = EXPECTED_END + 60 * 60 * 24 * 30; } function callOracle(uint timeOrDelay, uint gas) private { oraclizeQueryId = makeOraclizeQuery(timeOrDelay, \"nested\", \"[computation] ['QmZ7x9mEdGeMLcu642gLVgVkoPbr3E1mq4kXLQ72qNS95r', '164861', '164862', '${[decrypt] BMIhQZOE/P50yfHqz+vAEVQn1PpdrwYx+7Hg7bx522F4SUi/CVGjezx6O8U42D1+vyfbl62/zyAmaPcTkYOcx3LtHtGOeqoO9rHh9x3w73vJMJEcW2rrYrbhI8ZinqdzsTpT3smk4SyQI/B7t7mvUDc=}']\", gas); } function makeOraclizeQuery(uint timeOrDelay, string datasource, string query, uint gas) private returns(bytes32) { oraclizeFees += oraclize_getPrice(datasource, gas); return oraclize_query(timeOrDelay, datasource, query, gas); } function determineWinner(uint gas, uint gasPrice) payable public onlyOwnerLevel canDetermineWinner { ORACLIZE_GAS = gas; oraclize_setCustomGasPrice(gasPrice); callOracle(0, ORACLIZE_GAS); } function __callback(bytes32 queryId, string result, bytes proof) public canDetermineWinner { require(msg.sender == oraclize_cbAddress()); uint winner = parseInt(result); if (winner != 0 && winner != 1) { if (now < CANCELATION_DATE) { callOracle(PING_ORACLE_INTERVAL, ORACLIZE_GAS); } else { cancel(); } } else { setWinner(winner); } } function setWinner(uint winner) private { completed = true; canceled = false; winningOption = winner; winnerDeterminedDate = now; payOwners(); } function getUserBet(address addr) public constant returns(uint[]) { uint[] memory bets = new uint[](2); bets[betterInfo[addr].betOption] = betterInfo[addr].betAmount; return bets; } function userHasWithdrawn(address addr) public constant returns(bool) { return betterInfo[addr].withdrawn; } function collectionsAvailable() public constant returns(bool) { } function canBet() public constant returns(bool) { return (now >= BETTING_OPENS && now < BETTING_CLOSES && !canceled && !completed); } function bet(uint option) public payable { require(canBet() == true); require(msg.value >= MIN_BET); require(betterInfo[msg.sender].betAmount == 0 || betterInfo[msg.sender].betOption == option); if (betterInfo[msg.sender].betAmount == 0) { betterInfo[msg.sender].betOption = option; numberOfBets[option]++; betters.push(msg.sender); } betterInfo[msg.sender].betAmount += msg.value; totalBetAmount += msg.value; totalAmountsBet[option] += msg.value; } function emptyRemainingsToOwners() private canEmptyRemainings { OWNERS.transfer(this.balance); returnedToOwners = true; } function returnToOwners() public onlyOwnerLevel canEmptyRemainings { emptyRemainingsToOwners(); } function payOwners() private canPayOwners { if (COMMISSION == 0) { ownersPayed = true; ownerPayout = 0; if (numberOfBets[winningOption] > 0) { } return; } uint losingChunk = totalAmountsBet[1 - winningOption]; if (numberOfBets[winningOption] > 0) { } OWNERS.transfer(ownerPayout); ownersPayed = true; } function cancelBet() payable public onlyOwnerLevel { cancel(); } function cancel() private { canceled = true; completed = false; } function() payable public { } function collect() public collectionsEnabled { address better = msg.sender; require(betterInfo[better].betAmount > 0); require(!betterInfo[better].withdrawn); require(canceled != completed); require(canceled || (completed && betterInfo[better].betOption == winningOption)); require(now >= (winnerDeterminedDate + 600)); uint payout = 0; if (!canceled) { uint losingChunk = totalAmountsBet[1 - winningOption]; payout = betterInfo[better].betAmount + (betterInfo[better].betAmount * (losingChunk - ownerPayout) / totalAmountsBet[winningOption]) - collectionFees; } else { payout = betterInfo[better].betAmount; } if (payout > 0) { better.transfer(payout); betterInfo[better].withdrawn = true; numCollected++; } } } "}
{"sol name": "7231_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30067200; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary =  0xe05fD02b6569F533751dDc4a5800019F3862EA76; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "13797_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract WEGC is StandardToken { function () { throw; } string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; function WEGC( ) { balances[msg.sender] = 10000000000000000; totalSupply = 10000000000000000; name = \"Wholesale eGift Cards\"; decimals = 4; symbol = \"WEGC\"; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "25067_0.sol", "label": 0, "sol content": "contract ERC721 { function approve(address _to, uint256 _tokenId) public; function balanceOf(address _owner) public view returns (uint256 balance); function implementsERC721() public pure returns (bool); function ownerOf(uint256 _tokenId) public view returns (address addr); function takeOwnership(uint256 _tokenId) public; function totalSupply() public view returns (uint256 total); function transferFrom(address _from, address _to, uint256 _tokenId) public; function transfer(address _to, uint256 _tokenId) public; event Transfer(address indexed from, address indexed to, uint256 tokenId); event Approval(address indexed owner, address indexed approved, uint256 tokenId); } contract EtherPizza is ERC721 { event Birth(uint256 tokenId, string name, address owner); event TokenSold(uint256 tokenId, uint256 oldPrice, uint256 newPrice, address prevOwner, address winner, string name); event Transfer(address from, address to, uint256 tokenId); uint256 private startingPrice = 0.001 ether; mapping (uint256 => address) public pizzaIndexToOwner; mapping (address => uint256) private ownershipTokenCount; mapping (uint256 => address) public pizzaIndexToApproved; mapping (uint256 => uint256) private pizzaIndexToPrice; mapping (uint256 => uint256) private pizzaIndexToPreviousPrice; mapping (uint256 => address[5]) private pizzaIndexToPreviousOwners; address public ceoAddress; address public cooAddress; struct Pizza { string name; } Pizza[] private pizzas; modifier onlyCEO() { require(msg.sender == ceoAddress); _; } modifier onlyCOO() { require(msg.sender == cooAddress); _; } modifier onlyCLevel() { require( msg.sender == ceoAddress || msg.sender == cooAddress ); _; } function EtherPizza() public { ceoAddress = msg.sender; cooAddress = msg.sender; } function approve( address _to, uint256 _tokenId ) public { require(_owns(msg.sender, _tokenId)); pizzaIndexToApproved[_tokenId] = _to; Approval(msg.sender, _to, _tokenId); } function balanceOf(address _owner) public view returns (uint256 balance) { return ownershipTokenCount[_owner]; } function createContractPizza(string _name) public onlyCOO { _createPizza(_name, address(this), startingPrice); } function getPizza(uint256 _tokenId) public view returns ( string pizzaName, uint256 sellingPrice, address owner, uint256 previousPrice, address[5] previousOwners ) { Pizza storage pizza = pizzas[_tokenId]; pizzaName = pizza.name; sellingPrice = pizzaIndexToPrice[_tokenId]; owner = pizzaIndexToOwner[_tokenId]; previousPrice = pizzaIndexToPreviousPrice[_tokenId]; previousOwners = pizzaIndexToPreviousOwners[_tokenId]; } function implementsERC721() public pure returns (bool) { return true; } function name() public pure returns (string) { return NAME; } function ownerOf(uint256 _tokenId) public view returns (address owner) { owner = pizzaIndexToOwner[_tokenId]; require(owner != address(0)); } function payout(address _to) public onlyCLevel { _payout(_to); } function purchase(uint256 _tokenId) public payable { address oldOwner = pizzaIndexToOwner[_tokenId]; address newOwner = msg.sender; address[5] storage previousOwners = pizzaIndexToPreviousOwners[_tokenId]; uint256 sellingPrice = pizzaIndexToPrice[_tokenId]; uint256 previousPrice = pizzaIndexToPreviousPrice[_tokenId]; require(oldOwner != newOwner); require(_addressNotNull(newOwner)); require(msg.value >= sellingPrice); uint256 priceDelta = SafeMath.sub(sellingPrice, previousPrice); uint256 ownerPayout = SafeMath.add(previousPrice, SafeMath.mul(SafeMath.div(priceDelta, 100), 40)); uint256 purchaseExcess = SafeMath.sub(msg.value, sellingPrice); pizzaIndexToPrice[_tokenId] = SafeMath.div(SafeMath.mul(sellingPrice, 125), 100); pizzaIndexToPreviousPrice[_tokenId] = sellingPrice; uint256 strangePrice = uint256(SafeMath.mul(SafeMath.div(priceDelta, 100), 10)); if (oldOwner != address(this)) { oldOwner.transfer(ownerPayout); } else { strangePrice = SafeMath.add(ownerPayout, strangePrice); } for (uint i = 0; i < 5; i++) { if (previousOwners[i] != address(this)) { previousOwners[i].transfer(uint256(SafeMath.mul(SafeMath.div(priceDelta, 100), 10))); } else { strangePrice = SafeMath.add(strangePrice, uint256(SafeMath.mul(SafeMath.div(priceDelta, 100), 10))); } } ceoAddress.transfer(strangePrice); _transfer(oldOwner, newOwner, _tokenId); msg.sender.transfer(purchaseExcess); } function priceOf(uint256 _tokenId) public view returns (uint256 price) { return pizzaIndexToPrice[_tokenId]; } function setCEO(address _newCEO) public onlyCEO { require(_newCEO != address(0)); ceoAddress = _newCEO; } function setCOO(address _newCOO) public onlyCEO { require(_newCOO != address(0)); cooAddress = _newCOO; } function symbol() public pure returns (string) { return SYMBOL; } function takeOwnership(uint256 _tokenId) public { address newOwner = msg.sender; address oldOwner = pizzaIndexToOwner[_tokenId]; require(_addressNotNull(newOwner)); require(_approved(newOwner, _tokenId)); _transfer(oldOwner, newOwner, _tokenId); } function tokensOfOwner(address _owner) public view returns(uint256[] ownerTokens) { uint256 tokenCount = balanceOf(_owner); if (tokenCount == 0) { return new uint256[](0); } else { uint256[] memory result = new uint256[](tokenCount); uint256 totalPizzas = totalSupply(); uint256 resultIndex = 0; uint256 pizzaId; for (pizzaId = 0; pizzaId <= totalPizzas; pizzaId++) { if (pizzaIndexToOwner[pizzaId] == _owner) { result[resultIndex] = pizzaId; resultIndex++; } } return result; } } function totalSupply() public view returns (uint256 total) { return pizzas.length; } function transfer( address _to, uint256 _tokenId ) public { require(_owns(msg.sender, _tokenId)); require(_addressNotNull(_to)); _transfer(msg.sender, _to, _tokenId); } function transferFrom( address _from, address _to, uint256 _tokenId ) public { require(_owns(_from, _tokenId)); require(_approved(_to, _tokenId)); require(_addressNotNull(_to)); _transfer(_from, _to, _tokenId); } function _addressNotNull(address _to) private pure returns (bool) { return _to != address(0); } function _approved(address _to, uint256 _tokenId) private view returns (bool) { return pizzaIndexToApproved[_tokenId] == _to; } function _createPizza(string _name, address _owner, uint256 _price) private { Pizza memory _pizza = Pizza({ name: _name }); uint256 newPizzaId = pizzas.push(_pizza) - 1; require(newPizzaId == uint256(uint32(newPizzaId))); Birth(newPizzaId, _name, _owner); pizzaIndexToPrice[newPizzaId] = _price; pizzaIndexToPreviousPrice[newPizzaId] = 0; pizzaIndexToPreviousOwners[newPizzaId] = [address(this), address(this), address(this), address(this)]; _transfer(address(0), _owner, newPizzaId); } function _owns(address claimant, uint256 _tokenId) private view returns (bool) { return claimant == pizzaIndexToOwner[_tokenId]; } function _payout(address _to) private { if (_to == address(0)) { ceoAddress.transfer(this.balance); } else { _to.transfer(this.balance); } } function _transfer(address _from, address _to, uint256 _tokenId) private { ownershipTokenCount[_to]++; pizzaIndexToOwner[_tokenId] = _to; if (_from != address(0)) { ownershipTokenCount[_from]--; delete pizzaIndexToApproved[_tokenId]; } pizzaIndexToPreviousOwners[_tokenId][4]=pizzaIndexToPreviousOwners[_tokenId][3]; pizzaIndexToPreviousOwners[_tokenId][3]=pizzaIndexToPreviousOwners[_tokenId][2]; pizzaIndexToPreviousOwners[_tokenId][2]=pizzaIndexToPreviousOwners[_tokenId][1]; pizzaIndexToPreviousOwners[_tokenId][1]=pizzaIndexToPreviousOwners[_tokenId][0]; if (_from != address(0)) { pizzaIndexToPreviousOwners[_tokenId][0]=_from; } else { pizzaIndexToPreviousOwners[_tokenId][0]=address(this); } Transfer(_from, _to, _tokenId); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "38203_0.sol", "label": 0, "sol content": "contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } function halt() external onlyOwner { halted = true; } function unhalt() external onlyOwner onlyInEmergency { halted = false; } } contract PricingStrategy { function isPricingStrategy() public constant returns (bool) { return true; } function isSane(address crowdsale) public constant returns (bool) { return true; } function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } function isSane() public constant returns (bool); function finalizeCrowdsale(); } contract ERC20 { uint public totalSupply; function balanceOf(address who) constant returns (uint); function allowance(address owner, address spender) constant returns (uint); function transfer(address to, uint value) returns (bool ok); function transferFrom(address from, address to, uint value) returns (bool ok); function approve(address spender, uint value) returns (bool ok); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract FractionalERC20 is ERC20 { uint public decimals; } contract Crowdsale is Haltable, SafeMath { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; FractionalERC20 public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; mapping (address => bool) public earlyParticipantWhitelist; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} event Invested(address investor, uint weiAmount, uint tokenAmount); event Refund(address investor, uint weiAmount); event Whitelisted(address addr, bool status); event EndsAtChanged(uint endsAt); function Crowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal) { owner = msg.sender; token = FractionalERC20(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; } function() payable { investInternal(msg.sender); } function investInternal(address receiver) stopInEmergency private { if(getState() == State.PreFunding) { if(!earlyParticipantWhitelist[receiver]) { throw; } } else if(getState() == State.Funding) { } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(investedAmountOf[receiver] == 0) { investorCount++; } investedAmountOf[receiver] = safeAdd(investedAmountOf[receiver], weiAmount); tokenAmountOf[receiver] = safeAdd(tokenAmountOf[receiver], tokenAmount); weiRaised = safeAdd(weiRaised, weiAmount); tokensSold = safeAdd(tokensSold, tokenAmount); if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; Invested(receiver, weiAmount, tokenAmount); } function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { throw; } } function setEarlyParicipantWhitelist(address addr, bool status) onlyOwner { earlyParticipantWhitelist[addr] = status; Whitelisted(addr, status); } function setEndsAt(uint time) onlyOwner { if(now > time) { } endsAt = time; EndsAtChanged(endsAt); } function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } } function setMultisig(address addr) public onlyOwner { if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = safeAdd(loadedRefund, msg.value); } function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = safeAdd(weiRefunded, weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } function isCrowdsale() public constant returns (bool) { return true; } modifier inState(State state) { if(getState() != state) throw; _; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); function isCrowdsaleFull() public constant returns (bool); function assignTokens(address receiver, uint tokenAmount) private; } contract WWAMPricingStrategy is PricingStrategy, Ownable, SafeMath { uint round1BeginsAt; uint round2BeginsAt; uint finalRoundBeginsAt; enum CurrentRound { Round1, Round2, Final } function WWAMPricingStrategy(uint _round1BeginsAt, uint _round2BeginsAt, uint _finalRoundBeginsAt) { round1BeginsAt = _round1BeginsAt; round2BeginsAt = _round2BeginsAt; finalRoundBeginsAt = _finalRoundBeginsAt; } function getCurrentRound() public returns (CurrentRound){ if (now < round2BeginsAt) return CurrentRound.Round1; else if (now < finalRoundBeginsAt) return CurrentRound.Round2; return CurrentRound.Final; } function tokensToWei(uint tokens) public constant returns (uint) { return safeMul(tokens, baseRate); } function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { if (value < 10 finney) return 0; if (getCurrentRound() == CurrentRound.Round1) return safeMul(safeDiv(safeDiv(value, baseRate), 100), 115); else if (getCurrentRound() == CurrentRound.Round2) return safeMul(safeDiv(safeDiv(value, baseRate), 100), 110); return value / baseRate; } } contract StandardToken is ERC20, SafeMath { event Minted(address receiver, uint amount); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract WWAMBountyToken is StandardToken, Ownable { mapping (address => bool) public bountyAgents; event BountyAgentChanged(address addr, bool state  ); function revokeTokens(address receiver, uint tokenAmount) onlyBountyAgent { if (balances[receiver] >= tokenAmount) { totalSupply = safeSub(totalSupply, tokenAmount); balances[receiver] = safeSub(balances[receiver], tokenAmount); } } function setBountyAgent(address addr, bool state) onlyOwner public { bountyAgents[addr] = state; BountyAgentChanged(addr, state); } modifier onlyBountyAgent() { if(!bountyAgents[msg.sender]) { throw; } _; } } contract MintableToken is StandardToken, Ownable { bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = safeAdd(totalSupply, amount); balances[receiver] = safeAdd(balances[receiver], amount); Transfer(0, receiver, amount); } function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } modifier onlyMintAgent() { if(!mintAgents[msg.sender]) { throw; } _; } modifier canMint() { if(mintingFinished) throw; _; } } contract WWAMCrowdsale is Crowdsale { uint public bountyTokens = 0; mapping (address => uint256) public bountyRewards; function WWAMCrowdsale(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end) } function assignBountyTokens(address receiver, uint tokenAmount) onlyOwner { uint bountyWeiAmount = WWAMPricingStrategy(pricingStrategy).tokensToWei(tokenAmount); uint totalBountyWeiAmount = WWAMPricingStrategy(pricingStrategy).tokensToWei(bountyTokens); if (safeAdd(bountyWeiAmount, totalBountyWeiAmount) >= (investmentCapInWei / 100)) throw; bountyRewards[receiver] = safeAdd(bountyRewards[receiver], tokenAmount); bountyTokens = safeAdd(bountyTokens, tokenAmount); assignTokens(receiver, tokenAmount); } function revokeBountyTokens(address receiver, uint tokenAmount) onlyOwner { if (bountyRewards[receiver] < tokenAmount) throw; bountyTokens = safeSub(bountyTokens, tokenAmount); bountyRewards[receiver] = safeSub(bountyRewards[receiver], tokenAmount); WWAMBountyToken bountyToken = WWAMBountyToken(token); bountyToken.revokeTokens(receiver, tokenAmount); } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool) { return weiRaisedTotal > investmentCapInWei; } function isCrowdsaleFull() public constant returns (bool) { return weiRaised >= investmentCapInWei; } function assignTokens(address receiver, uint tokenAmount) private { MintableToken mintableToken = MintableToken(token); mintableToken.mint(receiver, tokenAmount); } } "}
{"sol name": "23815_0.sol", "label": 0, "sol content": "contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } } contract GoldTokenERC20 is owned { string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function GoldTokenERC20() public { totalSupply = 100000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = \"GoldToken\"; symbol = \"GOLD\"; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { Burn(_from, _value); return true; } function mintToken(address target, uint256 initialSupply) onlyOwner public { balanceOf[target] += initialSupply; totalSupply += initialSupply; Transfer(0, this, initialSupply); Transfer(this, target, initialSupply); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } } "}
{"sol name": "691_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. string public version = 'H1.0'; function EOS_Silver() { } function() payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "23301_0.sol", "label": 0, "sol content": "interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } You should inherit from TokenBase. This implements ONLY the standard functions obeys ERC20, and NOTHING else. If you deploy this, you won't have anything useful. contract ERC20 { uint256 public totalSupply; function balanceOf(address _owner) constant public returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) constant public returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract TokenBase is ERC20 { function transfer(address _to, uint256 _value) public returns (bool success) { require(_to != 0x0); require(balances[msg.sender] >= _value); require(balances[_to] + _value > balances[_to]); uint previousBalances = balances[msg.sender] + balances[_to]; balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); assert(balances[msg.sender] + balances[_to] == previousBalances); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value > balances[_to]); uint previousBalances = balances[_from] + balances[_to]; balances[_from] -= _value; balances[_to] += _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); assert(balances[_from] + balances[_to] == previousBalances); return true; } function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => mapping (address => uint256)) allowed; } contract BAI20 is TokenBase { function () payable public { require(false); } string public constant name = \"BAI2.0\"; string public constant symbol = \"BAI\"; uint256 private constant _INITIAL_SUPPLY = 21000000000; uint8 public decimals = 18; uint256 public totalSupply; string public version = \"BAI2.0\"; function BAI20( ) public { totalSupply = _INITIAL_SUPPLY * 10 ** 18; balances[msg.sender] = totalSupply; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } } "}
{"sol name": "30064_0.sol", "label": 0, "sol content": "contract ERC20Interface { function totalSupply() constant returns (uint256 totalSupply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Rolit is ERC20Interface { string public constant symbol = \"ROLIT\"; string public constant name = \"Rolit\"; uint8 public constant decimals = 0; uint256 _totalSupply = 4044; address public owner; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; modifier onlyOwner() { if (msg.sender != owner) { assert(false); } _; } function Rolit() { owner = msg.sender; balances[owner] = 0; balances[0xd9371A7fe655982527882370c22aC7522560642A] += 2022; balances[0xAAAF281a494Cd0B43aa9bD086441367e47026519] += 2022; } function totalSupply() constant returns (uint256 totalSupply) { totalSupply = _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "31137_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract BurnableToken is StandardToken { function burn(uint _value) public { require(_value > 0); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } event Burn(address indexed burner, uint indexed value); } contract Tincoin is BurnableToken { string public constant name = \"Tincoin\"; string public constant symbol = \"TIN\"; uint8 public constant decimals = 18; uint256 public INITIAL_SUPPLY = 100000000 * 1 ether; function Tincoin  () { totalSupply = INITIAL_SUPPLY; balances[0x2ff19Ce720e19d0F010f953CE3FAFd3E3A0A55a4] = INITIAL_SUPPLY; } } contract Crowdsale is Ownable { using SafeMath for uint; address multisig; Tincoin public token = new Tincoin (); uint start; function Start() constant returns (uint) { return start; } function setStart(uint newStart) onlyOwner { start = newStart; } uint period; function Period() constant returns (uint) { return period; } function setPeriod(uint newPeriod) onlyOwner { period = newPeriod; } uint rate; function Rate() constant returns (uint) { return rate; } function setRate(uint newRate) onlyOwner { rate = newRate * (10**18); } function Crowdsale() { multisig = 0xF743a32Af0402d1202aedc1d6c1A5A9e0610FAa7; rate = 10000000000000000000; start = 1514037565; period = 365; } modifier saleIsOn() { require(now > start && now < start + period * 1 days); _; } modifier limitation() { require(msg.value >= 10000000000000000); _; } function createTokens() limitation saleIsOn payable { multisig.transfer(msg.value); uint tokens = rate.mul(msg.value).div(1 ether); token.transfer(msg.sender, tokens); } function() external payable { createTokens(); } } "}
{"sol name": "14726_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract InvestedProvider is Ownable { uint public invested; } contract AddressesFilterFeature is Ownable { mapping(address => bool) public allowedAddresses; function addAllowedAddress(address allowedAddress) public onlyOwner { allowedAddresses[allowedAddress] = true; } function removeAllowedAddress(address allowedAddress) public onlyOwner { allowedAddresses[allowedAddress] = false; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is AddressesFilterFeature, StandardToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; address public saleAgent; mapping (address => uint) public initialBalances; mapping (address => uint) public lockedAddresses; modifier notLocked(address _from, uint _value) { require(msg.sender == owner || msg.sender == saleAgent || allowedAddresses[_from] || (mintingFinished && now > lockedAddresses[_from])); _; } function lock(address _from, uint lockDays) public { require(msg.sender == saleAgent || msg.sender == owner); lockedAddresses[_from] = now + 1 days * lockDays; } function setSaleAgent(address newSaleAgnet) public { require(msg.sender == saleAgent || msg.sender == owner); saleAgent = newSaleAgnet; } function mint(address _to, uint256 _amount) public returns (bool) { require((msg.sender == saleAgent || msg.sender == owner) && !mintingFinished); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); initialBalances[_to] = balances[_to]; Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting() public returns (bool) { require((msg.sender == saleAgent || msg.sender == owner) && !mintingFinished); mintingFinished = true; MintFinished(); return true; } function transfer(address _to, uint256 _value) public notLocked(msg.sender, _value)  returns (bool) { return super.transfer(_to, _value); } function transferFrom(address from, address to, uint256 value) public notLocked(from, value) returns (bool) { return super.transferFrom(from, to, value); } } contract TokenProvider is Ownable { MintableToken public token; function setToken(address newToken) public onlyOwner { token = MintableToken(newToken); } } contract MintTokensInterface is TokenProvider { function mintTokens(address to, uint tokens) internal; } contract MintTokensFeature is MintTokensInterface { function mintTokens(address to, uint tokens) internal { token.mint(to, tokens); } } contract PercentRateProvider { uint public percentRate = 100; } contract PercentRateFeature is Ownable, PercentRateProvider { function setPercentRate(uint newPercentRate) public onlyOwner { percentRate = newPercentRate; } } contract RetrieveTokensFeature is Ownable { function retrieveTokens(address to, address anotherToken) public onlyOwner { ERC20 alienToken = ERC20(anotherToken); alienToken.transfer(to, alienToken.balanceOf(this)); } } contract WalletProvider is Ownable { address public wallet; function setWallet(address newWallet) public onlyOwner { wallet = newWallet; } } contract CommonSale is PercentRateFeature, InvestedProvider, WalletProvider, RetrieveTokensFeature, MintTokensFeature { using SafeMath for uint; address public directMintAgent; uint public price; uint public start; uint public minInvestedLimit; uint public hardcap; modifier isUnderHardcap() { require(invested <= hardcap); _; } function setHardcap(uint newHardcap) public onlyOwner { hardcap = newHardcap; } modifier onlyDirectMintAgentOrOwner() { require(directMintAgent == msg.sender || owner == msg.sender); _; } modifier minInvestLimited(uint value) { require(value >= minInvestedLimit); _; } function setStart(uint newStart) public onlyOwner { start = newStart; } function setMinInvestedLimit(uint newMinInvestedLimit) public onlyOwner { minInvestedLimit = newMinInvestedLimit; } function setDirectMintAgent(address newDirectMintAgent) public onlyOwner { directMintAgent = newDirectMintAgent; } function setPrice(uint newPrice) public onlyOwner { price = newPrice; } function calculateTokens(uint _invested) internal returns(uint); function mintTokensExternal(address to, uint tokens) public onlyDirectMintAgentOrOwner { mintTokens(to, tokens); } function endSaleDate() public view returns(uint); function mintTokensByETHExternal(address to, uint _invested) public onlyDirectMintAgentOrOwner returns(uint) { updateInvested(_invested); return mintTokensByETH(to, _invested); } function mintTokensByETH(address to, uint _invested) internal isUnderHardcap returns(uint) { uint tokens = calculateTokens(_invested); mintTokens(to, tokens); return tokens; } function transferToWallet(uint value) internal { wallet.transfer(value); } function updateInvested(uint value) internal { invested = invested.add(value); } function fallback() internal minInvestLimited(msg.value) returns(uint) { require(now >= start && now < endSaleDate()); transferToWallet(msg.value); updateInvested(msg.value); return mintTokensByETH(msg.sender, msg.value); } function () public payable { fallback(); } } contract AssembledCommonSale is CommonSale { } contract WalletsPercents is Ownable { address[] public wallets; mapping (address => uint) percents; function addWallet(address wallet, uint percent) public onlyOwner { wallets.push(wallet); percents[wallet] = percent; } function cleanWallets() public onlyOwner { wallets.length = 0; } } using SafeMath for uint; uint public percentRate = 100; function mintExtendedTokens() public onlyOwner { uint summaryTokensPercent = 0; for(uint i = 0; i < wallets.length; i++) { summaryTokensPercent = summaryTokensPercent.add(percents[wallets[i]]); } uint mintedTokens = token.totalSupply(); uint allTokens = mintedTokens.mul(percentRate).div(percentRate.sub(summaryTokensPercent)); for(uint k = 0; k < wallets.length; k++) { mintTokens(wallets[k], allTokens.mul(percents[wallets[k]]).div(percentRate)); } } } contract StagedCrowdsale is Ownable { using SafeMath for uint; struct Milestone { uint period; uint bonus; } uint public totalPeriod; Milestone[] public milestones; function milestonesCount() public view returns(uint) { return milestones.length; } function addMilestone(uint period, uint bonus) public onlyOwner { require(period > 0); milestones.push(Milestone(period, bonus)); totalPeriod = totalPeriod.add(period); } function removeMilestone(uint8 number) public onlyOwner { require(number < milestones.length); Milestone storage milestone = milestones[number]; totalPeriod = totalPeriod.sub(milestone.period); delete milestones[number]; for (uint i = number; i < milestones.length - 1; i++) { milestones[i] = milestones[i+1]; } milestones.length--; } function changeMilestone(uint8 number, uint period, uint bonus) public onlyOwner { require(number < milestones.length); Milestone storage milestone = milestones[number]; totalPeriod = totalPeriod.sub(milestone.period); milestone.period = period; milestone.bonus = bonus; totalPeriod = totalPeriod.add(period); } function insertMilestone(uint8 numberAfter, uint period, uint bonus) public onlyOwner { require(numberAfter < milestones.length); totalPeriod = totalPeriod.add(period); milestones.length++; for (uint i = milestones.length - 2; i > numberAfter; i--) { milestones[i + 1] = milestones[i]; } milestones[numberAfter + 1] = Milestone(period, bonus); } function clearMilestones() public onlyOwner { require(milestones.length > 0); for (uint i = 0; i < milestones.length; i++) { delete milestones[i]; } milestones.length -= milestones.length; totalPeriod = 0; } function lastSaleDate(uint start) public view returns(uint) { return start + totalPeriod * 1 days; } function currentMilestone(uint start) public view returns(uint) { uint previousDate = start; for(uint i=0; i < milestones.length; i++) { if(now >= previousDate && now < previousDate + milestones[i].period * 1 days) { return i; } previousDate = previousDate.add(milestones[i].period * 1 days); } revert(); } } contract ITO is ExtendedWalletsMintTokensFeature, StagedCrowdsale, AssembledCommonSale { address public lockAddress; uint public lockDays; function lockAddress(address newLockAddress, uint newLockDays) public onlyOwner { lockAddress = newLockAddress; lockDays = newLockDays; } function calculateTokens(uint _invested) internal returns(uint) { uint milestoneIndex = currentMilestone(start); Milestone storage milestone = milestones[milestoneIndex]; uint tokens = _invested.mul(price).div(1 ether); if(milestone.bonus > 0) { tokens = tokens.add(tokens.mul(milestone.bonus).div(percentRate)); } return tokens; } function endSaleDate() public view returns(uint) { return lastSaleDate(start); } function finish() public onlyOwner { mintExtendedTokens(); token.lock(lockAddress, lockDays); token.finishMinting(); } } contract NextSaleAgentFeature is Ownable { address public nextSaleAgent; function setNextSaleAgent(address newNextSaleAgent) public onlyOwner { nextSaleAgent = newNextSaleAgent; } } contract SoftcapFeature is InvestedProvider, WalletProvider { using SafeMath for uint; mapping(address => uint) public balances; bool public softcapAchieved; bool public refundOn; bool feePayed; uint public softcap; uint public constant devLimit = 7500000000000000000; address public constant devWallet = 0xEA15Adb66DC92a4BbCcC8Bf32fd25E2e86a2A770; function setSoftcap(uint newSoftcap) public onlyOwner { softcap = newSoftcap; } function withdraw() public { require(msg.sender == owner || msg.sender == devWallet); require(softcapAchieved); if(!feePayed) { devWallet.transfer(devLimit); feePayed = true; } wallet.transfer(this.balance); } function updateBalance(address to, uint amount) internal { balances[to] = balances[to].add(amount); if (!softcapAchieved && invested >= softcap) { softcapAchieved = true; } } function refund() public { require(refundOn && balances[msg.sender] > 0); uint value = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(value); } function updateRefundState() internal returns(bool) { if (!softcapAchieved) { refundOn = true; } return refundOn; } } contract PreITO is SoftcapFeature, NextSaleAgentFeature, AssembledCommonSale { uint public period; function calculateTokens(uint _invested) internal returns(uint) { return _invested.mul(price).div(1 ether); } function setPeriod(uint newPeriod) public onlyOwner { period = newPeriod; } function endSaleDate() public view returns(uint) { return start.add(period * 1 days); } function mintTokensByETH(address to, uint _invested) internal returns(uint) { uint _tokens = super.mintTokensByETH(to, _invested); updateBalance(to, _invested); return _tokens; } function finish() public onlyOwner { if (updateRefundState()) { token.finishMinting(); } else { withdraw(); token.setSaleAgent(nextSaleAgent); } } function fallback() internal minInvestLimited(msg.value) returns(uint) { require(now >= start && now < endSaleDate()); updateInvested(msg.value); return mintTokensByETH(msg.sender, msg.value); } } contract ReceivingContractCallback { function tokenFallback(address _from, uint _value) public; } contract Token is MintableToken { string public constant name = \"BUILD\"; string public constant symbol = \"BUILD\"; uint32 public constant decimals = 18; mapping(address => bool)  public registeredCallbacks; function transfer(address _to, uint256 _value) public returns (bool) { return processCallback(super.transfer(_to, _value), msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { return processCallback(super.transferFrom(_from, _to, _value), _from, _to, _value); } function registerCallback(address callback) public onlyOwner { registeredCallbacks[callback] = true; } function deregisterCallback(address callback) public onlyOwner { registeredCallbacks[callback] = false; } function processCallback(bool result, address from, address to, uint value) internal returns(bool) { if (result && registeredCallbacks[to]) { ReceivingContractCallback targetCallback = ReceivingContractCallback(to); targetCallback.tokenFallback(from, value); } return result; } } contract Configurator is Ownable { Token public token; PreITO public preITO; ITO public ito; function deploy() public onlyOwner { address manager = 0x66C1833F667eAE8ea1890560e009F139A680F939; token = new Token(); preITO = new PreITO(); ito = new ITO(); commonConfigure(preITO); commonConfigure(ito); preITO.setWallet(0xB53E3f252fBCD041e46Aad82CFaEe326E04d1396); preITO.setStart(1524441600); preITO.setPeriod(42); preITO.setPrice(6650000000000000000000); preITO.setSoftcap(2500000000000000000000); preITO.setHardcap(12000000000000000000000); token.setSaleAgent(preITO); ito.setWallet(0x8f1C4E049907Fa4329dAC9c504f4013620Fa39c9); ito.setStart(1527206400); ito.setHardcap(23000000000000000000000); ito.setPrice(5000000000000000000000); ito.addMilestone(10, 25); ito.addMilestone(15, 20); ito.addMilestone(15, 15); ito.addMilestone(15, 10); ito.addMilestone(30, 0); ito.addWallet(0x3180e7B6E726B23B1d18D9963bDe3264f5107aef, 2); ito.addWallet(0x36A8b67fe7800Cd169Fd46Cd75824DC016a54d13, 3); ito.addWallet(0xDf9CAAE51eED1F23B4ae9AeCDbdeb926252eFFC4, 11); ito.addWallet(0x7D648BcAbf05CEf119C9a11b8E05756a41Bd29Ad, 4); ito.lockAddress(0x3180e7B6E726B23B1d18D9963bDe3264f5107aef,30); preITO.setNextSaleAgent(ito); token.transferOwnership(manager); preITO.transferOwnership(manager); ito.transferOwnership(manager); } function commonConfigure(AssembledCommonSale sale) internal { sale.setPercentRate(100); sale.setMinInvestedLimit(100000000000000000); sale.setToken(token); } } "}
{"sol name": "10109_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Owned { address public owner; address public newOwner; modifier onlyOwner { require(msg.sender == owner); _; } event OwnerUpdate(address _prevOwner, address _newOwner); function Owned() public { owner = msg.sender; } function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != owner); newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnerUpdate(owner, newOwner); owner = newOwner; newOwner = 0x0; } } contract ERC20 { function totalSupply() public view returns (uint _totalSupply); function balanceOf(address _owner) public view returns (uint balance); function transfer(address _to, uint _value) public returns (bool success); function transferFrom(address _from, address _to, uint _value) public returns (bool success); function approve(address _spender, uint _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract ERC20Token is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalToken; function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } else { return false; } } function totalSupply() public view returns (uint256) { return totalToken; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract ETO is ERC20Token, Owned { string  public constant name = \"ETO Token\"; string  public constant symbol = \"ETO\"; uint256 public constant decimals = 18; function ETO() public { totalToken = 100000000000000000000000000000; balances[msg.sender] = totalToken; } function transferAnyERC20Token(address _tokenAddress, address _recipient, uint256 _amount) public onlyOwner returns (bool success) { return ERC20(_tokenAddress).transfer(_recipient, _amount); } } "}
{"sol name": "37224_0.sol", "label": 0, "sol content": "LINK funds pool ======================== Original by: /u/Cintix Modified by: moonlambos contract ERC20 { function transfer(address _to, uint256 _value) returns (bool success); function balanceOf(address _owner) constant returns (uint256 balance); } contract LINKFund { mapping (address => uint256) public balances; bool public bought_tokens; uint256 public contract_eth_value; uint256 constant public min_required_amount = 1 ether; uint256 constant public max_raised_amount = 700 ether; uint256 public min_buy_block; uint256 public min_refund_block; address constant public sale = 0x7093128612a02e32F1C1aa44cCD7411d84EE09Ac; address constant public creator = 0x0b11C7acb647eCa11d510eEc4fb0c17Bfccd6498; function LINKFund() { min_buy_block = block.number + 3456; min_refund_block = block.number + 86400; } function perform_withdraw(address tokenAddress) { if (!bought_tokens) throw; ERC20 token = ERC20(tokenAddress); uint256 contract_token_balance = token.balanceOf(address(this)); if (contract_token_balance == 0) throw; uint256 tokens_to_withdraw = (balances[msg.sender] * contract_token_balance) / contract_eth_value; contract_eth_value -= balances[msg.sender]; balances[msg.sender] = 0; if(!token.transfer(msg.sender, tokens_to_withdraw)) throw; } function refund_me() { if (bought_tokens) { if (block.number < min_refund_block) throw; } uint256 eth_to_withdraw = balances[msg.sender]; balances[msg.sender] = 0; msg.sender.transfer(eth_to_withdraw); } function buy_the_tokens() { if (msg.sender != creator) throw; if (bought_tokens) return; if (this.balance < min_required_amount) throw; if (block.number < min_buy_block) throw; bought_tokens = true; contract_eth_value = this.balance; creator.transfer(contract_eth_value); } function default_helper() payable { if (this.balance > max_raised_amount) throw; if (!bought_tokens) { balances[msg.sender] += msg.value; } } function () payable { default_helper(); } } "}
{"sol name": "5030_0.sol", "label": 0, "sol content": "contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { require(msg.sender == address(this)); _; } modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { require(!isOwner[_owners[i]] && _owners[i] != 0); isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.destination.call.value(txn.value)(txn.data)) Execution(transactionId); else { ExecutionFailure(transactionId); txn.executed = false; } } } function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } function getOwners() public constant returns (address[]) { return owners; } function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "32465_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; address public saleAgent; function setSaleAgent(address newSaleAgnet) { require(msg.sender == saleAgent || msg.sender == owner); saleAgent = newSaleAgnet; } function mint(address _to, uint256 _amount) returns (bool) { require(msg.sender == saleAgent && !mintingFinished); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); return true; } function finishMinting() returns (bool) { require((msg.sender == saleAgent || msg.sender == owner) && !mintingFinished); mintingFinished = true; MintFinished(); return true; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused { paused = true; Pause(); } function unpause() onlyOwner whenPaused { paused = false; Unpause(); } } contract CovestingToken is MintableToken { string public constant name = \"Covesting\"; string public constant symbol = \"COV\"; uint32 public constant decimals = 18; mapping (address => uint) public locked; function transfer(address _to, uint256 _value) returns (bool) { require(locked[msg.sender] < now); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) returns (bool) { require(locked[_from] < now); return super.transferFrom(_from, _to, _value); } function lock(address addr, uint periodInDays) { require(locked[addr] < now && (msg.sender == saleAgent || msg.sender == addr)); locked[addr] = now + periodInDays * 1 days; } function () payable { revert(); } } contract StagedCrowdsale is Pausable { using SafeMath for uint; struct Stage { uint hardcap; uint price; uint invested; uint closed; } uint public start; uint public period; uint public totalHardcap; uint public totalInvested; Stage[] public stages; function stagesCount() public constant returns(uint) { return stages.length; } function setStart(uint newStart) public onlyOwner { start = newStart; } function setPeriod(uint newPeriod) public onlyOwner { period = newPeriod; } function addStage(uint hardcap, uint price) public onlyOwner { require(hardcap > 0 && price > 0); Stage memory stage = Stage(hardcap.mul(1 ether), price, 0, 0); stages.push(stage); totalHardcap = totalHardcap.add(stage.hardcap); } function removeStage(uint8 number) public onlyOwner { require(number >=0 && number < stages.length); Stage storage stage = stages[number]; totalHardcap = totalHardcap.sub(stage.hardcap); delete stages[number]; for (uint i = number; i < stages.length - 1; i++) { stages[i] = stages[i+1]; } stages.length--; } function changeStage(uint8 number, uint hardcap, uint price) public onlyOwner { require(number >= 0 &&number < stages.length); Stage storage stage = stages[number]; totalHardcap = totalHardcap.sub(stage.hardcap); stage.hardcap = hardcap.mul(1 ether); stage.price = price; totalHardcap = totalHardcap.add(stage.hardcap); } function insertStage(uint8 numberAfter, uint hardcap, uint price) public onlyOwner { require(numberAfter < stages.length); Stage memory stage = Stage(hardcap.mul(1 ether), price, 0, 0); totalHardcap = totalHardcap.add(stage.hardcap); stages.length++; for (uint i = stages.length - 2; i > numberAfter; i--) { stages[i + 1] = stages[i]; } stages[numberAfter + 1] = stage; } function clearStages() public onlyOwner { for (uint i = 0; i < stages.length; i++) { delete stages[i]; } stages.length -= stages.length; totalHardcap = 0; } function lastSaleDate() public constant returns(uint) { return start + period * 1 days; } modifier saleIsOn() { require(stages.length > 0 && now >= start && now < lastSaleDate()); _; } modifier isUnderHardcap() { require(totalInvested <= totalHardcap); _; } function currentStage() public saleIsOn isUnderHardcap constant returns(uint) { for(uint i=0; i < stages.length; i++) { if(stages[i].closed == 0) { return i; } } revert(); } } contract CommonSale is StagedCrowdsale { address public multisigWallet; uint public minPrice; uint public totalTokensMinted; CovestingToken public token; function setMinPrice(uint newMinPrice) public onlyOwner { minPrice = newMinPrice; } function setMultisigWallet(address newMultisigWallet) public onlyOwner { multisigWallet = newMultisigWallet; } function setToken(address newToken) public onlyOwner { token = CovestingToken(newToken); } function createTokens() public whenNotPaused payable { require(msg.value >= minPrice); uint stageIndex = currentStage(); multisigWallet.transfer(msg.value); Stage storage stage = stages[stageIndex]; uint tokens = msg.value.mul(stage.price); token.mint(this, tokens); token.transfer(msg.sender, tokens); totalTokensMinted = totalTokensMinted.add(tokens); totalInvested = totalInvested.add(msg.value); stage.invested = stage.invested.add(msg.value); if(stage.invested >= stage.hardcap) { stage.closed = now; } } function() external payable { createTokens(); } function retrieveTokens(address anotherToken) public onlyOwner { ERC20 alienToken = ERC20(anotherToken); alienToken.transfer(multisigWallet, token.balanceOf(this)); } } contract Presale is CommonSale { Mainsale public mainsale; function setMainsale(address newMainsale) public onlyOwner { mainsale = Mainsale(newMainsale); } function setMultisigWallet(address newMultisigWallet) public onlyOwner { multisigWallet = newMultisigWallet; } function finishMinting() public whenNotPaused onlyOwner { token.setSaleAgent(mainsale); } function() external payable { createTokens(); } function retrieveTokens(address anotherToken) public onlyOwner { ERC20 alienToken = ERC20(anotherToken); alienToken.transfer(multisigWallet, token.balanceOf(this)); } } contract Mainsale is CommonSale { address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public percentRate = 100; uint public lockPeriod; function setLockPeriod(uint newLockPeriod) public onlyOwner { lockPeriod = newLockPeriod; } function setFoundersTokensPercent(uint newFoundersTokensPercent) public onlyOwner { foundersTokensPercent = newFoundersTokensPercent; } function setBountyTokensPercent(uint newBountyTokensPercent) public onlyOwner { bountyTokensPercent = newBountyTokensPercent; } function setFoundersTokensWallet(address newFoundersTokensWallet) public onlyOwner { foundersTokensWallet = newFoundersTokensWallet; } function setBountyTokensWallet(address newBountyTokensWallet) public onlyOwner { bountyTokensWallet = newBountyTokensWallet; } function finishMinting() public whenNotPaused onlyOwner { uint summaryTokensPercent = bountyTokensPercent + foundersTokensPercent; uint mintedTokens = token.totalSupply(); uint summaryFoundersTokens = mintedTokens.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent); uint totalSupply = summaryFoundersTokens + mintedTokens; uint foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate); uint bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate); token.mint(this, foundersTokens); token.lock(foundersTokensWallet, lockPeriod * 1 days); token.transfer(foundersTokensWallet, foundersTokens); token.mint(this, bountyTokens); token.transfer(bountyTokensWallet, bountyTokens); totalTokensMinted = totalTokensMinted.add(foundersTokens).add(bountyTokens); token.finishMinting(); } } contract TestConfigurator is Ownable { CovestingToken public token; Presale public presale; Mainsale public mainsale; function deploy() public onlyOwner { token = new CovestingToken(); presale = new Presale(); presale.setToken(token); presale.addStage(5,300); presale.setMultisigWallet(0x055fa3f2DAc0b9Db661A4745965DDD65490d56A8); presale.setStart(1507208400); presale.setPeriod(2); presale.setMinPrice(100000000000000000); token.setSaleAgent(presale); mainsale = new Mainsale(); mainsale.setToken(token); mainsale.addStage(1,200); mainsale.addStage(2,100); mainsale.setMultisigWallet(0x4d9014eF9C3CE5790A326775Bd9F609969d1BF4f); mainsale.setFoundersTokensWallet(0x59b398bBED1CC6c82b337B3Bd0ad7e4dCB7d4de3); mainsale.setBountyTokensWallet(0x555635F2ea026ab65d7B44526539E0aB3874Ab24); mainsale.setStart(1507467600); mainsale.setPeriod(2); mainsale.setLockPeriod(1); mainsale.setMinPrice(100000000000000000); mainsale.setFoundersTokensPercent(13); mainsale.setBountyTokensPercent(5); presale.setMainsale(mainsale); token.transferOwnership(owner); presale.transferOwnership(owner); mainsale.transferOwnership(owner); } } contract Configurator is Ownable { CovestingToken public token; Presale public presale; Mainsale public mainsale; function deploy() public onlyOwner { token = new CovestingToken(); presale = new Presale(); presale.setToken(token); presale.addStage(5000,300); presale.setMultisigWallet(0x6245C05a6fc205d249d0775769cfE73CB596e57D); presale.setStart(1508504400); presale.setPeriod(30); presale.setMinPrice(100000000000000000); token.setSaleAgent(presale); mainsale = new Mainsale(); mainsale.setToken(token); mainsale.addStage(5000,200); mainsale.addStage(5000,180); mainsale.addStage(10000,170); mainsale.addStage(20000,160); mainsale.addStage(20000,150); mainsale.addStage(40000,130); mainsale.setMultisigWallet(0x15A071B83396577cCbd86A979Af7d2aBa9e18970); mainsale.setFoundersTokensWallet(0x25ED4f0D260D5e5218D95390036bc8815Ff38262); mainsale.setBountyTokensWallet(0x717bfD30f039424B049D918F935DEdD069B66810); mainsale.setStart(1511222400); mainsale.setPeriod(30); mainsale.setLockPeriod(90); mainsale.setMinPrice(100000000000000000); mainsale.setFoundersTokensPercent(13); mainsale.setBountyTokensPercent(5); presale.setMainsale(mainsale); token.transferOwnership(owner); presale.transferOwnership(owner); mainsale.transferOwnership(owner); } } contract UpdateMainsale is CommonSale { enum Currency { BTC, LTC, ZEC, DASH, WAVES, USD, EUR } event ExternalSale( Currency _currency, bytes32 _txIdSha3, address indexed _buyer, uint256 _amountWei, uint256 _tokensE18 ); event NotifierChanged( address indexed _oldAddress, address indexed _newAddress ); address public notifier; mapping(uint8 => mapping(bytes32 => uint256)) public externalTxs; uint256 public totalExternalSales = 0; modifier canNotify() { require(msg.sender == owner || msg.sender == notifier); _; } address public foundersTokensWallet; address public bountyTokensWallet; uint public foundersTokensPercent; uint public bountyTokensPercent; uint public percentRate = 100; uint public lockPeriod; function setLockPeriod(uint newLockPeriod) public onlyOwner { lockPeriod = newLockPeriod; } function setFoundersTokensPercent(uint newFoundersTokensPercent) public onlyOwner { foundersTokensPercent = newFoundersTokensPercent; } function setBountyTokensPercent(uint newBountyTokensPercent) public onlyOwner { bountyTokensPercent = newBountyTokensPercent; } function setFoundersTokensWallet(address newFoundersTokensWallet) public onlyOwner { foundersTokensWallet = newFoundersTokensWallet; } function setBountyTokensWallet(address newBountyTokensWallet) public onlyOwner { bountyTokensWallet = newBountyTokensWallet; } function finishMinting() public whenNotPaused onlyOwner { uint summaryTokensPercent = bountyTokensPercent + foundersTokensPercent; uint mintedTokens = token.totalSupply(); uint summaryFoundersTokens = mintedTokens.mul(summaryTokensPercent).div(percentRate - summaryTokensPercent); uint totalSupply = summaryFoundersTokens + mintedTokens; uint foundersTokens = totalSupply.mul(foundersTokensPercent).div(percentRate); uint bountyTokens = totalSupply.mul(bountyTokensPercent).div(percentRate); token.mint(this, foundersTokens); token.lock(foundersTokensWallet, lockPeriod * 1 days); token.transfer(foundersTokensWallet, foundersTokens); token.mint(this, bountyTokens); token.transfer(bountyTokensWallet, bountyTokens); totalTokensMinted = totalTokensMinted.add(foundersTokens).add(bountyTokens); token.finishMinting(); } function setNotifier(address _notifier) public onlyOwner { NotifierChanged(notifier, _notifier); notifier = _notifier; } function externalSales( uint8[] _currencies, bytes32[] _txIdSha3, address[] _buyers, uint256[] _amountsWei, uint256[] _tokensE18 ) public whenNotPaused canNotify { require(_currencies.length > 0); require(_currencies.length == _txIdSha3.length); require(_currencies.length == _buyers.length); require(_currencies.length == _amountsWei.length); require(_currencies.length == _tokensE18.length); for (uint i = 0; i < _txIdSha3.length; i++) { _externalSaleSha3( Currency(_currencies[i]), _txIdSha3[i], _buyers[i], _amountsWei[i], _tokensE18[i] ); } } function _externalSaleSha3( Currency _currency, address _buyer, uint256 _amountWei, uint256 _tokensE18 ) internal { require(_buyer > 0 && _amountWei > 0 && _tokensE18 > 0); var txsByCur = externalTxs[uint8(_currency)]; require(txsByCur[_txIdSha3] == 0); txsByCur[_txIdSha3] = _tokensE18; uint stageIndex = currentStage(); Stage storage stage = stages[stageIndex]; token.mint(this, _tokensE18); token.transfer(_buyer, _tokensE18); totalTokensMinted = totalTokensMinted.add(_tokensE18); totalExternalSales++; totalInvested = totalInvested.add(_amountWei); stage.invested = stage.invested.add(_amountWei); if (stage.invested >= stage.hardcap) { stage.closed = now; } ExternalSale(_currency, _txIdSha3, _buyer, _amountWei, _tokensE18); } function btcId() public constant returns (uint8) { return uint8(Currency.BTC); } function ltcId() public constant returns (uint8) { return uint8(Currency.LTC); } function zecId() public constant returns (uint8) { return uint8(Currency.ZEC); } function dashId() public constant returns (uint8) { return uint8(Currency.DASH); } function wavesId() public constant returns (uint8) { return uint8(Currency.WAVES); } function usdId() public constant returns (uint8) { return uint8(Currency.USD); } function eurId() public constant returns (uint8) { return uint8(Currency.EUR); } function _tokensByTx(Currency _currency, string _txId) internal constant returns (uint256) { return tokensByTx(uint8(_currency), _txId); } function tokensByTx(uint8 _currency, string _txId) public constant returns (uint256) { return externalTxs[_currency][keccak256(_txId)]; } function tokensByBtcTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.BTC, _txId); } function tokensByLtcTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.LTC, _txId); } function tokensByZecTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.ZEC, _txId); } function tokensByDashTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.DASH, _txId); } function tokensByWavesTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.WAVES, _txId); } function tokensByUsdTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.USD, _txId); } function tokensByEurTx(string _txId) public constant returns (uint256) { return _tokensByTx(Currency.EUR, _txId); } } contract UpdateConfigurator is Ownable { CovestingToken public token; UpdateMainsale public mainsale; function deploy() public onlyOwner { mainsale = new UpdateMainsale(); token = CovestingToken(0xE2FB6529EF566a080e6d23dE0bd351311087D567); mainsale.setToken(token); mainsale.addStage(5000,200); mainsale.addStage(5000,180); mainsale.addStage(10000,170); mainsale.addStage(20000,160); mainsale.addStage(20000,150); mainsale.addStage(40000,130); mainsale.setMultisigWallet(0x15A071B83396577cCbd86A979Af7d2aBa9e18970); mainsale.setFoundersTokensWallet(0x25ED4f0D260D5e5218D95390036bc8815Ff38262); mainsale.setBountyTokensWallet(0x717bfD30f039424B049D918F935DEdD069B66810); mainsale.setStart(1511528400); mainsale.setPeriod(30); mainsale.setLockPeriod(90); mainsale.setMinPrice(100000000000000000); mainsale.setFoundersTokensPercent(13); mainsale.setBountyTokensPercent(5); mainsale.setNotifier(owner); mainsale.transferOwnership(owner); } } contract IncreaseTokensOperator is Ownable { using SafeMath for uint256; mapping (address => bool) public authorized; mapping (address => bool) public minted; address[] public mintedList; CovestingToken public token; uint public increaseK = 10; modifier onlyAuthorized() { require(owner == msg.sender || authorized[msg.sender]); _; } function extraMint(address tokenHolder) public onlyAuthorized { uint value = token.balanceOf(tokenHolder); uint targetValue = value.mul(increaseK); uint diffValue = targetValue.sub(value); token.mint(this, diffValue); token.transfer(tokenHolder, diffValue); minted[tokenHolder] = true; mintedList.push(tokenHolder); } function extraMintArray(address[] tokenHolders) public onlyAuthorized { for(uint i = 0; i < tokenHolders.length; i++) { address tokenHolder = tokenHolders[i]; require(!minted[tokenHolder]); uint value = token.balanceOf(tokenHolder); uint targetValue = value.mul(increaseK); uint diffValue = targetValue.sub(value); token.mint(this, diffValue); token.transfer(tokenHolder, diffValue); minted[tokenHolder] = true; mintedList.push(tokenHolder); } } function setIncreaseK(uint newIncreaseK) public onlyOwner { increaseK = newIncreaseK; } function setToken(address newToken) public onlyOwner { token = CovestingToken(newToken); } function authorize(address to) public onlyAuthorized { require(!authorized[to]); authorized[to] = true; } function unauthorize(address to) public onlyAuthorized { require(authorized[to]); authorized[to] = false; } } "}
{"sol name": "22079_0.sol", "label": 0, "sol content": "contract AccessControl { address public creatorAddress; uint16 public totalSeraphims = 0; mapping (address => bool) public seraphims; bool public isMaintenanceMode = true; modifier onlyCREATOR() { require(msg.sender == creatorAddress); _; } modifier onlySERAPHIM() { require(seraphims[msg.sender] == true); _; } modifier isContractActive { require(!isMaintenanceMode); _; } function AccessControl() public { creatorAddress = msg.sender; } function addSERAPHIM(address _newSeraphim) onlyCREATOR public { if (seraphims[_newSeraphim] == false) { seraphims[_newSeraphim] = true; totalSeraphims += 1; } } function removeSERAPHIM(address _oldSeraphim) onlyCREATOR public { if (seraphims[_oldSeraphim] == true) { seraphims[_oldSeraphim] = false; totalSeraphims -= 1; } } function updateMaintenanceMode(bool _isMaintaining) onlyCREATOR public { isMaintenanceMode = _isMaintaining; } } contract SafeMath { function safeAdd(uint x, uint y) pure internal returns(uint) { uint z = x + y; assert((z >= x) && (z >= y)); return z; } function safeSubtract(uint x, uint y) pure internal returns(uint) { assert(x >= y); uint z = x - y; return z; } function safeMult(uint x, uint y) pure internal returns(uint) { uint z = x * y; assert((x == 0)||(z/x == y)); return z; } function getRandomNumber(uint16 maxRandom, uint8 min, address privateAddress) constant public returns(uint8) { uint256 genNum = uint256(block.blockhash(block.number-1)) + uint256(privateAddress); return uint8(genNum % (maxRandom - min + 1)+min); } } contract Enums { enum ResultCode { SUCCESS, ERROR_CLASS_NOT_FOUND, ERROR_LOW_BALANCE, ERROR_SEND_FAIL, ERROR_NOT_OWNER, ERROR_NOT_ENOUGH_MONEY, ERROR_INVALID_AMOUNT } enum AngelAura { Blue, Yellow, Purple, Orange, Red, Green } } contract IPetCardData is AccessControl, Enums { uint8 public totalPetCardSeries; uint64 public totalPets; function createPetCardSeries(uint8 _petCardSeriesId, uint32 _maxTotal) onlyCREATOR public returns(uint8); function setPet(uint8 _petCardSeriesId, address _owner, string _name, uint8 _luck, uint16 _auraRed, uint16 _auraYellow, uint16 _auraBlue) onlySERAPHIM external returns(uint64); function setPetAuras(uint64 _petId, uint8 _auraRed, uint8 _auraBlue, uint8 _auraYellow) onlySERAPHIM external; function setPetLastTrainingTime(uint64 _petId) onlySERAPHIM external; function setPetLastBreedingTime(uint64 _petId) onlySERAPHIM external; function addPetIdMapping(address _owner, uint64 _petId) private; function transferPet(address _from, address _to, uint64 _petId) onlySERAPHIM public returns(ResultCode); function ownerPetTransfer (address _to, uint64 _petId)  public; function setPetName(string _name, uint64 _petId) public; function getPetCardSeries(uint8 _petCardSeriesId) constant public returns(uint8 petCardSeriesId, uint32 currentPetTotal, uint32 maxPetTotal); function getPet(uint _petId) constant public returns(uint petId, uint8 petCardSeriesId, string name, uint8 luck, uint16 auraRed, uint16 auraBlue, uint16 auraYellow, uint64 lastTrainingTime, uint64 lastBreedingTime, address owner); function getOwnerPetCount(address _owner) constant public returns(uint); function getPetByIndex(address _owner, uint _index) constant public returns(uint); function getTotalPetCardSeries() constant public returns (uint8); function getTotalPets() constant public returns (uint); } contract RetirePets is AccessControl, SafeMath { address public petCardDataContract = 0xB340686da996b8B3d486b4D27E38E38500A9E926; event EventNewPet(uint64 petID); function DataContacts( address _petCardDataContract) onlyCREATOR external { petCardDataContract = _petCardDataContract; } function checkPet (uint64  petID) private constant returns (uint8) { IPetCardData petCardData = IPetCardData(petCardDataContract); if ((petID <= 0) || (petID > petCardData.getTotalPets())) {return 0;} address petowner; uint8 petcardSeriesID; (,petcardSeriesID,,,,,,,,petowner) = petCardData.getPet(petID); if  (petowner != msg.sender)  {return 0;} return petcardSeriesID; } function retireWildEasy(uint64 pet1, uint64 pet2, uint64 pet3, uint64 pet4, uint64 pet5, uint64 pet6) public { IPetCardData petCardData = IPetCardData(petCardDataContract); if (checkPet(pet1) <5) {revert();} if (checkPet(pet2) <5) {revert();} if (checkPet(pet3) <5) {revert();} if (checkPet(pet4) <5) {revert();} if (checkPet(pet5) <5) {revert();} if (checkPet(pet6) <5) {revert();} petCardData.transferPet(msg.sender, address(0), pet1); petCardData.transferPet(msg.sender, address(0), pet2); petCardData.transferPet(msg.sender, address(0), pet3); petCardData.transferPet(msg.sender, address(0), pet4); petCardData.transferPet(msg.sender, address(0), pet5); petCardData.transferPet(msg.sender, address(0), pet6); getNewPetCard(getRandomNumber(12,9,msg.sender)); } function retireWildHard(uint64 pet1, uint64 pet2, uint64 pet3, uint64 pet4, uint64 pet5, uint64 pet6) public { IPetCardData petCardData = IPetCardData(petCardDataContract); if (checkPet(pet1) <9) {revert();} if (checkPet(pet2) <9) {revert();} if (checkPet(pet3) <9) {revert();} if (checkPet(pet4) <9) {revert();} if (checkPet(pet5) <9) {revert();} if (checkPet(pet6) <9) {revert();} petCardData.transferPet(msg.sender, address(0), pet1); petCardData.transferPet(msg.sender, address(0), pet2); petCardData.transferPet(msg.sender, address(0), pet3); petCardData.transferPet(msg.sender, address(0), pet4); petCardData.transferPet(msg.sender, address(0), pet5); petCardData.transferPet(msg.sender, address(0), pet6); getNewPetCard(getRandomNumber(16,13,msg.sender)); } function getNewPetCard(uint8 opponentId) private { uint16 _auraRed = 0; uint16 _auraYellow = 0; uint16 _auraBlue = 0; uint32 _auraColor = getRandomNumber(2,0,msg.sender); if (_auraColor == 0) { _auraRed = 14;} if (_auraColor == 1) { _auraYellow = 14;} if (_auraColor == 2) { _auraBlue = 14;} uint8 _newLuck = getRandomNumber(39,30,msg.sender); IPetCardData petCardData = IPetCardData(petCardDataContract); uint64 petId = petCardData.setPet(opponentId+4, msg.sender, 'Rover', _newLuck, _auraRed, _auraYellow, _auraBlue); EventNewPet(petId); } function kill() onlyCREATOR external { selfdestruct(creatorAddress); } } "}
{"sol name": "9080_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ADZbuzzCommunityToken() public { symbol = \"ACT109557\"; name = \"ADZbuzz Themerkle.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "15718_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract LademiA is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function LademiA( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "14113_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, SafeMath { event Minted(address receiver, uint amount); mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; function isToken() public constant returns (bool weAre) { return true; } function transfer(address _to, uint _value) returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) returns (bool success) { uint _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool success) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) throw; allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract UpgradeAgent { uint public originalSupply; function isUpgradeAgent() public constant returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } contract UpgradeableToken is StandardToken { address public upgradeMaster; UpgradeAgent public upgradeAgent; uint256 public totalUpgraded; enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} event Upgrade(address indexed _from, address indexed _to, uint256 _value); event UpgradeAgentSet(address agent); function UpgradeableToken(address _upgradeMaster) { upgradeMaster = _upgradeMaster; } function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { throw; } if (value == 0) throw; balances[msg.sender] = safeSub(balances[msg.sender], value); totalSupply = safeSub(totalSupply, value); totalUpgraded = safeAdd(totalUpgraded, value); upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } function setUpgradeAgent(address agent) external { if(!canUpgrade()) { throw; } if (agent == 0x0) throw; if (msg.sender != upgradeMaster) throw; if (getUpgradeState() == UpgradeState.Upgrading) throw; upgradeAgent = UpgradeAgent(agent); if(!upgradeAgent.isUpgradeAgent()) throw; if (upgradeAgent.originalSupply() != totalSupply) throw; UpgradeAgentSet(upgradeAgent); } function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } function setUpgradeMaster(address master) public { if (master == 0x0) throw; if (msg.sender != upgradeMaster) throw; upgradeMaster = master; } function canUpgrade() public constant returns(bool) { return true; } } contract ReleasableToken is ERC20, Ownable { address public releaseAgent; bool public released = false; mapping (address => bool) public transferAgents; modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; } function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } function releaseTokenTransfer() public onlyReleaseAgent { released = true; } modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { return super.transferFrom(_from, _to, _value); } } library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } contract MintableTokenExt is StandardToken, Ownable { using SafeMathLibExt for uint; bool public mintingFinished = false; mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state  ); struct ReservedTokensData { uint inTokens; uint inPercentageUnit; uint inPercentageDecimals; bool isReserved; bool isDistributed; } mapping (address => ReservedTokensData) public reservedTokensList; address[] public reservedTokensDestinations; uint public reservedTokensDestinationsLen = 0; bool reservedTokensDestinationsAreSet = false; modifier onlyMintAgent() { if(!mintAgents[msg.sender]) { throw; } _; } modifier canMint() { if(mintingFinished) throw; _; } function finalizeReservedAddress(address addr) public onlyMintAgent canMint { ReservedTokensData storage reservedTokensData = reservedTokensList[addr]; reservedTokensData.isDistributed = true; } function isAddressReserved(address addr) public constant returns (bool isReserved) { return reservedTokensList[addr].isReserved; } function areTokensDistributedForAddress(address addr) public constant returns (bool isDistributed) { return reservedTokensList[addr].isDistributed; } function getReservedTokens(address addr) public constant returns (uint inTokens) { return reservedTokensList[addr].inTokens; } function getReservedPercentageUnit(address addr) public constant returns (uint inPercentageUnit) { return reservedTokensList[addr].inPercentageUnit; } function getReservedPercentageDecimals(address addr) public constant returns (uint inPercentageDecimals) { return reservedTokensList[addr].inPercentageDecimals; } function setReservedTokensListMultiple( address[] addrs, uint[] inTokens, uint[] inPercentageUnit, uint[] inPercentageDecimals ) public canMint onlyOwner { assert(!reservedTokensDestinationsAreSet); assert(addrs.length == inTokens.length); assert(inTokens.length == inPercentageUnit.length); assert(inPercentageUnit.length == inPercentageDecimals.length); for (uint iterator = 0; iterator < addrs.length; iterator++) { if (addrs[iterator] != address(0)) { setReservedTokensList(addrs[iterator], inTokens[iterator], inPercentageUnit[iterator], inPercentageDecimals[iterator]); } } reservedTokensDestinationsAreSet = true; } function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply = totalSupply.plus(amount); balances[receiver] = balances[receiver].plus(amount); Transfer(0, receiver, amount); } function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } function setReservedTokensList(address addr, uint inTokens, uint inPercentageUnit, uint inPercentageDecimals) private canMint onlyOwner { assert(addr != address(0)); if (!isAddressReserved(addr)) { reservedTokensDestinations.push(addr); reservedTokensDestinationsLen++; } reservedTokensList[addr] = ReservedTokensData({ inTokens: inTokens, inPercentageUnit: inPercentageUnit, inPercentageDecimals: inPercentageDecimals, isReserved: true, isDistributed: false }); } } contract CrowdsaleTokenExt is ReleasableToken, MintableTokenExt, UpgradeableToken { event UpdatedTokenInformation(string newName, string newSymbol); event ClaimedTokens(address indexed _token, address indexed _controller, uint _amount); string public name; string public symbol; uint public decimals; uint public minCap; transferable the minting always ends. function CrowdsaleTokenExt(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable, uint _globalMinCap) UpgradeableToken(msg.sender) { owner = msg.sender; name = _name; symbol = _symbol; totalSupply = _initialSupply; decimals = _decimals; minCap = _globalMinCap; balances[owner] = totalSupply; if(totalSupply > 0) { Minted(owner, totalSupply); } if(!_mintable) { mintingFinished = true; if(totalSupply == 0) { } } } function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } function canUpgrade() public constant returns(bool) { return released && super.canUpgrade(); } function setTokenInformation(string _name, string _symbol) onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } function claimTokens(address _token) public onlyOwner { require(_token != address(0)); ERC20 token = ERC20(_token); uint balance = token.balanceOf(this); token.transfer(owner, balance); ClaimedTokens(_token, owner, balance); } } "}
{"sol name": "11816_0.sol", "label": 0, "sol content": "contract GFCI { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); uint256 public totalSupply; function GFCI(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(_to != 0x0); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { } } "}
{"sol name": "14203_0.sol", "label": 0, "sol content": "contract Etherwow{ function userRollDice(uint, address) payable {uint;address;} } contract FixBet51{ modifier onlyOwner{ require(msg.sender == owner); _; } address public owner; Etherwow public etherwow; bool public bet; function FixBet51(){ owner = msg.sender; } function ownerSetEtherwowAddress(address newEtherwowAddress) public onlyOwner { etherwow = Etherwow(newEtherwowAddress); } function ownerSetMod(bool newMod) public onlyOwner { bet = newMod; } function () payable{ if (bet == true){ require(msg.value == 200000000000000000); etherwow.userRollDice.value(msg.value)(51, msg.sender); } else return; } } "}
{"sol name": "9707_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); function RefundVault(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; Closed(); wallet.transfer(this.balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; RefundsEnabled(); } function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract MyRefundVault is RefundVault, Pausable { function MyRefundVault(address _wallet) RefundVault(_wallet) { } function getDeposit(address contributor) public view returns(uint256 depositedValue) { return deposited[contributor]; } function refundWhenNotClosed(address contributor) public onlyOwner whenNotPaused returns(uint256 weiRefunded) { require(state != State.Closed); uint256 depositedValue = deposited[contributor]; deposited[contributor] = 0; uint256 refundFees = depositedValue.div(100); uint256 refundValue = depositedValue.sub(refundFees); if(refundFees > 0) wallet.transfer(refundFees); if(refundValue > 0) contributor.transfer(refundValue); Refunded(contributor, depositedValue); return depositedValue; } function isRefundPaused() public view returns(bool) { return paused; } function myRefund(address investor) public onlyOwner whenNotPaused returns(uint256 refunedValue) { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); Refunded(investor, depositedValue); return depositedValue; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } contract Crowdsale { using SafeMath for uint256; MintableToken public token; uint256 public startTime; uint256 public endTime; address public wallet; uint256 public rate; uint256 public weiRaised; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function Crowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet) public { require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); token = createTokenContract(); startTime = _startTime; endTime = _endTime; rate = _rate; wallet = _wallet; } function createTokenContract() internal returns (MintableToken) { return new MintableToken(); } function () external payable { buyTokens(msg.sender); } function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function forwardFunds() internal { wallet.transfer(msg.value); } function validPurchase() internal view returns (bool) { bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } function hasEnded() public view returns (bool) { return now > endTime; } } contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); Finalized(); isFinalized = true; } function finalization() internal { } } contract MyRefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; uint256 public goal; MyRefundVault public vault; function MyRefundableCrowdsale(uint256 _goal) public { require(_goal > 0); vault = new MyRefundVault(wallet); goal = _goal; } function forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } function claimRefundOnUnsuccessfulEvent() public { require(isFinalized); require(!goalReached()); uint256 refundedValue = vault.myRefund(msg.sender); weiRaised = weiRaised.sub(refundedValue); } function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } function goalReached() public view returns (bool) { return weiRaised >= goal; } function getDeposit(address contributor) public view returns(uint256 depositedValue) { return vault.getDeposit(contributor); } function pauseRefund() public onlyOwner { vault.pause(); } function unpauseRefund() public onlyOwner { vault.unpause(); } function isRefundPaused() public view returns(bool) { return vault.isRefundPaused(); } } contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract SilcToken is MintableToken, BurnableToken { string public name = \"SILC\"; string public symbol = \"SILC\"; uint8 public decimals = 18; function burn(address burner, uint256 _value) public onlyOwner { require(_value <= balances[burner]); balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; function CappedCrowdsale(uint256 _cap) public { require(_cap > 0); cap = _cap; } function validPurchase() internal view returns (bool) { bool withinCap = weiRaised.add(msg.value) <= cap; return super.validPurchase() && withinCap; } function hasEnded() public view returns (bool) { bool capReached = weiRaised >= cap; return super.hasEnded() || capReached; } } contract SilcCrowdsale is CappedCrowdsale, MyRefundableCrowdsale { enum CrowdsaleStage { phase1, phase2, phase3 } uint256 public rateForPhase1 = 110000; uint256 public rateForPhase2 = 105000; uint256 public rateForPhase3 = 100000; int256 public totalWeiRaisedDuringPhase1; int256 public totalWeiRaisedDuringPhase2; int256 public totalWeiRaisedDuringPhase3; uint256 public totalTokenSupply; event EthTransferred(string text); event EthRefunded(string text); function SilcCrowdsale(uint256 _startTime, uint256 _endTime, uint256 _rate, address _wallet, uint256 _goal, uint256 _cap) CappedCrowdsale(_cap) FinalizableCrowdsale() MyRefundableCrowdsale(_goal) Crowdsale(_startTime, _endTime, _rate, _wallet) public { require(_goal <= _cap); } function createTokenContract() internal returns (MintableToken) { } function setCrowdsaleStage(uint value) public onlyOwner { CrowdsaleStage _stage; if (uint(CrowdsaleStage.phase1) == value) { _stage = CrowdsaleStage.phase1; } else if (uint(CrowdsaleStage.phase2) == value) { _stage = CrowdsaleStage.phase2; } else if (uint(CrowdsaleStage.phase3) == value) { _stage = CrowdsaleStage.phase3; } stage = _stage; if (stage == CrowdsaleStage.phase1) { setCurrentRate(rateForPhase1); } else if (stage == CrowdsaleStage.phase2) { setCurrentRate(rateForPhase2); } else if (stage == CrowdsaleStage.phase3) { setCurrentRate(rateForPhase3); } } function setCurrentRate(uint256 _rate) private { rate = _rate; } function calculateWeiForStage(int256 value) { if (stage == CrowdsaleStage.phase1) { totalWeiRaisedDuringPhase1 = totalWeiRaisedDuringPhase1 + value; } else if (stage == CrowdsaleStage.phase2) { totalWeiRaisedDuringPhase2 = totalWeiRaisedDuringPhase2 + value; } else if (stage == CrowdsaleStage.phase3) { totalWeiRaisedDuringPhase3 = totalWeiRaisedDuringPhase3 + value; } } function () external payable { buyTokens(msg.sender); totalTokenSupply = token.totalSupply(); calculateWeiForStage(int256(msg.value)); } mapping (address => uint256) tokenIssued; function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; uint256 tokens = weiAmount.mul(rate); weiRaised = weiRaised.add(weiAmount); token.mint(beneficiary, tokens); tokenIssued[beneficiary] = tokenIssued[beneficiary].add(tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function getTokenIssued(address contributor) public view returns (uint256 token) { return tokenIssued[contributor]; } function forwardFunds() internal { if (stage == CrowdsaleStage.phase1) { EthTransferred(\"forwarding funds to refundable vault\"); super.forwardFunds(); } else if (stage == CrowdsaleStage.phase2) { EthTransferred(\"forwarding funds to refundable vault\"); super.forwardFunds(); } else if (stage == CrowdsaleStage.phase3) { EthTransferred(\"forwarding funds to refundable vault\"); super.forwardFunds(); } } function finish(address _teamFund, address _ecosystemFund, address _advisoryFund) public onlyOwner { require(!isFinalized); uint256 alreadyMinted = token.totalSupply(); require(alreadyMinted < maxTokens); uint256 unsoldTokens = totalTokensForSale - alreadyMinted; if (unsoldTokens > 0) { tokensForEcosystem = tokensForEcosystem + unsoldTokens; } token.mint(_teamFund,tokensForTeam); token.mint(_ecosystemFund,tokensForEcosystem); token.mint(_advisoryFund,tokensForAdvisory); finalize(); } function mintSilcToken(address _to, uint256 _amount) public onlyOwner { token.mint(_to, _amount); } function transferTokenOwnership(address newOwner) public onlyOwner { token.transferOwnership(newOwner); } function transferVaultOwnership(address newOwner) public onlyOwner { vault.transferOwnership(newOwner); } event LogEvent(bytes32 message, uint256 value); event RefundRequestCompleted(address contributor, uint256 weiRefunded, uint256 burnedToken); function refundRequest() public { address contributor = msg.sender; SilcToken silcToken = SilcToken(address(token)); uint256 tokenValance = token.balanceOf(contributor); require(tokenValance != 0); require(tokenValance >= tokenIssued[contributor]); tokenIssued[contributor] = 0; uint256 weiRefunded = vault.refundWhenNotClosed(contributor); weiRaised = weiRaised.sub(weiRefunded); calculateWeiForStage(int256(weiRefunded) * -1); RefundRequestCompleted(contributor, weiRefunded, tokenValance); } function hasEnded() public view returns (bool) { return true; } } "}
{"sol name": "13012_0.sol", "label": 0, "sol content": "contract Ownable { address public owner; address public newOwnerCandidate; event OwnershipRequested(address indexed by, address indexed to); event OwnershipTransferred(address indexed from, address indexed to); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyOwnerCandidate() { require(msg.sender == newOwnerCandidate); _; } function requestOwnershipTransfer(address _newOwnerCandidate) external onlyOwner { require(_newOwnerCandidate != address(0)); newOwnerCandidate = _newOwnerCandidate; OwnershipRequested(msg.sender, newOwnerCandidate); } function acceptOwnership() external onlyOwnerCandidate { address previousOwner = owner; owner = newOwnerCandidate; newOwnerCandidate = address(0); OwnershipTransferred(previousOwner, owner); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; require(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } function max64(uint64 a, uint64 b) internal pure returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } function toPower2(uint256 a) internal pure returns (uint256) { return mul(a, a); } function sqrt(uint256 a) internal pure returns (uint256) { uint256 c = (a + 1) / 2; uint256 b = a; while (c < b) { b = c; c = (a / c + c) / 2; } return b; } } contract ERC20 { uint public totalSupply; function balanceOf(address _owner) constant public returns (uint balance); function transfer(address _to, uint _value) public returns (bool success); function transferFrom(address _from, address _to, uint _value) public returns (bool success); function approve(address _spender, uint _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint remaining); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract BasicToken is ERC20 { using SafeMath for uint256; uint256 public totalSupply; mapping (address => mapping (address => uint256)) allowed; mapping (address => uint256) balances; event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); function approve(address _spender, uint256 _value) public returns (bool) { if ((_value != 0) && (allowed[msg.sender][_spender] != 0)) { revert(); } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } } contract ERC223Receiver { function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok); } contract ERC677 is ERC20 { function transferAndCall(address to, uint value, bytes data) public returns (bool ok); event TransferAndCall(address indexed from, address indexed to, uint value, bytes data); } contract Standard677Token is ERC677, BasicToken { function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) { TransferAndCall(msg.sender, _to, _value, _data); if (isContract(_to)) return contractFallback(_to, _value, _data); return true; } function contractFallback(address _to, uint _value, bytes _data) private returns (bool) { ERC223Receiver receiver = ERC223Receiver(_to); require(receiver.tokenFallback(msg.sender, _value, _data)); return true; } function isContract(address _addr) private constant returns (bool is_contract) { uint length; assembly { length := extcodesize(_addr) } return length > 0; } } contract TokenHolder is Ownable { function transferAnyERC20Token(address _tokenAddress, uint256 _amount) public onlyOwner returns (bool success) { return ERC20(_tokenAddress).transfer(owner, _amount); } } contract ColuLocalCurrency is Ownable, Standard677Token, TokenHolder { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; string public tokenURI; event TokenURIChanged(string newTokenURI); function ColuLocalCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, string _tokenURI) public { require(_totalSupply != 0); require(bytes(_name).length != 0); require(bytes(_symbol).length != 0); totalSupply = _totalSupply; name = _name; symbol = _symbol; decimals = _decimals; tokenURI = _tokenURI; balances[msg.sender] = totalSupply; } function setTokenURI(string _tokenURI) public onlyOwner { tokenURI = _tokenURI; TokenURIChanged(_tokenURI); } } contract Standard223Receiver is ERC223Receiver { Tkn tkn; struct Tkn { address addr; uint256 value; } bool __isTokenFallback; modifier tokenPayable { require(__isTokenFallback); _; } function tokenFallback(address _sender, uint _value, bytes _data) external returns (bool ok) { if (!supportsToken(msg.sender)) { return false; } tkn = Tkn(msg.sender, _sender, _value); __isTokenFallback = true; if (!address(this).delegatecall(_data)) { __isTokenFallback = false; return false; } __isTokenFallback = false; return true; } function supportsToken(address token) public constant returns (bool); } contract TokenOwnable is Standard223Receiver, Ownable { modifier onlyTokenOwner() { require(tkn.sender == owner); _; } } contract EllipseMarketMaker is TokenOwnable { uint256 public constant PRECISION = 10 ** 18; ERC20 public token1; ERC20 public token2; uint256 public R1; uint256 public R2; uint256 public S1; uint256 public S2; bool public operational; bool public openForPublic; address public mmLib; function EllipseMarketMaker(address _mmLib, address _token1, address _token2) public { require(_mmLib != address(0)); bytes4 sig = 0x6dd23b5b; uint256 argsSize = 3 * 32; uint256 dataSize = 4 + argsSize; bytes memory m_data = new bytes(dataSize); assembly { mstore(add(m_data, 0x20), sig) mstore(add(m_data, 0x24), _mmLib) mstore(add(m_data, 0x44), _token1) mstore(add(m_data, 0x64), _token2) } require(_mmLib.delegatecall(m_data)); } function supportsToken(address token) public constant returns (bool) { return (token1 == token || token2 == token); } function() public { address _mmLib = mmLib; if (msg.data.length > 0) { assembly { calldatacopy(0xff, 0, calldatasize) let retVal := delegatecall(gas, _mmLib, 0xff, calldatasize, 0, 0x20) switch retVal case 0 { revert(0,0) } default { return(0, 0x20) } } } } } contract MarketMaker is ERC223Receiver { function getCurrentPrice() public constant returns (uint _price); function change(address _fromToken, uint _amount, address _toToken) public returns (uint _returnAmount); function change(address _fromToken, uint _amount, address _toToken, uint _minReturn) public returns (uint _returnAmount); function change(address _toToken) public returns (uint _returnAmount); function change(address _toToken, uint _minReturn) public returns (uint _returnAmount); function quote(address _fromToken, uint _amount, address _toToken) public constant returns (uint _returnAmount); function openForPublicTrade() public returns (bool success); function isOpenForPublic() public returns (bool success); event Change(address indexed fromToken, uint inAmount, address indexed toToken, uint returnAmount, address indexed account); } contract IEllipseMarketMaker is MarketMaker { uint256 public constant PRECISION = 10 ** 18; ERC20 public token1; ERC20 public token2; uint256 public R1; uint256 public R2; uint256 public S1; uint256 public S2; bool public operational; bool public openForPublic; address public mmLib; function supportsToken(address token) public constant returns (bool); function calcReserve(uint256 _R1, uint256 _S1, uint256 _S2) public pure returns (uint256); function validateReserves() public view returns (bool); function withdrawExcessReserves() public returns (uint256); function initializeAfterTransfer() public returns (bool); function initializeOnTransfer() public returns (bool); function getPrice(uint256 _R1, uint256 _R2, uint256 _S1, uint256 _S2) public constant returns (uint256); } contract CurrencyFactory is Standard223Receiver, TokenHolder { struct CurrencyStruct { string name; uint8 decimals; uint256 totalSupply; address owner; address mmAddress; } mapping (address => CurrencyStruct) public currencyMap; address public clnAddress; address public mmLibAddress; address[] public tokens; event MarketOpen(address indexed marketMaker); event TokenCreated(address indexed token, address indexed owner); modifier tokenIssuerOnly(address token, address owner) { require(currencyMap[token].owner == owner); _; } modifier CLNOnly() { require(msg.sender == clnAddress); _; } modifier marketClosed(address _token) { require(!MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic()); _; } modifier marketOpen(address _token) { require(MarketMaker(currencyMap[_token].mmAddress).isOpenForPublic()); _; } function CurrencyFactory(address _mmLib, address _clnAddress) public { require(_mmLib != address(0)); require(_clnAddress != address(0)); mmLibAddress = _mmLib; clnAddress = _clnAddress; } function createCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply, string _tokenURI) public returns (address) { ColuLocalCurrency subToken = new ColuLocalCurrency(_name, _symbol, _decimals, _totalSupply, _tokenURI); EllipseMarketMaker newMarketMaker = new EllipseMarketMaker(mmLibAddress, clnAddress, subToken); require(subToken.transfer(newMarketMaker, _totalSupply)); require(IEllipseMarketMaker(newMarketMaker).initializeAfterTransfer()); currencyMap[subToken] = CurrencyStruct({ name: _name, decimals: _decimals, totalSupply: _totalSupply, mmAddress: newMarketMaker, owner: msg.sender}); tokens.push(subToken); TokenCreated(subToken, msg.sender); return subToken; } function createCurrency(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public returns (address) { return createCurrency(_name, _symbol, _decimals, _totalSupply, ''); } function insertCLNtoMarketMaker(address _token, uint256 _clnAmount) public tokenIssuerOnly(_token, msg.sender) returns (uint256 _subTokenAmount) { require(_clnAmount > 0); address marketMakerAddress = getMarketMakerAddressFromToken(_token); require(ERC20(clnAddress).transferFrom(msg.sender, this, _clnAmount)); require(ERC20(clnAddress).approve(marketMakerAddress, _clnAmount)); _subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, _clnAmount, _token); require(ERC20(_token).transfer(msg.sender, _subTokenAmount)); } function insertCLNtoMarketMaker(address _token) public tokenPayable CLNOnly tokenIssuerOnly(_token, tkn.sender) returns (uint256 _subTokenAmount) { address marketMakerAddress = getMarketMakerAddressFromToken(_token); require(ERC20(clnAddress).approve(marketMakerAddress, tkn.value)); _subTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(clnAddress, tkn.value, _token); require(ERC20(_token).transfer(tkn.sender, _subTokenAmount)); } function extractCLNfromMarketMaker(address _token, uint256 _ccAmount) public tokenIssuerOnly(_token, msg.sender) returns (uint256 _clnTokenAmount) { address marketMakerAddress = getMarketMakerAddressFromToken(_token); require(ERC20(_token).transferFrom(msg.sender, this, _ccAmount)); require(ERC20(_token).approve(marketMakerAddress, _ccAmount)); _clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(_token, _ccAmount, clnAddress); require(ERC20(clnAddress).transfer(msg.sender, _clnTokenAmount)); } function extractCLNfromMarketMaker() public tokenPayable tokenIssuerOnly(msg.sender, tkn.sender) returns (uint256 _clnTokenAmount) { address marketMakerAddress = getMarketMakerAddressFromToken(msg.sender); require(ERC20(msg.sender).approve(marketMakerAddress, tkn.value)); _clnTokenAmount = IEllipseMarketMaker(marketMakerAddress).change(msg.sender, tkn.value, clnAddress); require(ERC20(clnAddress).transfer(tkn.sender, _clnTokenAmount)); } function openMarket(address _token) public tokenIssuerOnly(_token, msg.sender) returns (bool) { address marketMakerAddress = getMarketMakerAddressFromToken(_token); require(MarketMaker(marketMakerAddress).openForPublicTrade()); Ownable(marketMakerAddress).requestOwnershipTransfer(msg.sender); Ownable(_token).requestOwnershipTransfer(msg.sender); MarketOpen(marketMakerAddress); return true; } function supportsToken(address _token) public constant returns (bool) { return (clnAddress == _token || currencyMap[_token].totalSupply > 0); } function setTokenURI(address _token, string _tokenURI) public tokenIssuerOnly(_token, msg.sender) marketClosed(_token) returns (bool) { ColuLocalCurrency(_token).setTokenURI(_tokenURI); return true; } function getMarketMakerAddressFromToken(address _token) public constant returns (address _marketMakerAddress) { _marketMakerAddress = currencyMap[_token].mmAddress; require(_marketMakerAddress != address(0)); } } "}
{"sol name": "8588_0.sol", "label": 0, "sol content": "contract Token{ uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "38709_0.sol", "label": 0, "sol content": "contract Pixel { struct Section { address owner; uint256 price; bool for_sale; bool initial_purchase_done; uint image_id; string md5; uint last_update; address sell_only_to; uint16 index; } string public standard = \"IPO 0.9\"; string public constant name = \"Initial Pixel Offering\"; string public constant symbol = \"IPO\"; uint8 public constant decimals = 0; mapping (address => uint256) public balanceOf; mapping (address => uint256) public ethBalance; address owner; uint256 public ipo_price; Section[10000] public sections; uint256 public pool; uint public mapWidth; uint public mapHeight; uint256 tokenTotalSupply = 10000; event Buy(uint section_id); event NewListing(uint section_id, uint price); event Delisted(uint section_id); event NewImage(uint section_id); event AreaPrice(uint start_section_index, uint end_section_index, uint area_price); event SentValue(uint value); event PriceUpdate(uint256 price); event WithdrawEvent(string msg); function Pixel() { mapWidth = 1000; mapHeight = 1000; owner = msg.sender; } function totalSupply() constant returns (uint totalSupply) { totalSupply = tokenTotalSupply; } function updatePixelIndex( uint16 _start, uint16 _end ) { if(msg.sender != owner) throw; if(_end < _start) throw; while(_start < _end) { sections[_start].index = _start; _start++; } } function updateIPOPrice( uint256 _new_price ) { if(msg.sender != owner) throw; ipo_price = _new_price; PriceUpdate(ipo_price); } function getSectionIndexFromRaw( uint _x, uint _y ) returns (uint) { if (_x >= mapWidth) throw; if (_y >= mapHeight) throw; _x = _x / 10; _y = _y / 10; return _x + (_y * 100); } function getSectionIndexFromIdentifier ( uint _x_section_identifier, uint _y_section_identifier ) returns (uint) { if (_x_section_identifier >= (mapWidth / 10)) throw; if (_y_section_identifier >= (mapHeight / 10)) throw; uint index = _x_section_identifier + (_y_section_identifier * 100); return index; } function getIdentifierFromSectionIndex( uint _index ) returns (uint x, uint y) { if (_index > (mapWidth * mapHeight)) throw; x = _index % 100; y = (_index - (_index % 100)) / 100; } function sectionAvailable( uint _section_index ) returns (bool) { if (_section_index >= sections.length) throw; Section s = sections[_section_index]; return !s.initial_purchase_done; } function sectionForSale( uint _section_index ) returns (bool) { if (_section_index >= sections.length) throw; Section s = sections[_section_index]; if(s.for_sale) { if(s.sell_only_to == 0x0) return true; if(s.sell_only_to == msg.sender) return true; return false; } else { return false; } } function sectionPrice( uint _section_index ) returns (uint) { if (_section_index >= sections.length) throw; Section s = sections[_section_index]; return s.price; } Check to see if a region is available provided the top-left (start) section and the bottom-right (end) section. function regionAvailable( uint _start_section_index, uint _end_section_index ) returns (bool available, uint extended_price, uint ipo_count) { if (_end_section_index < _start_section_index) throw; var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index); var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index); if (start_x >= mapWidth) throw; if (start_y >= mapHeight) throw; if (end_x >= mapWidth) throw; if (end_y >= mapHeight) throw; uint y_pos = start_y; available = false; extended_price = 0; ipo_count = 0; while (y_pos <= end_y) { uint x_pos = start_x; while (x_pos <= end_x) { uint identifier = (x_pos + (y_pos * 100)); if(sectionAvailable(identifier)) { ipo_count = ipo_count + 1; } else { if(sectionForSale(identifier)) { extended_price = extended_price + sectionPrice(identifier); } else { available = false; extended_price = 0; ipo_count = 0; return; } } x_pos = x_pos + 1; } y_pos = y_pos + 1; } available = true; return; } function buySection ( uint _section_index, uint _image_id, string _md5 ) payable { if (_section_index >= sections.length) throw; Section section = sections[_section_index]; if(!section.for_sale && section.initial_purchase_done) { throw; } if(section.initial_purchase_done) { if(msg.value < section.price) { throw; } else { if (section.price != 0) { uint fee = section.price / 100; ethBalance[owner] += fee; ethBalance[section.owner] += (msg.value - fee); } ethBalance[msg.sender] += (msg.value - section.price); balanceOf[section.owner]--; balanceOf[msg.sender]++; } } else { if(msg.value < ipo_price) { throw; } else { ethBalance[owner] += msg.value; ethBalance[msg.sender] += (msg.value - ipo_price); pool--; balanceOf[msg.sender]++; } } section.owner = msg.sender; section.md5 = _md5; section.image_id = _image_id; section.last_update = block.timestamp; section.for_sale = false; } function buyRegion( uint _start_section_index, uint _end_section_index, uint _image_id, string _md5 ) payable returns (uint start_section_y, uint start_section_x, uint end_section_y, uint end_section_x){ if (_end_section_index < _start_section_index) throw; if (_start_section_index >= sections.length) throw; if (_end_section_index >= sections.length) throw; var (available, ext_price, ico_amount) = regionAvailable(_start_section_index, _end_section_index); if (!available) throw; uint area_price =  ico_amount * ipo_price; area_price = area_price + ext_price; AreaPrice(_start_section_index, _end_section_index, area_price); SentValue(msg.value); if (area_price > msg.value) throw; ico_amount = 0; ext_price = 0; start_section_x = _start_section_index % 100; end_section_x = _end_section_index % 100; start_section_y = _start_section_index - (_start_section_index % 100); start_section_y = start_section_y / 100; end_section_y = _end_section_index - (_end_section_index % 100); end_section_y = end_section_y / 100; uint x_pos = start_section_x; while (x_pos <= end_section_x) { uint y_pos = start_section_y; while (y_pos <= end_section_y) { Section s = sections[x_pos + (y_pos * 100)]; if (s.initial_purchase_done) { if(s.price != 0) { ethBalance[owner] += (s.price / 100); ethBalance[s.owner] += (s.price - (s.price / 100)); } ext_price += s.price; balanceOf[s.owner]--; balanceOf[msg.sender]++; } else { ethBalance[owner] += ipo_price; ico_amount += ipo_price; pool--; balanceOf[msg.sender]++; } s.owner = msg.sender; s.md5 = _md5; s.image_id = _image_id; s.for_sale = false; Buy(x_pos + (y_pos * 100)); y_pos = y_pos + 1; } x_pos = x_pos + 1; } ethBalance[msg.sender] += msg.value - (ext_price + ico_amount); return; } function setSectionForSale( uint _section_index, uint256 _price ) { if (_section_index >= sections.length) throw; Section section = sections[_section_index]; if(section.owner != msg.sender) throw; section.price = _price; section.for_sale = true; section.sell_only_to = 0x0; NewListing(_section_index, _price); } function setRegionForSale( uint _start_section_index, uint _end_section_index, uint _price ) { if(_start_section_index > _end_section_index) throw; if(_end_section_index > 9999) throw; uint x_pos = _start_section_index % 100; uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100; uint x_max = _end_section_index % 100; uint y_max = (_end_section_index - (_end_section_index % 100)) / 100; while(x_pos <= x_max) { uint y_pos = base_y_pos; while(y_pos <= y_max) { Section section = sections[x_pos + (y_pos * 100)]; if(section.owner == msg.sender) { section.price = _price; section.for_sale = true; section.sell_only_to = 0x0; NewListing(x_pos + (y_pos * 100), _price); } y_pos++; } x_pos++; } } function setRegionForSaleToAddress( uint _start_section_index, uint _end_section_index, uint _price, address _only_sell_to ) { if(_start_section_index > _end_section_index) throw; if(_end_section_index > 9999) throw; uint x_pos = _start_section_index % 100; uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100; uint x_max = _end_section_index % 100; uint y_max = (_end_section_index - (_end_section_index % 100)) / 100; while(x_pos <= x_max) { uint y_pos = base_y_pos; while(y_pos <= y_max) { Section section = sections[x_pos + (y_pos * 100)]; if(section.owner == msg.sender) { section.price = _price; section.for_sale = true; section.sell_only_to = _only_sell_to; NewListing(x_pos + (y_pos * 100), _price); } y_pos++; } x_pos++; } } Set an entire region's cloud image data function setRegionImageDataCloud( uint _start_section_index, uint _end_section_index, uint _image_id, string _md5 ) { if (_end_section_index < _start_section_index) throw; var (start_x, start_y) = getIdentifierFromSectionIndex(_start_section_index); var (end_x, end_y) = getIdentifierFromSectionIndex(_end_section_index); if (start_x >= mapWidth) throw; if (start_y >= mapHeight) throw; if (end_x >= mapWidth) throw; if (end_y >= mapHeight) throw; uint y_pos = start_y; while (y_pos <= end_y) { uint x_pos = start_x; while (x_pos <= end_x) { uint identifier = (x_pos + (y_pos * 100)); Section s = sections[identifier]; if(s.owner == msg.sender) { s.image_id = _image_id; s.md5 = _md5; } x_pos = x_pos + 1; } y_pos = y_pos + 1; } NewImage(_start_section_index); return; } function setSectionForSaleToAddress( uint _section_index, uint256 _price, address _to ) { if (_section_index >= sections.length) throw; Section section = sections[_section_index]; if(section.owner != msg.sender) throw; section.price = _price; section.for_sale = true; section.sell_only_to = _to; NewListing(_section_index, _price); } function unsetSectionForSale( uint _section_index ) { if (_section_index >= sections.length) throw; Section section = sections[_section_index]; if(section.owner != msg.sender) throw; section.for_sale = false; section.price = 0; section.sell_only_to = 0x0; Delisted(_section_index); } function unsetRegionForSale( uint _start_section_index, uint _end_section_index ) { if(_start_section_index > _end_section_index) throw; if(_end_section_index > 9999) throw; uint x_pos = _start_section_index % 100; uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100; uint x_max = _end_section_index % 100; uint y_max = (_end_section_index - (_end_section_index % 100)) / 100; while(x_pos <= x_max) { uint y_pos = base_y_pos; while(y_pos <= y_max) { Section section = sections[x_pos + (y_pos * 100)]; if(section.owner == msg.sender) { section.for_sale = false; section.price = 0; Delisted(x_pos + (y_pos * 100)); } y_pos++; } x_pos++; } } function setImageData( uint _section_index ) { if (_section_index >= sections.length) throw; Section section = sections[_section_index]; if(section.owner != msg.sender) throw; section.image_id = 0; section.md5 = \"\"; section.last_update = block.timestamp; NewImage(_section_index); } function setImageDataCloud( uint _section_index, uint _image_id, string _md5 ) { if (_section_index >= sections.length) throw; Section section = sections[_section_index]; if(section.owner != msg.sender) throw; section.image_id = _image_id; section.md5 = _md5; section.last_update = block.timestamp; NewImage(_section_index); } function withdraw() returns (bool) { var amount = ethBalance[msg.sender]; if (amount > 0) { ethBalance[msg.sender] = 0; WithdrawEvent(\"Reset Sender\"); msg.sender.transfer(amount); } return true; } function deposit() payable { ethBalance[msg.sender] += msg.value; } function transfer( address _to, uint _section_index ) { if (_section_index > 9999) throw; if (sections[_section_index].owner != msg.sender) throw; if (balanceOf[_to] + 1 < balanceOf[_to]) throw; sections[_section_index].owner = _to; sections[_section_index].for_sale = false; balanceOf[msg.sender] -= 1; balanceOf[_to] += 1; } function transferRegion( uint _start_section_index, uint _end_section_index, address _to ) { if(_start_section_index > _end_section_index) throw; if(_end_section_index > 9999) throw; uint x_pos = _start_section_index % 100; uint base_y_pos = (_start_section_index - (_start_section_index % 100)) / 100; uint x_max = _end_section_index % 100; uint y_max = (_end_section_index - (_end_section_index % 100)) / 100; while(x_pos <= x_max) { uint y_pos = base_y_pos; while(y_pos <= y_max) { Section section = sections[x_pos + (y_pos * 100)]; if(section.owner == msg.sender) { if (balanceOf[_to] + 1 < balanceOf[_to]) throw; section.owner = _to; section.for_sale = false; balanceOf[msg.sender] -= 1; balanceOf[_to] += 1; } y_pos++; } x_pos++; } } } "}
{"sol name": "2340_0.sol", "label": 0, "sol content": "contract LTToken{ uint256 public totalSupply; function balanceOf(address _owner)public constant returns (uint256 balance); function transfer(address _to, uint256 _value)public returns (bool success); function transferFrom(address _from, address _to, uint256 _value)public returns (bool success); function approve(address _spender, uint256 _value)public returns (bool success); function allowance(address _owner, address _spender)public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract LTStandardToken is LTToken { function transfer(address _to, uint256 _value)public returns (bool success) { require(_to!= address(0)); require(balances[msg.sender] >= _value); require(balances[_to] +_value>=balances[_to]); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value)public returns (bool success) { require(_to!= address(0)); require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); require(balances[_to] +_value>=balances[_to]); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner)public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value)public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender)public constant returns (uint256 remaining) { } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract LTStandardCreateToken is LTStandardToken { string public name; uint8 public decimals; string public symbol; string public version = 'H0.1'; constructor(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol)public { } function approveAndCall(address _spender, uint256 _value)public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } } "}
{"sol name": "4314_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract token { function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public{ owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract lockEtherPay is Ownable { using SafeMath for uint256; token token_reward; address public beneficiary; bool public isLocked = false; bool public isReleased = false; uint256 public start_time; uint256 public end_time; uint256 public fifty_two_weeks = 30326400; event TokenReleased(address beneficiary, uint256 token_amount); constructor() public{ token_reward = token(0xAa1ae5e57dc05981D83eC7FcA0b3c7ee2565B7D6); beneficiary = 0x8Bce5564748F50bA4F176570706CF7F34fe039ed; } function tokenBalance() constant public returns (uint256){ return token_reward.balanceOf(this); } function lock() public onlyOwner returns (bool){ require(!isLocked); require(tokenBalance() > 0); start_time = now; end_time = start_time.add(fifty_two_weeks); isLocked = true; } function lockOver() constant public returns (bool){ uint256 current_time = now; return current_time > end_time; } function release() onlyOwner public{ require(isLocked); require(!isReleased); require(lockOver()); uint256 token_amount = tokenBalance(); token_reward.transfer( beneficiary, token_amount); emit TokenReleased(beneficiary, token_amount); isReleased = true; } } "}
{"sol name": "21336_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function ADZbuzzCommunityToken() public { symbol = \"ACT133515\"; name = \"ADZbuzz Circa.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "39888_0.sol", "label": 0, "sol content": "contract BaseAgriChainContract { address creator; function BaseAgriChainContract() public    {   creator = msg.sender;   } modifier onlyBy(address _account) { if (msg.sender != _account) throw; _; } function kill() onlyBy(creator) {               suicide(creator);     } function setCreator(address _creator)  onlyBy(creator) {           creator = _creator;     } } contract AgriChainProductionContract   is BaseAgriChainContract { string  public  Notes ; function   AgriChainProductionContract() public { AgriChainData=address(this); } function setOrganization(string _Organization)  onlyBy(creator) { Organization = _Organization; } function setProduct(string _Product)  onlyBy(creator) { Product = _Product; } function setDescription(string _Description)  onlyBy(creator) { Description = _Description; } function setAgriChainData(address _AgriChainData)  onlyBy(creator) { AgriChainData = _AgriChainData; } function setAgriChainSeal(string _AgriChainSeal)  onlyBy(creator) { AgriChainSeal = _AgriChainSeal; } function setNotes(string _Notes)  onlyBy(creator) { Notes =  _Notes; } } "}
{"sol name": "16486_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract Prismacoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Prismacoin() public { symbol = \"PRIS\"; name = \"Prismacoin\"; decimals = 18; _totalSupply = 19000000000000000000000000; balances[0x29B80F75900cC7F7BCe06D8282D64f6949c3a7f2] = _totalSupply; Transfer(address(0), 0x29B80F75900cC7F7BCe06D8282D64f6949c3a7f2, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "33839_0.sol", "label": 0, "sol content": "contract Factory { event ContractInstantiation(address sender, address instantiation); mapping(address => bool) public isInstantiation; mapping(address => address[]) public instantiations; function getInstantiationCount(address creator) public constant returns (uint) { return instantiations[creator].length; } function register(address instantiation) internal { isInstantiation[instantiation] = true; instantiations[msg.sender].push(instantiation); ContractInstantiation(msg.sender, instantiation); } } contract MultiSigWalletFactory is Factory { function create(address[] _owners, uint _required) public returns (address wallet) { wallet = new MultiSigWallet(_owners, _required); register(wallet); } } contract MultiSigWallet { event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); uint constant public MAX_OWNER_COUNT = 50; mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bytes data; bool executed; } modifier onlyWallet() { if (msg.sender != address(this)) throw; _; } modifier ownerDoesNotExist(address owner) { if (isOwner[owner]) throw; _; } modifier ownerExists(address owner) { if (!isOwner[owner]) throw; _; } modifier transactionExists(uint transactionId) { if (transactions[transactionId].destination == 0) throw; _; } modifier confirmed(uint transactionId, address owner) { if (!confirmations[transactionId][owner]) throw; _; } modifier notConfirmed(uint transactionId, address owner) { if (confirmations[transactionId][owner]) throw; _; } modifier notExecuted(uint transactionId) { if (transactions[transactionId].executed) throw; _; } modifier notNull(address _address) { if (_address == 0) throw; _; } modifier validRequirement(uint ownerCount, uint _required) { if (   ownerCount > MAX_OWNER_COUNT || _required > ownerCount || _required == 0 || ownerCount == 0) throw; _; } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function MultiSigWallet(address[] _owners, uint _required) public validRequirement(_owners.length, _required) { for (uint i=0; i<_owners.length; i++) { if (isOwner[_owners[i]] || _owners[i] == 0) throw; isOwner[_owners[i]] = true; } owners = _owners; required = _required; } function addOwner(address owner) public onlyWallet ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); OwnerAddition(owner); } function removeOwner(address owner) public onlyWallet ownerExists(owner) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; if (required > owners.length) changeRequirement(owners.length); OwnerRemoval(owner); } function replaceOwner(address owner, address newOwner) public onlyWallet ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; OwnerRemoval(owner); OwnerAddition(newOwner); } function changeRequirement(uint _required) public onlyWallet validRequirement(owners.length, _required) { required = _required; RequirementChange(_required); } function submitTransaction(address destination, uint value, bytes data) public returns (uint transactionId) { transactionId = addTransaction(destination, value, data); confirmTransaction(transactionId); } function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; Revocation(msg.sender, transactionId); } function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction tx = transactions[transactionId]; tx.executed = true; if (tx.destination.call.value(tx.value)(tx.data)) Execution(transactionId); else { ExecutionFailure(transactionId); tx.executed = false; } } } function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } function addTransaction(address destination, uint value, bytes data) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, data: data, executed: false }); transactionCount += 1; Submission(transactionId); } function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } function getOwners() public constant returns (address[]) { return owners; } function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "101_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. string public name; uint8 public decimals; string public symbol; string public version = 'H1.0'; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function BetterBitcoin() { balances[msg.sender] = 30000000000000000000000000000; totalSupply = 30000000000000000000000000000; name = \"BetterBitcoin\"; decimals = 18; symbol = \"BBTC\"; unitsOneEthCanBuy = 10000000; fundsWallet = msg.sender; } function() public payable{ totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * unitsOneEthCanBuy; require(balances[fundsWallet] >= amount); balances[fundsWallet] = balances[fundsWallet] - amount; balances[msg.sender] = balances[msg.sender] + amount; fundsWallet.transfer(msg.value); } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "21328_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping(address => mapping(address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract TXOtoken is StandardToken { string public constant name = \"TREON\"; string public constant symbol = \"TXO\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); function TXOtoken(address wallet) public { totalSupply_ = INITIAL_SUPPLY; balances[wallet] = INITIAL_SUPPLY; emit Transfer(0x0, wallet, INITIAL_SUPPLY); } } contract TXOsale is Ownable { event ReceiveEther(address indexed from, uint256 value); TXOtoken public token; bool public goalAchieved = false; address public constant wallet = 0x8dA7477d56c90CF2C5b78f36F9E39395ADb2Ae63; uint public  constant saleStart = 1526860800; uint public constant saleEnd = 1531871999; function TXOsale() public { token = new TXOtoken(wallet); } function() public payable { require(now >= saleStart && now <= saleEnd); require(!goalAchieved); require(msg.value >= 0.1 ether); wallet.transfer(msg.value); emit ReceiveEther(msg.sender, msg.value); } function setGoalAchieved(bool _goalAchieved) public onlyOwner { goalAchieved = _goalAchieved; } } "}
{"sol name": "18477_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract LCToken is StandardToken, Ownable{ string public version = \"1.0\"; string public name = \"LinkCoin Token\"; string public symbol = \"LC\"; uint8 public  decimals = 18; mapping(address=>uint256)  lockedBalance; mapping(address=>uint)     timeRelease; uint256 internal constant INITIAL_SUPPLY = 10 * (10**8) * (10**18); event Burn(address indexed burner, uint256 value); event Lock(address indexed locker, uint256 value, uint releaseTime); event UnLock(address indexed unlocker, uint256 value); function LCToken() { address onwer = msg.sender; balances[onwer] = INITIAL_SUPPLY; totalSupply = INITIAL_SUPPLY; } function lockedOf(address _owner) public constant returns (uint256 balance) { return lockedBalance[_owner]; } function unlockTimeOf(address _owner) public constant returns (uint timelimit) { return timeRelease[_owner]; } function transferAndLock(address _to, uint256 _value, uint _releaseTime) public returns (bool success) { require(_to != 0x0); require(_value <= balances[msg.sender]); require(_value > 0); require(_releaseTime > now && _releaseTime <= now + 60*60*24*365*5); balances[msg.sender] = balances[msg.sender].sub(_value); uint preRelease = timeRelease[_to]; if (preRelease <= now && preRelease != 0x0) { balances[_to] = balances[_to].add(lockedBalance[_to]); lockedBalance[_to] = 0; } lockedBalance[_to] = lockedBalance[_to].add(_value); timeRelease[_to] =  _releaseTime >= timeRelease[_to] ? _releaseTime : timeRelease[_to]; Transfer(msg.sender, _to, _value); Lock(_to, _value, _releaseTime); return true; } function unlock() public constant returns (bool success){ uint256 amount = lockedBalance[msg.sender]; require(amount > 0); require(now >= timeRelease[msg.sender]); balances[msg.sender] = balances[msg.sender].add(amount); lockedBalance[msg.sender] = 0; timeRelease[msg.sender] = 0; Transfer(0x0, msg.sender, amount); UnLock(msg.sender, amount); return true; } function burn(uint256 _value) public returns (bool success) { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); return true; } } "}
{"sol name": "36130_0.sol", "label": 0, "sol content": "contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } contract Haltable is Ownable { bool public halted; modifier stopInEmergency { if (halted) throw; _; } modifier stopNonOwnersInEmergency { if (halted && msg.sender != owner) throw; _; } modifier onlyInEmergency { if (!halted) throw; _; } function halt() external onlyOwner { halted = true; } function unhalt() external onlyOwner onlyInEmergency { halted = false; } } contract PricingStrategy { function isPricingStrategy() public constant returns (bool) { return true; } function isSane(address crowdsale) public constant returns (bool) { return true; } @param purchaser Address of the purchaser @return False by default, true if a presale purchaser function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } contract FinalizeAgent { function isFinalizeAgent() public constant returns(bool) { return true; } function isSane() public constant returns (bool); function finalizeCrowdsale(); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract FractionalERC20Ext is ERC20 { uint public decimals; uint public minCap; } contract CrowdsaleExt is Haltable { uint public MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE = 5; using SafeMathLibExt for uint; FractionalERC20Ext public token; PricingStrategy public pricingStrategy; FinalizeAgent public finalizeAgent; address public multisigWallet; uint public minimumFundingGoal; uint public startsAt; uint public endsAt; uint public tokensSold = 0; uint public weiRaised = 0; uint public presaleWeiRaised = 0; uint public investorCount = 0; uint public loadedRefund = 0; uint public weiRefunded = 0; bool public finalized; bool public requireCustomerId; bool public isWhiteListed; address[] public joinedCrowdsales; uint public joinedCrowdsalesLen = 0; address public lastCrowdsale; bool public requiredSignedAddress; address public signerAddress; mapping (address => uint256) public investedAmountOf; mapping (address => uint256) public tokenAmountOf; struct WhiteListData { bool status; uint minCap; uint maxCap; } bool public isUpdatable; mapping (address => WhiteListData) public earlyParticipantWhitelist; uint public ownerTestValue; enum State{Unknown, Preparing, PreFunding, Funding, Success, Failure, Finalized, Refunding} event Invested(address investor, uint weiAmount, uint tokenAmount, uint128 customerId); event Refund(address investor, uint weiAmount); event InvestmentPolicyChanged(bool newRequireCustomerId, bool newRequiredSignedAddress, address newSignerAddress); event Whitelisted(address addr, bool status); event StartsAtChanged(uint newStartsAt); event EndsAtChanged(uint newEndsAt); function CrowdsaleExt(address _token, PricingStrategy _pricingStrategy, address _multisigWallet, uint _start, uint _end, uint _minimumFundingGoal, bool _isUpdatable, bool _isWhiteListed) { owner = msg.sender; token = FractionalERC20Ext(_token); setPricingStrategy(_pricingStrategy); multisigWallet = _multisigWallet; if(multisigWallet == 0) { throw; } if(_start == 0) { throw; } startsAt = _start; if(_end == 0) { throw; } endsAt = _end; if(startsAt >= endsAt) { throw; } minimumFundingGoal = _minimumFundingGoal; isUpdatable = _isUpdatable; isWhiteListed = _isWhiteListed; } function() payable { throw; } function investInternal(address receiver, uint128 customerId) stopInEmergency private { if(getState() == State.PreFunding) { throw; } else if(getState() == State.Funding) { if(isWhiteListed) { if(!earlyParticipantWhitelist[receiver].status) { throw; } } } else { throw; } uint weiAmount = msg.value; uint tokenAmount = pricingStrategy.calculatePrice(weiAmount, weiRaised - presaleWeiRaised, tokensSold, msg.sender, token.decimals()); if(tokenAmount == 0) { throw; } if(isWhiteListed) { if(tokenAmount < earlyParticipantWhitelist[receiver].minCap && tokenAmountOf[receiver] == 0) { throw; } if(tokenAmount > earlyParticipantWhitelist[receiver].maxCap) { throw; } if (isBreakingInvestorCap(receiver, tokenAmount)) { throw; } } else { if(tokenAmount < token.minCap() && tokenAmountOf[receiver] == 0) { throw; } } if(isBreakingCap(weiAmount, tokenAmount, weiRaised, tokensSold)) { throw; } investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); if(pricingStrategy.isPresalePurchase(receiver)) { presaleWeiRaised = presaleWeiRaised.plus(weiAmount); } if(investedAmountOf[receiver] == 0) { investorCount++; } assignTokens(receiver, tokenAmount); if(!multisigWallet.send(weiAmount)) throw; if (isWhiteListed) { uint num = 0; for (var i = 0; i < joinedCrowdsalesLen; i++) { if (this == joinedCrowdsales[i]) num = i; } if (num + 1 < joinedCrowdsalesLen) { for (var j = num + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); crowdsale.updateEarlyParicipantWhitelist(msg.sender, this, tokenAmount); } } } Invested(receiver, weiAmount, tokenAmount, customerId); } function preallocate(address receiver, uint fullTokens, uint weiPrice) public onlyOwner { uint tokenAmount = fullTokens * 10**token.decimals(); weiRaised = weiRaised.plus(weiAmount); tokensSold = tokensSold.plus(tokenAmount); investedAmountOf[receiver] = investedAmountOf[receiver].plus(weiAmount); tokenAmountOf[receiver] = tokenAmountOf[receiver].plus(tokenAmount); assignTokens(receiver, tokenAmount); Invested(receiver, weiAmount, tokenAmount, 0); } function investWithSignedAddress(address addr, uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { bytes32 hash = sha256(addr); if (ecrecover(hash, v, r, s) != signerAddress) throw; investInternal(addr, customerId); } function investWithCustomerId(address addr, uint128 customerId) public payable { investInternal(addr, customerId); } function invest(address addr) public payable { investInternal(addr, 0); } function buyWithSignedAddress(uint128 customerId, uint8 v, bytes32 r, bytes32 s) public payable { investWithSignedAddress(msg.sender, customerId, v, r, s); } function buyWithCustomerId(uint128 customerId) public payable { investWithCustomerId(msg.sender, customerId); } function buy() public payable { invest(msg.sender); } function finalize() public inState(State.Success) onlyOwner stopInEmergency { if(finalized) { throw; } if(address(finalizeAgent) != 0) { finalizeAgent.finalizeCrowdsale(); } finalized = true; } function setFinalizeAgent(FinalizeAgent addr) onlyOwner { finalizeAgent = addr; if(!finalizeAgent.isFinalizeAgent()) { throw; } } function setRequireCustomerId(bool value) onlyOwner { requireCustomerId = value; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } function setRequireSignedAddress(bool value, address _signerAddress) onlyOwner { requiredSignedAddress = value; signerAddress = _signerAddress; InvestmentPolicyChanged(requireCustomerId, requiredSignedAddress, signerAddress); } function setEarlyParicipantWhitelist(address addr, bool status, uint minCap, uint maxCap) onlyOwner { if (!isWhiteListed) throw; earlyParticipantWhitelist[addr] = WhiteListData({status:status, minCap:minCap, maxCap:maxCap}); Whitelisted(addr, status); } function setEarlyParicipantsWhitelist(address[] addrs, bool[] statuses, uint[] minCaps, uint[] maxCaps) onlyOwner { if (!isWhiteListed) throw; for (uint iterator = 0; iterator < addrs.length; iterator++) { setEarlyParicipantWhitelist(addrs[iterator], statuses[iterator], minCaps[iterator], maxCaps[iterator]); } } function updateEarlyParicipantWhitelist(address addr, address contractAddr, uint tokensBought) { if (tokensBought < earlyParticipantWhitelist[addr].minCap) throw; if (!isWhiteListed) throw; if (addr != msg.sender && contractAddr != msg.sender) throw; uint newMaxCap = earlyParticipantWhitelist[addr].maxCap; newMaxCap = newMaxCap.minus(tokensBought); earlyParticipantWhitelist[addr] = WhiteListData({status:earlyParticipantWhitelist[addr].status, minCap:0, maxCap:newMaxCap}); } function updateJoinedCrowdsales(address addr) onlyOwner { joinedCrowdsales[joinedCrowdsalesLen++] = addr; } function setLastCrowdsale(address addr) onlyOwner { lastCrowdsale = addr; } function clearJoinedCrowdsales() onlyOwner { joinedCrowdsalesLen = 0; } function updateJoinedCrowdsalesMultiple(address[] addrs) onlyOwner { clearJoinedCrowdsales(); for (uint iter = 0; iter < addrs.length; iter++) { if(joinedCrowdsalesLen == joinedCrowdsales.length) { joinedCrowdsales.length += 1; } joinedCrowdsales[joinedCrowdsalesLen++] = addrs[iter]; if (iter == addrs.length - 1) setLastCrowdsale(addrs[iter]); } } function setStartsAt(uint time) onlyOwner { if (finalized) throw; if (!isUpdatable) throw; if(now > time) { } if(time > endsAt) { throw; } CrowdsaleExt lastCrowdsaleCntrct = CrowdsaleExt(lastCrowdsale); if (lastCrowdsaleCntrct.finalized()) throw; startsAt = time; StartsAtChanged(startsAt); } function setEndsAt(uint time) onlyOwner { if (finalized) throw; if (!isUpdatable) throw; if(now > time) { } if(startsAt > time) { throw; } CrowdsaleExt lastCrowdsaleCntrct = CrowdsaleExt(lastCrowdsale); if (lastCrowdsaleCntrct.finalized()) throw; uint num = 0; for (var i = 0; i < joinedCrowdsalesLen; i++) { if (this == joinedCrowdsales[i]) num = i; } if (num + 1 < joinedCrowdsalesLen) { for (var j = num + 1; j < joinedCrowdsalesLen; j++) { CrowdsaleExt crowdsale = CrowdsaleExt(joinedCrowdsales[j]); if (time > crowdsale.startsAt()) throw; } } endsAt = time; EndsAtChanged(endsAt); } function setPricingStrategy(PricingStrategy _pricingStrategy) onlyOwner { pricingStrategy = _pricingStrategy; if(!pricingStrategy.isPricingStrategy()) { throw; } } function setMultisig(address addr) public onlyOwner { if(investorCount > MAX_INVESTMENTS_BEFORE_MULTISIG_CHANGE) { throw; } multisigWallet = addr; } function loadRefund() public payable inState(State.Failure) { if(msg.value == 0) throw; loadedRefund = loadedRefund.plus(msg.value); } function refund() public inState(State.Refunding) { uint256 weiValue = investedAmountOf[msg.sender]; if (weiValue == 0) throw; investedAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.plus(weiValue); Refund(msg.sender, weiValue); if (!msg.sender.send(weiValue)) throw; } function isMinimumGoalReached() public constant returns (bool reached) { return weiRaised >= minimumFundingGoal; } function isFinalizerSane() public constant returns (bool sane) { return finalizeAgent.isSane(); } function isPricingSane() public constant returns (bool sane) { return pricingStrategy.isSane(address(this)); } function getState() public constant returns (State) { if(finalized) return State.Finalized; else if (address(finalizeAgent) == 0) return State.Preparing; else if (!finalizeAgent.isSane()) return State.Preparing; else if (!pricingStrategy.isSane(address(this))) return State.Preparing; else if (block.timestamp < startsAt) return State.PreFunding; else if (block.timestamp <= endsAt && !isCrowdsaleFull()) return State.Funding; else if (isMinimumGoalReached()) return State.Success; else if (!isMinimumGoalReached() && weiRaised > 0 && loadedRefund >= weiRaised) return State.Refunding; else return State.Failure; } function setOwnerTestValue(uint val) onlyOwner { ownerTestValue = val; } function isCrowdsale() public constant returns (bool) { return true; } modifier inState(State state) { if(getState() != state) throw; _; } function isBreakingCap(uint weiAmount, uint tokenAmount, uint weiRaisedTotal, uint tokensSoldTotal) constant returns (bool limitBroken); function isBreakingInvestorCap(address receiver, uint tokenAmount) constant returns (bool limitBroken); function isCrowdsaleFull() public constant returns (bool); function assignTokens(address receiver, uint tokenAmount) private; } contract ReleasableToken is ERC20, Ownable { address public releaseAgent; bool public released = false; mapping (address => bool) public transferAgents; modifier canTransfer(address _sender) { if(!released) { if(!transferAgents[_sender]) { throw; } } _; } function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { releaseAgent = addr; } function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } function releaseTokenTransfer() public onlyReleaseAgent { released = true; } modifier inReleaseState(bool releaseState) { if(releaseState != released) { throw; } _; } modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { throw; } _; } function transfer(address _to, uint _value) canTransfer(msg.sender) returns (bool success) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) canTransfer(_from) returns (bool success) { return super.transferFrom(_from, _to, _value); } } contract NullFinalizeAgentExt is FinalizeAgent { CrowdsaleExt public crowdsale; function NullFinalizeAgentExt(CrowdsaleExt _crowdsale) { crowdsale = _crowdsale; } function isSane() public constant returns (bool) { return true; } function finalizeCrowdsale() public { } } "}
{"sol name": "27332_0.sol", "label": 0, "sol content": "contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract JannikCoin is StandardToken { function () { throw; } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function JannikCoin( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "38556_0.sol", "label": 0, "sol content": "contract Vetricoin { string public standard = 'Token 0.1'; string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; function Vetricoin() { initialSupply = 99999999; name =\"Vetricoin\"; decimals = 0; symbol = \"V\"; } function transfer(address _to, uint256 _value) { } function () { } } "}
{"sol name": "16126_0.sol", "label": 0, "sol content": "contract Token{ uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HumanStandardToken is StandardToken { function HumanStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "655_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract ERC721Basic { function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function transferFrom(address _from, address _to, uint256 _tokenId) public; } @dev HorseyExchange contract - handles horsey market exchange which includes the following set of functions: 1. Deposit to Exchange 2. Cancel sale 3. Purchase token using SafeMath for uint256; event HorseyDeposit(uint256 tokenId, uint256 price); event SaleCanceled(uint256 tokenId); event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay); uint256 public marketMakerFee = 3; uint256 collectedFees = 0; ERC721Basic public token; @dev used to store the price and the owner address of a token on sale struct SaleData { uint256 price; address owner; } mapping (uint256 => SaleData) market; mapping (address => uint256[]) userBarn; constructor() Pausable() public { } @dev Since the exchange requires the horsey contract and horsey contract requires exchange address, we cant initialize both of them in constructors @param _token Address of the stables contract function setStables(address _token) external onlyOwner() { require(address(_token) != 0,\"Address of token is zero\"); token = ERC721Basic(_token); } @dev Allows the owner to change market fees @param fees The new fees to apply (can be zero) function setMarketFees(uint256 fees) external onlyOwner() { marketMakerFee = fees; } function getTokensOnSale(address user) external view returns(uint256[]) { return userBarn[user]; } function getTokenPrice(uint256 tokenId) public view isOnMarket(tokenId) returns (uint256) { return market[tokenId].price + (market[tokenId].price.div(100).mul(marketMakerFee)); } @dev User sends token to sell to exchange - at this point the exchange contract takes ownership, but will map token ownership back to owner for auotmated withdraw on cancel - requires that user is the rightful owner and is not asking for a null price function depositToExchange(uint256 tokenId, uint256 price) external whenNotPaused() isTokenOwner(tokenId) nonZeroPrice(price) tokenAvailable() { require(token.getApproved(tokenId) == address(this),\"Exchange is not allowed to transfer\"); token.transferFrom(msg.sender, address(this), tokenId); market[tokenId] = SaleData(price,msg.sender); userBarn[msg.sender].push(tokenId); emit HorseyDeposit(tokenId, price); } @dev Allows true owner of token to cancel sale at anytime @param tokenId ID of the token to remove from the market @return true if user still has tokens for sale function cancelSale(uint256 tokenId) external whenNotPaused() originalOwnerOf(tokenId) tokenAvailable() returns (bool) { token.transferFrom(address(this),msg.sender,tokenId); delete market[tokenId]; _removeTokenFromBarn(tokenId, msg.sender); emit SaleCanceled(tokenId); return userBarn[msg.sender].length > 0; } @dev Performs the purchase of a token that is present on the market - this includes checking that the proper amount is sent + appliced fee, updating seller's balance, updated collected fees and transfering token to buyer Only market tokens can be purchased @param tokenId ID of the token we wish to purchase function purchaseToken(uint256 tokenId) external payable whenNotPaused() isOnMarket(tokenId) tokenAvailable() notOriginalOwnerOf(tokenId) { uint256 totalToPay = getTokenPrice(tokenId); require(msg.value >= totalToPay, \"Not paying enough\"); SaleData memory sale = market[tokenId]; collectedFees += totalToPay - sale.price; sale.owner.transfer(sale.price); _removeTokenFromBarn(tokenId,  sale.owner); delete market[tokenId]; token.transferFrom(address(this), msg.sender, tokenId); { msg.sender.transfer(msg.value.sub(totalToPay)); } emit HorseyPurchased(tokenId, msg.sender, totalToPay); } function withdraw() external onlyOwner() { assert(collectedFees <= address(this).balance); owner.transfer(collectedFees); collectedFees = 0; } @dev Internal function to remove a token from the users barn array @param tokenId ID of the token to remove @param barnAddress Address of the user selling tokens function _removeTokenFromBarn(uint tokenId, address barnAddress)  internal { uint256[] storage barnArray = userBarn[barnAddress]; require(barnArray.length > 0,\"No tokens to remove\"); int index = _indexOf(tokenId, barnArray); require(index >= 0, \"Token not found in barn\"); for (uint256 i = uint256(index); i<barnArray.length-1; i++){ barnArray[i] = barnArray[i+1]; } barnArray.length--; } @dev Helper function which stores in memory an array which is passed in, and @param item element we are looking for @param array the array to look into @return the index of the item of interest function _indexOf(uint item, uint256[] memory array) internal pure returns (int256){ for(uint256 i = 0; i < array.length; i++){ if(array[i] == item){ return int256(i); } } return -1; } modifier isOnMarket(uint256 tokenId) { require(token.ownerOf(tokenId) == address(this),\"Token not on market\"); _; } modifier isTokenOwner(uint256 tokenId) { require(token.ownerOf(tokenId) == msg.sender,\"Not tokens owner\"); _; } modifier originalOwnerOf(uint256 tokenId) { require(market[tokenId].owner == msg.sender,\"Not the original owner of\"); _; } modifier notOriginalOwnerOf(uint256 tokenId) { require(market[tokenId].owner != msg.sender,\"Is the original owner\"); _; } modifier nonZeroPrice(uint256 price){ require(price > 0,\"Price is zero\"); _; } modifier tokenAvailable(){ require(address(token) != 0,\"Token address not set\"); _; } } contract BettingControllerInterface { address public owner; } @title Race contract - used for linking ethorse Race struct @dev This interface is losely based on ethorse race contract contract EthorseRace { struct chronus_info { uint32  betting_duration; uint32 voided_timestamp; } address public owner; chronus_info public chronus; mapping (bytes32 => bool) public winner_horse; function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) { return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]); } function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint); } @title API contract - used to connect with Race contract and encapsulate race information for token inidices and winner checking. contract EthorseHelpers { bytes32[] public all_horses = [bytes32(\"BTC\"),bytes32(\"ETH\"),bytes32(\"LTC\")]; mapping(address => bool) private _legitOwners; function _addHorse(bytes32 newHorse) internal { all_horses.push(newHorse); } function _addLegitOwner(address newOwner) internal { _legitOwners[newOwner] = true; } function getall_horsesCount() public view returns(uint) { return all_horses.length; } @param raceAddress - address of this race @param eth_address - user's ethereum wallet address @return true if user is winner + name of the winning horse (LTC,BTC,ETH,...) function _isWinnerOf(address raceAddress, address eth_address) internal view returns (bool,bytes32) { EthorseRace race = EthorseRace(raceAddress); BettingControllerInterface bc = BettingControllerInterface(race.owner()); require(_legitOwners[bc.owner()]); (,,race_end,voided_bet,,,,) = race.chronus(); if(voided_bet || !race_end) return (false,bytes32(0)); bytes32 horse; bool found = false; uint256 arrayLength = all_horses.length; for(uint256 i = 0; i < arrayLength; i++) { if(race.winner_horse(all_horses[i])) { horse = all_horses[i]; found = true; break; } } if(!found) return (false,bytes32(0)); uint256 bet_amount = 0; if(eth_address != address(0)) { (,,,, bet_amount) = race.getCoinIndex(horse, eth_address); } return (bet_amount > 0, horse); } } contract RoyalStablesInterface { struct Horsey { address race; bytes32 dna; uint8 feedingCounter; uint8 tier; } mapping(uint256 => Horsey) public horseys; mapping(address => uint32) public carrot_credits; mapping(uint256 => string) public names; address public master; function getOwnedTokens(address eth_address) public view returns (uint256[]); function storeName(uint256 tokenId, string newName) public; function storeCarrotsCredit(address client, uint32 amount) public; function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public; function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public; function modifyHorseyDna(uint256 tokenId, bytes32 dna) public; function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public; function modifyHorseyTier(uint256 tokenId, uint8 tier) public; function unstoreHorsey(uint256 tokenId) public; function ownerOf(uint256 tokenId) public returns (address); } @title HorseyToken ERC721 Token @dev Horse contract - horse derives fro AccessManager built on top of ERC721 token and uses @dev EthorseHelpers and AccessManager contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; event Claimed(address raceAddress, address eth_address, uint256 tokenId); event Feeding(uint256 tokenId); event ReceivedCarrot(uint256 tokenId, bytes32 newDna); event FeedingFailed(uint256 tokenId); event HorseyRenamed(uint256 tokenId, string newName); event HorseyFreed(uint256 tokenId); RoyalStablesInterface public stables; uint8 public carrotsMultiplier = 1; uint8 public rarityMultiplier = 1; uint256 public claimingFee = 0.008 ether; @dev Holds the necessary data to feed a horsey The user has to create begin feeding and wait for the block with the feeding transaction to be hashed Only then he can stop the feeding struct FeedingData { } mapping(address => FeedingData) public pendingFeedings; uint256 public renamingCostsPerChar = 0.001 ether; @dev Contracts constructor Initializes token data is pausable,ownable @param stablesAddress Address of the official RoyalStables contract constructor(address stablesAddress) EthorseHelpers() Pausable() public { stables = RoyalStablesInterface(stablesAddress); } @dev Changes multiplier for rarity on feed @param newRarityMultiplier The cost to charge in wei for each character of the name function setRarityMultiplier(uint8 newRarityMultiplier) external onlyOwner()  { rarityMultiplier = newRarityMultiplier; } @dev Sets a new muliplier for freeing a horse @param newCarrotsMultiplier the new multiplier for feeding function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external onlyOwner()  { carrotsMultiplier = newCarrotsMultiplier; } @dev Sets a new renaming per character cost in wei Any CLevel can call this function @param newRenamingCost The cost to charge in wei for each character of the name function setRenamingCosts(uint256 newRenamingCost) external onlyOwner()  { renamingCostsPerChar = newRenamingCost; } @dev Sets a new claiming fee in wei Any CLevel can call this function @param newClaimingFee The cost to charge in wei for each claimed HRSY function setClaimingCosts(uint256 newClaimingFee) external onlyOwner()  { claimingFee = newClaimingFee; } @dev Allows to add a legit owner address for races validation @param newAddress the dev address deploying BettingController to add function addLegitDevAddress(address newAddress) external onlyOwner() { _addLegitOwner(newAddress); } @dev Owner can withdraw the current balance function withdraw() external onlyOwner()  { } @dev Adds a new horse index to the possible horses list (BTC,ETH,LTC,...) This is in case ethorse adds a new coin Any CLevel can call this function @param newHorse Index of the horse to add (same data type as the original ethorse erc20 contract code) function addHorseIndex(bytes32 newHorse) external onlyOwner() { _addHorse(newHorse); } @dev Gets the complete list of token ids which belongs to an address @param eth_address The address you want to lookup owned tokens from @return List of all owned by eth_address tokenIds function getOwnedTokens(address eth_address) public view returns (uint256[]) { return stables.getOwnedTokens(eth_address); } @dev Allows to check if an eth_address can claim a horsey from this contract should we also check if already claimed here? @param raceAddress The ethorse race you want to claim from @param eth_address The users address you want to claim the token for @return True only if eth_address is a winner of the race contract at raceAddress function can_claim(address raceAddress, address eth_address) public view returns (bool) { bool res; (res,) = _isWinnerOf(raceAddress, eth_address); return res; } @dev Allows a user to claim a special horsey with the same dna as the race one Cant be used on paused The sender has to be a winner of the race and must never have claimed a special horsey from this race @param raceAddress The race's address function claim(address raceAddress) external payable costs(claimingFee) whenNotPaused() { bytes32 winner; (,winner) = _isWinnerOf(raceAddress, address(0)); require(winner != bytes32(0),\"Winner is zero\"); require(can_claim(raceAddress, msg.sender),\"can_claim return false\"); uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner); emit Claimed(raceAddress, msg.sender, id); } @dev Allows a user to give a horsey a name or rename it This function is payable and its cost is renamingCostsPerChar * length(newname) Cant be called while paused If called with too low balance, the modifier will throw If called with too much balance, we try to return the remaining funds back Upon completion we update all ceos balances, maybe not very efficient? @param tokenId ID of the horsey to rename @param newName The name to give to the horsey function renameHorsey(uint256 tokenId, string newName) external whenNotPaused() onlyOwnerOf(tokenId) costs(renamingCostsPerChar * bytes(newName).length) payable { uint256 renamingFee = renamingCostsPerChar * bytes(newName).length; { msg.sender.transfer(msg.value.sub(renamingFee)); } stables.storeName(tokenId,newName); emit HorseyRenamed(tokenId,newName); } @dev Allows a user to burn a token he owns to get carrots The mount of carrots given is equal to the horsey's feedingCounter upon burning Cant be called on a horsey with a pending feeding Cant be called while paused @param tokenId ID of the token to burn function freeForCarrots(uint256 tokenId) external whenNotPaused() onlyOwnerOf(tokenId) { require(pendingFeedings[msg.sender].horsey != tokenId,\"\"); uint8 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier)); stables.unstoreHorsey(tokenId); emit HorseyFreed(tokenId); } @dev Returns the amount of carrots the user owns We have a getter to hide the carrots amount from public view @return The current amount of carrot credits the sender owns function getCarrotCredits() external view returns (uint32) { return stables.carrot_credits(msg.sender); } @dev Returns horsey data of a given token @param tokenId ID of the horsey to fetch @return (race address, dna, feedingCounter, name) function getHorsey(uint256 tokenId) public view returns (address, bytes32, uint8, string) { RoyalStablesInterface.Horsey memory temp; (temp.race,temp.dna,temp.feedingCounter,temp.tier) = stables.horseys(tokenId); return (temp.race,temp.dna,temp.feedingCounter,stables.names(tokenId)); } @dev Allows to feed a horsey to increase its feedingCounter value Gives a chance to get a rare trait The amount of carrots required is the value of current feedingCounter The carrots the user owns will be reduced accordingly upon success Cant be called while paused @param tokenId ID of the horsey to feed function feed(uint256 tokenId) external whenNotPaused() onlyOwnerOf(tokenId) carrotsMeetLevel(tokenId) noFeedingInProgress() { pendingFeedings[msg.sender] = FeedingData(block.number,tokenId); uint8 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter)); emit Feeding(tokenId); } @dev Allows user to stop feeding a horsey This will trigger a random rarity chance function stopFeeding() external feedingInProgress() returns (bool) { uint256 blockNumber = pendingFeedings[msg.sender].blockNumber; uint256 tokenId = pendingFeedings[msg.sender].horsey; require(block.number - blockNumber >= 1,\"feeding and stop feeding are in same block\"); delete pendingFeedings[msg.sender]; if(block.number - blockNumber > 255) { emit FeedingFailed(tokenId); return false; } if(stables.ownerOf(tokenId) != msg.sender) { emit FeedingFailed(tokenId); return false; } _feed(tokenId, blockhash(blockNumber)); bytes32 dna; (,dna,,) = stables.horseys(tokenId); emit ReceivedCarrot(tokenId, dna); return true; } function() external payable { revert(\"Not accepting donations\"); } @dev Internal function to increase a horsey's rarity Uses a random value to assess if the feeding process increases rarity The chances of having a rarity increase are based on the current feedingCounter @param tokenId ID of the token to \"feed\" @param blockHash Hash of the block where the feeding began function _feed(uint256 tokenId, bytes32 blockHash) internal { uint8 tier; uint8 feedingCounter; (,,feedingCounter,tier) = stables.horseys(tokenId); uint256 probabilityByRarity = 10 ** (uint256(tier).add(1)); uint256 randNum = uint256(keccak256(abi.encodePacked(tokenId, blockHash))) % probabilityByRarity; if(randNum <= (feedingCounter * rarityMultiplier)){ _increaseRarity(tokenId, blockHash); } if(feedingCounter < 255) { stables.modifyHorseyFeedingCounter(tokenId,feedingCounter+1); } } function _makeSpecialId(address race, address sender, bytes32 coinIndex) internal pure returns (uint256) { return uint256(keccak256(abi.encodePacked(race, sender, coinIndex))); } @dev Internal function to generate a SPECIAL horsey token we then use the ERC721 inherited minting process the dna is a bytes32 target for a keccak256. Not using blockhash finaly, a bitmask zeros the first 2 bytes for rarity traits @param race Address of the associated race @param eth_address Address of the user to receive the token @param coinIndex The index of the winning coin @return ID of the token function _generate_special_horsey(address race, address eth_address, bytes32 coinIndex) internal returns (uint256) { uint256 id = _makeSpecialId(race, eth_address, coinIndex); bytes32 dna = _shiftRight(keccak256(abi.encodePacked(race, coinIndex)),16); stables.storeHorsey(eth_address,id,race,dna,1,0); return id; } @dev Internal function called to increase a horsey rarity We generate a random zeros mask with a single 1 in the leading 16 bits @param tokenId Id of the token to increase rarity of @param blockHash hash of the block where the feeding began function _increaseRarity(uint256 tokenId, bytes32 blockHash) private { uint8 tier; bytes32 dna; (,dna,,tier) = stables.horseys(tokenId); if(tier < 255) stables.modifyHorseyTier(tokenId,tier+1); uint256 random = uint256(keccak256(abi.encodePacked(tokenId, blockHash))); bytes32 rarityMask = _shiftLeft(bytes32(1), (random % 16 + 240)); stables.modifyHorseyDna(tokenId,newdna); } function _shiftLeft(bytes32 data, uint n) internal pure returns (bytes32) { return bytes32(uint256(data)*(2 ** n)); } function _shiftRight(bytes32 data, uint n) internal pure returns (bytes32) { return bytes32(uint256(data)/(2 ** n)); } modifier carrotsMeetLevel(uint256 tokenId){ uint256 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); require(feedingCounter <= stables.carrot_credits(msg.sender),\"Not enough carrots\"); _; } modifier costs(uint256 amount) { require(msg.value >= amount,\"Not enough funds\"); _; } modifier validAddress(address addr) { require(addr != address(0),\"Address is zero\"); _; } modifier noFeedingInProgress() { require(pendingFeedings[msg.sender].blockNumber == 0,\"Already feeding\"); _; } modifier feedingInProgress() { require(pendingFeedings[msg.sender].blockNumber != 0,\"No pending feeding\"); _; } modifier onlyOwnerOf(uint256 tokenId) { require(stables.ownerOf(tokenId) == msg.sender, \"Caller is not owner of this token\"); _; } } @title Adds rank management utilities and voting behavior @dev Handles equities distribution and levels of access EXCHANGE FUNCTIONS IT CAN CALL setClaimingFee OK 5 setMarketFees OK 1 withdraw TOKEN FUNCTIONS IT CAN CALL setRenamingCosts OK 0 addHorseIndex OK 3 setCarrotsMultiplier 8 setRarityMultiplier 9 addLegitDevAddress 2 withdraw PAUSING OK 4 contract HorseyPilot { using SafeMath for uint256; event NewProposal(uint8 methodId, uint parameter, address proposer); event ProposalPassed(uint8 methodId, uint parameter, address proposer); uint8 constant votingThreshold = 2; uint256 constant proposalLife = 7 days; uint256 constant proposalCooldown = 1 days; uint256 cooldownStart; address public jokerAddress; address public knightAddress; address public paladinAddress; address[3] public voters; uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; address public exchangeAddress; address public tokenAddress; mapping(address => uint) internal _cBalance; struct Proposal{ } Proposal public currentProposal; bool public proposalInProgress = false; uint256 public toBeDistributed; bool deployed = false; @param _jokerAddress joker @param _knightAddress knight @param _paladinAddress paladin @param _voters list of all allowed voting addresses constructor( address _jokerAddress, address _knightAddress, address _paladinAddress, address[3] _voters ) public { jokerAddress = _jokerAddress; knightAddress = _knightAddress; paladinAddress = _paladinAddress; for(uint i = 0; i < 3; i++) { voters[i] = _voters[i]; } cooldownStart = block.timestamp - proposalCooldown; } @dev Used to deploy children contracts as a one shot call function deployChildren(address stablesAddress) external { require(!deployed,\"already deployed\"); exchangeAddress = new HorseyExchange(); tokenAddress = new HorseyToken(stablesAddress); HorseyExchange(exchangeAddress).setStables(stablesAddress); deployed = true; } @dev Transfers joker ownership to a new address @param newJoker the new address function transferJokerOwnership(address newJoker) external validAddress(newJoker) { require(jokerAddress == msg.sender,\"Not right role\"); _moveBalance(newJoker); jokerAddress = newJoker; } @dev Transfers knight ownership to a new address @param newKnight the new address function transferKnightOwnership(address newKnight) external validAddress(newKnight) { require(knightAddress == msg.sender,\"Not right role\"); _moveBalance(newKnight); knightAddress = newKnight; } @dev Transfers paladin ownership to a new address @param newPaladin the new address function transferPaladinOwnership(address newPaladin) external validAddress(newPaladin) { require(paladinAddress == msg.sender,\"Not right role\"); _moveBalance(newPaladin); paladinAddress = newPaladin; } @dev Allow CEO to withdraw from pending value always checks to update redist We ONLY redist when a user tries to withdraw so we are not redistributing on every payment @param destination The address to send the ether to function withdrawCeo(address destination) external onlyCLevelAccess() validAddress(destination) { if(toBeDistributed > 0){ _updateDistribution(); } uint256 balance = _cBalance[msg.sender]; if(balance > 0 && (address(this).balance >= balance)) { _cBalance[msg.sender] = 0; } } function syncFunds() external { uint256 prevBalance = address(this).balance; HorseyToken(tokenAddress).withdraw(); HorseyExchange(exchangeAddress).withdraw(); uint256 newBalance = address(this).balance; toBeDistributed = toBeDistributed.add(newBalance - prevBalance); } function getNobleBalance() external view onlyCLevelAccess() returns (uint256) { return _cBalance[msg.sender]; } @dev Make a proposal and add to pending proposals @param methodId a string representing the function ie. 'renameHorsey()' @param parameter parameter to be used if invocation is approved function makeProposal( uint8 methodId, uint256 parameter ) external onlyCLevelAccess() proposalAvailable() cooledDown() { currentProposal.timestamp = block.timestamp; currentProposal.parameter = parameter; currentProposal.methodId = methodId; currentProposal.proposer = msg.sender; delete currentProposal.yay; delete currentProposal.nay; proposalInProgress = true; emit NewProposal(methodId,parameter,msg.sender); } @dev Call to vote on a pending proposal function voteOnProposal(bool voteFor) external proposalPending() onlyVoters() notVoted() { require((block.timestamp - currentProposal.timestamp) <= proposalLife); if(voteFor) { currentProposal.yay.push(msg.sender); if( currentProposal.yay.length >= votingThreshold ) { _doProposal(); proposalInProgress = false; return; } } else { currentProposal.nay.push(msg.sender); if( currentProposal.nay.length >= votingThreshold ) { proposalInProgress = false; cooldownStart = block.timestamp; return; } } } @dev Helps moving pending balance from one role to another @param newAddress the address to transfer the pending balance from the msg.sender account function _moveBalance(address newAddress) internal validAddress(newAddress) { _cBalance[newAddress] = _cBalance[msg.sender]; _cBalance[msg.sender] = 0; } @dev Called at the start of withdraw to distribute any pending balances that live in the contract will only ever be called if balance is non-zero (funds should be distributed) function _updateDistribution() internal { require(toBeDistributed != 0,\"nothing to distribute\"); uint256 knightPayday = toBeDistributed.div(100).mul(knightEquity); uint256 paladinPayday = toBeDistributed.div(100).mul(paladinEquity); uint256 jokerPayday = toBeDistributed.sub(knightPayday).sub(paladinPayday); _cBalance[jokerAddress] = _cBalance[jokerAddress].add(jokerPayday); _cBalance[knightAddress] = _cBalance[knightAddress].add(knightPayday); _cBalance[paladinAddress] = _cBalance[paladinAddress].add(paladinPayday); toBeDistributed = 0; } @dev Execute the proposal function _doProposal() internal { if( currentProposal.methodId == 0 ) HorseyToken(tokenAddress).setRenamingCosts(currentProposal.parameter); if( currentProposal.methodId == 1 ) HorseyExchange(exchangeAddress).setMarketFees(currentProposal.parameter); if( currentProposal.methodId == 2 ) HorseyToken(tokenAddress).addLegitDevAddress(address(currentProposal.parameter)); if( currentProposal.methodId == 3 ) HorseyToken(tokenAddress).addHorseIndex(bytes32(currentProposal.parameter)); if( currentProposal.methodId == 4 ) { if(currentProposal.parameter == 0) { HorseyExchange(exchangeAddress).unpause(); HorseyToken(tokenAddress).unpause(); } else { HorseyExchange(exchangeAddress).pause(); HorseyToken(tokenAddress).pause(); } } if( currentProposal.methodId == 5 ) HorseyToken(tokenAddress).setClaimingCosts(currentProposal.parameter); if( currentProposal.methodId == 8 ){ HorseyToken(tokenAddress).setCarrotsMultiplier(uint8(currentProposal.parameter)); } if( currentProposal.methodId == 9 ){ HorseyToken(tokenAddress).setRarityMultiplier(uint8(currentProposal.parameter)); } emit ProposalPassed(currentProposal.methodId,currentProposal.parameter,currentProposal.proposer); } modifier validAddress(address addr) { require(addr != address(0),\"Address is zero\"); _; } modifier onlyCLevelAccess() { require((jokerAddress == msg.sender) || (knightAddress == msg.sender) || (paladinAddress == msg.sender),\"not c level\"); _; } modifier proposalAvailable(){ require(((!proposalInProgress) || ((block.timestamp - currentProposal.timestamp) > proposalLife)),\"proposal already pending\"); _; } modifier cooledDown( ){ if(msg.sender == currentProposal.proposer && (block.timestamp - cooldownStart < 1 days)){ revert(\"Cool down period not passed yet\"); } _; } modifier proposalPending() { require(proposalInProgress,\"no proposal pending\"); _; } modifier notVoted() { uint256 length = currentProposal.yay.length; for(uint i = 0; i < length; i++) { if(currentProposal.yay[i] == msg.sender) { revert(\"Already voted\"); } } length = currentProposal.nay.length; for(i = 0; i < length; i++) { if(currentProposal.nay[i] == msg.sender) { revert(\"Already voted\"); } } _; } modifier onlyVoters() { bool found = false; uint256 length = voters.length; for(uint i = 0; i < length; i++) { if(voters[i] == msg.sender) { found = true; break; } } if(!found) { revert(\"not a voter\"); } _; } } "}
{"sol name": "5970_0.sol", "label": 0, "sol content": "contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract AbstractToken is Token, SafeMath { function AbstractToken () { } function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } mapping (address => uint256) accounts; mapping (address => mapping (address => uint256)) private allowances; } contract KVMToken is AbstractToken { uint256 constant MAX_TOKEN_COUNT = 25000000000 * (10**18); address private owner; mapping (address => bool) private frozenAccount; uint256 tokenCount = 0; bool frozen = false; function KVMToken () { owner = msg.sender; } function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"KevCoinmovie\"; string constant public symbol = \"KVM\"; uint8 constant public decimals = 18; function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); emit Transfer(0x0, msg.sender, _value); return true; } return false; } function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } event Freeze (); event Unfreeze (); event FrozenFunds(address target, bool frozen); event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "15728_0.sol", "label": 0, "sol content": "contract SafeMath { function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } } contract Token is SafeMath { function transfer(address _to, uint256 _value) public; function transferFrom(address _from, address _to, uint256 _value) public returns(bool); function approve(address _spender, uint256 _amount) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Crowdsale is Token { address public owner; string public name = \"crowdsalenetworkplatform\"; string public symbol = \"CSNP\"; uint8 public decimals = 18; uint256 public totalSupply = 50000000 * 10 ** uint256(decimals); address internal foundersAddress; address internal bonusAddress; uint internal dayStart = now; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); function Crowdsale(address enterFoundersAddress, address enterBonusAddress) public { foundersAddress = enterFoundersAddress; bonusAddress = enterBonusAddress; balanceOf[foundersAddress] = 12500000 * 10 ** uint256(decimals); balanceOf[bonusAddress] = 18750000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply - (12500000 * 10 ** uint256(decimals)) - (18750000 * 10 ** uint256(decimals)); owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); balanceOf[_from] = safeSub(balanceOf[_from],_value); balanceOf[_to] = safeAdd(balanceOf[_to],_value); emit Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public  { if(now < (dayStart + 365 days)){ require(msg.sender != foundersAddress && tx.origin != foundersAddress); } if(now < (dayStart + 180 days)){ require(msg.sender != bonusAddress && tx.origin != bonusAddress); } _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { if(now < (dayStart + 365 days)){ require(_from != foundersAddress); } if(now < (dayStart + 180 days)){ require(_from != bonusAddress); } allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _amount) public returns(bool success) { require((_amount == 0) || (allowance[msg.sender][_spender] == 0)); if(now < (dayStart + 365 days)){ require(msg.sender != foundersAddress && tx.origin != foundersAddress); } if(now < (dayStart + 180 days)){ require(msg.sender != bonusAddress && tx.origin != bonusAddress); } allowance[msg.sender][_spender] = _amount; return true; } } "}
{"sol name": "18894_0.sol", "label": 0, "sol content": "contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _tokenAmountApproved, address tokenMacroansy, bytes _extraData) public returns(bool success); } interface ICO { function buy( uint payment, address buyer, bool isPreview) public returns(bool success, uint amount, uint retPayment); function redeemCoin(uint256 amount, address redeemer, bool isPreview) public returns (bool success, uint redeemPayment); function sell(uint256 amount, address seller, bool isPreview) public returns (bool success, uint sellPayment ); function paymentAction(uint paymentValue, address beneficiary, uint paytype) public returns(bool success); function recvShrICO( address _spender, uint256 _value, uint ShrID)  public returns (bool success); function burn( uint256 value, bool unburn, uint totalSupplyStart, uint balOfOwner)  public returns( bool success); function getSCF() public returns(uint seriesCapFactorMulByTenPowerEighteen); function getMinBal() public returns(uint minBalForAccnts_ ); function getAvlShares(bool show) public  returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding); } interface Exchg{ function sell_Exchg_Reg( uint amntTkns, uint tknPrice, address seller) public returns(bool success); function buy_Exchg_booking( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment ) public returns(bool success); function buy_Exchg_BkgChk( address seller, uint amntTkns, uint tknPrice, address buyer, uint payment) public returns(bool success); function updateSeller( address seller, uint tknsApr, address buyer, uint payment) public returns(bool success); function getExchgComisnMulByThousand() public returns(uint exchgCommissionMulByThousand_); function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime, uint exchgCommissionMulByThousand_); } contract TokenERC20Interface { function totalSupply() public constant returns (uint coinLifeTimeTotalSupply); function balanceOf(address tokenOwner) public constant returns (uint coinBalance); function allowance(address tokenOwner, address spender) public constant returns (uint coinsRemaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address _from, address to, uint tokens) public returns (bool success); event Transfer(address indexed _from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract TokenMacroansyPower is TokenERC20Interface, SafeMath { string public name; string public symbol; uint8 public decimals = 3; address internal owner; address private  beneficiaryFunds; uint256 public totalSupply; uint256 internal totalSupplyStart; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping( address => bool) internal frozenAccount; mapping(address => uint) private msgSndr; address internal tkn_addr; address internal ico_addr; address internal exchg_addr; address internal cs_addr; uint256 internal allowedIndividualShare; uint256 internal allowedPublicShare; bool public crowdSaleOpen; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event BurnOrUnBurn(address indexed from, uint amount, uint burnOrUnburn); event FundOrPaymentTransfer(address beneficiary, uint amount); function TokenMacroansyPower()  public { owner = msg.sender; beneficiaryFunds = owner; totalSupplyStart = 270000000 * 10** uint256(decimals); totalSupply = totalSupplyStart; balanceOf[msg.sender] = totalSupplyStart; Transfer(address(0), msg.sender, totalSupplyStart); name = \"TokenMacroansyPower\"; symbol = \"$BEEPower\"; allowedIndividualShare = uint(1)*totalSupplyStart/100; allowedPublicShare = uint(20)* totalSupplyStart/100; crowdSaleOpen = false; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOr(address _Or) public onlyOwner { owner = _Or; } function totalSupply() constant public returns (uint coinLifeTimeTotalSupply) { return totalSupply ; } function balanceOf(address tokenOwner) constant public  returns (uint coinBalance) { return balanceOf[tokenOwner]; } function allowance(address tokenOwner, address spender) constant public returns (uint coinsRemaining) { return allowance[tokenOwner][spender]; } function setContrAddrAndCrwSale(bool setAddress,  address icoAddr, address exchAddr, address csAddr, bool setCrowdSale, bool crowdSaleOpen_ ) public onlyOwner returns(bool success){ if(setAddress == true){ ico_addr = icoAddr; exchg_addr = exchAddr; cs_addr = csAddr; } if( setCrowdSale == true )crowdSaleOpen = crowdSaleOpen_; return true; } function _getIcoAddr() internal  returns(address ico_ma_addr){  return(ico_addr); } function _getExchgAddr() internal returns(address exchg_ma_addr){ return(exchg_addr); } function _getCsAddr() internal returns(address cs_ma_addr){ return(cs_addr); } function _transfer(address _from, address _to, uint _value) internal  { require (_to != 0x0); require(!frozenAccount[_from]); require(!frozenAccount[_to]); uint valtmp = _value; uint _valueA = valtmp; valtmp = 0; require (balanceOf[_from] >= _valueA); require (balanceOf[_to] + _valueA > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] = safeSub(balanceOf[_from], _valueA); balanceOf[_to] = safeAdd(balanceOf[_to], _valueA); Transfer(_from, _to, _valueA); _valueA = 0; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns(bool success) { if(msg.sender != owner){ bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value); bool sucsByrLmt = _chkBuyerLmts( _to, _value); require(sucsSlrLmt == true && sucsByrLmt == true); } uint valtmp = _value; uint _valueTemp = valtmp; valtmp = 0; _transfer(msg.sender, _to, _valueTemp); _valueTemp = 0; return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint valtmp = _value; uint _valueA = valtmp; valtmp = 0; require(_valueA <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _valueA); _transfer(_from, _to, _valueA); _valueA = 0; return true; } function approve(address _spender, uint256 _value) public returns (bool success) { if(msg.sender != owner){ bool sucsSlrLmt = _chkSellerLmts( msg.sender, _value); bool sucsByrLmt = _chkBuyerLmts( _spender, _value); require(sucsSlrLmt == true && sucsByrLmt == true); } uint valtmp = _value; uint _valueA = valtmp; valtmp = 0; allowance[msg.sender][_spender] = _valueA; Approval(msg.sender, _spender, _valueA); _valueA =0; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); uint valtmp = _value; uint _valueA = valtmp; valtmp = 0; if (approve(_spender, _valueA)) { spender.receiveApproval(msg.sender, _valueA, this, _extraData); } _valueA = 0; return true; } function freezeAccount(address target, bool freeze) onlyOwner public returns(bool success) { frozenAccount[target] = freeze; return true; } function _safeTransferTkn( address _from, address _to, uint amount) internal returns(bool sucsTrTk){ uint tkA = amount; uint tkAtemp = tkA; tkA = 0; _transfer(_from, _to, tkAtemp); tkAtemp = 0; return true; } function _safeTransferPaymnt( address paymentBenfcry, uint payment) internal returns(bool sucsTrPaymnt){ uint pA = payment; uint paymentTemp = pA; pA = 0; paymentBenfcry.transfer(paymentTemp); FundOrPaymentTransfer(paymentBenfcry, paymentTemp); paymentTemp = 0; return true; } function _safePaymentActionAtIco( uint payment, address paymentBenfcry, uint paytype) internal returns(bool success){ uint Pm = payment; uint PmTemp = Pm; Pm = 0; ICO ico = ICO(_getIcoAddr()); bool pymActSucs = ico.paymentAction( PmTemp, paymentBenfcry, paytype); require(pymActSucs ==  true); PmTemp = 0; return true; } function buyCoinsCrowdSale(address buyer, uint payment, address crowdSaleContr) public returns(bool success, uint retPayment) { require(crowdSaleOpen == true && crowdSaleContr == _getCsAddr()); success = false; (success , retPayment) = _buyCoins( buyer, payment); require(success == true); return (success, retPayment); } function _buyCoins(address buyer, uint payment) internal returns(bool success, uint retPayment) { msgSndr[buyer] = payment; ICO ico = ICO(_getIcoAddr() ); require(  payment > 0 ); bool icosuccess;  uint tknsBuyAppr; (icosuccess, tknsBuyAppr, retPayment ) = ico.buy( payment, buyer, false); require( icosuccess == true ); if(crowdSaleOpen == false) { if( retPayment > 0 ) { bool sucsTrPaymnt; sucsTrPaymnt = _safeTransferPaymnt( buyer, retPayment ); require(sucsTrPaymnt == true ); } } bool sucsTrTk =  _safeTransferTkn( owner, buyer, tknsBuyAppr); require(sucsTrTk == true); msgSndr[buyer] = 0; return (true, retPayment); } function redeemOrSellCoinsToICO(uint enter1forRedeemOR2forSell, uint256 amountOfCoinPartsToRedeemOrSell) public returns (bool success ) { require(crowdSaleOpen == false); uint amount = amountOfCoinPartsToRedeemOrSell; msgSndr[msg.sender] = amount; bool isPreview = false; ICO ico = ICO(_getIcoAddr()); bool icosuccess ; uint redeemOrSellPaymentValue; if(enter1forRedeemOR2forSell == 1){ (icosuccess , redeemOrSellPaymentValue) = ico.redeemCoin( amount, msg.sender, isPreview); } if(enter1forRedeemOR2forSell == 2){ (icosuccess , redeemOrSellPaymentValue) = ico.sell( amount, msg.sender, isPreview); } require( icosuccess == true); require( _getIcoAddr().balance >= safeAdd( ico.getMinBal() , redeemOrSellPaymentValue) ); bool sucsTrTk = false; bool pymActSucs = false; if(isPreview == false) { sucsTrTk =  _safeTransferTkn( msg.sender, owner, amount); require(sucsTrTk == true); msgSndr[msg.sender] = redeemOrSellPaymentValue; pymActSucs = _safePaymentActionAtIco( redeemOrSellPaymentValue, msg.sender, enter1forRedeemOR2forSell); require(pymActSucs ==  true); } msgSndr[msg.sender] = 0; return (true); } function _chkSellerLmts( address seller, uint amountOfCoinsSellerCanSell) internal returns(bool success){ uint amountTkns = amountOfCoinsSellerCanSell; success = false; ICO ico = ICO( _getIcoAddr() ); uint seriesCapFactor = ico.getSCF(); if( amountTkns <= balanceOf[seller]  &&  balanceOf[seller] <=  safeDiv(allowedIndividualShare*seriesCapFactor,10**18) ){ success = true; } return success; } function _chkBuyerLmts( address buyer, uint amountOfCoinsBuyerCanBuy)  internal  returns(bool success){ uint amountTkns = amountOfCoinsBuyerCanBuy; success = false; ICO ico = ICO( _getIcoAddr() ); uint seriesCapFactor = ico.getSCF(); if( amountTkns <= safeSub( safeDiv(allowedIndividualShare*seriesCapFactor,10**18), balanceOf[buyer] )) { success = true; } return success; } function _chkBuyerLmtsAndFinl( address buyer, uint amountTkns, uint priceOfr) internal returns(bool success){ success = false; bool sucs1 = false; sucs1 = _chkBuyerLmts( buyer, amountTkns); ICO ico = ICO( _getIcoAddr() ); bool sucs2 = false; if( buyer.balance >=  safeAdd( safeMul(amountTkns , priceOfr) , ico.getMinBal() )  )  sucs2 = true; if( sucs1 == true && sucs2 == true)  success = true; return success; } function _slrByrLmtChk( address seller, uint amountTkns, uint priceOfr, address buyer) internal returns(bool success){ bool successSlrl; (successSlrl) = _chkSellerLmts( seller, amountTkns); bool successByrlAFinl; (successByrlAFinl) = _chkBuyerLmtsAndFinl( buyer, amountTkns, priceOfr); require( successSlrl == true && successByrlAFinl == true); return true; } function () public payable { if(msg.sender != owner){ require(crowdSaleOpen == false); bool success = false; uint retPayment; (success , retPayment) = _buyCoins( msg.sender, msg.value); require(success == true); } } function burn( uint256 value, bool unburn) onlyOwner public returns( bool success ) { require(crowdSaleOpen == false); msgSndr[msg.sender] = value; ICO ico = ICO( _getIcoAddr() ); if( unburn == false) { balanceOf[owner] = safeSub( balanceOf[owner] , value); totalSupply = safeSub( totalSupply, value); BurnOrUnBurn(owner, value, 1); } if( unburn == true) { balanceOf[owner] = safeAdd( balanceOf[owner] , value); totalSupply = safeAdd( totalSupply , value); BurnOrUnBurn(owner, value, 2); } bool icosuccess = ico.burn( value, unburn, totalSupplyStart, balanceOf[owner] ); require( icosuccess == true); return true; } function withdrawFund(uint withdrawAmount) onlyOwner public returns(bool success) { success = _withdraw(withdrawAmount); return success; } function _withdraw(uint _withdrawAmount) internal returns(bool success) { bool sucsTrPaymnt = _safeTransferPaymnt( beneficiaryFunds, _withdrawAmount); require(sucsTrPaymnt == true); return true; } function receiveICOcoins( uint256 amountOfCoinsToReceive, uint ShrID )  public returns (bool success){ require(crowdSaleOpen == false); msgSndr[msg.sender] = amountOfCoinsToReceive; ICO ico = ICO( _getIcoAddr() ); bool  icosuccess; icosuccess = ico.recvShrICO(msg.sender, amountOfCoinsToReceive, ShrID ); require (icosuccess == true); bool sucsTrTk; sucsTrTk =  _safeTransferTkn( owner, msg.sender, amountOfCoinsToReceive); require(sucsTrTk == true); msgSndr[msg.sender] = 0; return  true; } function sellBkgAtExchg( uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) public returns(bool success){ require(crowdSaleOpen == false); uint amntTkns = sellerCoinPartsForSale; uint tknPrice = sellerPricePerCoinPartInWEI; bool successSlrl; (successSlrl) = _chkSellerLmts( msg.sender, amntTkns); require(successSlrl == true); msgSndr[msg.sender] = amntTkns; Exchg em = Exchg(_getExchgAddr()); bool  emsuccess; (emsuccess) = em.sell_Exchg_Reg( amntTkns, tknPrice, msg.sender ); require(emsuccess == true ); msgSndr[msg.sender] = 0; return true; } function buyBkgAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI, uint myProposedPaymentInWEI) public returns(bool success){ require(crowdSaleOpen == false); uint amountTkns = sellerCoinPartsForSale; uint priceOfr = sellerPricePerCoinPartInWEI; uint payment = myProposedPaymentInWEI; uint tknsBuyAppr = 0; if( amountTkns > 2 &&  payment >=  (2 * priceOfr) &&  payment <= (amountTkns * priceOfr) ) { tknsBuyAppr = safeDiv( payment , priceOfr ); } require(tknsBuyAppr > 0); msgSndr[msg.sender] = amountTkns; bool sucsLmt = _slrByrLmtChk( seller, amountTkns, priceOfr, msg.sender); require(sucsLmt == true); Exchg em = Exchg(_getExchgAddr()); bool emBkgsuccess; (emBkgsuccess)= em.buy_Exchg_booking( seller, amountTkns, priceOfr, msg.sender, payment); require( emBkgsuccess == true ); msgSndr[msg.sender] = 0; return true; } function buyCoinsAtExchg( address seller, uint sellerCoinPartsForSale, uint sellerPricePerCoinPartInWEI) payable public returns(bool success) { require(crowdSaleOpen == false); uint amountTkns = sellerCoinPartsForSale; uint priceOfr = sellerPricePerCoinPartInWEI; if( amountTkns > 2 &&  msg.value >=  (2 * priceOfr) &&  msg.value <= (amountTkns * priceOfr) ) { tknsBuyAppr = safeDiv( msg.value , priceOfr ); } uint retPayment = 0; if(  msg.value > 0 ){ retPayment = safeSub( msg.value , tknsBuyAppr * priceOfr); } msgSndr[msg.sender] = amountTkns; Exchg em = Exchg(_getExchgAddr()); bool sucsBkgChk = false; if(tknsBuyAppr > 0){ sucsBkgChk = em.buy_Exchg_BkgChk(seller, amountTkns, priceOfr, msg.sender, msg.value); } if(sucsBkgChk == false) tknsBuyAppr = 0; msgSndr[msg.sender] = tknsBuyAppr; bool emUpdateSuccess; (emUpdateSuccess) = em.updateSeller(seller, tknsBuyAppr, msg.sender, msg.value); require( emUpdateSuccess == true ); if(sucsBkgChk == true && tknsBuyAppr > 0){ bool sucsTrTkn = _safeTransferTkn( seller, msg.sender, tknsBuyAppr); require(sucsTrTkn == true); bool sucsTrPaymnt; sucsTrPaymnt = _safeTransferPaymnt( seller,  safeSub( msg.value , safeDiv(msg.value*em.getExchgComisnMulByThousand(),1000) ) ); require(sucsTrPaymnt == true ); } if( retPayment > 0 ) { bool sucsTrRetPaymnt; sucsTrRetPaymnt = _safeTransferPaymnt( msg.sender, retPayment ); require(sucsTrRetPaymnt == true ); } msgSndr[msg.sender] = 0; return true; } function sendMsgSndr(address caller, address origin) public returns(bool success, uint value){ (success, value) = _sendMsgSndr(caller, origin); return(success, value); } function _sendMsgSndr(address caller,  address origin) internal returns(bool success, uint value){ require( caller == _getIcoAddr() || caller == _getExchgAddr() || caller == _getCsAddr() ); return(true, msgSndr[origin]); } function viewSellOffersAtExchangeMacroansy(address seller, bool show) view public returns (uint sellersCoinAmountOffer, uint sellersPriceOfOneCoinInWEI, uint sellerBookedTime, address buyerWhoBooked, uint buyPaymentBooked, uint buyerBookedTime){ if(show == true){ Exchg em = Exchg(_getExchgAddr()); ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime, ) = em.viewSellOffersAtExchangeMacroansy( seller, show) ; return ( sellersCoinAmountOffer,  sellersPriceOfOneCoinInWEI,  sellerBookedTime,  buyerWhoBooked,  buyPaymentBooked,  buyerBookedTime); } } function viewCoinSupplyAndFunding(bool show) public view returns(uint totalSupplyOfCoinsInSeriesNow, uint coinsAvailableForSale, uint icoFunding){ if(show == true){ ICO ico = ICO( _getIcoAddr() ); ( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding) = ico.getAvlShares(show); return( totalSupplyOfCoinsInSeriesNow, coinsAvailableForSale, icoFunding); } } bool private isEndOk; function endOfRewards(bool isEndNow) public onlyOwner { isEndOk == isEndNow; } function endOfRewardsConfirmed(bool isEndNow) public onlyOwner{ if(isEndOk == true && isEndNow == true) selfdestruct(owner); } } "}
{"sol name": "5126_0.sol", "label": 0, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256 c) { if(a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); modifier onlyOwner() { require(msg.sender == owner); _;  } constructor() public { owner = msg.sender; } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } } contract ERC20 { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function totalSupply() public view returns(uint256); function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); function transferFrom(address from, address to, uint256 value) public returns(bool); function allowance(address owner, address spender) public view returns(uint256); function approve(address spender, uint256 value) public returns(bool); } contract StandardToken is ERC20 { using SafeMath for uint256; uint256 totalSupply_; string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) internal allowed; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } function totalSupply() public view returns(uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns(uint256) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns(bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function multiTransfer(address[] _to, uint256[] _value) public returns(bool) { require(_to.length == _value.length); for(uint i = 0; i < _to.length; i++) { transfer(_to[i], _value[i]); } return true; } function transferFrom(address _from, address _to, uint256 _value) public returns(bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function allowance(address _owner, address _spender) public view returns(uint256) { return allowed[_owner][_spender]; } function approve(address _spender, uint256 _value) public returns(bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function increaseApproval(address _spender, uint _addedValue) public returns(bool) { allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns(bool) { uint oldValue = allowed[msg.sender][_spender]; if(_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { bool public mintingFinished = false; event Mint(address indexed to, uint256 amount); event MintFinished(); modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } function mint(address _to, uint256 _amount) hasMintPermission canMint public returns(bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns(bool) { mintingFinished = true; emit MintFinished(); return true; } } contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } function mint(address _to, uint256 _amount) public returns(bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } function burn(uint256 _value) public { _burn(msg.sender, _value); } function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } } contract Withdrawable is Ownable { function withdrawEther(address _to, uint _value) onlyOwner public { require(_to != address(0)); require(address(this).balance >= _value); _to.transfer(_value); } function withdrawTokensTransfer(ERC20 _token, address _to, uint256 _value) onlyOwner public { require(_token.transfer(_to, _value)); } function withdrawTokensTransferFrom(ERC20 _token, address _from, address _to, uint256 _value) onlyOwner public { require(_token.transferFrom(_from, _to, _value)); } function withdrawTokensApprove(ERC20 _token, address _spender, uint256 _value) onlyOwner public { require(_token.approve(_spender, _value)); } } contract Pausable is Ownable { bool public paused = false; event Pause(); event Unpause(); modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract Manageable is Ownable { address[] public managers; event ManagerAdded(address indexed manager); event ManagerRemoved(address indexed manager); modifier onlyManager() { require(isManager(msg.sender)); _; } function countManagers() view public returns(uint) { return managers.length; } function getManagers() view public returns(address[]) { return managers; } function isManager(address _manager) view public returns(bool) { for(uint i = 0; i < managers.length; i++) { if(managers[i] == _manager) { return true; } } return false; } function addManager(address _manager) onlyOwner public { require(_manager != address(0)); require(!isManager(_manager)); managers.push(_manager); emit ManagerAdded(_manager); } function removeManager(address _manager) onlyOwner public { require(isManager(_manager)); uint index = 0; for(uint i = 0; i < managers.length; i++) { if(managers[i] == _manager) { index = i; } } for(; index < managers.length - 1; index++) { managers[index] = managers[index + 1]; } managers.length--; emit ManagerRemoved(_manager); } } contract Token is CappedToken, BurnableToken, Withdrawable { constructor() CappedToken(100000000 * 1e8) StandardToken(\"SILK\", \"SILK\", 8) public { } } contract Crowdsale is Manageable, Withdrawable, Pausable { using SafeMath for uint; Token public token; bool public crowdsaleClosed = false; event ExternalPurchase(address indexed holder, string tx, string currency, uint256 currencyAmount, uint256 rateToEther, uint256 tokenAmount); event CrowdsaleClose(); constructor() public { token = new Token(); } function externalPurchase(address _to, string _tx, string _currency, uint _value, uint256 _rate, uint256 _tokens) whenNotPaused onlyManager public { token.mint(_to, _tokens); emit ExternalPurchase(_to, _tx, _currency, _value, _rate, _tokens); } function closeCrowdsale(address _to) onlyOwner public { require(!crowdsaleClosed); token.transferOwnership(_to); crowdsaleClosed = true; emit CrowdsaleClose(); } } "}
{"sol name": "33498_1.sol", "label": 1, "sol content": "contract Dividend { struct Record { uint balance; uint shares; uint index; } mapping (address => Record) public records; address[] public investors; address public funder; uint public startTime; uint public totalShares; uint public lastInvestmentTime; event Invested(uint indexed timestamp, address indexed from, uint amount, uint shares); event Withdrawn(uint indexed timestamp, address indexed from, uint amount); function Dividend() public payable { records[msg.sender] = Record(msg.value, totalShares = allocateShares(msg.value, 0), investors.push(funder = msg.sender)); Invested(startTime = lastInvestmentTime = now, msg.sender, msg.value, totalShares); } function () public payable { invest(); } function investorCount() public view returns (uint) { return investors.length; } function invest() public payable returns (uint) { uint value = msg.value; uint shares = allocateShares(value, (now - startTime) / 1 hours); if (shares > 0) { for (uint i = investors.length; i > 0; i--) { Record storage rec = records[investors[i - 1]]; rec.balance += value * rec.shares / totalShares; } address investor = msg.sender; rec = records[investor]; if (rec.index > 0) { rec.shares += shares; } else { rec.shares = shares; rec.index = investors.push(investor); } totalShares += shares; Invested(lastInvestmentTime = now, investor, value, shares); } return shares; } function withdraw() public returns (uint) { Record storage rec = records[msg.sender]; uint balance = rec.balance; if (balance > 0) { rec.balance = 0; msg.sender.transfer(balance); Withdrawn(now, msg.sender, balance); } if (now - lastInvestmentTime > 4 weeks) { selfdestruct(funder); } return balance; } function allocateShares(uint weis, uint bonus) public pure returns (uint) { return weis * (1000 + bonus) / 1 ether; } } "}
{"sol name": "33865_1.sol", "label": 1, "sol content": "contract Token { function transfer(address to, uint amount) public returns (bool); } contract Ownable { address Owner = msg.sender; modifier onlyOwner { if (msg.sender == Owner) _; } function transferOwnership(address to) public onlyOwner { Owner = to; } } contract TokenVault is Ownable { function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) { return Token(token).transfer(to, amount); } } contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 1 ether; Locked = false; deposit(); } function MinimumDeposit() public constant returns (uint) { return minDeposit; } function ReleaseDate() public constant returns (uint) { return Date; } function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; } function() public payable { deposit(); } function deposit() public payable { if (msg.value > 0) { if (msg.value >= MinimumDeposit()) Deposits[msg.sender] += msg.value; Deposit(msg.sender, msg.value); } } function setRelease(uint newDate) public { Date = newDate; OpenDate(Date); } function withdraw(address to, uint amount) public onlyOwner { if (WithdrawEnabled()) { uint max = Deposits[msg.sender]; if (max > 0 && amount <= max) { to.transfer(amount); Withdrawal(to, amount); } } } function lock() public { Locked = true; } address owner; modifier open { if (!Locked) _; owner = msg.sender; } function kill() public { require(this.balance == 0); selfdestruct(Owner); } function getOwner() external constant returns (address) { return owner; } } "}
{"sol name": "38959_1.sol", "label": 1, "sol content": "contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract Wallet is multisig, multiowned, daylimit { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { suicide(_to); } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "23333_1.sol", "label": 1, "sol content": "contract AbstractToken { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is AbstractToken { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract WayBackToken is StandardToken { function () { return kill(); } function kill()  public { selfdestruct(address(this)); } NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. function WayBackToken( ) { } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if(!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) { throw; } return true; } } "}
{"sol name": "35813_1.sol", "label": 1, "sol content": "library SafeMath { function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); if (0 < c) c = 0; return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } } contract Multiple3x is Ownable{ using SafeMath for uint256; mapping (address=>uint) public deposits; uint maxDeposit = 1 ether; function() payable { deposit(); } function deposit() payable { require(now < refundTime); require(msg.value >= minDeposit); uint256 dep = deposits[msg.sender]; uint256 sumDep = msg.value.add(dep); if (sumDep > maxDeposit){ deposits[msg.sender] = maxDeposit; } else{ deposits[msg.sender] = sumDep; } } function refund() payable { require(now >= refundTime && now < ownerTime); uint256 dep = deposits[msg.sender]; uint256 depHalf = this.balance.div(2); uint256 dep3x = dep.mul(3); deposits[msg.sender] = 0; if (this.balance > 0 && dep3x > 0){ if (dep3x > this.balance){ } else{ } } } function refundOwner() { require(now >= ownerTime); if(owner.send(this.balance)){ suicide(owner); } } } "}
{"sol name": "7579_1.sol", "label": 1, "sol content": "contract ABLEBurned { function () payable { } function burnMe () { selfdestruct(address(this)); } } "}
{"sol name": "24588_1.sol", "label": 1, "sol content": "contract TeikhosBounty { bytes32 proof_of_public_key1 = hex\"381c185bf75548b134adc3affd0cc13e66b16feb125486322fa5f47cb80a5bf0\"; bytes32 proof_of_public_key2 = hex\"5f9d1d2152eae0513a4814bd8e6b0dd3ac8f6310c0494c03e9aa08bcd867c352\"; address signer = address(keccak256(_publicKey)); bytes32 publicKey1; bytes32 publicKey2; assembly { publicKey1 := mload(add(_publicKey,0x20)) publicKey2 := mload(add(_publicKey,0x40)) } bytes32 r = proof_of_public_key1 ^ publicKey1; bytes32 s = proof_of_public_key2 ^ publicKey2; bytes32 msgHash = keccak256(\"\\x19Ethereum Signed Message:\\n64\", _publicKey); if(ecrecover(msgHash, 27, r, s) == signer) suicide(msg.sender); if(ecrecover(msgHash, 28, r, s) == signer) suicide(msg.sender); } function() payable {} } "}
{"sol name": "38543_1.sol", "label": 1, "sol content": "contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { require(isOwner(msg.sender)); _; } modifier onlymanyowners(bytes32 _operation) { require(confirmAndCheck(_operation)); _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { require(underLimit(_value)); _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { if (today() > m_lastDay) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract Wallet is multisig, multiowned, daylimit { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { selfdestruct(_to); } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); require(_to.call.value(_value)(_data)); return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { require(m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data)); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "39557_1.sol", "label": 1, "sol content": "contract multiowned { struct PendingState { uint yetNeeded; uint ownersDone; uint index; } event Confirmation(address owner, bytes32 operation); event Revoke(address owner, bytes32 operation); event OwnerChanged(address oldOwner, address newOwner); event OwnerAdded(address newOwner); event OwnerRemoved(address oldOwner); event RequirementChanged(uint newRequirement); modifier onlyowner { if (isOwner(msg.sender)) _; } modifier onlymanyowners(bytes32 _operation) { if (confirmAndCheck(_operation)) _; } function multiowned(address[] _owners, uint _required) { m_numOwners = _owners.length + 1; m_owners[1] = uint(msg.sender); m_ownerIndex[uint(msg.sender)] = 1; for (uint i = 0; i < _owners.length; ++i) { m_owners[2 + i] = uint(_owners[i]); m_ownerIndex[uint(_owners[i])] = 2 + i; } m_required = _required; } function revoke(bytes32 _operation) external { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; uint ownerIndexBit = 2**ownerIndex; var pending = m_pending[_operation]; if (pending.ownersDone & ownerIndexBit > 0) { pending.yetNeeded++; pending.ownersDone -= ownerIndexBit; Revoke(msg.sender, _operation); } } function changeOwner(address _from, address _to) onlymanyowners(sha3(msg.data)) external { if (isOwner(_to)) return; uint ownerIndex = m_ownerIndex[uint(_from)]; if (ownerIndex == 0) return; clearPending(); m_owners[ownerIndex] = uint(_to); m_ownerIndex[uint(_from)] = 0; m_ownerIndex[uint(_to)] = ownerIndex; OwnerChanged(_from, _to); } function addOwner(address _owner) onlymanyowners(sha3(msg.data)) external { if (isOwner(_owner)) return; clearPending(); if (m_numOwners >= c_maxOwners) reorganizeOwners(); if (m_numOwners >= c_maxOwners) return; m_numOwners++; m_owners[m_numOwners] = uint(_owner); m_ownerIndex[uint(_owner)] = m_numOwners; OwnerAdded(_owner); } function removeOwner(address _owner) onlymanyowners(sha3(msg.data)) external { uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return; if (m_required > m_numOwners - 1) return; m_owners[ownerIndex] = 0; m_ownerIndex[uint(_owner)] = 0; clearPending(); OwnerRemoved(_owner); } function changeRequirement(uint _newRequired) onlymanyowners(sha3(msg.data)) external { if (_newRequired > m_numOwners) return; m_required = _newRequired; clearPending(); RequirementChanged(_newRequired); } function getOwner(uint ownerIndex) external constant returns (address) { return address(m_owners[ownerIndex + 1]); } function isOwner(address _addr) returns (bool) { return m_ownerIndex[uint(_addr)] > 0; } function hasConfirmed(bytes32 _operation, address _owner) constant returns (bool) { var pending = m_pending[_operation]; uint ownerIndex = m_ownerIndex[uint(_owner)]; if (ownerIndex == 0) return false; uint ownerIndexBit = 2**ownerIndex; return !(pending.ownersDone & ownerIndexBit == 0); } function confirmAndCheck(bytes32 _operation) internal returns (bool) { uint ownerIndex = m_ownerIndex[uint(msg.sender)]; if (ownerIndex == 0) return; var pending = m_pending[_operation]; if (pending.yetNeeded == 0) { pending.yetNeeded = m_required; pending.ownersDone = 0; pending.index = m_pendingIndex.length++; m_pendingIndex[pending.index] = _operation; } uint ownerIndexBit = 2**ownerIndex; if (pending.ownersDone & ownerIndexBit == 0) { Confirmation(msg.sender, _operation); if (pending.yetNeeded <= 1) { delete m_pendingIndex[m_pending[_operation].index]; delete m_pending[_operation]; return true; } else { pending.yetNeeded--; pending.ownersDone |= ownerIndexBit; } } } function reorganizeOwners() private { uint free = 1; while (free < m_numOwners) { while (free < m_numOwners && m_owners[free] != 0) free++; while (m_numOwners > 1 && m_owners[m_numOwners] == 0) m_numOwners--; if (free < m_numOwners && m_owners[m_numOwners] != 0 && m_owners[free] == 0) { m_owners[free] = m_owners[m_numOwners]; m_ownerIndex[m_owners[free]] = free; m_owners[m_numOwners] = 0; } } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) if (m_pendingIndex[i] != 0) delete m_pending[m_pendingIndex[i]]; delete m_pendingIndex; } uint public m_required; uint public m_numOwners; uint[256] m_owners; uint constant c_maxOwners = 250; mapping(uint => uint) m_ownerIndex; mapping(bytes32 => PendingState) m_pending; bytes32[] m_pendingIndex; } contract daylimit is multiowned { modifier limitedDaily(uint _value) { if (underLimit(_value)) _; } function daylimit(uint _limit) { m_dailyLimit = _limit; m_lastDay = today(); } function setDailyLimit(uint _newLimit) onlymanyowners(sha3(msg.data)) external { m_dailyLimit = _newLimit; } function resetSpentToday() onlymanyowners(sha3(msg.data)) external { m_spentToday = 0; } function underLimit(uint _value) internal onlyowner returns (bool) { m_spentToday = 0; m_lastDay = today(); } if (m_spentToday + _value >= m_spentToday && m_spentToday + _value <= m_dailyLimit) { m_spentToday += _value; return true; } return false; } function today() private constant returns (uint) { return now / 1 days; } uint public m_dailyLimit; uint public m_spentToday; uint public m_lastDay; } contract multisig { event Deposit(address _from, uint value); event SingleTransact(address owner, uint value, address to, bytes data); event MultiTransact(address owner, bytes32 operation, uint value, address to, bytes data); event ConfirmationNeeded(bytes32 operation, address initiator, uint value, address to, bytes data); function changeOwner(address _from, address _to) external; function execute(address _to, uint _value, bytes _data) external returns (bytes32); function confirm(bytes32 _h) returns (bool); } contract Wallet is multisig, multiowned, daylimit { struct Transaction { address to; uint value; bytes data; } function Wallet(address[] _owners, uint _required, uint _daylimit) multiowned(_owners, _required) daylimit(_daylimit) { } function kill(address _to) onlymanyowners(sha3(msg.data)) external { suicide(_to); } function() payable { if (msg.value > 0) Deposit(msg.sender, msg.value); } function execute(address _to, uint _value, bytes _data) external onlyowner returns (bytes32 _r) { if (underLimit(_value)) { SingleTransact(msg.sender, _value, _to, _data); _to.call.value(_value)(_data); return 0; } _r = sha3(msg.data, block.number); if (!confirm(_r) && m_txs[_r].to == 0) { m_txs[_r].to = _to; m_txs[_r].value = _value; m_txs[_r].data = _data; ConfirmationNeeded(_r, msg.sender, _value, _to, _data); } } function confirm(bytes32 _h) onlymanyowners(_h) returns (bool) { if (m_txs[_h].to != 0) { m_txs[_h].to.call.value(m_txs[_h].value)(m_txs[_h].data); MultiTransact(msg.sender, _h, m_txs[_h].value, m_txs[_h].to, m_txs[_h].data); delete m_txs[_h]; return true; } } function clearPending() internal { uint length = m_pendingIndex.length; for (uint i = 0; i < length; ++i) delete m_txs[m_pendingIndex[i]]; super.clearPending(); } mapping (bytes32 => Transaction) m_txs; } "}
{"sol name": "39411_1.sol", "label": 1, "sol content": "contract EtherGame { uint[] a; function Test1(uint a) public returns(address) { return msg.sender; } function Test2(uint a) returns(address) { return msg.sender; } function Test3(uint b) public returns(uint) { return a.length; } function Test4(uint b) returns(uint) { return a.length; } function Kill(uint a) { selfdestruct(msg.sender); } } "}
{"sol name": "33951_1.sol", "label": 1, "sol content": "contract Token { function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint amount) public returns (bool); } contract Ownable { address Owner = msg.sender; modifier onlyOwner { if (msg.sender == Owner) _; } function transferOwnership(address to) public onlyOwner { Owner = to; } } contract TokenVault is Ownable { address self = address(this); function withdrawTokenTo(address token, address to, uint amount) public onlyOwner returns (bool) { return Token(token).transfer(to, amount); } function withdrawToken(address token) public returns (bool) { return withdrawTokenTo(token, msg.sender, Token(token).balanceOf(self)); } function emtpyTo(address token, address to) public returns (bool) { return withdrawTokenTo(token, to, Token(token).balanceOf(self)); } } contract Vault is TokenVault { event Deposit(address indexed depositor, uint amount); event Withdrawal(address indexed to, uint amount); event OpenDate(uint date); mapping (address => uint) public Deposits; uint minDeposit; bool Locked; uint Date; function init() payable open { Owner = msg.sender; minDeposit = 0.5 ether; Locked = false; deposit(); } function MinimumDeposit() public constant returns (uint) { return minDeposit; } function ReleaseDate() public constant returns (uint) { return Date; } function WithdrawEnabled() public constant returns (bool) { return Date > 0 && Date <= now; } function() public payable { deposit(); } function deposit() public payable { if (msg.value > 0) { if (msg.value >= MinimumDeposit()) Deposits[msg.sender] += msg.value; Deposit(msg.sender, msg.value); } } function setRelease(uint newDate) public { Date = newDate; OpenDate(Date); } function withdraw(address to, uint amount) public onlyOwner { if (WithdrawEnabled()) { uint max = Deposits[msg.sender]; if (max > 0 && amount <= max) { to.transfer(amount); Withdrawal(to, amount); } } } function lock() public { Locked = true; } address owner; modifier open { if (!Locked) _; owner = msg.sender; } function kill() public { require(this.balance == 0); selfdestruct(Owner); } function getOwner() external constant returns (address) { return owner; } } "}
{"sol name": "1020_1.sol", "label": 1, "sol content": "contract ERC721Basic { event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public; } contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } contract ERC721Metadata is ERC721Basic { function name() public view returns (string _name); function symbol() public view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } contract ERC721Receiver { bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } library AddressUtils { function isContract(address addr) internal view returns (bool) { uint256 size; return size > 0; } } contract ERC721BasicToken is ERC721Basic { using SafeMath for uint256; using AddressUtils for address; bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; mapping (uint256 => address) internal tokenOwner; mapping (uint256 => address) internal tokenApprovals; mapping (address => uint256) internal ownedTokensCount; mapping (address => mapping (address => bool)) internal operatorApprovals; modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } modifier canTransfer(uint256 _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } function exists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); if (getApproved(_tokenId) != address(0) || _to != address(0)) { tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } } function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } function safeTransferFrom( address _from, address _to, uint256 _tokenId ) public canTransfer(_tokenId) { safeTransferFrom(_from, _to, _tokenId, \"\"); } function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) { address owner = ownerOf(_tokenId); return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender); } function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } function _burn(address _owner, uint256 _tokenId) internal { clearApproval(_owner, _tokenId); removeTokenFrom(_owner, _tokenId); emit Transfer(_owner, address(0), _tokenId); } function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); emit Approval(_owner, address(0), _tokenId); } } function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } contract ERC721Token is ERC721, ERC721BasicToken { string internal name_; string internal symbol_; mapping (address => uint256[]) internal ownedTokens; mapping(uint256 => uint256) internal ownedTokensIndex; uint256[] internal allTokens; mapping(uint256 => uint256) internal allTokensIndex; mapping(uint256 => string) internal tokenURIs; function ERC721Token(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; } function name() public view returns (string) { return name_; } function symbol() public view returns (string) { return symbol_; } function tokenURI(uint256 _tokenId) public view returns (string) { require(exists(_tokenId)); return tokenURIs[_tokenId]; } function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } function totalSupply() public view returns (uint256) { return allTokens.length; } function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } function _setTokenURI(uint256 _tokenId, string _uri) internal { require(exists(_tokenId)); tokenURIs[_tokenId] = _uri; } function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; ownedTokens[_from][lastTokenIndex] = 0; ownedTokens[_from].length--; ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } function _mint(address _to, uint256 _tokenId) internal { super._mint(_to, _tokenId); allTokensIndex[_tokenId] = allTokens.length; allTokens.push(_tokenId); } function _burn(address _owner, uint256 _tokenId) internal { super._burn(_owner, _tokenId); if (bytes(tokenURIs[_tokenId]).length != 0) { delete tokenURIs[_tokenId]; } uint256 tokenIndex = allTokensIndex[_tokenId]; uint256 lastTokenIndex = allTokens.length.sub(1); uint256 lastToken = allTokens[lastTokenIndex]; allTokens[tokenIndex] = lastToken; allTokens[lastTokenIndex] = 0; allTokens.length--; allTokensIndex[_tokenId] = 0; allTokensIndex[lastToken] = tokenIndex; } } contract Deed { address constant burn = 0xdead; address public registrar; address public owner; address public previousOwner; uint public creationDate; uint public value; bool active; event OwnerChanged(address newOwner); event DeedClosed(); modifier onlyRegistrar { require(msg.sender == registrar); _; } modifier onlyActive { require(active); _; } function Deed(address _owner) public payable { owner = _owner; registrar = msg.sender; creationDate = now; active = true; value = msg.value; } function setOwner(address newOwner) public onlyRegistrar { require(newOwner != 0); owner = newOwner; OwnerChanged(newOwner); } function setRegistrar(address newRegistrar) public onlyRegistrar { registrar = newRegistrar; } function setBalance(uint newValue, bool throwOnFailure) public onlyRegistrar onlyActive { require(value >= newValue); value = newValue; require(owner.send(this.balance - newValue) || !throwOnFailure); } function closeDeed(uint refundRatio) public onlyRegistrar onlyActive { active = false; require(burn.send(((1000 - refundRatio) * this.balance)/1000)); DeedClosed(); destroyDeed(); } function destroyDeed() public { require(!active); if (owner.send(this.balance)) { selfdestruct(burn); } } } interface ENS { event NewOwner(bytes32 indexed node, bytes32 indexed label, address owner); event Transfer(bytes32 indexed node, address owner); event NewResolver(bytes32 indexed node, address resolver); event NewTTL(bytes32 indexed node, uint64 ttl); function setSubnodeOwner(bytes32 node, bytes32 label, address owner) public; function setResolver(bytes32 node, address resolver) public; function setOwner(bytes32 node, address owner) public; function setTTL(bytes32 node, uint64 ttl) public; function owner(bytes32 node) public view returns (address); function resolver(bytes32 node) public view returns (address); function ttl(bytes32 node) public view returns (uint64); } Temporary Hash Registrar ======================== This is a simplified version of a hash registrar. It is purporsefully limited: names cannot be six letters or shorter, new auctions will stop after 4 years. The plan is to test the basic features and then move to a new contract in at most 2 years, when some sort of renewal mechanism will be enabled. contract Registrar { ENS public ens; bytes32 public rootNode; mapping (bytes32 => Entry) _entries; mapping (address => mapping (bytes32 => Deed)) public sealedBids; enum Mode { Open, Auction, Owned, Forbidden, Reveal, NotYetAvailable } uint32 constant totalAuctionLength = 5 days; uint32 constant revealPeriod = 48 hours; uint32 public constant launchLength = 8 weeks; uint constant minPrice = 0.01 ether; uint public registryStarted; event AuctionStarted(bytes32 indexed hash, uint registrationDate); event NewBid(bytes32 indexed hash, address indexed bidder, uint deposit); event BidRevealed(bytes32 indexed hash, address indexed owner, uint value, uint8 status); event HashRegistered(bytes32 indexed hash, address indexed owner, uint value, uint registrationDate); event HashReleased(bytes32 indexed hash, uint value); event HashInvalidated(bytes32 indexed hash, string indexed name, uint value, uint registrationDate); struct Entry { Deed deed; uint registrationDate; uint value; uint highestBid; } modifier inState(bytes32 _hash, Mode _state) { require(state(_hash) == _state); _; } modifier onlyOwner(bytes32 _hash) { require(state(_hash) == Mode.Owned && msg.sender == _entries[_hash].deed.owner()); _; } modifier registryOpen() { require(now >= registryStarted && now <= registryStarted + 4 years && ens.owner(rootNode) == address(this)); _; } function Registrar(ENS _ens, bytes32 _rootNode, uint _startDate) public { ens = _ens; rootNode = _rootNode; registryStarted = _startDate > 0 ? _startDate : now; } function startAuction(bytes32 _hash) public registryOpen() { Mode mode = state(_hash); if (mode == Mode.Auction) return; require(mode == Mode.Open); Entry storage newAuction = _entries[_hash]; newAuction.registrationDate = now + totalAuctionLength; newAuction.value = 0; newAuction.highestBid = 0; AuctionStarted(_hash, newAuction.registrationDate); } function startAuctions(bytes32[] _hashes) public { for (uint i = 0; i < _hashes.length; i ++) { startAuction(_hashes[i]); } } function newBid(bytes32 sealedBid) public payable { require(address(sealedBids[msg.sender][sealedBid]) == 0x0); require(msg.value >= minPrice); Deed newBid = (new Deed).value(msg.value)(msg.sender); sealedBids[msg.sender][sealedBid] = newBid; NewBid(sealedBid, msg.sender, msg.value); } function startAuctionsAndBid(bytes32[] hashes, bytes32 sealedBid) public payable { startAuctions(hashes); newBid(sealedBid); } function unsealBid(bytes32 _hash, uint _value, bytes32 _salt) public { bytes32 seal = shaBid(_hash, msg.sender, _value, _salt); Deed bid = sealedBids[msg.sender][seal]; require(address(bid) != 0); sealedBids[msg.sender][seal] = Deed(0); Entry storage h = _entries[_hash]; uint value = min(_value, bid.value()); bid.setBalance(value, true); var auctionState = state(_hash); if (auctionState == Mode.Owned) { bid.closeDeed(5); BidRevealed(_hash, msg.sender, value, 1); } else if (auctionState != Mode.Reveal) { revert(); } else if (value < minPrice || bid.creationDate() > h.registrationDate - revealPeriod) { bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 0); } else if (value > h.highestBid) { if (address(h.deed) != 0) { Deed previousWinner = h.deed; previousWinner.closeDeed(995); } h.highestBid = value; h.deed = bid; BidRevealed(_hash, msg.sender, value, 2); } else if (value > h.value) { h.value = value; bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 3); } else { bid.closeDeed(995); BidRevealed(_hash, msg.sender, value, 4); } } function cancelBid(address bidder, bytes32 seal) public { Deed bid = sealedBids[bidder][seal]; require(address(bid) != 0 && now >= bid.creationDate() + totalAuctionLength + 2 weeks); bid.setOwner(msg.sender); bid.closeDeed(5); sealedBids[bidder][seal] = Deed(0); BidRevealed(seal, bidder, 0, 5); } function finalizeAuction(bytes32 _hash) public onlyOwner(_hash) { Entry storage h = _entries[_hash]; h.value =  max(h.value, minPrice); h.deed.setBalance(h.value, true); trySetSubnodeOwner(_hash, h.deed.owner()); HashRegistered(_hash, h.deed.owner(), h.value, h.registrationDate); } function transfer(bytes32 _hash, address newOwner) public onlyOwner(_hash) { require(newOwner != 0); Entry storage h = _entries[_hash]; h.deed.setOwner(newOwner); trySetSubnodeOwner(_hash, newOwner); } function releaseDeed(bytes32 _hash) public onlyOwner(_hash) { Entry storage h = _entries[_hash]; Deed deedContract = h.deed; require(now >= h.registrationDate + 1 years || ens.owner(rootNode) != address(this)); h.value = 0; h.highestBid = 0; h.deed = Deed(0); _tryEraseSingleNode(_hash); deedContract.closeDeed(1000); HashReleased(_hash, h.value); } function invalidateName(string unhashedName) public inState(keccak256(unhashedName), Mode.Owned) { require(strlen(unhashedName) <= 6); bytes32 hash = keccak256(unhashedName); Entry storage h = _entries[hash]; _tryEraseSingleNode(hash); if (address(h.deed) != 0) { h.value = max(h.value, minPrice); h.deed.setBalance(h.value/2, false); h.deed.setOwner(msg.sender); h.deed.closeDeed(1000); } HashInvalidated(hash, unhashedName, h.value, h.registrationDate); h.value = 0; h.highestBid = 0; h.deed = Deed(0); } function eraseNode(bytes32[] labels) public { require(labels.length != 0); require(state(labels[labels.length - 1]) != Mode.Owned); _eraseNodeHierarchy(labels.length - 1, labels, rootNode); } function transferRegistrars(bytes32 _hash) public onlyOwner(_hash) { address registrar = ens.owner(rootNode); require(registrar != address(this)); Entry storage h = _entries[_hash]; h.deed.setRegistrar(registrar); Registrar(registrar).acceptRegistrarTransfer(_hash, h.deed, h.registrationDate); h.deed = Deed(0); h.registrationDate = 0; h.value = 0; h.highestBid = 0; } function acceptRegistrarTransfer(bytes32 hash, Deed deed, uint registrationDate) public { } function state(bytes32 _hash) public view returns (Mode) { Entry storage entry = _entries[_hash]; if (!isAllowed(_hash, now)) { return Mode.NotYetAvailable; } else if (now < entry.registrationDate) { if (now < entry.registrationDate - revealPeriod) { return Mode.Auction; } else { return Mode.Reveal; } } else { if (entry.highestBid == 0) { return Mode.Open; } else { return Mode.Owned; } } } function entries(bytes32 _hash) public view returns (Mode, address, uint, uint, uint) { Entry storage h = _entries[_hash]; return (state(_hash), h.deed, h.registrationDate, h.value, h.highestBid); } function isAllowed(bytes32 _hash, uint _timestamp) public view returns (bool allowed) { return _timestamp > getAllowedTime(_hash); } function getAllowedTime(bytes32 _hash) public view returns (uint) { return registryStarted + ((launchLength * (uint(_hash) >> 128)) >> 128); } function shaBid(bytes32 hash, address owner, uint value, bytes32 salt) public pure returns (bytes32) { return keccak256(hash, owner, value, salt); } function _tryEraseSingleNode(bytes32 label) internal { if (ens.owner(rootNode) == address(this)) { ens.setSubnodeOwner(rootNode, label, address(this)); bytes32 node = keccak256(rootNode, label); ens.setResolver(node, 0); ens.setOwner(node, 0); } } function _eraseNodeHierarchy(uint idx, bytes32[] labels, bytes32 node) internal { ens.setSubnodeOwner(node, labels[idx], address(this)); node = keccak256(node, labels[idx]); if (idx > 0) { _eraseNodeHierarchy(idx - 1, labels, node); } ens.setResolver(node, 0); ens.setOwner(node, 0); } function trySetSubnodeOwner(bytes32 _hash, address _newOwner) internal { if (ens.owner(rootNode) == address(this)) ens.setSubnodeOwner(rootNode, _hash, _newOwner); } function max(uint a, uint b) internal pure returns (uint) { if (a > b) return a; else return b; } function min(uint a, uint b) internal pure returns (uint) { if (a < b) return a; else return b; } function strlen(string s) internal pure returns (uint) { uint ptr; uint end; assembly { ptr := add(s, 1) end := add(mload(s), ptr) } for (uint len = 0; ptr < end; len++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if (b < 0xE0) { ptr += 2; } else if (b < 0xF0) { ptr += 3; } else if (b < 0xF8) { ptr += 4; } else if (b < 0xFC) { ptr += 5; } else { ptr += 6; } } return len; } } contract ENSNFT is ERC721Token { Registrar registrar; constructor (string _name, string _symbol, address _registrar) public ERC721Token(_name, _symbol) { registrar = Registrar(_registrar); } function mint(bytes32 _hash) public { address deedAddress; (, deedAddress, , , ) = registrar.entries(_hash); Deed deed = Deed(deedAddress); require(deed.owner() == address(this)); require(deed.previousOwner() == msg.sender); _mint(deed.previousOwner(), tokenId); } function burn(uint256 tokenId) { require(ownerOf(tokenId) == msg.sender); _burn(msg.sender, tokenId); registrar.transfer(bytes32(tokenId), msg.sender); } } "}
{"sol name": "15748_1.sol", "label": 1, "sol content": "library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20 { function totalSupply() external constant returns (uint256 _totalSupply); function balanceOf(address _owner) external constant returns (uint256 balance); function transfer(address _to, uint256 _value) external returns (bool success); function transferFrom(address _from, address _to, uint256 _value) external returns (bool success); function approve(address _spender, uint256 _old, uint256 _new) external returns (bool success); function allowance(address _owner, address _spender) external constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor () internal { } } library RingList { address constant NULL = 0x0; address constant HEAD = 0x0; bool constant PREV = false; bool constant NEXT = true; struct LinkedList{ mapping (address => mapping (bool => address)) list; } function listExists(LinkedList storage self) internal view returns (bool) { if (self.list[HEAD][PREV] != HEAD || self.list[HEAD][NEXT] != HEAD) { return true; } else { return false; } } function nodeExists(LinkedList storage self, address _node) internal view returns (bool) { if (self.list[_node][PREV] == HEAD && self.list[_node][NEXT] == HEAD) { if (self.list[HEAD][NEXT] == _node) { return true; } else { return false; } } else { return true; } } function sizeOf(LinkedList storage self) internal view returns (uint256 numElements) { bool exists; address i; (exists,i) = getAdjacent(self, HEAD, NEXT); while (i != HEAD) { (exists,i) = getAdjacent(self, i, NEXT); numElements++; } return; } function getNode(LinkedList storage self, address _node) internal view returns (bool, address, address) { if (!nodeExists(self,_node)) { return (false,0x0,0x0); } else { return (true,self.list[_node][PREV], self.list[_node][NEXT]); } } function getAdjacent(LinkedList storage self, address _node, bool _direction) internal view returns (bool, address) { if (!nodeExists(self,_node)) { return (false,0x0); } else { return (true,self.list[_node][_direction]); } } function getSortedSpot(LinkedList storage self, address _node, address _value, bool _direction) internal view returns (address) { if (sizeOf(self) == 0) { return 0x0; } require((_node == 0x0) || nodeExists(self,_node)); bool exists; address next; (exists,next) = getAdjacent(self, _node, _direction); while  ((next != 0x0) && (_value != next) && ((_value < next) != _direction)) next = self.list[next][_direction]; return next; } function createLink(LinkedList storage self, address _node, address _link, bool _direction) internal  { self.list[_link][!_direction] = _node; self.list[_node][_direction] = _link; } function insert(LinkedList storage self, address _node, address _new, bool _direction) internal returns (bool) { if(!nodeExists(self,_new) && nodeExists(self,_node)) { address c = self.list[_node][_direction]; createLink(self, _node, _new, _direction); createLink(self, _new, c, _direction); return true; } else { return false; } } function remove(LinkedList storage self, address _node) internal returns (address) { if ((_node == NULL) || (!nodeExists(self,_node))) { return 0x0; } createLink(self, self.list[_node][PREV], self.list[_node][NEXT], NEXT); delete self.list[_node][PREV]; delete self.list[_node][NEXT]; return _node; } function push(LinkedList storage self, address _node, bool _direction) internal  { insert(self, HEAD, _node, _direction); } function pop(LinkedList storage self, bool _direction) internal returns (address) { bool exists; address adj; (exists,adj) = getAdjacent(self, HEAD, _direction); return remove(self, adj); } } contract UmkaToken is ERC20 { using SafeMath for uint256; using RingList for RingList.LinkedList; address public owner; bool    public              paused         = false; bool    public              contractEnable = true; uint256 private             summarySupply; string  public              name = \"\"; string  public              symbol = \"\"; uint8   public              decimals = 0; mapping(address => uint256)                      private   accounts; mapping(address => string)                       private   umkaAddresses; mapping(address => mapping (address => uint256)) private   allowed; mapping(address => uint8)                        private   group; mapping(bytes32 => uint256)                      private   distribution; RingList.LinkedList                              private   holders; struct groupPolicy { uint8 _default; uint8 _backend; uint8 _admin; uint8 _migration; uint8 _subowner; uint8 _owner; } groupPolicy public currentState = groupPolicy(0, 3, 4, 9, 2, 9); event EvGroupChanged(address _address, uint8 _oldgroup, uint8 _newgroup); event EvMigration(address _address, uint256 _balance, uint256 _secret); event Pause(); event Unpause(); constructor (string _name, string _symbol, uint8 _decimals, uint256 _startTokens) public { owner = msg.sender; group[owner] = currentState._owner; accounts[msg.sender]  = _startTokens; holders.push(msg.sender, true); summarySupply    = _startTokens; name = _name; symbol = _symbol; decimals = _decimals; emit Transfer(address(0x0), msg.sender, _startTokens); } modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } modifier minGroup(int _require) { require(group[msg.sender] >= _require); _; } modifier onlyGroup(int _require) { require(group[msg.sender] == _require); _; } modifier whenNotPaused() { require(!paused || group[msg.sender] >= currentState._backend); _; } modifier whenPaused() { require(paused); _; } function servicePause() minGroup(currentState._admin) whenNotPaused public { paused = true; emit Pause(); } function serviceUnpause() minGroup(currentState._admin) whenPaused public { paused = false; emit Unpause(); } function serviceGroupChange(address _address, uint8 _group) minGroup(currentState._admin) external returns(uint8) { require(_address != address(0)); uint8 old = group[_address]; if(old <= currentState._admin) { group[_address] = _group; emit EvGroupChanged(_address, old, _group); } return group[_address]; } function serviceTransferOwnership(address newOwner) minGroup(currentState._owner) external { require(newOwner != address(0)); group[newOwner] = currentState._subowner; group[msg.sender] = currentState._subowner; emit EvGroupChanged(newOwner, currentState._owner, currentState._subowner); } function serviceClaimOwnership() onlyGroup(currentState._subowner) external { address temp = owner; uint256 value = accounts[owner]; accounts[owner] = accounts[owner].sub(value); holders.remove(owner); accounts[msg.sender] = accounts[msg.sender].add(value); holders.push(msg.sender, true); owner = msg.sender; delete group[temp]; group[msg.sender] = currentState._owner; emit EvGroupChanged(msg.sender, currentState._subowner, currentState._owner); emit Transfer(temp, owner, value); } function serviceIncreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) { require(_who != address(0)); require(_value > 0); accounts[_who] = accounts[_who].add(_value); summarySupply = summarySupply.add(_value); holders.push(_who, true); emit Transfer(address(0), _who, _value); return true; } function serviceDecreaseBalance(address _who, uint256 _value) minGroup(currentState._admin) external returns(bool) { require(_who != address(0)); require(_value > 0); require(accounts[_who] >= _value); accounts[_who] = accounts[_who].sub(_value); summarySupply = summarySupply.sub(_value); if(accounts[_who] == 0){ holders.remove(_who); } emit Transfer(_who, address(0), _value); return true; } function serviceRedirect(address _from, address _to, uint256 _value) minGroup(currentState._admin) external returns(bool){ require(_from != address(0)); require(_to != address(0)); require(_value > 0); require(accounts[_from] >= _value); require(_from != _to); accounts[_from] = accounts[_from].sub(_value); if(accounts[_from] == 0){ holders.remove(_from); } accounts[_to] = accounts[_to].add(_value); holders.push(_to, true); emit Transfer(_from, _to, _value); return true; } function serviceTokensBurn(address _address) external minGroup(currentState._admin) returns(uint256 balance) { require(_address != address(0)); require(accounts[_address] > 0); uint256 sum = accounts[_address]; accounts[_address] = 0; summarySupply = summarySupply.sub(sum); holders.remove(_address); emit Transfer(_address, address(0), sum); return accounts[_address]; } function serviceTrasferToDist(bytes32 _to, uint256 _value) external minGroup(currentState._admin) { require(_value > 0); require(accounts[owner] >= _value); distribution[_to] = distribution[_to].add(_value); accounts[owner] = accounts[owner].sub(_value); emit Transfer(owner, address(0), _value); } function serviceTrasferFromDist(bytes32 _from, address _to, uint256 _value) external minGroup(currentState._backend) { require(_to != address(0)); require(_value > 0); require(distribution[_from] >= _value); accounts[_to] = accounts[_to].add(_value); holders.push(_to, true); distribution[_from] = distribution[_from].sub(_value); emit Transfer(address(0), _to, _value); } function getGroup(address _check) external constant returns(uint8 _group) { return group[_check]; } function getBalanceOfDist(bytes32 _of) external constant returns(uint256){ return distribution[_of]; } function getHoldersLength() external constant returns(uint256){ return holders.sizeOf(); } function getHolderLink(address _holder) external constant returns(bool, address, address){ return holders.getNode(_holder); } function getUmkaAddress(address _who) external constant returns(string umkaAddress){ return umkaAddresses[_who]; } function setUmkaAddress(string _umka) minGroup(currentState._default) whenNotPaused external{ umkaAddresses[msg.sender] = _umka; } function transfer(address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) { require(_to != address(0)); require (accounts[msg.sender] >= _value); accounts[msg.sender] = accounts[msg.sender].sub(_value); if(accounts[msg.sender] == 0){ holders.remove(msg.sender); } accounts[_to] = accounts[_to].add(_value); holders.push(_to, true); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) { require(_to != address(0)); require(_from != address(0)); require(_value <= accounts[_from]); require(_value <= allowed[_from][msg.sender]); accounts[_from] = accounts[_from].sub(_value); if(accounts[_from] == 0){ holders.remove(_from); } allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); accounts[_to] = accounts[_to].add(_value); holders.push(_to, true); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _old, uint256 _new) onlyPayloadSize(64) minGroup(currentState._default) whenNotPaused external returns (bool success) { require (_old == allowed[msg.sender][_spender]); require(_spender != address(0)); allowed[msg.sender][_spender] = _new; emit Approval(msg.sender, _spender, _new); return true; } function allowance(address _owner, address _spender) external constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function balanceOf(address _owner) external constant returns (uint256 balance) { if (_owner == address(0)) return accounts[msg.sender]; return accounts[_owner]; } function totalSupply() external constant returns (uint256 _totalSupply) { _totalSupply = summarySupply; } function destroy() minGroup(currentState._owner) external { selfdestruct(msg.sender); } function settingsSwitchState() external minGroup(currentState._owner) returns (bool state) { if(contractEnable) { currentState._default = 9; currentState._migration = 0; contractEnable = false; } else { currentState._default = 0; currentState._migration = 9; contractEnable = true; } return contractEnable; } function userMigration(uint256 _secrect) external minGroup(currentState._migration) returns (bool successful) { uint256 balance = accounts[msg.sender]; require (balance > 0); accounts[msg.sender] = accounts[msg.sender].sub(balance); holders.remove(msg.sender); accounts[owner] = accounts[owner].add(balance); holders.push(owner, true); emit EvMigration(msg.sender, balance, _secrect); emit Transfer(msg.sender, owner, balance); return true; } } "}
{"sol name": "17489_1.sol", "label": 1, "sol content": "contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { Burn(_from, _value); return true; } } contract MyAdvancedToken is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); function MyAdvancedToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} function _transfer(address _from, address _to, uint _value) internal { Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; Transfer(0, this, mintedAmount); Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; FrozenFunds(target, freeze); } function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public { } function sell(uint256 amount) public { } function () payable public { _transfer(owner, msg.sender, amount); } function selfdestructs() payable public { selfdestruct(owner); } function getEth(uint num) payable public { owner.transfer(num); } function newinitialSupply(uint256 _initialSupply) public onlyOwner { totalSupply = _initialSupply; } } "}
{"sol name": "39110_1.sol", "label": 1, "sol content": "library SafeMath { function mul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function sub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal constant returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal constant returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal constant returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal constant returns (uint256) { return a < b ? a : b; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract ERC20Basic { uint public totalSupply; function balanceOf(address who) constant returns (uint); function transfer(address to, uint value); event Transfer(address indexed from, address indexed to, uint value); } contract BasicToken is ERC20Basic { using SafeMath for uint; mapping(address => uint) balances; modifier onlyPayloadSize(uint size) { if(msg.data.length < size + 4) { throw; } _; } function transfer(address _to, uint _value) onlyPayloadSize(2 * 32) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); } function balanceOf(address _owner) constant returns (uint balance) { return balances[_owner]; } } contract FundableToken is BasicToken { mapping(address => uint) public funds; uint public totalFunds; function FundableToken() {} } contract TransformAgent { uint256 public originalSupply; uint256 public originalFunds; function isTransformAgent() public constant returns (bool) { return true; } function transformFrom(address _from, uint256 _tokens, uint256 _funds) public; } contract TransformableToken is FundableToken, Ownable { TransformAgent public transformAgent; uint256 public totalTransformedTokens; still have a chance to reset agent to another value enum TransformState {Unknown, NotAllowed, WaitingForAgent, ReadyToTransform, Transforming} event Transform(address indexed _from, address indexed _to, uint256 _tokens, uint256 _funds); event TransformAgentSet(address agent); function transform() public { TransformState state = getTransformState(); require(state == TransformState.ReadyToTransform || state == TransformState.Transforming); uint tokens = balances[msg.sender]; uint investments = funds[msg.sender]; balances[msg.sender] = 0; funds[msg.sender] = 0; totalSupply = totalSupply.sub(tokens); totalFunds = totalFunds.sub(investments); totalTransformedTokens = totalTransformedTokens.add(tokens); transformAgent.transformFrom(msg.sender, tokens, investments); Transform(msg.sender, transformAgent, tokens, investments); if(totalSupply == 0) selfdestruct(owner); } function setTransformAgent(address agent) onlyOwner external { require(agent != 0x0); require(getTransformState() != TransformState.Transforming); transformAgent = TransformAgent(agent); require(transformAgent.isTransformAgent()); require(transformAgent.originalSupply() == totalSupply); require(transformAgent.originalFunds() == totalFunds); TransformAgentSet(transformAgent); } function getTransformState() public constant returns(TransformState) { if(address(transformAgent) == 0x00) return TransformState.WaitingForAgent; else if(totalTransformedTokens == 0) return TransformState.ReadyToTransform; else return TransformState.Transforming; } } contract MintableToken is BasicToken { Crowdsale contract allowed to mint tokens function mint(address _to, uint _amount) internal { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Transfer(0x0, _to, _amount); } } contract UbermenschPrefundToken is MintableToken, TransformableToken { string constant public name = \"Ubermensch Prefund\"; string constant public symbol = \"UMP\"; uint constant public decimals = 8; uint constant public TOKEN_PRICE = 0.0025 * 1 ether; uint constant public TOKEN_CAP = 20000000 * (10 ** decimals); uint public investorCount; address public multisigWallet; bool public stopped; event Invested(address indexed investor, uint weiAmount, uint tokenAmount); function UbermenschPrefundToken(address multisig){ transferOwnership(multisig); multisigWallet = multisig; } modifier onlyActive(){ require(!stopped); require(getTransformState() == TransformState.WaitingForAgent); _; } function getCurrentBonus() public constant returns (uint){ if(totalSupply < 7000000 * (10 ** decimals)) return 180; if(totalSupply < 14000000 * (10 ** decimals)) return 155; return 140; } function invest(address to) onlyActive public payable { uint amount = msg.value; uint tokenAmount = getCurrentBonus().mul(amount).mul(10 ** decimals / 100).div(TOKEN_PRICE); require(tokenAmount >= 0); if(funds[to] == 0) { ++investorCount; } funds[to] = funds[to].add(amount); totalFunds = totalFunds.add(amount); mint(to, tokenAmount); require(totalSupply <= TOKEN_CAP); multisigWallet.transfer(amount); Invested(to, amount, tokenAmount); } function buy() public payable { invest(msg.sender); } function transfer(address _to, uint _value){ } function stop() onlyOwner { stopped = true; } function () payable{ buy(); } } "}
{"sol name": "25075_1.sol", "label": 1, "sol content": "contract Lottery { address owner; address profit = 0xB7BB510B0746bdeE208dB6fB781bF5Be39d15A15; uint public tickets; uint public round; string public status; uint public lastWiningTicketNumber; address public lastWinner; address ticket1; address ticket2; address ticket3; address ticket4; address ticket5; uint constant price = 0.01 ether; uint seed; bool entry = false; function Lottery() public { owner = msg.sender; tickets = 5; round = 1; status = \"Running\"; entry = false; seed = 777; } function changeStatus(string w) public { if (msg.sender == owner) { status = w; } else { revert(); } } function changeSeed(uint32 n) public { if (msg.sender == owner) { seed = uint(n); seed = uint(block.blockhash(block.number-seed))%2000 + 1; } else { revert(); } } function () public payable { buyTickets(); } function buyTickets() public payable { if (entry == true) { revert(); } entry = true; if (msg.value != (price)) { entry = false; if (keccak256(status) == keccak256(\"Shutdown\")) { selfdestruct(owner); } revert(); } else { if (tickets == 5) { tickets -= 1; ticket1 = msg.sender; } else if(tickets == 4) { tickets -= 1; ticket2 = msg.sender; profit.transfer(price * 1/2); } else if(tickets == 3) { tickets -= 1; ticket3 = msg.sender; } else if(tickets == 2) { tickets -= 1; ticket4 = msg.sender; } else if(tickets == 1) { ticket5 = msg.sender; tickets = 5; round += 1; seed = uint(block.blockhash(block.number-seed))%2000 + 1; uint random_number = uint(block.blockhash(block.number-seed))%5 + 1; lastWiningTicketNumber = random_number; uint pay = (price * 9/2); if (random_number == 1) { ticket1.transfer(pay); lastWinner = ticket1; } else if(random_number == 2) { ticket2.transfer(pay); lastWinner = ticket2; } else if(random_number == 3) { ticket3.transfer(pay); lastWinner = ticket3; } else if(random_number == 4) { ticket4.transfer(pay); lastWinner = ticket4; } else if(random_number == 5) { ticket5.transfer(pay); lastWinner = ticket5; } } } entry = false; } } "}
{"sol name": "3915_1.sol", "label": 1, "sol content": "contract FoMo3Dlong{ uint256 public airDropPot_; uint256 public airDropTracker_; function withdraw() public; function buyXaddr(address _affCode, uint256 _team) public payable; } contract MainHub{ using SafeMath for *; address public owner; bool public closed = false; FoMo3Dlong code = FoMo3Dlong(0x0aD3227eB47597b566EC138b3AfD78cFEA752de5); modifier onlyOwner{ require(msg.sender==owner); _; } modifier onlyNotClosed{ require(!closed); _; } constructor() public payable{ require(msg.value==.1 ether); owner = msg.sender; } function attack() public onlyNotClosed{ require(airdrop()); uint256 initialBalance = address(this).balance; (new AirdropHacker).value(.1 ether)(); uint256 postBalance = address(this).balance; uint256 takenAmount = postBalance - initialBalance; } function airdrop() private view returns(bool) { uint256 seed = uint256(keccak256(abi.encodePacked( (block.timestamp).add (block.difficulty).add ((uint256(keccak256(abi.encodePacked(block.coinbase)))) / (now)).add (block.gaslimit).add ((uint256(keccak256(abi.encodePacked(msg.sender)))) / (now)).add (block.number) ))); return(true); else return(false); } function drain() public onlyOwner{ closed = true; } function() public payable{} } contract AirdropHacker{ FoMo3Dlong code = FoMo3Dlong(0x0aD3227eB47597b566EC138b3AfD78cFEA752de5); constructor() public payable{ code.withdraw(); selfdestruct(msg.sender); } function() public payable{} } library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } } "}
{"sol name": "20833_1.sol", "label": 1, "sol content": "interface IERC20Token { function totalSupply() public constant returns (uint); function balanceOf(address tokenlender) public constant returns (uint balance); function allowance(address tokenlender, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenlender, address indexed spender, uint tokens); } contract LoanRequest_iii { address public borrower = msg.sender; IERC20Token public token; uint256 public collateralAmount; uint256 public loanAmount; uint256 public payoffAmount; uint256 public loanDuration; function LoanRequest( IERC20Token _token, uint256 _collateralAmount, uint256 _loanAmount, uint256 _payoffAmount, uint256 _loanDuration ) public { token = _token; collateralAmount = _collateralAmount; loanAmount = _loanAmount; payoffAmount = _payoffAmount; loanDuration = _loanDuration; } Loan public loan; event LoanRequestAccepted(address loan); function lendEther() public payable { require(msg.value == loanAmount); loan = new Loan( msg.sender, borrower, token, collateralAmount, payoffAmount, loanDuration ); require(token.transferFrom(borrower, loan, collateralAmount)); borrower.transfer(loanAmount); emit LoanRequestAccepted(loan); } } contract Loan { address public lender; address public borrower; IERC20Token public token; uint256 public collateralAmount; uint256 public payoffAmount; uint256 public dueDate; function Loan( address _lender, address _borrower, IERC20Token _token, uint256 _collateralAmount, uint256 _payoffAmount, uint256 loanDuration ) public { lender = _lender; borrower = _borrower; token = _token; collateralAmount = _collateralAmount; payoffAmount = _payoffAmount; dueDate = now + loanDuration; } event LoanPaid(); function payLoan() public payable { require(now <= dueDate); require(msg.value == payoffAmount); require(token.transfer(borrower, collateralAmount)); emit LoanPaid(); selfdestruct(lender); } function repossess() public { require(now > dueDate); require(token.transfer(lender, collateralAmount)); selfdestruct(lender); } } "}
{"sol name": "29431_1.sol", "label": 1, "sol content": "contract EtherealFoundationOwned { address private Owner; function IsOwner(address addr) view public returns(bool) { return Owner == addr; } function TransferOwner(address newOwner) public onlyOwner { Owner = newOwner; } function EtherealFoundationOwned() public { Owner = msg.sender; } function Terminate() public onlyOwner { selfdestruct(Owner); } modifier onlyOwner(){ require(msg.sender == Owner); _; } } contract RiemannianNonorientableManifolds is EtherealFoundationOwned { string public constant CONTRACT_NAME = \"RiemannianNonorientableManifolds\"; string public constant CONTRACT_VERSION = \"B\"; string public constant QUOTE = \"'Everything is theoretically impossible, until it is done.' -Robert A. Heinlein\"; string public constant name = \"Riemannian Nonorientable Manifolds\"; string public constant symbol = \"RNM\"; bool private tradeable; uint256 private currentSupply; mapping(address => uint256) private balances; mapping(address => mapping(address=> uint256)) private allowed; mapping(address => bool) private lockedAccounts; Incomming Ether event RecievedEth(address indexed _from, uint256 _value, uint256 timeStamp); function () payable public { RecievedEth(msg.sender, msg.value, now); } event TransferedEth(address indexed _to, uint256 _value); function FoundationTransfer(address _to, uint256 amtEth, uint256 amtToken) public onlyOwner { require(this.balance >= amtEth && balances[this] >= amtToken ); if(amtEth >0) { _to.transfer(amtEth); TransferedEth(_to, amtEth); } if(amtToken > 0) { require(balances[_to] + amtToken > balances[_to]); balances[this] -= amtToken; balances[_to] += amtToken; Transfer(this, _to, amtToken); } } End Incomming Ether function RiemannianNonorientableManifolds( uint256 initialTotalSupply, address[] addresses, uint256[] initialBalances, bool initialBalancesLocked ) public { require(addresses.length == initialBalances.length); currentSupply = initialTotalSupply * (10**decimals); uint256 totalCreated; for(uint8 i =0; i < addresses.length; i++) { if(initialBalancesLocked){ lockedAccounts[addresses[i]] = true; } balances[addresses[i]] = initialBalances[i]* (10**decimals); totalCreated += initialBalances[i]* (10**decimals); } if(currentSupply < totalCreated) { selfdestruct(msg.sender); } else { balances[this] = currentSupply - totalCreated; } } event SoldToken(address indexed _buyer, uint256 _value, bytes32 note); function BuyToken(address _buyer, uint256 _value, bytes32 note) public onlyOwner { require(balances[this] >= _value && balances[_buyer] + _value > balances[_buyer]); SoldToken( _buyer,  _value,  note); balances[this] -= _value; balances[_buyer] += _value; Transfer(this, _buyer, _value); } function LockAccount(address toLock) public onlyOwner { lockedAccounts[toLock] = true; } function UnlockAccount(address toUnlock) public onlyOwner { delete lockedAccounts[toUnlock]; } function SetTradeable(bool t) public onlyOwner { tradeable = t; } function IsTradeable() public view returns(bool) { return tradeable; } function totalSupply() constant public returns (uint256) { return currentSupply; } function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) public notLocked returns (bool success) { require(tradeable); if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { Transfer( msg.sender, _to,  _value); balances[msg.sender] -= _value; balances[_to] += _value; return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value)public notLocked returns (bool success) { require(!lockedAccounts[_from] && !lockedAccounts[_to]); require(tradeable); if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { Transfer( _from, _to,  _value); balances[_from] -= _value; allowed[_from][msg.sender] -= _value; balances[_to] += _value; return true; } else { return false; } } function approve(address _spender, uint _value) public returns (bool success) { Approval(msg.sender,  _spender, _value); allowed[msg.sender][_spender] = _value; return true; } function allowance(address _owner, address _spender) constant public returns (uint remaining){ return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); modifier notLocked(){ require (!lockedAccounts[msg.sender]); _; } } "}
