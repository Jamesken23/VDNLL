{"sol name": "662.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract GEONToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"GEON\"; name = \"GEON\"; decimals = 18; _totalSupply = 850000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "472.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'BAQ' 'Bitstraq Token' token contract // // Symbol      : BAQ // Name        : Bitstraq Token // Total supply: 500000000.0000000000 // Decimals    : 10 // // Enjoy. // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial BAQ supply // ---------------------------------------------------------------------------- contract BitstraqToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function BAQToken() public { symbol = \"BAQ\"; name = \"Bitstraq Token\"; decimals = 10; _totalSupply = 500000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "583.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } } contract AIToken is PausableToken { string public name = 'AIToken'; string public symbol = 'AIToken'; string public version = '1.0.1'; uint8 public decimals = 18; function AIToken(uint256 initialSupply) public { totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; } function () { //if ether is sent to this address, send it back. revert(); } } "}
{"sol name": "769.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract MCBA is SafeMath{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function MCBA( uint256 initialSupply, string tokenName, string tokenSymbol, address holder)  public{ totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply balanceOf[holder] = totalSupply;                       // Give the creator all initial tokens name = tokenName;                                      // Set the name for display purposes symbol = tokenSymbol;                                  // Set the symbol for display purposes owner = holder; } /* Send coins */ function transfer(address _to, uint256 _value) public{ require(_to != 0x0);  // Prevent transfer to 0x0 address. Use burn() instead require(_value > 0); require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) public returns (bool success) { require(_value > 0); allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != 0x0);                                // Prevent transfer to 0x0 address. Use burn() instead require(_value > 0); require(balanceOf[_from] >= _value);                 // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]);  // Check for overflows require(_value <= allowance[_from][msg.sender]);     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } function freeze(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) public returns (bool success) { require(freezeOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } } "}
{"sol name": "1750.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "603.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract wehome { /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; /* Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply ) public { balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens } /* Send coins */ function transfer(address _to, uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] -= _value;                    // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient return true; } } "}
{"sol name": "439.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping (address => uint256) private balances; mapping (address => mapping (address => uint256)) private allowed; uint256 private totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Internal function that mints an amount of the token and assigns it to * an account. This encapsulates the modification of balances such that the * proper events are emitted. * @param _account The account that will receive the created tokens. * @param _amount The amount that will be created. */ function _mint(address _account, uint256 _amount) internal { require(_account != 0); totalSupply_ = totalSupply_.add(_amount); balances[_account] = balances[_account].add(_amount); emit Transfer(address(0), _account, _amount); } /** * @dev Internal function that burns an amount of the token of a given * account. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burn(address _account, uint256 _amount) internal { require(_account != 0); require(balances[_account] > _amount); totalSupply_ = totalSupply_.sub(_amount); balances[_account] = balances[_account].sub(_amount); emit Transfer(_account, address(0), _amount); } /** * @dev Internal function that burns an amount of the token of a given * account, deducting from the sender's allowance for said account. Uses the * internal _burn function. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burnFrom(address _account, uint256 _amount) internal { require(allowed[_account][msg.sender] > _amount); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount); _burn(_account, _amount); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { _mint(_to, _amount); emit Mint(_to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { _burnFrom(_from, _value); } /** * @dev Overrides StandardToken._burn in order for burn and burnFrom to emit * an additional Burn event. */ function _burn(address _who, uint256 _value) internal { super._burn(_who, _value); emit Burn(_who, _value); } } "}
{"sol name": "582.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //\u4e16\u754c\u4f5b\u5546\u94fe World Buddhist business chain string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "307.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "1705.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; // File: node_modules\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor(address _owner) public { owner = _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: node_modules\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: node_modules\\openzeppelin-solidity\\contracts\\token\\ERC20\\MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: contracts\\MyToken.sol contract MyToken is MintableToken { string public name; string public symbol; uint8 public decimals; function MyToken (string _name, string _symbol, uint8 _decimals, address _owner) public Ownable(_owner) { name = _name; symbol = _symbol; decimals = _decimals; } } // File: contracts\\TokenCreator.sol contract TokenCreator { event TokenCreated(address indexed owner, address token); function createToken (string _name, string _symbol, uint8 _decimals) public { emit TokenCreated(msg.sender, new MyToken(_name, _symbol, _decimals, msg.sender)); } } "}
{"sol name": "1974.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient{ function receiveApproval(address _from,uint256 _value,address _token,bytes _extraData) external ; } contract BicasoBIOToken{ address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; bool public sellOpen; bool public buyOpen; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address=>bool) public frozenAccount; event Transfer(address indexed from,address indexed to , uint256 value); event Approval(address indexed owner,address indexed spender,uint256 value); event FrozenFunds(address target,bool freeze); event SellToken(address seller,uint256 sellPrice, uint256 amount,uint256 getEth); event BuyToken(address buyer,uint256 buyPrice,uint256 amount,uint256 spendEth); modifier onlyOwner { require(msg.sender == owner); _; } constructor() public { owner = 0x28F1DdeC2218ec95b14076127a7AdE2F2986E4A6; name = \"BICASO\"; symbol = \"BIO\"; decimals = 8; totalSupply = 5000000000 * 10 ** uint256(8); balanceOf[owner] = totalSupply; } function () public payable { if(msg.sender!=owner){ _buy(); } } function transfer(address _to,uint256 _value) public{ require(!frozenAccount[msg.sender]); if(_to == address(this)){ _sell(msg.sender,_value); }else{ _transfer(msg.sender,_to,_value); } } function transferFrom(address _from,address _to,uint256 _value) public returns (bool success){ require(!frozenAccount[_from]&&!frozenAccount[msg.sender]); require(_value<=allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; if(_to == address(this)){ _sell(_from,_value); }else { _transfer(_from,_to,_value); } return true; } function approve(address _spender,uint256 _value) public returns (bool success){ require(!frozenAccount[msg.sender]); allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender,uint256 _value,bytes _extraData) public returns (bool success){ require(!frozenAccount[msg.sender]); tokenRecipient spender = tokenRecipient(_spender); if(approve(_spender,_value)){ spender.receiveApproval(msg.sender,_value,this,_extraData); return true; } } function freezeAccount(address target,bool freeze)  onlyOwner public{ require(target!=owner); frozenAccount[target] = freeze; emit FrozenFunds(target,freeze); } function transferOwnership(address newOwner) onlyOwner public{ _transfer(owner,newOwner,balanceOf[owner]); owner = newOwner; } function setPrices(uint256 newSellPrice,uint256 newBuyPrice) onlyOwner public{ sellPrice = newSellPrice; buyPrice = newBuyPrice; } function setBuyOpen(bool newBuyOpen) onlyOwner public{ require(buyPrice>0); buyOpen = newBuyOpen; } function setSellOpen(bool newSellOpen) onlyOwner public{ require(sellPrice>0); sellOpen = newSellOpen; } function transferEth(uint256 amount) onlyOwner public{ msg.sender.transfer(amount*10**uint256(18)); } function _transfer(address _from,address _to, uint256 _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >balanceOf[_to]); uint256 previousBalances = balanceOf[_from]+balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from,_to,_value); assert(balanceOf[_from]+balanceOf[_to] == previousBalances); } function _buy() internal returns (uint256 amount){ require(buyOpen); require(buyPrice>0); require(msg.value>0); amount = msg.value / buyPrice; _transfer(owner,msg.sender,amount); emit BuyToken(msg.sender,buyPrice,amount,msg.value); return amount; } function _sell(address _from,uint256 amount) internal returns (uint256 revenue){ require(sellOpen); require(!frozenAccount[_from]); require(amount>0); require(sellPrice>0); require(_from!=owner); _transfer(_from,owner,amount); revenue = amount * sellPrice; _from.transfer(revenue); emit SellToken(_from,sellPrice,amount,revenue); return revenue; } } "}
{"sol name": "918.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract ERC20Token { uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ZToken is ERC20Token { function () public { require(false); } function ZToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "1821.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract KaiKuangChain { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function KaiKuangChain( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "172.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns(uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else{ uint256 z = x; for (uint256 i = 1; i < y; i++) z = mul(z,x); return (z); } } } interface shareProfit { function increaseProfit() external payable returns(bool); } contract RTB2 is shareProfit { using SafeMath for uint256; uint8 public decimals = 0; uint256 public totalSupply = 700; uint256 public totalSold = 0; uint256 public constant price = 1 ether; string public name = \"Retro Block Token 2\"; string public symbol = \"RTB2\"; address public owner; address public finance; mapping (address=>uint256) received; uint256 profit; address public jackpot; shareProfit public shareContract; mapping (address=>uint256) changeProfit; mapping (address=>uint256) balances; mapping (address=>mapping (address=>uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit); event Withdraw(address indexed _addr, uint256 _value); modifier onlyOwner() { require(msg.sender == owner, \"only owner\"); _; } modifier onlyHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } constructor(address _shareAddr) public { owner = msg.sender; finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0; jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC; shareContract = shareProfit(_shareAddr); balances[this] = 700; } function() public payable { require(msg.value > 0, \"Amount must be provided\"); profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); } function increaseProfit() external payable returns(bool){ if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); return true; }else{ return false; } } function totalSupply() external view returns (uint256){ return totalSupply; } function balanceOf(address _owner) external view returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { require(_value > 0 && allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) external returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) external returns (bool) { return _transfer(msg.sender, _to, _value); } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0), \"Receiver address cannot be null\"); require(_from != _to); require(_value > 0 && _value <= balances[_from]); uint256 newToVal = balances[_to] + _value; assert(newToVal >= balances[_to]); uint256 newFromVal = balances[_from] - _value; balances[_to] = newToVal; balances[_from] =  newFromVal; uint256 temp = _value.mul(profit); changeProfit[_from] = changeProfit[_from].add(temp); received[_to] = received[_to].add(temp); emit Transfer(_from, _to, _value); return true; } function buy(uint256 _amount) external onlyHuman payable{ require(_amount > 0); uint256 _money = _amount.mul(price); require(msg.value == _money); require(balances[this] >= _amount); require((totalSupply - totalSold) >= _amount, \"Sold out\"); _transfer(this, msg.sender, _amount); finance.transfer(_money.mul(60).div(100)); jackpot.transfer(_money.mul(20).div(100)); shareContract.increaseProfit.value(_money.mul(20).div(100))(); totalSold += _amount; } function withdraw() external { uint256 value = getProfit(msg.sender); require(value > 0, \"No cash available\"); emit Withdraw(msg.sender, value); received[msg.sender] = received[msg.sender].add(value); msg.sender.transfer(value); } function getProfit(address _addr) public view returns(uint256){ return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]); } function setJackpot(address _addr) public onlyOwner{ jackpot = _addr; } function setShare(address _addr) public onlyOwner{ shareContract = shareProfit(_addr); } function setFinance(address _addr) public onlyOwner{ finance = _addr; } } "}
{"sol name": "870.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "309.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "1709.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { if (msg.sender != owner) revert(); _; } function transferOwnership(address newOwner) onlyOwner private { owner = newOwner; } } // ---------------------------------------------------------------------------------------------- // Original from: // https://theethereum.wiki/w/index.php/ERC20_Token_Standard // (c) BokkyPooBah 2017. The MIT Licence. // ---------------------------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/issues/20 contract ERC20Interface { // Get the total token supply     function totalSupply() constant returns (uint256 totalSupply); // Get the account balance of another account with address _owner function balanceOf(address _owner) constant public returns (uint256 balance); // Send _value amount of tokens to address _to function transfer(address _to, uint256 _value) public returns (bool success); // Send _value amount of token from address _from to address _to function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); // Allow _spender to withdraw from your account, multiple times, up to the _value amount. // If this function is called again it overwrites the current allowance with _value. // this function is required for some DEX functionality function approve(address _spender, uint256 _value) public returns (bool success); // Returns the amount which _spender is still allowed to withdraw from _owner function allowance(address _owner, address _spender) constant public returns (uint256 remaining); // Triggered when tokens are transferred. event Transfer(address indexed _from, address indexed _to, uint256 _value); // Triggered whenever approve(address _spender, uint256 _value) is called. event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /// @title Yoyo Ark Coin (YAC) contract YoyoArkCoin is owned, ERC20Interface { // Public variables of the token string public constant standard = 'ERC20'; string public constant name = 'Yoyo Ark Coin'; string public constant symbol = 'YAC'; uint8  public constant decimals = 18; uint public registrationTime = 0; bool public registered = false; uint256 totalTokens = 960 * 1000 * 1000 * 10**18; // This creates an array with all balances mapping (address => uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address => mapping (address => uint256)) allowed; // These are related to YAC team members mapping (address => bool) public frozenAccount; mapping (address => uint[3]) public frozenTokens; // Variable of token frozen rules for YAC team members. uint public unlockat; // Constructor constructor() public { } // This unnamed function is called whenever someone tries to send ether to it function () private { revert(); // Prevents accidental sending of ether } function totalSupply() constant public returns (uint256) { return totalTokens; } // What is the balance of a particular account? function balanceOf(address _owner) constant public returns (uint256) { return balances[_owner]; } // Transfer the balance from owner's account to another account function transfer(address _to, uint256 _amount) public returns (bool success) { if (!registered) return false; if (_amount <= 0) return false; if (frozenRules(msg.sender, _amount)) return false; if (balances[msg.sender] >= _amount && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; emit Transfer(msg.sender, _to, _amount); return true; } else { return false; } } // Send _value amount of tokens from address _from to address _to // The transferFrom method is used for a withdraw workflow, allowing contracts to send // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge // fees in sub-currencies; the command should fail unless the _from account has // deliberately authorized the sender of the message via some mechanism; we propose // these standardized APIs for approval: function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) { if (!registered) return false; if (_amount <= 0) return false; if (frozenRules(_from, _amount)) return false; if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; emit Transfer(_from, _to, _amount); return true; } else { return false; } } // Allow _spender to withdraw from your account, multiple times, up to the _value amount. // If this function is called again it overwrites the current allowance with _value. function approve(address _spender, uint256 _amount) public returns (bool success) { allowed[msg.sender][_spender] = _amount; emit Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } /// @dev Register for Token Initialize, /// 100% of total Token will initialize to dev Account. function initRegister() public { // (85%) of total supply to sender contract balances[msg.sender] = 960 * 1000 * 1000 * 10**18; // Frozen 15% of total supply for team members. registered = true; registrationTime = now; unlockat = registrationTime + 6 * 30 days; // Frozen rest (15%) of total supply for development team and contributors // 144,000,000 * 10**18; frozenForTeam(); } /// @dev Frozen for the team members. function frozenForTeam() internal { uint totalFrozeNumber = 144 * 1000 * 1000 * 10**18; freeze(msg.sender, totalFrozeNumber); } /// @dev Frozen 15% of total supply for team members. /// @param _account The address of account to be frozen. /// @param _totalAmount The amount of tokens to be frozen. function freeze(address _account, uint _totalAmount) public onlyOwner { frozenAccount[_account] = true; frozenTokens[_account][0] = _totalAmount;            // 100% of locked token within 6 months } /// @dev Token frozen rules for token holders. /// @param _from The token sender. /// @param _value The token amount. function frozenRules(address _from, uint256 _value) internal returns (bool success) { if (frozenAccount[_from]) { if (now < unlockat) { // 100% locked within the first 6 months. if (balances[_from] - _value < frozenTokens[_from][0]) return true; } else { // 100% unlocked after 6 months. frozenAccount[_from] = false; } } return false; } } "}
{"sol name": "1828.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Spooskter Coin' token contract // // Deployed to : 0x6370f9A136162A31eD4EbFdB460597d471A2203a // Symbol      : SPOOK // Name        : SpooksterCoin // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract SpooksterCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function SpooksterCoin() public { symbol = \"SPOOK\"; name = \"Spookster Coin\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x6370f9A136162A31eD4EbFdB460597d471A2203a] = _totalSupply; Transfer(address(0), 0x6370f9A136162A31eD4EbFdB460597d471A2203a, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1815.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(msg.sender != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_from != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. * https://github.com/OpenZeppelin * openzeppelin-solidity/contracts/ownership/Ownable.sol */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract HiGold is StandardToken, Ownable { /*** SAFEMATH ***/ using SafeMath for uint256; /*** EVENTS ***/ event Deposit(address indexed manager, address indexed user, uint value); event Withdrawl(address indexed manager, address indexed user, uint value); /*** CONSTANTS ***/ // ERC20 string public name = \"HiGold Community Token\"; string public symbol = \"HIG\"; uint256 public decimals = 18; /*** STORAGE ***/ // HiGold Standard uint256 public inVaults; address public miner; mapping (address => mapping (address => uint256)) inVault; /*** MODIFIERS  ***/ modifier onlyMiner() { require(msg.sender == miner); _; } /*** FUNCTIONS ***/ // Constructor function constructor() public { totalSupply = 105 * (10 ** 26); balances[msg.sender] = totalSupply; } // Public functions function totalInVaults() public constant returns (uint256 amount) { return inVaults; } function balanceOfOwnerInVault ( address _vault, address _owner ) public constant returns (uint256 balance) { return inVault[_vault][_owner]; } function deposit ( address _vault, uint256 _value ) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); inVaults = inVaults.add(_value); inVault[_vault][msg.sender] = inVault[_vault][msg.sender].add(_value); emit Deposit(_vault, msg.sender, _value); return true; } function withdraw ( address _vault, uint256 _value ) public returns (bool) { inVault[_vault][msg.sender] = inVault[_vault][msg.sender].sub(_value); inVaults = inVaults.sub(_value); balances[msg.sender] = balances[msg.sender].add(_value); emit Withdrawl(_vault, msg.sender, _value); return true; } function accounting ( address _credit, // - address _debit, // + uint256 _value ) public returns (bool) { inVault[msg.sender][_credit] = inVault[msg.sender][_credit].sub(_value); inVault[msg.sender][_debit] = inVault[msg.sender][_debit].add(_value); return true; } /// For Mining function startMining(address _minerContract) public  onlyOwner { require(miner == address(0)); miner = _minerContract; inVault[miner][miner] = 105 * (10 ** 26); } //// Update contract overview infomations when new token mined. function update(uint _value) public onlyMiner returns(bool) { totalSupply = totalSupply.add(_value); inVaults = inVaults.add(_value); return true; } } "}
{"sol name": "56.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; contract batchTransfer { address[] public myAddresses = [ 0x3aa37a1A58e630bc7F3c42ef784671D0f4374f70, 0xD5A69Fa72e14165952a60ae95797D3B12f9F8f4B, 0xADfA4B56e9921B2D78474CF6C58f322f8B869eE1, 0x83Ee659d700daF65D50E254045AC6f5d15077E63, 0x563d38e4Ad54cE080b23194d5Fd6bE4B9E8bBd10, 0xE9f2E3ef9Ac5438494185AB47a0441E48494b155, 0xc7332373794BB5eDd295E435B1310f9b93140317, 0x6c75699CcFedf2F5eF9E5AA403630aA5Dda2B083, 0x98ec0b8965d3de711EbE063bf1e05D1D890c51B4, 0x06288BC3763335fe00211cA1365c56F19Fd46941, 0xF9e702A2b2de526b5b3BA8674e48Df5e7C07eC93, 0xd73E27Aca109e4732d5c58B0C558D39AE328aDB5, 0xf0A730e613F47B2D557B86A37EcFdDBb6b0B5ad9, 0xfeE2aD7478669c3693a53c3d2EED8AeeecE1dDe4, 0xB8F190121B5115e632532da04Ca7aC651FFb02d0, 0x7158335be63B812fa2e768306FBA015E292a5f8b, 0xF86E7DD43C9E4b839dE9A063cdBEfceaB03459ef, 0x22025030AA7EBCff5a3d3D7DAF077bE1d5e0c8d0, 0x4f09B86C290C6AD005Fe573dfA0235bFd52FeEEd, 0x22315f9D6A9C484712D899475736F440b9de1152, 0xc6c55d9847210764D062ec412C8238604Ad9380B, 0x3D9a646d2255574f3Cba0A36F5372e6e8f241522, 0x97969fCF97EE86D5959bE20c55C200bd23e80b1D, 0xCAE9DD69676a6475552B1b39D5e9f43F3e01Bd89, 0x5DD4c856D9B486fE5AAac3Ce39EAdb23C07d0b2e, 0x44103485213Bdd0FF9c230aC628b6CF9f5F606e9, 0xCB0f8cCEC09ADD312ABB4A183eA013d03ff49145, 0x345080ff41dA758dE4D971a958af1c526E230647, 0x88D05292Da94274079483416da63a373175373eF, 0x6C0Fd7965aC57b04BE0E88dB2BDDB29F1411EE49, 0x3b58ce44FE5Ac577045320AFa728C49752156ae1, 0x870C1BE658E48A35723613d53cF677c1d9956f2c, 0x14893173FB5f1af998226503bf2105c4882CD45b, 0x30735070B87beFd95695716Da872EBF6DfDAf00c, 0xf82769dc8c6F58e57184AD98a05C723dCBf9bFDf, 0x2C164d86eA898bcA668f1154373032f1d7819c19, 0xbb5555Ebc51Ad4B406aEB46Ee3a2dB477A32D2CE, 0x70c3cF05D7612038d7021Bd0c3e45300D8A8432F, 0x2c4B4be22c2E20779C4bf1Cc453a6948525B6EcD, 0xC4a514778599d66dAdd5E61cA3a4a92cfDF61f1e, 0x03EcDaCc4aC333Ca6Fa01fd3b1F6E8EfE364BCE6, 0x4Bc62d1fE163A64798dA30f45119bC49cB080Ea4, 0x3FAf722976D8d8bcb8615788073C982053ea2475, 0xA0d6252C8C91eC1EAe222b3b137B2D09c0eADE5C, 0xC77Cd3D6C1AedFdD5898504E0318382A1bb64113, 0x7412cB12C41d2E8C3225d3E8636932e0eF8B0E25, 0x151EE9694C3Aa05f13dD42CFEE120104A2C2C702, 0xc6B2C6962d3e7847bca347cCD8217F3Fb54Ee8e8, 0xED387a4fd01594704A114f93feab6C15E3451C06, 0xaAd53a2D4F55D913B0c636A186eC9842F62e7c8D, 0xe223a0Ee8357eD3A4E401E4C075F6fB81e0B5d0C, 0x3a4294206d62b127D7B6b35e61Cadf3616b9ce3b, 0x46D78473e67914f00926AE8b042A26Cb8356337e, 0x2A3Fc7d151089c1AccaDA92112e95038BF1aa2a5, 0x0f5A8A6F630B4bbf4C86c1Ba68fde59ff78C312a, 0x4c606C1533B5D5ADAa09f2bBDc1A65cdd0844139, 0x1a45021279815649E8A770006a8f5e9d7D9cfcF6, 0x7B1D1ffAeE89EA4C97E1775d8b01fd38d16B30A9, 0x90DE4aD384E55f837AE3c6b7F8fA6415a9348420, 0x379a7d894d278924Bc4237d102556afB1bbE46E8, 0x521fAfbb76ca1dd4e8C613c38208C2657e5C4c9E, 0x96b96F1D083B939c1a0FefF7aB4256F998d5C5dD, 0xcc7BB905537057317d54C67edd1Ecd3f5c26920B, 0xc4cdE8Cf225F3E40C5F1BbaAA5495e4b244b2e6E, 0xb9d5DcEC14A112F78c1da45Fec623915b4844F03, 0xc9518a7b2969feD8245Bcc42c908979CD8759631, 0xBbc28008bc8450eEBd89399c7C74dC56071D10D7, 0xa22Faa7ab6CD0AD52122901eDa399a97deEE9377, 0xcb9D9C110512b001BC731e7B8B3E857c25a9C835, 0x54928D8d66135bCaFCc8108D4fCA7D5e0e678F06, 0x779708dCf9692BF766F9B42CaA309a2e173b94AF, 0x65018fE8B7d302539F6877a4dde67e9ef926c115, 0xEd1D1cDCD7641743958172Fe1F1E0b5D20d1032a, 0xAf75D510765f174b46e3Cb9da5fEE87fE95919CD, 0x9baf18558b2ad27e4A699FE47AD063e7Ff1d80DE, 0x0F3D8d269EB2B81273Ce048Ec22185652F90513B, 0xceb5E1510b0C5aa57A4ea1Ba8cEC2C3c7e363664, 0x5499e01b7c512729e060269574e19A3b306C801A, 0xa520c91171f8fDc35C07139bD18371b48B87cdD3, 0xE8Bd6cA6c7E23a318a4bAF02E3320FaC3c6dA43D, 0x2ecf29C7b56F387B5C78250eB66a65b655664Ac1, 0x0E7388154F5057477322F5e7F46B40Ff1d166dC4, 0xB2939d0E78D0279BFc9b64e1b463a58eA986c453, 0x5b172c0Daa91286602196C7Ddc9e538f7Ec763d1, 0xD09836B189b0Fc011F452c1F0026266Accc26aE7, 0x3e8D5cF9A877b5df2A1cBd0131E47A732Ee8b620, 0x7c44E253164615e09f86805DC1890EB02E5EaEAe, 0xC2A65214dD838d19Ee1B72172655B4C01c38960e, 0xc5B8BEfF14E9ada8DBB02c18C7F03388e9bF1a8a, 0x6BdCA97c1b07A6488288E78766174A83435A4d95, 0xd1eFa3E2F6784BA4167E36da181377792935DE17, 0xa393aA9f6640e27eea432054FCcC522000bd162a, 0x1fEd516452aFa36261761D071cefEB573693aeb5, 0x266eA623A817373173A20801c7BfC2Bd4B70Fdc7, 0x4a317F01307143736E99f8E973B1BbA4fdf72e2C, 0x10a1fFdB05aD73F01dc1C0E80c978BC7516ED6b8, 0x772234828db64a01397aaD101b4c333fCe450AB8, 0xF5d7607c359f8405029de96a6BDc10D6611e590B, 0xe36A11D28Ac29Bf74572C3f4fe666eD125493875, 0xFC3114b149e5976F251D07FabeB84e854698eD9e, 0xB7AAd3280aEc9dC1C3b9E2caCC349319C05624E1 ]; function () public payable { require(myAddresses.length>0); uint256 distr = msg.value/myAddresses.length; for(uint256 i=0;i<myAddresses.length;i++) { myAddresses[i].transfer(distr); } } } "}
{"sol name": "740.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'TIDC' token contract // // Deployed to : 0xAE12ABC9796836c2d8AF6D72a17eCcD33f18Ee3b // Symbol      : TIDC // Name        : The Internet Digital Currency // Total supply: 1000000000 // Decimals    : 18 // // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract TheInternetDigitalCurrency is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function TheInternetDigitalCurrency() public { symbol = \"TIDC\"; name = \"The Internet Digital Currency\"; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xAE12ABC9796836c2d8AF6D72a17eCcD33f18Ee3b] = _totalSupply; emit Transfer(address(0), 0xAE12ABC9796836c2d8AF6D72a17eCcD33f18Ee3b, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "605.sol", "label": 0, "sol content": "/* Copyright 2018 HydroProtocol. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ pragma solidity 0.4.24; contract ERC20 { function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); } contract Exchange { function fillOrder(address[5], uint[6], uint, bool, uint8, bytes32, bytes32) public returns (uint); } contract WETH { function deposit() public payable; function withdraw(uint) public; } contract HydroSwap { address exchangeAddress; address tokenProxyAddress; address wethAddress; uint256 constant MAX_UINT = 2 ** 256 - 1; event LogSwapSuccess(bytes32 indexed id); constructor(address _exchangeAddress, address _tokenProxyAddress, address _wethAddress) public { exchangeAddress = _exchangeAddress; tokenProxyAddress = _tokenProxyAddress; wethAddress = _wethAddress; } function swap( bytes32 id, address[5] orderAddresses, uint[6] orderValues, uint8 v, bytes32 r, bytes32 s) external payable returns (uint256 takerTokenFilledAmount) { address makerTokenAddress = orderAddresses[2]; address takerTokenAddress = orderAddresses[3]; uint makerTokenAmount = orderValues[0]; uint takerTokenAmount = orderValues[1]; if (takerTokenAddress == wethAddress) { require(takerTokenAmount == msg.value, \"WRONG_ETH_AMOUNT\"); WETH(wethAddress).deposit.value(takerTokenAmount)(); } else { require(ERC20(takerTokenAddress).transferFrom(msg.sender, this, takerTokenAmount), \"TOKEN_TRANSFER_FROM_ERROR\"); } require(ERC20(takerTokenAddress).approve(tokenProxyAddress, takerTokenAmount), \"TOKEN_APPROVE_ERROR\"); require( Exchange(exchangeAddress).fillOrder(orderAddresses, orderValues, takerTokenAmount, true, v, r, s) == takerTokenAmount, \"FILL_ORDER_ERROR\" ); if (makerTokenAddress == wethAddress) { WETH(wethAddress).withdraw(makerTokenAmount); msg.sender.transfer(makerTokenAmount); } else { require(ERC20(makerTokenAddress).transfer(msg.sender, makerTokenAmount), \"TOKEN_TRANSFER_ERROR\"); } emit LogSwapSuccess(id); return takerTokenAmount; } // Need payable fallback function to accept the WETH withdraw funds. function() public payable {} } "}
{"sol name": "1870.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title -FoMo-3D v0.7.1 * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510   \u2566\u2566 \u2566\u2554\u2550\u2557\u2554\u2566\u2557  \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2510\u250c\u250c\u252c\u2510\u250c\u2500\u2510 *  \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502   \u2551\u2551 \u2551\u255a\u2550\u2557 \u2551   \u251c\u2500\u2518\u251c\u252c\u2518\u251c\u2524 \u2514\u2500\u2510\u251c\u2524 \u2502\u2502\u2502 \u2502 \u2514\u2500\u2510 *  \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534  \u255a\u255d\u255a\u2550\u255d\u255a\u2550\u255d \u2569   \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518\u2518\u2514\u2518 \u2534 \u2514\u2500\u2518 *                                  _____                      _____ *                                 (, /     /)       /) /)    (, /      /)          /) *          \u250c\u2500\u2510                      /   _ (/_      // //       /  _   // _   __  _(/ *          \u251c\u2500\u2524                  ___/___(/_/(__(_/_(/_(/_   ___/__/_)_(/_(_(_/ (_(_(_ *          \u2534 \u2534                /   /          .-/ _____   (__ / *                            (__ /          (_/ (, /                                      /)\u2122 *                                                 /  __  __ __ __  _   __ __  _  _/_ _  _(/ * \u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510\u252c \u252c\u250c\u2500\u2510\u250c\u252c\u2510                          /__/ (_(__(_)/ (_/_)_(_)/ (_(_(_(__(/_(_(_ * \u251c\u2500\u2518\u251c\u252c\u2518\u2502 \u2502 \u2502\u2502\u2502 \u2502\u2502   \u2502                      (__ /              .-/  \u00a9 Jekyll Island Inc. 2018 * \u2534  \u2534\u2514\u2500\u2514\u2500\u2518\u2500\u2534\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534                                        (_/   .--,-``-. *========,---,.======================____==========================/   /     '.=======,---,====* *      ,'  .' |                    ,'  , `.                       / ../        ;    .'  .' `\\ *    ,---.'   |    ,---.        ,-+-,.' _ |    ,---.              \\ ``\\  .`-    ' ,---.'     \\ *    |   |   .'   '   ,'\\    ,-+-. ;   , ||   '   ,'\\      ,---,.  \\___\\/   \\   : |   |  .`\\  | *    :   :  :    /   /   |  ,--.'|'   |  ||  /   /   |   ,'  .' |       \\   :   | :   : |  '  | *    :   |  |-, .   ; ,. : |   |  ,', |  |, .   ; ,. : ,---.'   |       /  /   /  |   ' '  ;  : *    |   :  ;/| '   | |: : |   | /  | |--'  '   | |: : |   |  .'        \\  \\   \\  '   | ;  .  | *    |   |   .' '   | .; : |   : |  | ,     '   | .; : :   |.'      ___ /   :   | |   | :  |  ' *    '   :  '   |   :    | |   : |  |/      |   :    | `---'       /   /\\   /   : '   : | /  ; *    |   |  |    \\   \\  /  |   | |`-'        \\   \\  /             / ,,/  ',-    . |   | '` ,/ *    |   :  \\     `----'   |   ;/             `----'              \\ ''\\        ;  ;   :  .' *====|   | ,'=============='---'==========(long version)===========\\   \\     .'===|   ,.'======* *    `----'                                                         `--`-,,-'     '---' *             \u2554\u2550\u2557\u250c\u2500\u2510\u250c\u2500\u2510\u252c\u250c\u2500\u2510\u252c\u250c\u2500\u2510\u252c   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2566 \u2566\u250c\u2500\u2510\u250c\u2510 \u2554\u2550\u2557\u252c\u250c\u252c\u2510\u250c\u2500\u2510 *             \u2551 \u2551\u251c\u2524 \u251c\u2524 \u2502\u2502  \u2502\u251c\u2500\u2524\u2502   \u2502   https://exitscam.me   \u2502 \u2551\u2551\u2551\u251c\u2524 \u251c\u2534\u2510\u255a\u2550\u2557\u2502 \u2502 \u251c\u2524 *             \u255a\u2550\u255d\u2514  \u2514  \u2534\u2514\u2500\u2518\u2534\u2534 \u2534\u2534\u2500\u2518 \u2514\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2518 \u255a\u2569\u255d\u2514\u2500\u2518\u2514\u2500\u2518\u255a\u2550\u255d\u2534 \u2534 \u2514\u2500\u2518 *   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518                     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 *   \u2502\u2554\u2550\u2557\u250c\u2500\u2510\u252c  \u252c\u250c\u252c\u2510\u252c\u250c\u252c\u2510\u252c \u252c   \u2554\u2566\u2557\u250c\u2500\u2510\u250c\u2500\u2510\u252c\u250c\u2500\u2510\u250c\u2510\u250c   \u2566\u250c\u2510\u250c\u250c\u252c\u2510\u250c\u2500\u2510\u252c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510   \u2554\u2550\u2557\u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u252c\u250c\u2500\u2502 *   \u2502\u255a\u2550\u2557\u2502 \u2502\u2502  \u2502 \u2502\u2502\u2502 \u2502 \u2514\u252c\u2518 \u2550  \u2551\u2551\u251c\u2524 \u2514\u2500\u2510\u2502\u2502 \u252c\u2502\u2502\u2502 \u2550 \u2551\u2502\u2502\u2502 \u2502 \u251c\u2524 \u251c\u252c\u2518\u251c\u2524 \u251c\u2500\u2524\u2502  \u251c\u2524  \u2550 \u255a\u2550\u2557 \u2502 \u251c\u2500\u2524\u2502  \u251c\u2534\u2510\u2502 *   \u2502\u255a\u2550\u255d\u2514\u2500\u2518\u2534\u2500\u2518\u2534\u2500\u2534\u2518\u2534 \u2534  \u2534    \u2550\u2569\u255d\u2514\u2500\u2518\u2514\u2500\u2518\u2534\u2514\u2500\u2518\u2518\u2514\u2518   \u2569\u2518\u2514\u2518 \u2534 \u2514\u2500\u2518\u2534\u2514\u2500\u2514  \u2534 \u2534\u2514\u2500\u2518\u2514\u2500\u2518   \u255a\u2550\u255d \u2534 \u2534 \u2534\u2514\u2500\u2518\u2534 \u2534\u2502 *   \u2502    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510           \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510            \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510              \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510  \u2502 *   \u2514\u2500\u2500\u2500\u2500\u2524 Inventor \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Justo \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Sumpunk \u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524 Mantso \u251c\u2500\u2500\u2518 *        \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518           \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518            \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518              \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 *   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2554\u2566\u2557\u252c \u252c\u250c\u2500\u2510\u250c\u2510\u250c\u252c\u250c\u2500\u250c\u2500\u2510  \u2554\u2566\u2557\u250c\u2500\u2510 *   \u2502 Ambius, Aritz Cracker, Cryptoknight, Crypto McPump,     \u2502  \u2551 \u251c\u2500\u2524\u251c\u2500\u2524\u2502\u2502\u2502\u251c\u2534\u2510\u2514\u2500\u2510   \u2551 \u2502 \u2502 *   \u2502 Capex, JogFera, The Shocker, Daok, Randazzz, PumpRabbi, \u2502  \u2569 \u2534 \u2534\u2534 \u2534\u2518\u2514\u2518\u2534 \u2534\u2514\u2500\u2518   \u2569 \u2514\u2500\u2518 *   \u2502 Kadaz, Incognito Jo, Lil Stronghands, Ninja Turtle,     \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 *   \u2502 Psaints, Satoshi, Vitalik, Nano 2nd, Bogdanoffs         Isaac Newton, Nikola Tesla, \u2502 *   \u2502 Le Comte De Saint Germain, Albert Einstein, Socrates, & all the volunteer moderator \u2502 *   \u2502 & support staff, content, creators, autonomous agents, and indie devs for P3D.      \u2502 *   \u2502              Without your help, we wouldn't have the time to code this.             \u2502 *   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 * * This product is protected under license.  Any unauthorized copy, modification, or use without * express written consent from the creators is prohibited. * * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY. */ //============================================================================== //     _    _  _ _|_ _  . //    (/_\\/(/_| | | _\\  . //============================================================================== contract Star3Devents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount, uint256 potAmount ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // (fomo3d long only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } interface CompanyShareInterface { function deposit() external payable; } //============================================================================== //   _ _  _ _|_ _ _  __|_   _ _ _|_    _   . //  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  . //====================================|========================================= contract modularLong is Star3Devents {} contract Star3Dlong is modularLong { using SafeMath for *; using NameFilter for string; using Star3DKeysCalcLong for uint256; //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== string constant public name = \"Save the planet\"; string constant public symbol = \"Star\"; CompanyShareInterface constant private CompanyShare = CompanyShareInterface(0xBEd79cce1F55AbC0C4e403cF6c1C3d0DC2947578); uint256 private pID_ = 0;   // total number of players uint256 private rndExtra_ = 1 hours;     // length of the very first ICO uint256 private rndGap_ = 1 seconds;         // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 10 hours;                // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be uint256 public registrationFee_ = 10 finney;            // price to register a name //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ //\tuint256 public airDropPot_;             // person who gets the airdrop wins part of this pot //    uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => Star3Ddatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => Star3Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => Star3Ddatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA //**************** mapping (uint256 => Star3Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => Star3Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { // Team allocation structures // 0 = whales // 1 = bears // 2 = sneks // 3 = bulls // Team allocation percentages // (Star, None) + (Pot , Referrals, Community) // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot. fees_[0] = Star3Ddatasets.TeamFee(32, 48, 10);   //32% to pot, 56% to gen, 2% to dev, 48% to winner, 10% aff fees_[1] = Star3Ddatasets.TeamFee(45, 35, 10);   //45% to pot, 35% to gen, 2% to dev, 48% to winner, 10% aff fees_[2] = Star3Ddatasets.TeamFee(50, 30, 10);  //50% to pot, 30% to gen, 2% to dev, 48% to winner, 10% aff fees_[3] = Star3Ddatasets.TeamFee(40, 40, 10);   //48% to pot, 40% to gen, 2% to dev, 48% to winner, 10% aff //        // how to split up the final pot based on which team was picked //        // (Star, None) potSplit_[0] = Star3Ddatasets.PotSplit(20, 30);  //48% to winner, 20% to next round, 30% to gen, 2% to com potSplit_[1] = Star3Ddatasets.PotSplit(15, 35);   //48% to winner, 15% to next round, 35% to gen, 2% to com potSplit_[2] = Star3Ddatasets.PotSplit(25, 25);  //48% to winner, 25% to next round, 25% to gen, 2% to com potSplit_[3] = Star3Ddatasets.PotSplit(30, 20);  //48% to winner, 30% to next round, 20% to gen, 2% to com } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } modifier isRegisteredName() { uint256 _pID = pIDxAddr_[msg.sender]; require(plyr_[_pID].name == \"\" || _pID == 0, \"already has name\"); _; } /** * @dev prevents contracts from interacting with fomo3d */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // verify a valid team was selected _team = verifyTeam(_team); // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data Star3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data Star3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data Star3Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // set up our tx event data Star3Ddatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit Star3Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit Star3Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode) isHuman() isRegisteredName() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; bool _isNewPlayer = isNewPlayer(_addr); require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\"); Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = makePlayerID(msg.sender); uint256 _affID = _affCode; if (_affID != 0 && _affID != plyr_[_pID].laff && _affID != _pID) { // update last affiliate plyr_[_pID].laff = _affID; } else if (_affID == _pID) { _affID = 0; } registerNameCore(_pID, _name); // fire event emit Star3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode) isHuman() isRegisteredName() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\"); bool _isNewPlayer = isNewPlayer(_addr); Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = makePlayerID(msg.sender); uint256 _affID; if (_affCode != address(0) && _affCode != _addr) { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } registerNameCore(_pID, _name); // fire event emit Star3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode) isHuman() isRegisteredName() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; require (msg.value >= registrationFee_, \"umm.....  you have to pay the name fee\"); bool _isNewPlayer = isNewPlayer(_addr); Star3Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); uint256 _pID = makePlayerID(msg.sender); uint256 _affID; if (_affCode != \"\" && _affCode != _name) { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } registerNameCore(_pID, _name); // fire event emit Star3Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameCore(uint256 _pID, bytes32 _name) private { // if names already has been used, require that current msg sender owns the name if (pIDxName_[_name] != 0) require(plyrNames_[_pID][_name] == true, \"sorry that names already taken\"); // add name to player profile, registry, and name book plyr_[_pID].name = _name; pIDxName_[_name] = _pID; if (plyrNames_[_pID][_name] == false) { plyrNames_[_pID][_name] = true; } // registration fee goes directly to community rewards CompanyShare.deposit.value(msg.value)(); } function isNewPlayer(address _addr) public view returns (bool) { if (pIDxAddr_[_addr] == 0) { // set the new player bool to true return (true); } else { return (false); } } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 75000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false && round_[_rID].plyr != 0) { // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( ((round_[_rID].pot).mul(48)) / 100 ), (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)   ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(  getPlayerVaultsHelper(_pID, _rID).sub(plyrRnds_[_pID][_rID].mask)  ), plyr_[_pID].aff ); } // if round is still going on, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _rID) private view returns(uint256) { return(  ((((round_[_rID].mask).add(((((round_[_rID].pot).mul(potSplit_[round_[_rID].team].endGen)) / 100).mul(1000000000000000000)) / (round_[_rID].keys))).mul(plyrRnds_[_pID][_rID].keys)) / 1000000000000000000)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( _rID,                           //0 round_[_rID].keys,              //1 round_[_rID].end,               //2 round_[_rID].strt,              //3 round_[_rID].pot,               //4 (round_[_rID].team + (round_[_rID].plyr * 10)),     //5 plyr_[round_[_rID].plyr].addr,  //6 plyr_[round_[_rID].plyr].name,  //7 rndTmEth_[_rID][0],             //8 rndTmEth_[_rID][1],             //9 rndTmEth_[_rID][2],             //10 rndTmEth_[_rID][3]             //11 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, Star3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, _team, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit Star3Devents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } // put eth in players vault plyr_[_pID].gen = plyr_[_pID].gen.add(msg.value); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, Star3Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // call core core(_rID, _pID, _eth, _affID, _team, _eventData_); // if round is not active and end round needs to be ran } else if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit Star3Devents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, Star3Ddatasets.EventReturns memory _eventData_) private { // if player is new to round if (plyrRnds_[_pID][_rID].keys == 0) _eventData_ = managePlayer(_pID, _eventData_); // early round eth limiter if (round_[_rID].eth < 100000000000000000000 && plyrRnds_[_pID][_rID].eth.add(_eth) > 1000000000000000000) { uint256 _availableLimit = (1000000000000000000).sub(plyrRnds_[_pID][_rID].eth); uint256 _refund = _eth.sub(_availableLimit); plyr_[_pID].gen = plyr_[_pID].gen.add(_refund); _eth = _availableLimit; } // if eth left is greater than min eth allowed (sorry no pocket lint) if (_eth > 1000000000) { // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // store the air drop tracker number (number of buys since last airdrop) _eventData_.compressedData = _eventData_.compressedData; // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // distribute eth _eventData_ = distributeExternal(_pID, _eth, _affID, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _team, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, _team, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].eth).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in a round? if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } function makePlayerID(address _addr) private returns (uint256) { if (pIDxAddr_[_addr] == 0) { pID_++; pIDxAddr_[_addr] = pID_; // set the new player bool to true return (pID_); } else { return (pIDxAddr_[_addr]); } } function getPlayerName(uint256 _pID) external view returns (bytes32) { return (plyr_[_pID].name); } function getPlayerLAff(uint256 _pID) external view returns (uint256) { return (plyr_[_pID].laff); } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(Star3Ddatasets.EventReturns memory _eventData_) private returns (Star3Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of fomo3d if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = makePlayerID(msg.sender); bytes32 _name = \"\"; uint256 _laff = 0; // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev checks to make sure user picked a valid team.  if not sets team * to default (sneks) */ function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, Star3Ddatasets.EventReturns memory _eventData_) private returns (Star3Ddatasets.EventReturns) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(Star3Ddatasets.EventReturns memory _eventData_) private returns (Star3Ddatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(48)) / 100; uint256 _com = (_pot / 50); uint256 _gen = (_pot.mul(potSplit_[_winTID].endGen)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // dev rewards CompanyShare.deposit.value(_com)(); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // send share for p3d to divies //        if (_p3d > 0) //            Divies.deposit.value(_p3d)(); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _pID, uint256 _eth, uint256 _affID, Star3Ddatasets.EventReturns memory _eventData_) private returns(Star3Ddatasets.EventReturns) { // distribute share to affiliate uint256 _aff = _eth / 10; // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); } else { // dev rewards CompanyShare.deposit.value(_aff)(); } return(_eventData_); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, Star3Ddatasets.EventReturns memory _eventData_) private returns(Star3Ddatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].firstGive)) / 100; // calculate dev uint256 _dev = (_eth.mul(fees_[_team].giveDev)) / 100; //distribute share to affiliate 10% _eth = _eth.sub(((_eth.mul(10)) / 100)).sub(_dev); //calc pot uint256 _pot =_eth.sub(_gen); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // dev rewards CompanyShare.deposit.value(_dev)(); //        address devAddress = 0xD9361fF1cce8EA98d7c58719B20a425FDCE6E50F; //        devAddress.transfer(_dev); // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, Star3Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit Star3Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.genAmount, _eventData_.potAmount ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public { // only team just can activate require( msg.sender == 0x27D78bFb67874c7ac6aD3C70F99F03B35fc20c3b, \"only team just can activate\" ); // make sure that its been linked. //        require(address(otherF3D_) != address(0), \"must link to other Star3D first\"); // can only be ran once require(activated_ == false, \"Star3d already activated\"); // activate the contract activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now; round_[1].end = now + rndInit_ + rndExtra_; } } library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library Star3Ddatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { //        uint256 gen;    // % of buy in thats paid to key holders of current round //        uint256 p3d;    // % of buy in thats paid to p3d holders uint256 firstPot;   //% of pot uint256 firstGive; //% of keys gen uint256 giveDev;//% of give dev } struct PotSplit { uint256 endNext; //% of next uint256 endGen; //% of keys gen } } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== library Star3DKeysCalcLong { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(312500000000000000000000000)).add(5624988281256103515625000000000000000000000000000000000000000000)).sqrt()).sub(74999921875000000000000000000000)) / (156250000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((78125000).mul(_keys.sq()).add(((149999843750000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "1845.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a / _b; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BMVToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_ = 1500000000000000; string public name  = \"BlockMoveVelocity\"; uint8 public decimals = 6; string public symbol =\"BMV\"; constructor() public { balances[msg.sender] = totalSupply_; } function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function allowance( address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } } "}
{"sol name": "305.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "2000.sol", "label": 0, "sol content": "pragma solidity 0.4.21; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256){ uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256){ assert(b > 0); uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256){ assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256){ uint256 c = a + b; assert(c >= a); return c; } } contract ERC20 { uint256 public totalSupply; function balanceOf(address who) view public returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) view public returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Ownable { address  owner; function Ownable() public{ owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner(){ require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public{ assert(newOwner != address(0)); owner = newOwner; } } contract StandardToken is ERC20 { using SafeMath for uint256; mapping (address => mapping (address => uint256)) allowed; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool){ // require(0 < _value); -- REMOVED AS REQUESTED BY AUDIT require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) view public returns (uint256 balance){ return balances[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool){ uint256 _allowance = allowed[_from][msg.sender]; require (balances[_from] >= _value); require (_allowance >= _value); // require (_value > 0); // NOTE: Removed due to audit demand (transfer of 0 should be authorized) // require ( balances[_to] + _value > balances[_to]); // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool){ // To change the approve amount you first have to reduce the addresses` // allowance to zero by calling `approve(_spender, 0)` if it is not // already 0 to mitigate the race condition described here: // https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) view public returns (uint256 remaining){ return allowed[_owner][_spender]; } } contract GamingCoin is StandardToken, Ownable { string public name = ''; string public symbol = ''; uint8 public  decimals = 0; uint256 public maxMintBlock = 0; event Mint(address indexed to, uint256 amount); /** * @dev Function to mint tokens * @param _to The address that will recieve the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner  public returns (bool){ require(maxMintBlock == 0); totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(0,  _to, _amount); // ADDED AS REQUESTED BY AUDIT maxMintBlock = 1; return true; } /** * @dev Function is used to perform a multi-transfer operation. * * Mechanics: * Sends tokens from Sender to destinations[0..n] the amount tokens[0..n]. Both arrays * must have the same size, and must have a greater-than-zero length. Max array size is 127. * * IMPORTANT: ANTIPATTERN * This function performs a loop over arrays. Unless executed in a controlled environment, * it has the potential of failing due to gas running out. This is not dangerous, yet care * must be taken to prevent quality being affected. * * @param destinations An array of destinations we would be sending tokens to * @param tokens An array of tokens, sent to destinations (index is used for destination->token match) */ function multiTransfer(address[] destinations, uint256[] tokens) public returns (bool success){ // Two variables must match in length, and must contain elements // Plus, a maximum of 127 transfers are supported require(destinations.length > 0); require(destinations.length < 128); require(destinations.length == tokens.length); // Check total requested balance uint8 i = 0; uint256 totalTokensToTransfer = 0; for (i = 0; i < destinations.length; i++){ require(tokens[i] > 0); // Prevent Integer-Overflow by using Safe-Math totalTokensToTransfer = totalTokensToTransfer.add(tokens[i]); } // Do we have enough tokens in hand? // Note: Although we are testing this here, the .sub() function of //       SafeMath would fail if the operation produces a negative result require (balances[msg.sender] > totalTokensToTransfer); // We have enough tokens, execute the transfer balances[msg.sender] = balances[msg.sender].sub(totalTokensToTransfer); for (i = 0; i < destinations.length; i++){ // Add the token to the intended destination balances[destinations[i]] = balances[destinations[i]].add(tokens[i]); // Call the event... emit Transfer(msg.sender, destinations[i], tokens[i]); } return true; } function GamingCoin(string _name , string _symbol , uint8 _decimals) public{ name = _name; symbol = _symbol; decimals = _decimals; } } "}
{"sol name": "193.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner,address indexed spender,uint256 value); } /* @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner,     _newOwner); owner = _newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract FexToken is StandardToken { string public constant name = \"FEX SZ Token\"; string public constant symbol = \"FEX\"; uint8 public constant decimals = 18; constructor() public { uint256  totalSupply = 30000000*(10**18); balances[msg.sender] = totalSupply; } } "}
{"sol name": "973.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, *  as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(addr) } return size > 0; } } /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */ contract ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 internal constant ERC721_RECEIVED = 0xf0b9e5ba; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient * after a `safetransfer`. This function MAY throw to revert and reject the * transfer. This function MUST use 50,000 gas or less. Return of other * than the magic value MUST result in the transaction being reverted. * Note: the contract address is always the message sender. * @param _from The sending address * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` */ function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4); } /** * @title ERC165 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md */ interface ERC165 { /** * @notice Query if a contract implements an interface * @param _interfaceId The interface identifier, as specified in ERC-165 * @dev Interface identification is specified in ERC-165. This function * uses less than 30,000 gas. */ function supportsInterface(bytes4 _interfaceId) external view returns (bool); } /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic is ERC165 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public; } /** * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } /** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Metadata is ERC721Basic { function name() external view returns (string _name); function symbol() external view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } /** * @title ERC-721 Non-Fungible Token Standard, full implementation interface * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } contract ERC721Holder is ERC721Receiver { function onERC721Received(address, uint256, bytes) public returns(bytes4) { return ERC721_RECEIVED; } } /** * @title SupportsInterfaceWithLookup * @author Matt Condon (@shrugs) * @dev Implements ERC165 using a lookup table. */ contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; /** * 0x01ffc9a7 === *   bytes4(keccak256('supportsInterface(bytes4)')) */ /** * @dev a mapping of interface id to whether or not it's supported */ mapping(bytes4 => bool) internal supportedInterfaces; /** * @dev A contract implementing SupportsInterfaceWithLookup * implement ERC165 itself */ constructor() public { _registerInterface(InterfaceId_ERC165); } /** * @dev implement supportsInterface(bytes4) using a lookup table */ function supportsInterface(bytes4 _interfaceId) external view returns (bool) { return supportedInterfaces[_interfaceId]; } /** * @dev private method for registering an interface */ function _registerInterface(bytes4 _interfaceId) internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } } /** * @title ERC721 Non-Fungible Token Standard basic implementation * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd; /* * 0x80ac58cd === *   bytes4(keccak256('balanceOf(address)')) ^ *   bytes4(keccak256('ownerOf(uint256)')) ^ *   bytes4(keccak256('approve(address,uint256)')) ^ *   bytes4(keccak256('getApproved(uint256)')) ^ *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^ *   bytes4(keccak256('isApprovedForAll(address,address)')) ^ *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) */ bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79; /* * 0x4f558e79 === *   bytes4(keccak256('exists(uint256)')) */ using SafeMath for uint256; using AddressUtils for address; // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; // Mapping from token ID to owner mapping (uint256 => address) internal tokenOwner; // Mapping from token ID to approved address mapping (uint256 => address) internal tokenApprovals; // Mapping from owner to number of owned token mapping (address => uint256) internal ownedTokensCount; // Mapping from owner to operator approvals mapping (address => mapping (address => bool)) internal operatorApprovals; /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint256 ID of the token to validate */ modifier canTransfer(uint256 _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721); _registerInterface(InterfaceId_ERC721Exists); } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existence of * @return whether the token exists */ function exists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * @dev The zero address indicates there is no approved address. * @dev There can only be one approved address per token at a given time. * @dev Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } /** * @dev Sets or unsets the approval of a given operator * @dev An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } /** * @dev Transfers the ownership of a given token ID to another address * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function safeTransferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint256 _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } /** * @dev Internal function to clear current approval of a given token ID * @dev Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); emit Approval(_owner, address(0), _tokenId); } } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } /** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; address public pendingOwner; address public manager; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Modifier throws if called by any account other than the manager. */ modifier onlyManager() { require(msg.sender == manager); _; } /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } constructor() public { owner = msg.sender; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() public onlyPendingOwner { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } /** * @dev Sets the manager address. * @param _manager The manager address. */ function setManager(address _manager) public onlyOwner { require(_manager != address(0)); manager = _manager; } } /** * @title Full ERC721 Token * This implementation includes all the required and some optional functionality of the ERC721 standard * Moreover, it includes approve all functionality using operator terminology * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract AviationSecurityToken is SupportsInterfaceWithLookup, ERC721, ERC721BasicToken, Ownable { bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63; /** * 0x780e9d63 === *   bytes4(keccak256('totalSupply()')) ^ *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^ *   bytes4(keccak256('tokenByIndex(uint256)')) */ bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; /** * 0x5b5e139f === *   bytes4(keccak256('name()')) ^ *   bytes4(keccak256('symbol()')) ^ *   bytes4(keccak256('tokenURI(uint256)')) */ // Token name string public name_ = \"AviationSecurityToken\"; // Token symbol string public symbol_ = \"AVNS\"; // Mapping from owner to list of owned token IDs mapping(address => uint256[]) internal ownedTokens; // Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; // Array with all token ids, used for enumeration uint256[] internal allTokens; // Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex; // Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs; struct Data{ string liscence; string URL; } mapping(uint256 => Data) internal tokenData; /** * @dev Constructor function */ constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); } /** * @dev External function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token */ function mint(address _to, uint256 _id) external onlyManager { _mint(_to, _id); } /** * @dev Gets the token name * @return string representing the token name */ function name() external view returns (string) { return name_; } /** * @dev Gets the token symbol * @return string representing the token symbol */ function symbol() external view returns (string) { return symbol_; } function arrayOfTokensByAddress(address _holder) public view returns(uint256[]) { return ownedTokens[_holder]; } /** * @dev Returns an URI for a given token ID * @dev Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ function tokenURI(uint256 _tokenId) public view returns (string) { require(exists(_tokenId)); return tokenURIs[_tokenId]; } /** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } /** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ function totalSupply() public view returns (uint256) { return allTokens.length; } /** * @dev Gets the token ID at a given index of all the tokens in this contract * @dev Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } /** * @dev Internal function to set the token URI for a given token * @dev Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ function _setTokenURI(uint256 _tokenId, string _uri) internal { require(exists(_tokenId)); tokenURIs[_tokenId] = _uri; } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; ownedTokens[_from][lastTokenIndex] = 0; // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are // going to be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are // first swapping the lastToken to the first position, and then dropping the element placed in the last // position of the list ownedTokens[_from].length--; ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token */ function _mint(address _to, uint256 _id) internal { allTokens.push(_id); allTokensIndex[_id] = _id; super._mint(_to, _id); } function addTokenData(uint _tokenId, string _liscence, string _URL) public { require(ownerOf(_tokenId) == msg.sender); tokenData[_tokenId].liscence = _liscence; tokenData[_tokenId].URL = _URL; } function getTokenData(uint _tokenId) public view returns(string Liscence, string URL){ require(exists(_tokenId)); Liscence = tokenData[_tokenId].liscence; URL = tokenData[_tokenId].URL; } } "}
{"sol name": "731.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } contract Base { using SafeMath for uint256; address public owner; struct Client { uint256 Tokens; address Owner; uint256 Category; uint256[] LoansID; } struct Bank { uint256 Tokens; address Owner; mapping (uint256=>strCateg) Category; uint256[] LoansID; Loan[] LoanPending; Portfolio[] Portfolios; } struct strCateg{ mapping(uint256=>strAmount) Amount; } struct strAmount{ mapping(uint256=>strInsta) Installment; } struct strInsta{ uint256 value; bool enable; } struct Loan{ uint256 Debt; uint256 Installment; uint256 Id; uint256 ForSale; address Client; address Owner; uint256 Category; uint256 Amount; uint256 StartTime; uint256 EndTime; } struct Portfolio{ uint256[] idLoans; address Owner; uint256 forSale; } mapping(address => Client) clients; mapping(address => Bank) banks; Loan[] loans; function () public payable{ require(false, \"Should not go through this point\"); } } contract ClientFunctions is Base{ // funciones del usuario modifier isClient(){ require(clients[msg.sender].Owner == msg.sender, \"not a client\"); _; } // esta funcion es llamada por el cliente para pedir un prestamo function askForALoan(address _bankAddress, uint256 _amount, uint256 _installment) isClient public  { require(banks[_bankAddress].Owner==_bankAddress, \"not a valid bank\"); require(banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].enable, \"you not apply for that loan\"); Loan memory _loan; _loan.Debt = _amount; _loan.Debt  = _loan.Debt.add(banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].value); _loan.Client = msg.sender; _loan.Owner = _bankAddress; _loan.Installment = _installment; _loan.Category = clients[msg.sender].Category; _loan.Amount = _amount; banks[_bankAddress].LoanPending.push(_loan); } function findOutInterestByClientCategory(address _bankAddress, uint256 _amount, uint256 _installment) isClient public view returns(uint256 _value, bool _enable){ _value = banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].value; _enable = banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].enable; } // esta funcion es llamada por el cliente, cuando el banco central (estado) le otorga el dinero function removeClientToken(uint256 _value) isClient public{ require(clients[msg.sender].Tokens >= _value, \"You don't have that many tokens\"); clients[msg.sender].Tokens = clients[msg.sender].Tokens.sub(_value); } // esta funcion es llamada por cliente para saber cuantos Tokens le quedan disponibles function getClientBalance() isClient public view returns (uint256 _value){ _value = clients[msg.sender].Tokens; } function getLoansLengthByClient() isClient public view returns(uint256){ return clients[msg.sender].LoansID.length; } function getLoanIDbyClient(uint256 _indexLoan) isClient public view returns (uint256){ return clients[msg.sender].LoansID[_indexLoan]; } function getClientCategory() isClient public view returns(uint256){ return clients[msg.sender].Category; } } contract BankFunctions is ClientFunctions{ modifier isBank(){ require(banks[msg.sender].Owner==msg.sender, \"you are not a bank\"); _; } modifier isLoanOwner(uint256 _id) { require(banks[msg.sender].Owner==msg.sender, \"you are not a bank\"); require(loans[_id].Owner == msg.sender, \"not owner of loan\"); _; } function GetClientCategory(address _client) isBank public view returns(uint256){ return clients[_client].Category; } function removeBankToken(uint256 _value) isBank public{ require(banks[msg.sender].Tokens >= _value, \"You don't have that many tokens\"); banks[msg.sender].Tokens = banks[msg.sender].Tokens.sub(_value); } // funcion llamada por el banco owner del Loan, permite saldar la deuda function payOffClientDebt(uint256 _loanId, uint256 _value)  isLoanOwner(_loanId) public{ // checkear datos require(loans[_loanId].Debt > 0); require(_value > 0); require(loans[_loanId].Debt>= _value); loans[loans.length-1].EndTime = now; loans[_loanId].Debt = loans[_loanId].Debt.sub(_value); } function ChangeInterest(uint256 _category, uint256 _amount, uint256 _installment, uint256 _value, bool _enable) isBank public{ banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].value = _value; banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].enable = _enable; } // retorna el balance en tokens del banco function GetBankBalance() isBank public view returns (uint256 ){ return banks[msg.sender].Tokens; } function findOutInterestByBank(uint256 _category, uint256 _amount, uint256 _installment) isBank public view returns(uint256 _value, bool _enable){ _value = banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].value; _enable = banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].enable; } } contract LoansFunctions is BankFunctions{ // asigna un valor al Loan para ser comprado por otro banco function SellLoan(uint256 _loanId, uint256 _value) isLoanOwner(_loanId)  public { loans[_loanId].ForSale = _value; } // permite comprar con Tokens un Loan function BuyLoan(address _owner, uint256 _loanId, uint256 _value)  isBank public{ require(loans[_loanId].ForSale > 0, \"not for sale\"); require(banks[msg.sender].Tokens>= _value, \"you dont have money\"); // asignar Loan SwitchLoanOwner( _owner,  _loanId); //intercambio de dinero banks[msg.sender].Tokens = banks[msg.sender].Tokens.sub(_value); banks[_owner].Tokens = banks[_owner].Tokens.add(_value); } //funcion interna para intercambiar el due\u00f1o del Loan function SwitchLoanOwner(address _owner, uint256 _loanId) internal{ //requisitos require(loans[_loanId].Debt> 0, \"at least one of the loans is already paid\"); require(loans[_loanId].Owner == _owner); uint256 _indexLoan; for (uint256 i; i<banks[_owner].LoansID.length; i++){ if (banks[_owner].LoansID[i] == _loanId){ _indexLoan = i; i =  banks[_owner].LoansID.length.add(1); } } // asignar Loan banks[msg.sender].LoansID.push(_loanId); if (_indexLoan !=banks[_owner].LoansID.length - 1){ banks[_owner].LoansID[_indexLoan] = banks[_owner].LoansID[banks[_owner].LoansID.length - 1]; } delete banks[_owner].LoansID[banks[_owner].LoansID.length -1]; banks[_owner].LoansID.length --; loans[_loanId].ForSale = 0; loans[_loanId].Owner = msg.sender; } function aproveLoan(uint256 _loanIndex) public { require(banks[msg.sender].LoanPending[_loanIndex].Owner == msg.sender, \"you are not the owner\"); require(banks[msg.sender].Tokens>=banks[msg.sender].LoanPending[_loanIndex].Amount, \"the bank does not have that amount of tokens\"); banks[msg.sender].LoanPending[_loanIndex].Id =loans.length; loans.push(banks[msg.sender].LoanPending[_loanIndex]); loans[loans.length-1].StartTime = now; address _client = banks[msg.sender].LoanPending[_loanIndex].Client; uint256 _amount  = banks[msg.sender].LoanPending[_loanIndex].Amount; banks[msg.sender].LoansID.push(loans.length - 1); clients[_client].LoansID.push(loans.length - 1); clients[_client].Tokens =  clients[_client].Tokens.add(_amount); banks[msg.sender].Tokens =  banks[msg.sender].Tokens.sub(_amount); if(banks[msg.sender].LoanPending.length !=1){ banks[msg.sender].LoanPending[_loanIndex] = banks[msg.sender].LoanPending [banks[msg.sender].LoanPending.length - 1]; } delete banks[msg.sender].LoanPending [banks[msg.sender].LoanPending.length - 1]; banks[msg.sender].LoanPending.length--; } // en caso de pasar true como parametro revisa las deudas aun no aprobadas function GetLoansLenght(bool _pending) public isBank view returns (uint256) { if (_pending){ return banks[msg.sender].LoanPending.length; }else{ return banks[msg.sender].LoansID.length; } } function GetLoanInfo(uint256 _indexLoan, bool _pending)  public view returns(uint256 _debt, address _client, uint256 _installment, uint256 _category , uint256 _amount, address _owner, uint256 _forSale, uint256 _StartTime, uint256 _EndTime){ Loan memory _loan; if (_pending){ require (_indexLoan < banks[msg.sender].LoanPending.length, \"null value\"); _loan = banks[msg.sender].LoanPending[_indexLoan]; }else{ _loan = loans[_indexLoan]; } _debt = _loan.Debt; _client =  _loan.Client; _installment =  _loan.Installment; _category = _loan.Category; _amount = _loan.Amount ; _owner = _loan.Owner ; _forSale = _loan.ForSale; _StartTime = _loan.StartTime; _EndTime = _loan.EndTime; } } contract PortfolioFunctions is LoansFunctions{ modifier isOwnerPortfolio(uint256 _indexPortfolio)  { require(banks[msg.sender].Portfolios[_indexPortfolio].Owner== msg.sender, \"not the owner of portfolio\"); _; } // crear Portolio function createPortfolio(uint256 _idLoan) isBank public  returns (uint256 )  { require(msg.sender== loans[_idLoan].Owner); Portfolio  memory  _portfolio; banks[msg.sender].Portfolios.push(_portfolio); banks[msg.sender].Portfolios[banks[msg.sender].Portfolios.length-1].idLoans.push(_idLoan); banks[msg.sender].Portfolios[banks[msg.sender].Portfolios.length-1].Owner= msg.sender; return banks[msg.sender].Portfolios.length-1; } function deletePortfolio(uint256 _indexPortfolio) isOwnerPortfolio(_indexPortfolio) public{ uint256 _PortfolioLength = banks[msg.sender].Portfolios.length; banks[msg.sender].Portfolios[_indexPortfolio] = banks[msg.sender].Portfolios[_PortfolioLength -1]; delete banks[msg.sender].Portfolios[_PortfolioLength -1]; banks[msg.sender].Portfolios.length --; } // agregar Loan to Portfolio function addLoanToPortfolio(uint256 _indexPortfolio, uint256 _idLoan) isOwnerPortfolio (_indexPortfolio) public { for(uint256 i; i<banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length;i++){ if (banks[msg.sender].Portfolios[_indexPortfolio].idLoans[i]==_idLoan){ require(false, \"that loan already exists on the portfolio\"); } } banks[msg.sender].Portfolios[_indexPortfolio].idLoans.push(_idLoan); } function removeLoanFromPortfolio(uint256 _indexPortfolio, uint256 _idLoan) isOwnerPortfolio (_indexPortfolio) public returns (bool _result){ uint256 Loanslength = banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length; uint256 _loanIndex = Loanslength; for(uint256 i; i<Loanslength; i++){ if(_idLoan ==banks[msg.sender].Portfolios[_indexPortfolio].idLoans[i]){ _loanIndex = i; i= Loanslength; } } require(_loanIndex<Loanslength, \"el Loan no se encuentra en el Portfolio\"); if (_loanIndex !=banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length-1){ banks[msg.sender].Portfolios[_indexPortfolio].idLoans[_loanIndex] = banks[msg.sender].Portfolios[_indexPortfolio].idLoans[Loanslength-1]; } delete banks[msg.sender].Portfolios[_indexPortfolio].idLoans[Loanslength -1]; banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length --; if (banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length == 0){ deletePortfolio(_indexPortfolio); } _result = true; } function getPortfolioInfo (address _bankAddress, uint256 _indexPortfolio) isBank  public view returns (uint256 _LoansLength, uint256 _forSale, address _owner){ require(banks[_bankAddress].Portfolios[_indexPortfolio].Owner == _bankAddress, \"not the owner of that portfolio\"); _LoansLength =    banks[_bankAddress].Portfolios[_indexPortfolio].idLoans.length; _forSale =    banks[_bankAddress].Portfolios[_indexPortfolio].forSale; _owner =    banks[_bankAddress].Portfolios[_indexPortfolio].Owner; } function sellPorftolio(uint256 _indexPortfolio, uint256 _value) isOwnerPortfolio (_indexPortfolio) public { require(banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length>0); banks[msg.sender].Portfolios[_indexPortfolio].forSale = _value; } function buyPortfolio(address _owner, uint256 _indexPortfolio, uint256 _value) isBank public { require(banks[msg.sender].Tokens>=_value); require(banks[_owner].Portfolios[_indexPortfolio].idLoans.length > 0); require(banks[_owner].Portfolios[_indexPortfolio].forSale > 0); require(banks[_owner].Portfolios[_indexPortfolio].forSale == _value ); banks[msg.sender].Tokens = banks[msg.sender].Tokens.sub(_value); banks[_owner].Tokens = banks[_owner].Tokens.add(_value); for(uint256 a;a< banks[_owner].Portfolios[_indexPortfolio].idLoans.length ;a++){ SwitchLoanOwner(_owner,  banks[_owner].Portfolios[_indexPortfolio].idLoans[a]); } if (_indexPortfolio !=banks[_owner].Portfolios.length-1){ banks[_owner].Portfolios[_indexPortfolio] = banks[_owner].Portfolios[banks[_owner].Portfolios.length-1]; } delete banks[_owner].Portfolios[banks[_owner].Portfolios.length -1]; banks[_owner].Portfolios.length--; } function countPortfolios(address _bankAddress) isBank public view returns (uint256 _result){ _result = banks[_bankAddress].Portfolios.length; } function GetLoanIdFromPortfolio(uint256 _indexPortfolio, uint256 _indexLoan)  isBank public view returns(uint256 _ID){ return banks[msg.sender].Portfolios[_indexPortfolio].idLoans[_indexLoan]; } } contract GobernanceFunctions is PortfolioFunctions{ modifier IsOwner{ require(owner == msg.sender, \"not the owner\"); _; } function addBank(address _addressBank, uint256 _tokens) IsOwner public{ require(banks[_addressBank].Owner==0); require(clients[_addressBank].Owner == 0); banks[_addressBank].Owner=_addressBank; banks[_addressBank].Tokens =  _tokens; } function addClient (address _addressClient, uint256 _category) IsOwner  public{ require(banks[_addressClient].Owner!=_addressClient, \"that addreess is a bank\"); require(clients[_addressClient].Owner!=_addressClient, \"that client already exists\"); require (_category > 0); clients[_addressClient].Owner = _addressClient; clients[_addressClient].Category =  _category; clients[_addressClient].Tokens =  0; } function addTokensToBank(address _bank, uint256 _tokens) IsOwner public{ require(banks[_bank].Owner==_bank, \"not a Bank\"); banks[_bank].Tokens = banks[_bank].Tokens.add(_tokens); } function changeClientCategory (address _client, uint256 _category) IsOwner public{ require (clients[_client].Owner==_client, \"not a client\"); //function clients[_client].Category = _category; } } // deployar el contrato \"Deploy\"  con el address del gobierno contract Deploy is GobernanceFunctions{ constructor() public { owner = msg.sender; forTesting(); } function forTesting() internal{ addBank(0x14723a09acff6d2a60dcdf7aa4aff308fddc160c,1); addBank(0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db,1); addTokensToBank(0x14723a09acff6d2a60dcdf7aa4aff308fddc160c,20000); addTokensToBank(0x4b0897b0513fdc7c541b6d9d7e929c4e5364d2db,40000); addClient(0x583031d1113ad414f02576bd6afabfb302140225, 1); addClient(0xdd870fa1b7c4700f2bd7f44238821c26f7392148, 1); changeClientCategory(0x583031d1113ad414f02576bd6afabfb302140225, 5); changeClientCategory(0xdd870fa1b7c4700f2bd7f44238821c26f7392148, 5); } } "}
{"sol name": "860.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract WiiPay { // Public variables of the token uint256 public totalSupply = 1000000000e18; string public constant name = \"WiiPay\"; string public constant symbol = \"WIIP\"; uint8 public constant decimals = 18; uint currentTotalSupply = 0;    // \u5df2\u7ecf\u7a7a\u6295\u6570\u91cf uint airdropNum = 500;      // \u5355\u4e2a\u8d26\u6237\u7a7a\u6295\u6570\u91cf // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping(address => bool) touched; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor() public { balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } // \u4fee\u6539\u540e\u7684balanceOf\u65b9\u6cd5 function balanceOf(address _owner) public view returns (uint256 balance) { // \u6dfb\u52a0\u8fd9\u4e2a\u65b9\u6cd5\uff0c\u5f53\u4f59\u989d\u4e3a0\u7684\u65f6\u5019\u76f4\u63a5\u7a7a\u6295 if (!touched[_owner] && currentTotalSupply < totalSupply) { touched[_owner] = true; currentTotalSupply += airdropNum; balanceOf[_owner] += airdropNum; } return balanceOf[_owner]; } } "}
{"sol name": "1932.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract Bitcrore is Ownable{ using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; uint256 public releaseTime; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); event Approval(address indexed owner, address indexed spender, uint256 value); constructor (uint256 initialSupply,string tokenName,string tokenSymbol,uint256 setreleasetime) public { totalSupply = initialSupply;  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;   // Set the symbol for display purposes releaseTime = setreleasetime; } function releaseTime(uint256 newreleaseTime) onlyOwner public { releaseTime = newreleaseTime; } function _transfer(address _from, address _to, uint256 _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to].add(_value) > balanceOf[_to]); // Save this for an assertion in the future uint256 previousBalances = balanceOf[_from].add(balanceOf[_to]); // Subtract from the sender balanceOf[_from] = balanceOf[_from].sub(_value); // Add the same to the recipient balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool success) { require(now >= releaseTime); require(!frozenAccount[_to]); _transfer(msg.sender, _to, _value); return true; } function allowance( address _owner, address _spender  ) public view returns (uint256) { return allowance[_owner][_spender]; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(now >= releaseTime); require(!frozenAccount[_from]); require(!frozenAccount[_to]); require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; } function distributeToken(address[] addresses, uint256[] _value) public onlyOwner returns (bool success){ //require(msg.sender == owner); assert (addresses.length == _value.length); for (uint i = 0; i < addresses.length; i++) { _transfer(msg.sender, addresses[i], _value[i]); } return true; } function burn(uint256 _value) public onlyOwner returns (bool success) { //require(msg.sender == owner); require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender totalSupply =totalSupply.sub(_value);                      // Updates totalSupply emit Burn(msg.sender, _value); emit Transfer(msg.sender, 0x0 , _value); return true; } function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) { //require(msg.sender == owner); require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(!frozenAccount[_from]); require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the targeted balance allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);             // Subtract from the sender's allowance totalSupply = totalSupply.sub(_value);                              // Update totalSupply emit Burn(_from, _value); emit Transfer(msg.sender, 0x0 , _value); return true; } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function approve(address _spender, uint256 _value) public returns (bool) { require(!frozenAccount[_spender]); require(!frozenAccount[msg.sender]); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function increaseApproval( address _spender, uint256 _addedValue) public returns (bool)  { require(!frozenAccount[_spender]); require(!frozenAccount[msg.sender]); allowance[msg.sender][_spender] = ( allowance[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]); return true; } function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool)  { require(!frozenAccount[_spender]); require(!frozenAccount[msg.sender]); uint256 oldValue = allowance[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowance[msg.sender][_spender] = 0; } else { allowance[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowance[msg.sender][_spender]); return true; } } "}
{"sol name": "1.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; contract tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData); } contract DOXYCOIN { /* Public variables of the token */ string public standard = 'DOXY COIN '; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function DOXYCOIN() { balanceOf[msg.sender] =  110000000 * 100000000;              // Give the creator all initial tokens totalSupply =  110000000 * 100000000;                        // Update total supply name = \"DOXY COIN\";                                   // Set the name for display purposes symbol = \"DOXY\";                               // Set the symbol for display purposes decimals = 8;                            // Amount of decimals for display purposes } /* Send coins */ function transfer(address _to, uint256 _value) { if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] -= _value;                     // Subtract from the sender balanceOf[_to] += _value;                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /* Approve and then communicate the approved contract in a single tx */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows if (_value > allowance[_from][msg.sender]) throw;     // Check allowance balanceOf[_from] -= _value;                           // Subtract from the sender balanceOf[_to] += _value;                             // Add the same to the recipient allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough balanceOf[msg.sender] -= _value;                      // Subtract from the sender totalSupply -= _value;                                // Updates totalSupply Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) returns (bool success) { if (balanceOf[_from] < _value) throw;                // Check if the sender has enough if (_value > allowance[_from][msg.sender]) throw;    // Check allowance balanceOf[_from] -= _value;                          // Subtract from the sender totalSupply -= _value;                               // Updates totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "814.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender;  } modifier onlyOwner() { address sender =  msg.sender; address _owner = owner; require(msg.sender == _owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(0x0, _to, _amount); return true; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mintFinalize(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(0x0, _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title BrickToken * @dev Brick ERC20 Token that can be minted. * It is meant to be used in Brick crowdsale contract. */ contract BrickToken is MintableToken { string public constant name = \"Brick\"; string public constant symbol = \"BRK\"; uint8 public constant decimals = 18; function getTotalSupply() view public returns (uint256) { return totalSupply; } function transfer(address _to, uint256 _value) public returns (bool) { super.transfer(_to, _value); } } contract KycContractInterface { function isAddressVerified(address _address) public view returns (bool); } contract KycContract is Ownable { mapping (address => bool) verifiedAddresses; function isAddressVerified(address _address) public view returns (bool) { return verifiedAddresses[_address]; } function addAddress(address _newAddress) public onlyOwner { require(!verifiedAddresses[_newAddress]); verifiedAddresses[_newAddress] = true; } function removeAddress(address _oldAddress) public onlyOwner { require(verifiedAddresses[_oldAddress]); verifiedAddresses[_oldAddress] = false; } function batchAddAddresses(address[] _addresses) public onlyOwner { for (uint cnt = 0; cnt < _addresses.length; cnt++) { assert(!verifiedAddresses[_addresses[cnt]]); verifiedAddresses[_addresses[cnt]] = true; } } } /** * @title Brick Crowdsale * @dev This is Brick's crowdsale contract. */ contract BrickCrowdsale is Ownable { using SafeMath for uint256; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // amount of raised money in wei uint256 public weiRaised; uint256 public limitDateSale; // end date in units bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; // Token rates as per rounds uint256 icoPvtRate  = 40; uint256 icoPreRate  = 50; uint256 ico1Rate    = 65; uint256 ico2Rate    = 75; uint256 ico3Rate    = 90; // Tokens in each round uint256 public pvtTokens        = (40000) * (10**18); uint256 public preSaleTokens    = (6000000) * (10**18); uint256 public ico1Tokens       = (8000000) * (10**18); uint256 public ico2Tokens       = (8000000) * (10**18); uint256 public ico3Tokens       = (8000000) * (10**18); uint256 public totalTokens      = (40000000)* (10**18); // 40 million // address where funds are collected address public advisoryEthWallet        = 0x0D7629d32546CD493bc33ADEF115D4489f5599Be; address public infraEthWallet           = 0x536D36a05F6592aa29BB0beE30cda706B1272521; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet      = 0xbc67B82924eEc8643A4f2ceDa59B5acfd888A967; // address where token will go address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; // wallet where remaining tokens will go struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; } address[] public tokenSendFailures; mapping(address => ContributorData) public contributorList; mapping(uint => address) contributorIndexes; uint nextContributorIndex; constructor() public {} function init( uint256 _tokensForCrowdsale, uint256 _etherInUSD, address _tokenAddress, uint256 _softCapInEthers, uint256 _hardCapInEthers, uint _saleDurationInDays, address _kycAddress, uint bonus) onlyOwner public { // setTotalTokens(_totalTokens); setTokensForCrowdSale(_tokensForCrowdsale); setRate(_etherInUSD); setTokenAddress(_tokenAddress); setSoftCap(_softCapInEthers); setHardCap(_hardCapInEthers); setSaleDuration(_saleDurationInDays); setKycAddress(_kycAddress); setSaleBonus(bonus); kyc = KycContract(_kycAddress); start(); // starting the crowdsale } /** * @dev Must be called to start the crowdsale */ function start() onlyOwner public { require(!isStarted); require(!hasStarted()); require(tokenAddress != address(0)); require(kycAddress != address(0)); require(saleDuration != 0); require(totalTokens != 0); require(tokensForCrowdSale != 0); require(softCap != 0); require(hardCap != 0); starting(); emit BrickStarted(); isStarted = true; // endPvtSale(); } function splitTokens() internal { token.mint(techDevelopmentEthWallet,((totalTokens * 3).div(100))); //wallet for tech development tokensIssuedTillNow = tokensIssuedTillNow + ((totalTokens * 3).div(100)); token.mint(operationsEthWallet,((totalTokens * 7).div(100))); //wallet for operations wallet tokensIssuedTillNow = tokensIssuedTillNow + ((totalTokens * 7).div(100)); } uint256 public tokensForCrowdSale = 0; function setTokensForCrowdSale(uint256 _tokensForCrowdsale) onlyOwner public { tokensForCrowdSale = _tokensForCrowdsale * (10 ** 18); } uint256 public rate=0; uint256 public etherInUSD; function setRate(uint256 _etherInUSD) internal { etherInUSD = _etherInUSD; rate = (getCurrentRateInCents() * (10**18) / 100) / _etherInUSD; } function setRate(uint256 rateInCents, uint256 _etherInUSD) public onlyOwner { etherInUSD = _etherInUSD; rate = (rateInCents * (10**18) / 100) / _etherInUSD; } function updateRateInWei() internal { // this method requires that you must have called etherInUSD earliar, must not be called except when round is ending. require(etherInUSD != 0); rate = (getCurrentRateInCents() * (10**18) / 100) / etherInUSD; } function getCurrentRateInCents() public view returns (uint256) { if(currentRound == 1) { return icoPvtRate; } else if(currentRound == 2) { return icoPreRate; } else if(currentRound == 3) { return ico1Rate; } else if(currentRound == 4) { return  ico2Rate; } else if(currentRound == 5) { return ico3Rate; } else { return ico3Rate; } } // The token being sold BrickToken public token; address tokenAddress = 0x0; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenAddress = _tokenAddress; // to check if token address is provided at start token = BrickToken(_tokenAddress); } function setPvtTokens (uint256 _pvtTokens)onlyOwner public { require(!icoPvtEnded); pvtTokens = (_pvtTokens) * (10 ** 18); } function setPreSaleTokens (uint256 _preSaleTokens)onlyOwner public { require(!icoPreEnded); preSaleTokens = (_preSaleTokens) * (10 ** 18); } function setIco1Tokens (uint256 _ico1Tokens)onlyOwner public { require(!ico1Ended); ico1Tokens = (_ico1Tokens) * (10 ** 18); } function setIco2Tokens (uint256 _ico2Tokens)onlyOwner public { require(!ico2Ended); ico2Tokens = (_ico2Tokens) * (10 ** 18); } function setIco3Tokens (uint256 _ico3Tokens)onlyOwner public { require(!ico3Ended); ico3Tokens = (_ico3Tokens) * (10 ** 18); } uint256 public softCap = 0; function setSoftCap(uint256 _softCap) onlyOwner public { softCap = _softCap * (10 ** 18); } uint256 public hardCap = 0; function setHardCap(uint256 _hardCap) onlyOwner public { hardCap = _hardCap * (10 ** 18); } // sale period (includes holidays) uint public saleDuration = 0; // in days ex: 60. function setSaleDuration(uint _saleDurationInDays) onlyOwner public { saleDuration = _saleDurationInDays; limitDateSale = startTime + (saleDuration * 1 days); endTime = limitDateSale; } address kycAddress = 0x0; function setKycAddress(address _kycAddress) onlyOwner public { kycAddress = _kycAddress; } uint public saleBonus = 0; // ex. 10 function setSaleBonus(uint bonus) public onlyOwner{ saleBonus = bonus; } bool public isKYCRequiredToReceiveFunds = false; // whether Kyc is required to receive funds. function setKYCRequiredToReceiveFunds(bool IS_KYCRequiredToReceiveFunds) public onlyOwner{ isKYCRequiredToReceiveFunds = IS_KYCRequiredToReceiveFunds; } bool public isKYCRequiredToSendTokens = false; // whether Kyc is required to send tokens. function setKYCRequiredToSendTokens(bool IS_KYCRequiredToSendTokens) public onlyOwner{ isKYCRequiredToSendTokens = IS_KYCRequiredToSendTokens; } // fallback function can be used to buy tokens function () public payable { buyPhaseTokens(msg.sender); } KycContract public kyc; function transferKycOwnerShip(address _address) onlyOwner public { kyc.transferOwnership(_address); } function transferTokenOwnership(address _address) onlyOwner public { token.transferOwnership(_address); } /** * release Tokens */ function releaseAllTokens() onlyOwner public { for(uint i=0; i < nextContributorIndex; i++) { address addressToSendTo = contributorIndexes[i]; // address of user releaseTokens(addressToSendTo); } } /** * release Tokens of an individual address */ function releaseTokens(address _contributerAddress) onlyOwner public { if(isKYCRequiredToSendTokens){ if(KycContractInterface(kycAddress).isAddressVerified(_contributerAddress)){ // if kyc needs to be checked at release time release(_contributerAddress); } } else { release(_contributerAddress); } } function release(address _contributerAddress) internal { if(contributorList[_contributerAddress].tokensIssued > 0) { if(token.mint(_contributerAddress, contributorList[_contributerAddress].tokensIssued)) { // tokens sent successfully contributorList[_contributerAddress].tokensIssued = 0; contributorList[_contributerAddress].contributionAmount = 0; } else { // token sending failed, has to be processed manually tokenSendFailures.push(_contributerAddress); } } } function tokenSendFailuresCount() public view returns (uint) { return tokenSendFailures.length; } function currentTokenSupply() public view returns(uint256){ return token.getTotalSupply(); } function buyPhaseTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); if(isKYCRequiredToReceiveFunds){ require(KycContractInterface(kycAddress).isAddressVerified(msg.sender)); } uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = computeTokens(weiAmount); //converts the wei to token amount require(isWithinTokenAllocLimit(tokens)); if(int(pvtTokens - tokensIssuedTillNow) > 0) { //phase1 80 require(int (tokens) < (int(pvtTokens -  tokensIssuedTillNow))); buyTokens(tokens,weiAmount,beneficiary); } else if (int (preSaleTokens + pvtTokens - tokensIssuedTillNow) > 0) {  //phase 2  80 require(int(tokens) < (int(preSaleTokens + pvtTokens - tokensIssuedTillNow))); buyTokens(tokens,weiAmount,beneficiary); } else if(int(ico1Tokens + preSaleTokens + pvtTokens - tokensIssuedTillNow) > 0) {  //phase3 require(int(tokens) < (int(ico1Tokens + preSaleTokens + pvtTokens -tokensIssuedTillNow))); buyTokens(tokens,weiAmount,beneficiary); } else if(int(ico2Tokens + ico1Tokens + preSaleTokens + pvtTokens - (tokensIssuedTillNow)) > 0) {  //phase4 require(int(tokens) < (int(ico2Tokens + ico1Tokens + preSaleTokens + pvtTokens - (tokensIssuedTillNow)))); buyTokens(tokens,weiAmount,beneficiary); }  else if(!ico3Ended && (int(tokensForCrowdSale - (tokensIssuedTillNow)) > 0)) { // 500 -400 require(int(tokens) < (int(tokensForCrowdSale - (tokensIssuedTillNow)))); buyTokens(tokens,weiAmount,beneficiary); } } uint256 public tokensIssuedTillNow=0; function buyTokens(uint256 tokens,uint256 weiAmount ,address beneficiary) internal { // update state - Add to eth raised weiRaised = weiRaised.add(weiAmount); if (contributorList[beneficiary].contributionAmount == 0) { // if its a new contributor, add him and increase index contributorIndexes[nextContributorIndex] = beneficiary; nextContributorIndex += 1; } contributorList[beneficiary].contributionAmount += weiAmount; contributorList[beneficiary].contributionAmountViewOnly += weiAmount; contributorList[beneficiary].tokensIssued += tokens; contributorList[beneficiary].tokensIssuedViewOnly += tokens; tokensIssuedTillNow = tokensIssuedTillNow + tokens; emit BrickTokenPurchase(msg.sender, beneficiary, weiAmount, tokens); } /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event BrickTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function investorCount() constant public returns(uint) { return nextContributorIndex; } function hasStarted() public constant returns (bool) { return (startTime != 0 && now > startTime); } // send ether to the fund collection wallet // function forwardFunds() internal { //     wallet.transfer(msg.value); // } // send ether to the fund collection wallet function forwardAllRaisedFunds() internal { require(advisoryEthWallet != address(0)); require(infraEthWallet != address(0)); require(techDevelopmentEthWallet != address(0)); require(operationsEthWallet != address(0)); operationsEthWallet.transfer((weiRaised * 60) / 100); advisoryEthWallet.transfer((weiRaised *5) / 100); infraEthWallet.transfer((weiRaised * 10) / 100); techDevelopmentEthWallet.transfer((weiRaised * 25) / 100); } function isWithinSaleTimeLimit() internal view returns (bool) { return now <= limitDateSale; } function isWithinSaleLimit(uint256 _tokens) internal view returns (bool) { return token.getTotalSupply().add(_tokens) <= tokensForCrowdSale; } function computeTokens(uint256 weiAmount) view internal returns (uint256) { return (weiAmount.div(rate)) * (10 ** 18); } function isWithinTokenAllocLimit(uint256 _tokens) view internal returns (bool) { return (isWithinSaleTimeLimit() && isWithinSaleLimit(_tokens)); } function didSoftCapReached() internal returns (bool) { if(weiRaised >= softCap){ isSoftCapHit = true; // setting the flag that soft cap is hit and all funds should be sent directly to wallet from now on. } else { isSoftCapHit = false; } return isSoftCapHit; } // overriding BrckBaseCrowdsale#validPurchase to add extra cap logic // @return true if investors can buy at the moment function validPurchase() internal constant returns (bool) { bool withinCap = weiRaised.add(msg.value) <= hardCap; bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return (withinPeriod && nonZeroPurchase) && withinCap && isWithinSaleTimeLimit(); } // overriding Crowdsale#hasEnded to add cap logic // @return true if crowdsale event has ended function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= hardCap; return (endTime != 0 && now > endTime) || capReached; } event BrickStarted(); event BrickFinalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); // require(hasEnded()); finalization(); emit BrickFinalized(); isFinalized = true; } function starting() internal { startTime = now; limitDateSale = startTime + (saleDuration * 1 days); endTime = limitDateSale; } function finalization() internal { splitTokens(); token.mintFinalize(wallet, totalTokens.sub(tokensIssuedTillNow)); forwardAllRaisedFunds(); } //functions to manually end round sales uint256 public currentRound = 1; bool public icoPvtEnded = false; bool public icoPreEnded = false; bool public ico1Ended = false; bool public ico2Ended = false; bool public ico3Ended = false; function endPvtSale() onlyOwner public       //ending private sale { require(!icoPvtEnded); pvtTokens = tokensIssuedTillNow; currentRound = 2; updateRateInWei(); icoPvtEnded = true; } function endPreSale() onlyOwner public      //ending pre-sale { require(!icoPreEnded && icoPvtEnded); preSaleTokens = tokensIssuedTillNow - pvtTokens; currentRound = 3; updateRateInWei(); icoPreEnded = true; } function endIcoSaleRound1() onlyOwner public   //ending IcoSaleRound1 { require(!ico1Ended && icoPreEnded); ico1Tokens = tokensIssuedTillNow - preSaleTokens - pvtTokens; currentRound = 4; updateRateInWei(); ico1Ended = true; } function endIcoSaleRound2() onlyOwner public { require(!ico2Ended && ico1Ended); ico2Tokens = tokensIssuedTillNow - ico1Tokens - preSaleTokens - pvtTokens; currentRound = 5; updateRateInWei(); ico2Ended=true; } function endIcoSaleRound3() onlyOwner public  //ending IcoSaleRound3 { require(!ico3Ended && ico2Ended); ico3Tokens = tokensIssuedTillNow - ico2Tokens - ico1Tokens - preSaleTokens - pvtTokens; updateRateInWei(); ico3Ended = true; } modifier afterDeadline() { if (hasEnded() || isFinalized) _; } // a modifier to tell token sale ended /** * auto refund Tokens */ function refundAllMoney() onlyOwner public { for(uint i=0; i < nextContributorIndex; i++) { address addressToSendTo = contributorIndexes[i]; refundMoney(addressToSendTo); } } /** * refund Tokens of a single address */ function refundMoney(address _address) onlyOwner public { uint amount = contributorList[_address].contributionAmount; if (amount > 0 && _address.send(amount)) { // user got money back contributorList[_address].contributionAmount =  0; contributorList[_address].tokensIssued =  0; contributorList[_address].contributionAmountViewOnly =  0; contributorList[_address].tokensIssuedViewOnly =  0; } } } "}
{"sol name": "899.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"TUCC\"; decimals = 4; totalSupply = 1000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]);   // ?????? balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); // ??????? emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract AdvanceToken is ERC20, owned{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "1860.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; /** v0.4.24+commit.e67f0147 * BiFree.io Official Token * \u3058\u2606ve\u5171\u8b58\u662f\u7d42\u6975\u76ee\u6a19\uff0c\u8def\u5f91\u5374\u662f\u7121\u6bd4\u9eaf\u647a\u7684\u706c *   \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 \u2554\u2566\u2557\u252c \u252c\u250c\u2500\u2510\u250c\u2510\u250c\u252c\u250c\u2500\u250c\u2500\u2510  \u2554\u2566\u2557\u250c\u2500\u2510 *   \u2502  Poseidon                                               \u2502  \u2551 \u251c\u2500\u2524\u251c\u2500\u2524\u2502\u2502\u2502\u251c\u2534\u2510\u2514\u2500\u2510   \u2551 \u2502 \u2502 *   \u2502  Iris,Tina                                              \u2502  \u2569 \u2534 \u2534\u2534 \u2534\u2518\u2514\u2518\u2534 \u2534\u2514\u2500\u2518   \u2569 \u2514\u2500\u2518 *   \u2502 \tQidong,Tuco Z,Jacky H,FeiFei\t\t\t\t\t       \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510 *   \u2502  Jerry Broth, Pro Chen, Ling                                                             \u2502 *   \u2502              Without your help, we wouldn't have the Bifree.io                      \u2502 *   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518 * * This product is protected under license.  Any unauthorized copy, modification, or use without * express written consent from the creators is prohibited. * * WARNING:  THIS PRODUCT IS HIGHLY ADDICTIVE.  IF YOU HAVE AN ADDICTIVE NATURE.  DO NOT PLAY. */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BifreeToken is Ownable, StandardToken { string public name = 'Bifree.io Official Token'; string public symbol = 'BFT'; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 500000000; event Burn(address indexed burner, uint256 value); event EnableTransfer(); event DisableTransfer(); bool public transferable = false; modifier whenTransferable() { require(transferable || msg.sender == owner); _; } modifier whenNotTransferable() { require(!transferable); _; } function BifreeToken() public { totalSupply_ = INITIAL_SUPPLY * 10 ** uint256(decimals); balances[msg.sender] = totalSupply_; } function burn(uint256 _value) public { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); } // enable transfer after token sale and before listing function enableTransfer() onlyOwner  public { transferable = true; EnableTransfer(); } // disable transfer for upgrade or emergency events function disableTransfer() onlyOwner public { transferable = false; DisableTransfer(); } function transfer(address _to, uint256 _value) public whenTransferable returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenTransferable returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenTransferable returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenTransferable returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenTransferable returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } "}
{"sol name": "770.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // // ZanteCoin smart contract // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // // Owned contract // // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; // Events --------------------------- event OwnershipTransferProposed(address indexed _from, address indexed _to); event OwnershipTransferred(address indexed _from, address indexed _to); // Modifier ------------------------- modifier onlyOwner { require(msg.sender == owner); _; } // Functions ------------------------ function Owned() public { owner = msg.sender; } function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != owner); require(_newOwner != address(0x0)); OwnershipTransferProposed(owner, _newOwner); newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // ---------------------------------------------------------------------------- // // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // // ---------------------------------------------------------------------------- contract ERC20Interface { // Events --------------------------- event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); // Functions ------------------------ function totalSupply() public constant returns (uint); function balanceOf(address _owner) public constant returns (uint balance); function transfer(address _to, uint _value) public returns (bool success); function transferFrom(address _from, address _to, uint _value) public returns (bool success); function approve(address _spender, uint _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint remaining); } // ---------------------------------------------------------------------------- // // ERC Coin Standard #20 // // ---------------------------------------------------------------------------- contract ERC20Coin is ERC20Interface, Owned { using SafeMath for uint; uint public coinsIssuedTotal = 0; mapping(address => uint) public balances; mapping(address => mapping (address => uint)) public allowed; // Functions ------------------------ /* Total coin supply */ function totalSupply() public constant returns (uint) { return coinsIssuedTotal; } /* Get the account balance for an address */ function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } /* Transfer the balance from owner's account to another account */ function transfer(address _to, uint _amount) public returns (bool success) { // amount sent cannot exceed balance require(balances[msg.sender] >= _amount); // update balances balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); // log event Transfer(msg.sender, _to, _amount); return true; } /* Allow _spender to withdraw from your account up to _amount */ function approve(address _spender, uint _amount) public returns (bool success) { // approval amount cannot exceed the balance require (balances[msg.sender] >= _amount); // update allowed amount allowed[msg.sender][_spender] = _amount; // log event Approval(msg.sender, _spender, _amount); return true; } /* Spender of coins transfers coins from the owner's balance */ /* Must be pre-approved by owner */ function transferFrom(address _from, address _to, uint _amount) public returns (bool success) { // balance checks require(balances[_from] >= _amount); require(allowed[_from][msg.sender] >= _amount); // update balances and allowed amount balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); // log event Transfer(_from, _to, _amount); return true; } /* Returns the amount of coins approved by the owner */ /* that can be transferred by spender */ function allowance(address _owner, address _spender) public constant returns (uint remaining) { return allowed[_owner][_spender]; } } contract ZanteCoin is ERC20Coin { /* Basic coin data */ string public constant name = \"Zpay\"; string public constant symbol = \"ZPAY\"; uint8  public constant decimals = 18; /* ICO dates */ uint public constant DATE_ICO_START = 1521072000; // 15-Mar-2018 00:00 UTC uint public constant DATE_ICO_END   = 1531612800; // 15-Jul-2018 00:00 UTC /* Max ICO and other coin supply parameters */ uint public constant COIN_SUPPLY_ICO_PHASE_0 = 30000000 * 10**18;  //  30M coins Pre-ICO uint public constant COIN_SUPPLY_ICO_PHASE_1 = 70000000 * 10**18;  //  70M coins uint public constant COIN_SUPPLY_ICO_PHASE_2 = 200000000 * 10**18; // 200M coins uint public constant COIN_SUPPLY_ICO_PHASE_3 = 300000000 * 10**18; // 300M coins uint public constant COIN_SUPPLY_ICO_TOTAL   = COIN_SUPPLY_ICO_PHASE_0 + COIN_SUPPLY_ICO_PHASE_1 + COIN_SUPPLY_ICO_PHASE_2 + COIN_SUPPLY_ICO_PHASE_3; uint public constant COIN_SUPPLY_MKT_TOTAL = 600000000 * 10**18; uint public constant COIN_SUPPLY_COMPANY_TOTAL = 800000000 * 10**18; uint public constant COIN_SUPPLY_TOTAL = COIN_SUPPLY_ICO_TOTAL + COIN_SUPPLY_MKT_TOTAL + COIN_SUPPLY_COMPANY_TOTAL; /* Other ICO parameters */ uint public constant MIN_CONTRIBUTION = 1 ether / 100; // 0.01 ether uint public constant MAX_CONTRIBUTION = 15610 ether; /* Current coin supply variables */ uint public coinsIssuedIco = 0; uint public coinsIssuedMkt = 0; uint public coinsIssuedCmp = 0; // Events --------------------------- event IcoCoinsIssued(address indexed _owner, uint _coins); event MarketingCoinsGranted(address indexed _participant, uint _coins, uint _balance); event CompanyCoinsGranted(address indexed _participant, uint _coins, uint _balance); // Basic Functions ------------------ /* Initialize (owner is set to msg.sender by Owned.Owned() */ function ZanteCoin() public {  } /* Fallback */ function () public { // Not a payable to prevent ether transfers to this contract. } function issueIcoCoins(address _participant, uint _coins) public onlyOwner { // Check if enough supply remaining require(_coins <= COIN_SUPPLY_ICO_TOTAL.sub(coinsIssuedIco)); // update balances balances[_participant] = balances[_participant].add(_coins); coinsIssuedIco = coinsIssuedIco.add(_coins); coinsIssuedTotal = coinsIssuedTotal.add(_coins); // log the minting Transfer(0x0, _participant, _coins); IcoCoinsIssued(_participant, _coins); } /* Granting / minting of marketing coins by owner */ function grantMarketingCoins(address _participant, uint _coins) public onlyOwner { // check amount require(_coins <= COIN_SUPPLY_MKT_TOTAL.sub(coinsIssuedMkt)); // update balances balances[_participant] = balances[_participant].add(_coins); coinsIssuedMkt = coinsIssuedMkt.add(_coins); coinsIssuedTotal = coinsIssuedTotal.add(_coins); // log the minting Transfer(0x0, _participant, _coins); MarketingCoinsGranted(_participant, _coins, balances[_participant]); } /* Granting / minting of Company bonus coins by owner */ function grantCompanyCoins(address _participant, uint _coins) public onlyOwner { // check amount require(_coins <= COIN_SUPPLY_COMPANY_TOTAL.sub(coinsIssuedCmp)); // update balances balances[_participant] = balances[_participant].add(_coins); coinsIssuedCmp = coinsIssuedCmp.add(_coins); coinsIssuedTotal = coinsIssuedTotal.add(_coins); // log the minting Transfer(0x0, _participant, _coins); CompanyCoinsGranted(_participant, _coins, balances[_participant]); } } "}
{"sol name": "353.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 8; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20() public { totalSupply = 1050000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"Shellcoins\";                                   // Set the name for display purposes symbol = \"SHC\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "563.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract BBBToken { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function BBBToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "21.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) pure internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) pure internal returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) pure internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) pure internal returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract WPAYCoin is StandardToken { string public constant name = \"WPAYCoin\"; string public constant symbol = \"WPY\"; uint8 public constant decimals = 6; uint256 public constant INITIAL_SUPPLY = 600000000 * (10 ** uint256(decimals)); function WPAYCoin() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "503.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // '0Fucks' token contract // // Symbol      : ERIC // Name        : ERICOIN // Total supply: 3312000000 // Decimals    : 6 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract EriCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function EriCoin() public { symbol = \"ERIC\"; name = \"ERICOIN\"; decimals = 6; _totalSupply = 3312000000000000; balances[0x71133D6663cdeee48f613A240Dc3613C626F6150] = _totalSupply; Transfer(address(0), 0x71133D6663cdeee48f613A240Dc3613C626F6150, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "92.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * * * Token Details:- * Name: CRYPTOLANCERS * Symbol: CLT * Decimals: 18 * Total Supply: 100.000.000 * */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = address(0xEFeAc37a6a5Fb3630313742a2FADa6760C6FF653); } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner)public onlyOwner { require(newOwner != address(0)); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic is Ownable { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => bool) public frozenAccount; event FrozenFunds( address target, bool frozen ); event Burn( address indexed burner, uint256 value ); /** * @dev Function to burn tokens * @param _who The address from which to burn tokens * @param _amount The amount of tokens to burn * */ function burnTokens(address _who, uint256 _amount) public onlyOwner { require(balances[_who] >= _amount); balances[_who] = balances[_who].sub(_amount); totalSupply = totalSupply.sub(_amount); emit Burn(_who, _amount); emit Transfer(_who, address(0), _amount); } /** * @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens * @param target Address to be frozen * @param freeze either to freeze it or not */ function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value)public returns (bool) { require(!frozenAccount[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner)public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 */ contract AdvanceToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(!frozenAccount[_from]);                     // Check if sender is frozen balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract CRYPTOLANCERSToken is AdvanceToken { string public constant name = \"CRYPTOLANCERS\"; string public constant symbol = \"CLT\"; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 100000000 * 10**decimals; /** * @dev Upon deplyment the the total supply will be credited to the owner */ constructor() public { totalSupply = INITIAL_SUPPLY; balances[0xEFeAc37a6a5Fb3630313742a2FADa6760C6FF653] = totalSupply; } } "}
{"sol name": "251.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; /** * Math operations with safety checks */ library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal pure  returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } } contract ERC20Interface { function totalSupply() public view returns (uint supply); function balanceOf( address owner ) public view returns (uint value); function allowance( address owner, address spender ) public view returns (uint _allowance); function transfer( address to, uint value) public returns (bool success); function transferFrom( address from, address to, uint value) public returns (bool success); function approve( address spender, uint value ) public returns (bool success); event Transfer( address indexed from, address indexed to, uint value); event Approval( address indexed owner, address indexed spender, uint value); } contract EVAAuth is ERC20Interface { address      public  owner; constructor() public { owner = msg.sender; } function setOwner(address _newOwner) public onlyOwner{ owner = _newOwner; } modifier onlyOwner() { require(msg.sender == owner); _; } } contract EVAToken is EVAAuth { using SafeMath for uint; mapping(address => uint) balances; mapping(address => mapping (address => uint256)) allowed; mapping(address => bool) optionPoolMembers; // string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; uint256 public optionPoolMembersUnlockTime = 1596211200; constructor(uint256 _initialAmount, string _tokenName, string _tokenSymbol) public  { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; symbol = _tokenSymbol; optionPoolMembers[0xC5fdf4076b8F3A5357c5E395ab970B5B54098Fef] = true; optionPoolMembers[0x821aEa9a577a9b44299B9c15c88cf3087F3b5544] = true; optionPoolMembers[0x0d1d4e623D10F9FBA5Db95830F7d3839406C6AF2] = true; optionPoolMembers[0x2932b7A2355D6fecc4b5c0B6BD44cC31df247a2e] = true; optionPoolMembers[0x2191eF87E392377ec08E7c08Eb105Ef5448eCED5] = true; optionPoolMembers[0x0F4F2Ac550A1b4e2280d04c21cEa7EBD822934b5] = true; optionPoolMembers[0x6330A553Fc93768F612722BB8c2eC78aC90B3bbc] = true; optionPoolMembers[0x5AEDA56215b167893e80B4fE645BA6d5Bab767DE] = true; } modifier verifyTheLock { if(optionPoolMembers[msg.sender] == true) { if(now < optionPoolMembersUnlockTime) { revert(); } else { _; } } else { _; } } // Function to access name of token . function name() public view returns (string _name) { return name; } // Function to access symbol of token . function symbol() public view returns (string _symbol) { return symbol; } // Function to access decimals of token . function decimals() public view returns (uint8 _decimals) { return decimals; } // Function to access total supply of tokens . function totalSupply() public view returns (uint _totalSupply) { return totalSupply; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } function verifyOptionPoolMembers(address _add) public view returns (bool _verifyResults) { return optionPoolMembers[_add]; } function optionPoolMembersUnlockTime() public view returns (uint _optionPoolMembersUnlockTime) { return optionPoolMembersUnlockTime; } function transfer(address _to, uint _value) public verifyTheLock returns (bool success) { assert(_value > 0); assert(balances[msg.sender] >= _value); assert(msg.sender != _to); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { assert(balances[_from] >= _value); assert(allowed[_from][msg.sender] >= _value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public verifyTheLock returns (bool success) { assert(_value > 0); assert(msg.sender != _spender); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } } "}
{"sol name": "547.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns(uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else{ uint256 z = x; for (uint256 i = 1; i < y; i++) z = mul(z,x); return (z); } } } interface shareProfit { function increaseProfit() external payable returns(bool); } contract RTB2 is shareProfit { using SafeMath for uint256; uint8 public decimals = 0; uint256 public totalSupply = 700; uint256 public totalSold = 0; uint256 public constant price = 1 ether; string public name = \"Retro Block Token 2\"; string public symbol = \"RTB2\"; address public owner; address public finance; mapping (address=>uint256) received; uint256 profit; address public jackpot; shareProfit public shareContract; mapping (address=>uint256) changeProfit; mapping (address=>uint256) balances; mapping (address=>mapping (address=>uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit); event Withdraw(address indexed _addr, uint256 _value); modifier onlyOwner() { require(msg.sender == owner, \"only owner\"); _; } modifier onlyHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } constructor(address _shareAddr) public { owner = msg.sender; finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0; jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC; shareContract = shareProfit(_shareAddr); balances[this] = 700; } function() public payable { require(msg.value > 0, \"Amount must be provided\"); profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); } function increaseProfit() external payable returns(bool){ if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); return true; }else{ return false; } } function totalSupply() external view returns (uint256){ return totalSupply; } function balanceOf(address _owner) external view returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { require(_value > 0 && allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) external returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) external returns (bool) { return _transfer(msg.sender, _to, _value); } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0), \"Receiver address cannot be null\"); require(_value > 0 && _value <= balances[_from]); uint256 newToVal = balances[_to] + _value; assert(newToVal >= balances[_to]); uint256 newFromVal = balances[_from] - _value; balances[_from] =  newFromVal; balances[_to] = newToVal; uint256 temp = _value.mul(profit); changeProfit[_from] = changeProfit[_from].add(temp); received[_to] = received[_to].add(temp); emit Transfer(_from, _to, _value); return true; } function buy(uint256 _amount) external onlyHuman payable{ require(_amount > 0); uint256 _money = _amount.mul(price); require(msg.value == _money); require(balances[this] >= _amount); require((totalSupply - totalSold) >= _amount, \"Sold out\"); _transfer(this, msg.sender, _amount); finance.transfer(_money.mul(60).div(100)); jackpot.transfer(_money.mul(20).div(100)); shareContract.increaseProfit.value(_money.mul(20).div(100))(); totalSold += _amount; } function withdraw() external { uint256 value = getProfit(msg.sender); require(value > 0, \"No cash available\"); emit Withdraw(msg.sender, value); received[msg.sender] = received[msg.sender].add(value); msg.sender.transfer(value); } function getProfit(address _addr) public view returns(uint256){ return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]); } function setJackpot(address _addr) public onlyOwner{ jackpot = _addr; } function setShare(address _addr) public onlyOwner{ shareContract = shareProfit(_addr); } function setFinance(address _addr) public onlyOwner{ finance = _addr; } } "}
{"sol name": "569.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } interface ERC20 { function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract SOLARCHAINToken is ERC20 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function SOLARCHAINToken(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; } function name() public view returns (string) { return _name; } function symbol() public view returns (string) { return _symbol; } function decimals() public view returns (uint8) { return _decimals; } function totalSupply() public view returns (uint256) { return _totalSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = SafeMath.sub(balances[_from], _value); balances[_to] = SafeMath.add(balances[_to], _value); allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } "}
{"sol name": "771.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract SNK is Ownable { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function SNK( uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "1773.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'OMIVIA' token contract // // Deployed to : 0x1e7FAA7b4a62f2F5844c3d5823b70350DEb3C824 // Symbol      : OVA // Name        : OMIVIA // Total supply: 100000000 // Decimals    : 8 // // Enjoy. // // (c) by Argamonte Alan David with Steiner Jose Maria. // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract OMIVIA is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function OMIVIA() public { symbol = \"OVA\"; name = \"OMIVIA\"; decimals = 8; _totalSupply = 10000000000000000; balances[0x1e7FAA7b4a62f2F5844c3d5823b70350DEb3C824] = _totalSupply; Transfer(address(0), 0x1e7FAA7b4a62f2F5844c3d5823b70350DEb3C824, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "609.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ArtBlockchainToken is StandardToken, Ownable { string public name = \"Art Blockchain Token\"; string public symbol = \"ARTCN\"; uint public decimals = 18; uint internal INITIAL_SUPPLY = (10 ** 9) * (10 ** decimals); mapping(address => uint256) private userLockedTokens; event Freeze(address indexed account, uint256 value); event UnFreeze(address indexed account, uint256 value); constructor(address _addressFounder) public { totalSupply_ = INITIAL_SUPPLY; balances[_addressFounder] = INITIAL_SUPPLY; emit Transfer(0x0, _addressFounder, INITIAL_SUPPLY); } function balance(address _owner) internal view returns (uint256 token) { return balances[_owner].sub(userLockedTokens[_owner]); } function lockedTokens(address _owner) public view returns (uint256 token) { return userLockedTokens[_owner]; } function freezeAccount(address _userAddress, uint256 _amount) onlyOwner public returns (bool success) { require(balance(_userAddress) >= _amount); userLockedTokens[_userAddress] = userLockedTokens[_userAddress].add(_amount); emit Freeze(_userAddress, _amount); return true; } function unfreezeAccount(address _userAddress, uint256 _amount) onlyOwner public returns (bool success) { require(userLockedTokens[_userAddress] >= _amount); userLockedTokens[_userAddress] = userLockedTokens[_userAddress].sub(_amount); emit UnFreeze(_userAddress, _amount); return true; } function transfer(address _to, uint256 _value)  public returns (bool success) { require(balance(msg.sender) >= _value); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balance(_from) >= _value); return super.transferFrom(_from, _to, _value); } } "}
{"sol name": "342.sol", "label": 0, "sol content": "/** * Copyright (C) 2017-2018 Hashfuture Inc. All rights reserved. */ pragma solidity ^0.4.22; /** * @title String & slice utility library for Solidity contracts. * @author Nick Johnson <[email\u00a0protected]> */ library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private pure { // Copy word-length chunks while possible for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } // Copy remaining bytes uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } /* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ function toString(slice memory self) internal pure returns (string memory) { string memory ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } /* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ function toSlice(string memory self) internal pure returns (slice memory) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } /* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ function empty(slice memory self) internal pure returns (bool) { return self._len == 0; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ function split(slice memory self, slice memory needle) internal pure returns (slice memory token) { split(self, needle, token); } // Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } /* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ function count(slice memory self, slice memory needle) internal pure returns (uint cnt) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { cnt++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } } contract owned { address public holder; constructor() public { holder = msg.sender; } modifier onlyHolder { require(msg.sender == holder, \"This function can only be called by holder\"); _; } } contract asset is owned { using strings for *; /** * Asset Struct */ struct data { //link URL of the original information for storing data //     null means undisclosed string link; //The encryption method of the original data, such as SHA-256 string encryptionType; //Hash value string hashValue; } data[] dataArray; uint dataNum; //The validity of the contract bool public isValid; //The init status bool public isInit; //The tradeable status of asset bool public isTradeable; uint public price; //Some notes string public remark1; //Other notes, holder can be written //Reservations for validation functions string public remark2; /** constructor */ constructor() public { isValid = true; isInit = false; isTradeable = false; price = 0; dataNum = 0; } /** * Initialize a new asset * @param dataNumber The number of data array * @param linkSet The set of URL of the original information for storing data, empty means undisclosed *          needle is \" \" * @param encryptionTypeSet The set of encryption method of the original data, such as SHA-256 *          needle is \" \" * @param hashValueSet The set of hashvalue *          needle is \" \" */ function initAsset( uint dataNumber, string linkSet, string encryptionTypeSet, string hashValueSet) public onlyHolder { // split string to array var links = linkSet.toSlice(); var encryptionTypes = encryptionTypeSet.toSlice(); var hashValues = hashValueSet.toSlice(); var delim = \" \".toSlice(); dataNum = dataNumber; // after init, the initAsset function cannot be called require(isInit == false, \"The contract has been initialized\"); //check data require(dataNumber >= 1, \"Param dataNumber smaller than 1\"); require(dataNumber - 1 == links.count(delim), \"Param linkSet invalid\"); require(dataNumber - 1 == encryptionTypes.count(delim), \"Param encryptionTypeSet invalid\"); require(dataNumber - 1 == hashValues.count(delim), \"Param hashValueSet invalid\"); isInit = true; var empty = \"\".toSlice(); for (uint i = 0; i < dataNumber; i++) { var link = links.split(delim); var encryptionType = encryptionTypes.split(delim); var hashValue = hashValues.split(delim); //require data not null // link can be empty require(!encryptionType.empty(), \"Param encryptionTypeSet data error\"); require(!hashValue.empty(), \"Param hashValueSet data error\"); dataArray.push( data(link.toString(), encryptionType.toString(), hashValue.toString()) ); } } /** * Get base asset info */ function getAssetBaseInfo() public view returns (uint _price, bool _isTradeable, uint _dataNum, string _remark1, string _remark2) { require(isValid == true, \"contract invaild\"); _price = price; _isTradeable = isTradeable; _dataNum = dataNum; _remark1 = remark1; _remark2 = remark2; } /** * Get data info by index * @param index index of dataArray */ function getDataByIndex(uint index) public view returns (string link, string encryptionType, string hashValue) { require(isValid == true, \"contract invaild\"); require(index >= 0, \"Param index smaller than 0\"); require(index < dataNum, \"Param index not smaller than dataNum\"); link = dataArray[index].link; encryptionType = dataArray[index].encryptionType; hashValue = dataArray[index].hashValue; } /** * set the price of asset * @param newPrice price of asset * Only can be called by holder */ function setPrice(uint newPrice) public onlyHolder { require(isValid == true, \"contract invaild\"); price = newPrice; } /** * set the tradeable status of asset * @param status status of isTradeable * Only can be called by holder */ function setTradeable(bool status) public onlyHolder { require(isValid == true, \"contract invaild\"); isTradeable = status; } /** * set the remark1 * @param content new content of remark1 * Only can be called by holder */ function setRemark1(string content) public onlyHolder { require(isValid == true, \"contract invaild\"); remark1 = content; } /** * set the remark2 * @param content new content of remark2 * Only can be called by holder */ function setRemark2(string content) public onlyHolder { require(isValid == true, \"contract invaild\"); remark2 = content; } /** * Modify the link of the indexth data to be url * @param index index of assetInfo * @param url new link * Only can be called by holder */ function setDataLink(uint index, string url) public onlyHolder { require(isValid == true, \"contract invaild\"); require(index >= 0, \"Param index smaller than 0\"); require(index < dataNum, \"Param index not smaller than dataNum\"); dataArray[index].link = url; } /** * cancel contract * Only can be called by holder */ function cancelContract() public onlyHolder { isValid = false; } /** * Get the number of assetInfo */ function getDataNum() public view returns (uint num) { num = dataNum; } /** * Transfer holder */ function transferOwnership(address newHolder, bool status) public onlyHolder { holder = newHolder; isTradeable = status; } } "}
{"sol name": "286.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract LineageCode is StandardToken { string public name = 'LineageCode'; string public symbol = 'LIN'; uint public decimals = 10; uint public INITIAL_SUPPLY = 80 * 100000000 * (10 ** decimals); address owner; bool public released = false; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; owner = msg.sender; } function release() public { require(owner == msg.sender); require(!released); released = true; } function lock() public { require(owner == msg.sender); require(released); released = false; } function get_Release() view public returns (bool) { return released; } modifier onlyReleased() { if (owner != msg.sender) require(released); _; } function transfer(address to, uint256 value) public onlyReleased returns (bool) { super.transfer(to, value); } function allowance(address _owner, address _spender) public onlyReleased view returns (uint256) { super.allowance(_owner, _spender); } function transferFrom(address from, address to, uint256 value) public onlyReleased returns (bool) { super.transferFrom(from, to, value); } function approve(address spender, uint256 value) public onlyReleased returns (bool) { super.approve(spender, value); } } "}
{"sol name": "1900.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** Token Developer : Adeel */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract NamoToken is StandardToken, PausableToken { string public constant name = \"Namo Coin\"; string public constant symbol = \"NAMO\"; uint8 public constant decimals = 8; uint256 public constant initialSupply = SafeMath.mul(56000000000000 , 1 ether); function NamoToken () { totalSupply_ = initialSupply; balances[owner] = initialSupply; } } "}
{"sol name": "1952.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface IERC20 { function balanceOf(address _owner) external view returns (uint256); function allowance(address _owner, address _spender) external view returns (uint256); function transfer(address _to, uint256 _value) external returns (bool); function transferFrom(address _from, address _to, uint256 _value) external returns (bool); function approve(address _spender, uint256 _value) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ANBXToken is IERC20 { using SafeMath for uint256; string public name = \"ANBX Exchange Token\"; string public symbol = \"ANBX\"; uint8 public constant decimals = 18; uint256 public constant decimalFactor = 10 ** uint256(decimals); uint256 public constant totalSupply = 2000000000 * decimalFactor; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); constructor() public { balances[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } "}
{"sol name": "525.sol", "label": 0, "sol content": "pragma solidity 0.4.21; contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract ROE is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ROE() public { symbol = \"ROE\"; name = \"NeoWorld Rare Ore E\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1893.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); var _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title QQBToken is Standard ERC20 token */ contract QQBToken is StandardToken { string public name = \"Qualified Quality Block \"; string public symbol = \"QQB\"; uint public decimals = 8; uint256 public constant total= 1000000000 * (10 ** uint256(decimals)); function QQBToken(address owner) { balances[owner] = total; totalSupply = total; } } "}
{"sol name": "121.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"FEB\"; decimals = 4; totalSupply = 10000000000000; balanceOf[msg.sender] = totalSupply; } function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract AdvanceToken is ERC20, owned{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "679.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'EZ25COIN' token contract // // Deployed to : 0x562Ff820D191F5420A9F021606e2270F08dA8dd0 // Symbol      : EZC // Name        : EZ25COIN // Total supply: 2500000000000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract EZ25COIN is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function EZ25COIN() public { symbol = \"EZC\"; name = \"EZ25COIN\"; decimals = 8; _totalSupply = 2500000000000000; balances[0x562Ff820D191F5420A9F021606e2270F08dA8dd0] = _totalSupply; Transfer(address(0), 0x562Ff820D191F5420A9F021606e2270F08dA8dd0, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "229.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint _value, address _token, bytes _extraData) external; } contract owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner public returns (bool success) { newOwner = _newOwner; return true; } function acceptOwnership() public returns (bool success) { require(msg.sender == newOwner); owner = newOwner; emit OwnershipTransferred(owner, newOwner); newOwner = address(0); return true; } } contract TokenERC20 is owned { string public name = 'Telex'; string public symbol = 'TLX'; uint8 public decimals = 8; uint public totalSupply = 2000000000000000; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed _owner, address indexed _spender, uint _value); event FrozenFunds(address indexed target, bool frozen); constructor() TokenERC20() public { balanceOf[msg.sender] = totalSupply; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); if (msg.sender != owner) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); } uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function _multipleTransfer(address _from, address[] addresses, uint[] amounts) internal { for (uint i=0; i<addresses.length; i++) { address _to = addresses[i]; uint _value = amounts[i]; _transfer(_from, _to, _value); } } function transfer(address _to, uint _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function multipleTransfer(address[] addresses, uint[] amounts) public returns (bool success) { _multipleTransfer(msg.sender, addresses, amounts); return true; } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { if (msg.sender != owner) { require(allowance[_from][msg.sender] >= _value); allowance[_from][msg.sender] -= _value; } _transfer(_from, _to, _value); return true; } function approve(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function freezeAccount(address target, bool freeze) onlyOwner public returns (bool success) { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); return true; } } "}
{"sol name": "1844.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract cryptocurrencyClubTest { uint originalTime; constructor() public{ originalTime = now; } //prints a birthday message and then becomes impossible to execute after 23 hours function BirthdayBoyClickHere() public view returns(string) { require(now < originalTime + 23 hours); return \"Happy Birthday Harrison! I know this contract is noobish but I will get better.\"; } } "}
{"sol name": "476.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract BiboToken is PausableToken { string public name = \"Bibo Token\"; string public symbol = \"BIBO\"; uint public decimals = 18; uint public INITIAL_SUPPLY = 100000000000*10**decimals; function BiboToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "269.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /* suport  tocoin.com * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510 \u252c \u250c\u2500\u2510    \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510 *  \u2502 \u2502 \u2502\u2502  \u2502 \u2502 \u2502 \u2502 \u2502     \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502 *  \u2534 \u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534 \u2534 \u2534     \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534 */ interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } } "}
{"sol name": "865.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'AGRI' - AgriChain Utility Token Contract // // Symbol           : AGRI // Name             : AgriChain Utility Token // Max Total supply : 1,000,000,000.000000000000000000 (1 billion) // Decimals         : 18 // // Company          : AgriChain Pty Ltd //                  : https://agrichain.com // Version          : 2.0 // Author           : Martin Halford <[email\u00a0protected]> // Published        : 13 Aug 2018 // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { uint256 constant public MAX_UINT256 = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function add(uint256 x, uint256 y) internal pure returns (uint256 z) { if (x > MAX_UINT256 - y) revert(); return x + y; } function sub(uint256 x, uint256 y) internal pure returns (uint256 z) { if (x < y) revert(); return x - y; } function mul(uint256 x, uint256 y) internal pure returns (uint256 z) { if (y == 0) return 0; if (x > MAX_UINT256 / y) revert(); return x * y; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // Agri Token // ---------------------------------------------------------------------------- contract AgriToken is ERC20Interface, Owned { using SafeMath for uint; uint256 constant public MAX_SUPPLY = 1000000000000000000000000000; // 1 billion Agri string public symbol; string public  name; uint8 public decimals; uint256 _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // Flag to allow or disallow transfers bool public isAllowingTransfers; // List of admins who can mint, burn and allow transfers of tokens mapping (address => bool) public administrators; // modifier to check if transfers being allowed modifier allowingTransfers() { require(isAllowingTransfers); _; } // modifier to check admin status modifier onlyAdmin() { require(administrators[msg.sender]); _; } // This notifies clients about the amount burnt , only owner is able to burn tokens event Burn(address indexed burner, uint256 value); // This notifies clients about the transfers being allowed or disallowed event AllowTransfers (); event DisallowTransfers (); // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor(uint initialTokenSupply) public { symbol = \"AGRI\"; name = \"AgriChain\"; decimals = 18; _totalSupply = initialTokenSupply * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public allowingTransfers returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public allowingTransfers returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyAdmin returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } // ------------------------------------------------------------------------ // Administrator can mint additional tokens // Do ** NOT ** let totalSupply exceed MAX_SUPPLY // ------------------------------------------------------------------------ function mintTokens(uint256 _value) public onlyAdmin { require(_totalSupply.add(_value) <= MAX_SUPPLY); balances[msg.sender] = balances[msg.sender].add(_value); _totalSupply = _totalSupply.add(_value); emit Transfer(0, msg.sender, _value); } // ------------------------------------------------------------------------ // Administrator can burn tokens // ------------------------------------------------------------------------ function burn(uint256 _value) public onlyAdmin { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); _totalSupply = _totalSupply.sub(_value); emit Burn(burner, _value); } // ------------------------------------------------------------------------ // Administrator can allow transfer of tokens // ------------------------------------------------------------------------ function allowTransfers() public onlyAdmin { isAllowingTransfers = true; emit AllowTransfers(); } // ------------------------------------------------------------------------ // Administrator can disallow transfer of tokens // ------------------------------------------------------------------------ function disallowTransfers() public onlyAdmin { isAllowingTransfers = false; emit DisallowTransfers(); } // ------------------------------------------------------------------------ // Owner can add administrators of tokens // ------------------------------------------------------------------------ function addAdministrator(address _admin) public onlyOwner { administrators[_admin] = true; } // ------------------------------------------------------------------------ // Owner can remove administrators of tokens // ------------------------------------------------------------------------ function removeAdministrator(address _admin) public onlyOwner { administrators[_admin] = false; } } "}
{"sol name": "481.sol", "label": 0, "sol content": "pragma solidity ^0.4.22; /* * The MIT License (MIT) * * Copyright (c) 2018 Hexlant, Inc. * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is * furnished to do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE * SOFTWARE. * * * * Open Source License Announcement * This smart contract code contains copyrighted source code under MIT License. *  - Copyright (c) 2016 Smart Contract Solutions, Inc. *    https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/LICENSE * * * Contact Us : [email\u00a0protected] * Website    : http://hexlant.com * Medium Blog: https://medium.com/hexlant */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; newOwner = address(0); } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyNewOwner() { require(msg.sender != address(0)); require(msg.sender == newOwner); _; } function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0)); newOwner = _newOwner; } function acceptOwnership() public onlyNewOwner returns(bool) { emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = 0x0; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function allowance(address owner, address spender) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } interface TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract SyncoToken is ERC20, Ownable, Pausable { using SafeMath for uint256; struct LockupInfo { uint256 releaseTime; uint256 termOfRound; uint256 unlockAmountPerRound; uint256 lockupBalance; } string public name; string public symbol; uint8 constant public decimals =18; uint256 internal initialSupply; uint256 internal totalSupply_; mapping(address => uint256) internal balances; mapping(address => bool) internal locks; mapping(address => bool) public frozen; mapping(address => mapping(address => uint256)) internal allowed; mapping(address => LockupInfo[]) internal lockupInfo; event Lock(address indexed holder, uint256 value); event Unlock(address indexed holder, uint256 value); event Burn(address indexed owner, uint256 value); event Mint(uint256 value); event Freeze(address indexed holder); event Unfreeze(address indexed holder); modifier notFrozen(address _holder) { require(!frozen[_holder]); _; } constructor() public { name = \"SYNCO Token\"; symbol = \"SYNCO\"; initialSupply = 13000000000; totalSupply_ = initialSupply * 10 ** uint(decimals); balances[owner] = totalSupply_; emit Transfer(address(0), owner, totalSupply_); } function () public payable { revert(); } function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public whenNotPaused notFrozen(msg.sender) returns (bool) { if (locks[msg.sender]) { autoUnlock(msg.sender); } require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _holder) public view returns (uint256 balance) { uint256 lockedBalance = 0; if(locks[_holder]) { for(uint256 idx = 0; idx < lockupInfo[_holder].length ; idx++ ) { lockedBalance = lockedBalance.add(lockupInfo[_holder][idx].lockupBalance); } } return balances[_holder] + lockedBalance; } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused notFrozen(_from)returns (bool) { if (locks[_from]) { autoUnlock(_from); } require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { require(isContract(_spender)); TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function allowance(address _holder, address _spender) public view returns (uint256) { return allowed[_holder][_spender]; } function lock(address _holder, uint256 _amount, uint256 _releaseStart, uint256 _termOfRound, uint256 _releaseRate) public onlyOwner returns (bool) { require(balances[_holder] >= _amount); if(_termOfRound==0 ) { _termOfRound = 1; } balances[_holder] = balances[_holder].sub(_amount); lockupInfo[_holder].push( LockupInfo(_releaseStart, _termOfRound, _amount.div(100).mul(_releaseRate), _amount) ); locks[_holder] = true; emit Lock(_holder, _amount); return true; } function unlock(address _holder, uint256 _idx) public onlyOwner returns (bool) { require(locks[_holder]); require(_idx < lockupInfo[_holder].length); LockupInfo storage lockupinfo = lockupInfo[_holder][_idx]; uint256 releaseAmount = lockupinfo.lockupBalance; delete lockupInfo[_holder][_idx]; lockupInfo[_holder][_idx] = lockupInfo[_holder][lockupInfo[_holder].length.sub(1)]; lockupInfo[_holder].length -=1; if(lockupInfo[_holder].length == 0) { locks[_holder] = false; } emit Unlock(_holder, releaseAmount); balances[_holder] = balances[_holder].add(releaseAmount); return true; } function freezeAccount(address _holder) public onlyOwner returns (bool) { require(!frozen[_holder]); frozen[_holder] = true; emit Freeze(_holder); return true; } function unfreezeAccount(address _holder) public onlyOwner returns (bool) { require(frozen[_holder]); frozen[_holder] = false; emit Unfreeze(_holder); return true; } function getNowTime() public view returns(uint256) { return now; } function showLockState(address _holder, uint256 _idx) public view returns (bool, uint256, uint256, uint256, uint256, uint256) { if(locks[_holder]) { return ( locks[_holder], lockupInfo[_holder].length, lockupInfo[_holder][_idx].lockupBalance, lockupInfo[_holder][_idx].releaseTime, lockupInfo[_holder][_idx].termOfRound, lockupInfo[_holder][_idx].unlockAmountPerRound ); } else { return ( locks[_holder], lockupInfo[_holder].length, 0,0,0,0 ); } } function distribute(address _to, uint256 _value) public onlyOwner returns (bool) { require(_to != address(0)); require(_value <= balances[owner]); balances[owner] = balances[owner].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(owner, _to, _value); return true; } function distributeWithLockup(address _to, uint256 _value, uint256 _releaseStart, uint256 _termOfRound, uint256 _releaseRate) public onlyOwner returns (bool) { distribute(_to, _value); lock(_to, _value, _releaseStart, _termOfRound, _releaseRate); return true; } function claimToken(ERC20 token, address _to, uint256 _value) public onlyOwner returns (bool) { token.transfer(_to, _value); return true; } function burn(uint256 _value) public onlyOwner returns (bool success) { require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); return true; } function mint(address _to, uint256 _amount) onlyOwner public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(address(0), _to, _amount); return true; } function isContract(address addr) internal view returns (bool) { uint size; assembly{size := extcodesize(addr)} return size > 0; } function autoUnlock(address _holder) internal returns (bool) { for(uint256 idx =0; idx < lockupInfo[_holder].length ; idx++ ) { if(locks[_holder]==false) { return true; } if (lockupInfo[_holder][idx].releaseTime <= now) { // If lockupinfo was deleted, loop restart at same position. if( releaseTimeLock(_holder, idx) ) { idx -=1; } } } return true; } function releaseTimeLock(address _holder, uint256 _idx) internal returns(bool) { require(locks[_holder]); require(_idx < lockupInfo[_holder].length); // If lock status of holder is finished, delete lockup info. LockupInfo storage info = lockupInfo[_holder][_idx]; uint256 releaseAmount = info.unlockAmountPerRound; uint256 sinceFrom = now.sub(info.releaseTime); uint256 sinceRound = sinceFrom.div(info.termOfRound); releaseAmount = releaseAmount.add( sinceRound.mul(info.unlockAmountPerRound) ); if(releaseAmount >= info.lockupBalance) { releaseAmount = info.lockupBalance; delete lockupInfo[_holder][_idx]; lockupInfo[_holder][_idx] = lockupInfo[_holder][lockupInfo[_holder].length.sub(1)]; lockupInfo[_holder].length -=1; if(lockupInfo[_holder].length == 0) { locks[_holder] = false; } emit Unlock(_holder, releaseAmount); balances[_holder] = balances[_holder].add(releaseAmount); return true; } else { lockupInfo[_holder][_idx].releaseTime = lockupInfo[_holder][_idx].releaseTime.add( sinceRound.add(1).mul(info.termOfRound) ); lockupInfo[_holder][_idx].lockupBalance = lockupInfo[_holder][_idx].lockupBalance.sub(releaseAmount); emit Unlock(_holder, releaseAmount); balances[_holder] = balances[_holder].add(releaseAmount); return false; } } } "}
{"sol name": "204.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /** * Copyright 2018 AOABANK. */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } interface TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { totalSupply = initialSupply * 10 ** uint256(decimalUnits);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;              // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes decimals = decimalUnits;                            // Amount of decimals for display purposes owner = msg.sender; } /* Send coins */ function transfer(address _to, uint256 _value) { if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns(bool) { if (approve(_spender, _value)) { TokenRecipient spender = TokenRecipient(_spender); spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } return false; } /** * approve should be called when allowances[_spender] == 0. To increment * allowances value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { if (_addedValue <= 0) throw; allowance[msg.sender][_spender] = SafeMath.safeAdd(allowance[msg.sender][_spender], _addedValue); Approval(msg.sender, _spender, allowance[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowance[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowance[msg.sender][_spender] = 0; } else { allowance[msg.sender][_spender] = oldValue - _subtractedValue; } Approval(msg.sender, _spender, allowance[msg.sender][_spender]); return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows if (_value > allowance[_from][msg.sender]) throw;     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns(bool) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from]  = SafeMath.safeSub(balanceOf[_from],_value);     // Subtract from the targeted balance allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender],_value);             // Subtract from the sender's allowance totalSupply = SafeMath.safeSub(totalSupply,_value);                            // Update totalSupply Burn(_from, _value); return true; } function freeze(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) returns (bool success) { if (freezeOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } } contract AOABANK is TokenERC20 { function AOABANK() TokenERC20(100*10**8, \"AOABANK\", 18 , \"ANK\") public { } } "}
{"sol name": "107.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 8; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "63.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'VRF' '0xVerify' token contract // // Symbol      : VRF // Name        : 0xVerify // Decimals    : 18 // // A faucet distributed token, powered by ethverify.net // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event TokensClaimed(address indexed to, uint tokens); } contract EthVerifyCore{ mapping (address => bool) public verifiedUsers; } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // 0xVRF ERC20 Token // ---------------------------------------------------------------------------- contract VerifyToken is ERC20Interface { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public dailyDistribution; uint public timestep; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => uint) public lastClaimed; uint public claimedYesterday; uint public claimedToday; uint public dayStartTime; bool public activated=false; address public creator; EthVerifyCore public ethVerify=EthVerifyCore(0x1c307A39511C16F74783fCd0091a921ec29A0b51);//0x1Ea6fAd76886fE0C0BF8eBb3F51678B33D24186c);//0x286A090b31462890cD9Bf9f167b610Ed8AA8bD1a); // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { timestep=24 hours;//10 minutes;//24 hours; symbol = \"VRF\"; name = \"0xVerify\"; decimals = 18; dailyDistribution=10000000 * 10**uint(decimals); claimedYesterday=20; claimedToday=0; dayStartTime=now; _totalSupply=140000000 * 10**uint(decimals); balances[msg.sender] = _totalSupply; creator=msg.sender; } function activate(){ require(!activated); require(msg.sender==creator); dayStartTime=now-1 minutes; activated=true; } // ------------------------------------------------------------------------ // Claim VRF tokens daily, requires an Eth Verify account // ------------------------------------------------------------------------ function claimTokens() public{ require(activated); //progress the day if needed if(dayStartTime<now.sub(timestep)){ uint daysPassed=(now.sub(dayStartTime)).div(timestep); dayStartTime=dayStartTime.add(daysPassed.mul(timestep)); claimedYesterday=claimedToday > 1 ? claimedToday : 1; //make 1 the minimum to avoid divide by zero claimedToday=0; } //requires each account to be verified with eth verify require(ethVerify.verifiedUsers(msg.sender)); //only allows each account to claim tokens once per day require(lastClaimed[msg.sender] <= dayStartTime); lastClaimed[msg.sender]=now; //distribute tokens based on the amount distributed the previous day; the goal is to shoot for an average equal to dailyDistribution. claimedToday=claimedToday.add(1); balances[msg.sender]=balances[msg.sender].add(dailyDistribution.div(claimedYesterday)); _totalSupply=_totalSupply.add(dailyDistribution.div(claimedYesterday)); emit TokensClaimed(msg.sender,dailyDistribution.div(claimedYesterday)); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } } // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } "}
{"sol name": "1884.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'SPEX' 'ShareProfitEx' // // Symbol      : SPEX // Name        : ShareProfitEx // Total supply: 200,000,000.000000000000000000 // Decimals    : 18 // // // (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract SPEX is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function SPEX() public { symbol = \"SPEX\"; name = \"ShareProfitEx\"; decimals = 18; _totalSupply = 200000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1738.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // \u672ctoken\u7684\u516c\u5171\u53d8\u91cf string public name; string public symbol; uint8 public decimals = 18; // 18\u4f4d\u5c0f\u6570\u70b9\uff0c\u5c3d\u91cf\u4e0d\u4fee\u6539 uint256 public totalSupply; // \u4f59\u989d\u6570\u7ec4 mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; //2\u7ef4\u6570\u7ec4\u9650\u989d //Token\u8f6c\u79fb\u4e8b\u4ef6 This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // \u84b8\u53d1\u67d0\u4e2a\u8d26\u6237\u7684token This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * \u521d\u59cb\u5316 \u5408\u7ea6 Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // \u5c0f\u6570\u53d8\u6574\u6570 \u4e5818\u4e2a0   Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // \u521d\u59cbtoken\u6570\u91cf Give the creator all initial tokens name = tokenName;                                   // \u8bbe\u7f6etoken\u540d\u79f0  Set the name for display purposes symbol = tokenSymbol;                               // \u8bbe\u7f6etoken\u7b26\u53f7 Set the symbol for display purposes } /** * \u8d60\u9001\u8d27\u5e01 Internal transfer, only can be called by this contract \u4ed8\u6b3e\u5730\u5740\uff0c\u6536\u6b3e\u5730\u5740\uff0c\u6570\u91cf */ function _transfer(address _from, address _to, uint _value) internal { // \u786e\u5b9a\u6536\u6b3e\u5730\u5740\u5b58\u5728  Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // \u68c0\u67e5\u4ed8\u6b3e\u5730\u5740\u662f\u5426\u6709\u8db3\u591f\u7684\u4f59\u989d Check if the sender has enough require(balanceOf[_from] >= _value); //\u68c0\u67e5\u6536\u6b3e\u5730\u5740\u6536\u5230\u7684\u91d1\u989d\u662f\u5426\u662f\u8d1f\u6570  Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); //\u6536\u6b3e\u5730\u5740\u548c\u4ed8\u6b3e\u5730\u5740\u7684\u603b\u989d  Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // \u4ed8\u6b3e\u5730\u5740\u4e2d\u7684\u4f59\u989d-\u4ed8\u6b3e\u91d1\u989d  Subtract from the sender balanceOf[_from] -= _value; // \u6536\u6b3e\u5730\u5740\u4e2d\u7684\u4f59\u989d+\u4ed8\u6b3e\u91d1\u989d Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // \u5224\u65ad\u4ed8\u6b3e\u884c\u4e3a\u540e\u4e24\u4e2a\u8d26\u6237\u7684\u603b\u989d\u662f\u5426\u53d1\u751f\u53d8\u5316   Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens *\u4ece\u5f53\u524d\u8d26\u6237\u5411\u5176\u4ed6\u8d26\u6237\u53d1\u9001token * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // \u68c0\u67e5\u9650\u989d Check allowance allowance[_from][msg.sender] -= _value;  //\u51cf\u5c11\u76f8\u5e94\u7684\u9650\u989d _transfer(_from, _to, _value);  //\u8c03\u7528\u8c03\u7528\u4ea4\u6613\uff0c\u5b8c\u6210\u4ea4\u6613 return true; } /** * \u8bbe\u7f6e\u8d26\u6237\u9650\u989d  Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * \u8bbe\u7f6e\u5176\u4ed6\u8d26\u6237\u9650\u989d Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens *\u84b8\u53d1\u81ea\u5df1\u7684token * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   //\u5224\u65ad\u4f7f\u7528\u8005\u7684\u4f59\u989d\u662f\u5426\u5145\u8db3 Check if the sender has enough balanceOf[msg.sender] -= _value;            //\u51cf\u6389token Subtract from the sender totalSupply -= _value;                      //\u51cf\u6389\u603btaoken\u6570 Updates totalSupply emit Burn(msg.sender, _value);              //\u89e6\u53d1Burn\u4e8b\u4ef6 return true; } /** * Destroy tokens from other account *\u84b8\u53d1\u522b\u4eba\u7684token * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // \u68c0\u67e5\u522b\u4eba\u7684\u4f59\u989d\u662f\u5426\u5145\u8db3  Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // \u68c0\u67e5\u9650\u989d\u662f\u5426\u5145\u8db3 Check allowance balanceOf[_from] -= _value;                         // \u84b8\u53d1token Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // \u53bb\u9664\u9650\u989d Subtract from the sender's allowance totalSupply -= _value;                              // \u51cf\u6389\u603btaoken\u6570Update totalSupply emit Burn(_from, _value);\t\t\t    //\u89e6\u53d1Burn\u4e8b\u4ef6 return true; } } contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } contract mcs is owned, TokenERC20{ bool public freeze=true; function mcs() TokenERC20(600000000, \"Magicstonelink\", \"MCS\") public {} function _transfer(address _from, address _to, uint _value) internal { require (freeze); require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows uint previousBalances = balanceOf[_from] + balanceOf[_to]; // \u4ed8\u6b3e\u5730\u5740\u4e2d\u7684\u4f59\u989d-\u4ed8\u6b3e\u91d1\u989d  Subtract from the sender balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); // \u5224\u65ad\u4ed8\u6b3e\u884c\u4e3a\u540e\u4e24\u4e2a\u8d26\u6237\u7684\u603b\u989d\u662f\u5426\u53d1\u751f\u53d8\u5316   Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function setfreeze(bool state) onlyOwner public{ freeze=state; } } "}
{"sol name": "568.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /*-------------------------------------------------- ____                           ____              _ / ___| _   _ _ __   ___ _ __   / ___|__ _ _ __ __| | \\___ \\| | | | '_ \\ / _ \\ '__| | |   / _` | '__/ _` | ___) | |_| | |_) |  __/ |    | |__| (_| | | | (_| | |____/ \\__,_| .__/ \\___|_|     \\____\\__,_|_|  \\__,_| |_| 2018-08-08 V0.8 ---------------------------------------------------*/ contract SPCevents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit, add pot directly by admin to next round event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } //============================================================================== //   _ _  _ _|_ _ _  __|_   _ _ _|_    _   . //  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  . //====================================|========================================= contract SuperCard is SPCevents { using SafeMath for *; using NameFilter for string; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xbac825cdb506dcf917a7715a4bf3fa1b06abe3e4); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== address private admin = msg.sender; string constant public name   = \"SuperCard\"; string constant public symbol = \"SPC\"; uint256 private rndExtra_     = 0;     // length of the very first ICO uint256 private rndGap_ = 2 minutes;         // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 6 hours;           // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // last rID uint256 public pID_;    // last pID //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => SPCdatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => SPCdatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => SPCdatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id mapping (uint256 => uint256) public attend;   // (index => pID) player ID attend current round //**************** // TEAM FEE DATA //**************** mapping (uint256 => SPCdatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => SPCdatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { fees_[0] = SPCdatasets.TeamFee(80,2); fees_[1] = SPCdatasets.TeamFee(80,2); fees_[2] = SPCdatasets.TeamFee(80,2); fees_[3] = SPCdatasets.TeamFee(80,2); // how to split up the final pot based on which team was picked potSplit_[0] = SPCdatasets.PotSplit(20,10); potSplit_[1] = SPCdatasets.PotSplit(20,10); potSplit_[2] = SPCdatasets.PotSplit(20,10); potSplit_[3] = SPCdatasets.PotSplit(20,10); /* activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; */ } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { if ( activated_ == false ){ if ( (now >= pre_active_time) &&  (pre_active_time > 0) ){ activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } require(activated_ == true, \"its not ready yet.\"); _; } /** * @dev prevents contracts from interacting with SuperCard */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // buy core, team set to 2, snake buyCore(_pID, _affCode, 2, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // reload core, team set to 2, snake reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 upperLimit = 0; uint256 usedGen = 0; // eth send to player uint256 ethout = 0; uint256 over_gen = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = (calceth(plyrRnds_[_pID][rID_].keys).mul(105))/100; if(plyr_[_pID].gen >= upperLimit) { over_gen = (plyr_[_pID].gen).sub(upperLimit); round_[rID_].keys = (round_[rID_].keys).sub(plyrRnds_[_pID][rID_].keys); plyrRnds_[_pID][rID_].keys = 0; round_[rID_].pot = (round_[rID_].pot).add(over_gen); usedGen = upperLimit; } else { plyrRnds_[_pID][rID_].keys = (plyrRnds_[_pID][rID_].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); round_[rID_].keys = (round_[rID_].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); usedGen = plyr_[_pID].gen; } ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); } else { ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)); } plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].addr.transfer(ethout); // check to see if round has ended and no one has run round end yet if (_now > round_[rID_].end && round_[rID_].ended == false && round_[rID_].plyr != 0) { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[rID_].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit SPCevents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, ethout, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // fire withdraw event emit SPCevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, ethout, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // price 0.01 ETH return(10000000000000000); } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, 2, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } // put eth in players vault, to win vault plyr_[_pID].win = plyr_[_pID].win.add(msg.value); } } /** * @dev gen limit handle */ function genLimit(uint256 _pID) private returns(uint256) { uint256 upperLimit = 0; uint256 usedGen = 0; uint256 over_gen = 0; uint256 eth_can_use = 0; uint256 tempnum = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = ((plyrRnds_[_pID][rID_].keys).mul(105))/10000; if(plyr_[_pID].gen >= upperLimit) { over_gen = (plyr_[_pID].gen).sub(upperLimit); round_[rID_].keys = (round_[rID_].keys).sub(plyrRnds_[_pID][rID_].keys); plyrRnds_[_pID][rID_].keys = 0; round_[rID_].pot = (round_[rID_].pot).add(over_gen); usedGen = upperLimit; } else { tempnum = ((plyr_[_pID].gen).mul(10000))/105; plyrRnds_[_pID][rID_].keys = (plyrRnds_[_pID][rID_].keys).sub(tempnum); round_[rID_].keys = (round_[rID_].keys).sub(tempnum); usedGen = plyr_[_pID].gen; } eth_can_use = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } else { eth_can_use = (plyr_[_pID].win).add(plyr_[_pID].aff); plyr_[_pID].win = 0; plyr_[_pID].aff = 0; } return(eth_can_use); } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID // grab time uint256 _now = now; uint256 eth_can_use = 0; // if round is active if (_now > round_[rID_].strt + rndGap_ && (_now <= round_[rID_].end || (_now > round_[rID_].end && round_[rID_].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. eth_can_use = genLimit(_pID); if(eth_can_use > 0) { // call core core(rID_, _pID, eth_can_use, _affID, 2, _eventData_); } // if round is not active and end round needs to be ran } else if (_now > round_[rID_].end && round_[rID_].ended == false) { // end the round (distributes pot) & start new round round_[rID_].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // if player is new to round\u3002 if (plyrRnds_[_pID][_rID].jionflag != 1) { _eventData_ = managePlayer(_pID, _eventData_); plyrRnds_[_pID][_rID].jionflag = 1; attend[round_[_rID].attendNum] = _pID; round_[_rID].attendNum  = (round_[_rID].attendNum).add(1); } if (_eth > 10000000000000000) { // mint the new keys uint256 _keys = calckeys(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; round_[_rID].team = 2; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][2] = _eth.add(rndTmEth_[_rID][2]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, 2, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, 2, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, 2, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { uint256 temp; temp = (round_[_rIDlast].mask).mul((plyrRnds_[_pID][_rIDlast].keys)/1000000000000000000); if(temp > plyrRnds_[_pID][_rIDlast].mask) { return( temp.sub(plyrRnds_[_pID][_rIDlast].mask) ); } else { return( 0 ); } } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { return ( calckeys(_eth) ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { return ( _keys/100 ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of SuperCard if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); pID_ = _pID; // save Last pID bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 temp_eth = 0; // if player has played a previous round, move their unmasked earnings // from that round to win vault. if (plyr_[_pID].lrnd != 0) { updateGenVault(_pID, plyr_[_pID].lrnd); temp_eth = ((plyr_[_pID].win).add((plyr_[_pID].gen))).add(plyr_[_pID].aff); plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].win = temp_eth; } // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(30)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards _com = _com.add(_p3d.sub(_p3d / 2)); admin.transfer(_com); _res = _res.add(_p3d / 2); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // pay 3% out to community rewards uint256 _p3d = (_eth/100).mul(3); // distribute share to affiliate // 5%:3%:2% uint256 _aff_cent = (_eth) / 100; uint256 tempID  = _affID; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered // 5% if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(5)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(5), now); } else { _p3d = _p3d.add(_aff_cent.mul(5)); } tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(3)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(3), now); } else { _p3d = _p3d.add(_aff_cent.mul(3)); } tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(2)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(2), now); } else { _p3d = _p3d.add(_aff_cent.mul(2)); } // pay out p3d _p3d = _p3d.add((_eth.mul(fees_[2].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); // set up event data _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } /** * @dev */ function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit SPCevents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // calculate gen share\uff0c80% uint256 _gen = (_eth.mul(fees_[2].gen)) / 100; // pot 5% uint256 _pot = (_eth.mul(5)) / 100; // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (2 * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit SPCevents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; //uint256 public pre_active_time = 0; uint256 public pre_active_time = 1534412700; /** * @dev return active flag \u3001time * @return active flag * @return active time * @return system time */ function getRunInfo() public view returns(bool, uint256, uint256) { return ( activated_,      //0 pre_active_time, //1 now          //2 ); } function setPreActiveTime(uint256 _pre_time) public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); pre_active_time = _pre_time; } function activate() public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); // can only be ran once require(activated_ == false, \"SuperCard already activated\"); // activate the contract activated_ = true; //activated_ = false; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== function calckeys(uint256 _eth) pure public returns(uint256) { return ( (_eth).mul(100) ); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function calceth(uint256 _keys) pure public returns(uint256) { return( (_keys)/100 ); } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library SPCdatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used uint256 gen2;   // general for clear keys } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 jionflag;   // player not jion round uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase uint256 attendNum; // number of players attend } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 p3d;    // % of buy in thats paid to p3d holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 p3d;    // % of pot thats paid to p3d holders } } //============================================================================== //  . _ _|_ _  _ |` _  _ _  _  . //  || | | (/_| ~|~(_|(_(/__\\  . //============================================================================== interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } /** * @title -Name Filter- v0.1.9 */ library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } } "}
{"sol name": "559.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /*-------------------------------------------------- ____                           ____              _ / ___| _   _ _ __   ___ _ __   / ___|__ _ _ __ __| | \\___ \\| | | | '_ \\ / _ \\ '__| | |   / _` | '__/ _` | ___) | |_| | |_) |  __/ |    | |__| (_| | | | (_| | |____/ \\__,_| .__/ \\___|_|     \\____\\__,_|_|  \\__,_| |_| 2018-08-08 V0.8 ---------------------------------------------------*/ contract SPCevents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit, add pot directly by admin to next round event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } //============================================================================== //   _ _  _ _|_ _ _  __|_   _ _ _|_    _   . //  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  . //====================================|========================================= contract SuperCard is SPCevents { using SafeMath for *; using NameFilter for string; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xbac825cdb506dcf917a7715a4bf3fa1b06abe3e4); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== address private admin = msg.sender; string constant public name   = \"SuperCard\"; string constant public symbol = \"SPC\"; uint256 private rndExtra_     = 0;     // length of the very first ICO uint256 private rndGap_ = 2 minutes;         // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 6 hours;           // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // last rID uint256 public pID_;    // last pID //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => SPCdatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => SPCdatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => SPCdatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id mapping (uint256 => uint256) public attend;   // (index => pID) player ID attend current round //**************** // TEAM FEE DATA //**************** mapping (uint256 => SPCdatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => SPCdatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { fees_[0] = SPCdatasets.TeamFee(80,2); fees_[1] = SPCdatasets.TeamFee(80,2); fees_[2] = SPCdatasets.TeamFee(80,2); fees_[3] = SPCdatasets.TeamFee(80,2); // how to split up the final pot based on which team was picked potSplit_[0] = SPCdatasets.PotSplit(20,10); potSplit_[1] = SPCdatasets.PotSplit(20,10); potSplit_[2] = SPCdatasets.PotSplit(20,10); potSplit_[3] = SPCdatasets.PotSplit(20,10); /* activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; */ } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { if ( activated_ == false ){ if ( (now >= pre_active_time) &&  (pre_active_time > 0) ){ activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } require(activated_ == true, \"its not ready yet.\"); _; } /** * @dev prevents contracts from interacting with SuperCard */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // reload core, team set to 2, snake reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 myrID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 upperLimit = 0; uint256 usedGen = 0; // eth send to player uint256 ethout = 0; uint256 over_gen = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = (calceth(plyrRnds_[_pID][myrID].keys).mul(105))/100; if(plyr_[_pID].gen >= upperLimit) { over_gen = (plyr_[_pID].gen).sub(upperLimit); round_[myrID].keys = (round_[myrID].keys).sub(plyrRnds_[_pID][myrID].keys); plyrRnds_[_pID][myrID].keys = 0; round_[myrID].pot = (round_[myrID].pot).add(over_gen); usedGen = upperLimit; } else { plyrRnds_[_pID][myrID].keys = (plyrRnds_[_pID][myrID].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); round_[myrID].keys = (round_[myrID].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); usedGen = plyr_[_pID].gen; } ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); } else { ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)); } plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].addr.transfer(ethout); // check to see if round has ended and no one has run round end yet if (_now > round_[myrID].end && round_[myrID].ended == false && round_[myrID].plyr != 0) { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[myrID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit SPCevents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, ethout, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // fire withdraw event emit SPCevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, ethout, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // price 0.01 ETH return(10000000000000000); } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // if round has ended.  but round end has not been run (so contract has not distributed winnings) return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, 2, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } // put eth in players vault, to win vault plyr_[_pID].win = plyr_[_pID].win.add(msg.value); } } /** * @dev gen limit handle */ function genLimit(uint256 _pID) private returns(uint256) { // setup local rID uint256 myrID = rID_; uint256 upperLimit = 0; uint256 usedGen = 0; uint256 over_gen = 0; uint256 eth_can_use = 0; uint256 tempnum = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = ((plyrRnds_[_pID][myrID].keys).mul(105))/10000; if(plyr_[_pID].gen >= upperLimit) { over_gen = (plyr_[_pID].gen).sub(upperLimit); round_[myrID].keys = (round_[myrID].keys).sub(plyrRnds_[_pID][myrID].keys); plyrRnds_[_pID][myrID].keys = 0; round_[myrID].pot = (round_[myrID].pot).add(over_gen); usedGen = upperLimit; } else { tempnum = ((plyr_[_pID].gen).mul(10000))/105; plyrRnds_[_pID][myrID].keys = (plyrRnds_[_pID][myrID].keys).sub(tempnum); round_[myrID].keys = (round_[myrID].keys).sub(tempnum); usedGen = plyr_[_pID].gen; } eth_can_use = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } else { eth_can_use = (plyr_[_pID].win).add(plyr_[_pID].aff); plyr_[_pID].win = 0; plyr_[_pID].aff = 0; } return(eth_can_use); } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 myrID = rID_; // grab time uint256 _now = now; uint256 eth_can_use = 0; // if round is active if (_now > round_[myrID].strt + rndGap_ && (_now <= round_[myrID].end || (_now > round_[myrID].end && round_[myrID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. eth_can_use = genLimit(_pID); if(eth_can_use > 0) { // call core core(myrID, _pID, eth_can_use, _affID, 2, _eventData_); } // if round is not active and end round needs to be ran } else if (_now > round_[myrID].end && round_[myrID].ended == false) { // end the round (distributes pot) & start new round round_[myrID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // if player is new to round\u3002 if (plyrRnds_[_pID][_rID].jionflag != 1) { _eventData_ = managePlayer(_pID, _eventData_); plyrRnds_[_pID][_rID].jionflag = 1; attend[round_[_rID].attendNum] = _pID; round_[_rID].attendNum  = (round_[_rID].attendNum).add(1); } if (_eth > 10000000000000000) { // mint the new keys uint256 _keys = calckeys(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; round_[_rID].team = 2; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][2] = _eth.add(rndTmEth_[_rID][2]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, 2, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, 2, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, 2, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { uint256 temp; temp = (round_[_rIDlast].mask).mul((plyrRnds_[_pID][_rIDlast].keys)/1000000000000000000); if(temp > plyrRnds_[_pID][_rIDlast].mask) { return( temp.sub(plyrRnds_[_pID][_rIDlast].mask) ); } else { return( 0 ); } } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { return ( calckeys(_eth) ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { return ( _keys/100 ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of SuperCard if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); pID_ = _pID; // save Last pID bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 temp_eth = 0; // if player has played a previous round, move their unmasked earnings // from that round to win vault. if (plyr_[_pID].lrnd != 0) { updateGenVault(_pID, plyr_[_pID].lrnd); temp_eth = ((plyr_[_pID].win).add((plyr_[_pID].gen))).add(plyr_[_pID].aff); plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].win = temp_eth; } // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(30)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards _com = _com.add(_p3d.sub(_p3d / 2)); admin.transfer(_com); _res = _res.add(_p3d / 2); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // pay 3% out to community rewards uint256 _p3d = (_eth/100).mul(3); // distribute share to affiliate // 5%:3%:2% uint256 _aff_cent = (_eth) / 100; uint256 tempID  = _affID; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered // 5% if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(5)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(5), now); } else { _p3d = _p3d.add(_aff_cent.mul(5)); } tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(3)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(3), now); } else { _p3d = _p3d.add(_aff_cent.mul(3)); } tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(2)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(2), now); } else { _p3d = _p3d.add(_aff_cent.mul(2)); } // pay out p3d _p3d = _p3d.add((_eth.mul(fees_[2].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); // set up event data _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } /** * @dev */ function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit SPCevents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // calculate gen share\uff0c80% uint256 _gen = (_eth.mul(fees_[2].gen)) / 100; // pot 5% uint256 _pot = (_eth.mul(5)) / 100; // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (2 * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit SPCevents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; //uint256 public pre_active_time = 0; uint256 public pre_active_time = now + 600 seconds; /** * @dev return active flag \u3001time * @return active flag * @return active time * @return system time */ function getRunInfo() public view returns(bool, uint256, uint256) { return ( activated_,      //0 pre_active_time, //1 now          //2 ); } function setPreActiveTime(uint256 _pre_time) public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); pre_active_time = _pre_time; } function activate() public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); // can only be ran once require(activated_ == false, \"SuperCard already activated\"); // activate the contract activated_ = true; //activated_ = false; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== function calckeys(uint256 _eth) pure public returns(uint256) { return ( (_eth).mul(100) ); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function calceth(uint256 _keys) pure public returns(uint256) { return( (_keys)/100 ); } function clearKeys(uint256 num) public { // setup local rID uint256 myrID = rID_; uint256 number = num; if(num == 1) { number = 10000; } uint256 over_gen; uint256 cleared = 0; uint256 checkID; uint256 upperLimit; uint256 i; for(i = 0; i< round_[myrID].attendNum; i++) { checkID = attend[i]; updateGenVault(checkID, plyr_[checkID].lrnd); if (plyr_[checkID].gen > 0) { upperLimit = ((plyrRnds_[checkID][myrID].keys).mul(105))/10000; if(plyr_[checkID].gen >= upperLimit) { over_gen = (plyr_[checkID].gen).sub(upperLimit); cleared = cleared.add(plyrRnds_[checkID][myrID].keys); round_[myrID].keys = (round_[myrID].keys).sub(plyrRnds_[checkID][myrID].keys); plyrRnds_[checkID][myrID].keys = 0; round_[myrID].pot = (round_[myrID].pot).add(over_gen); plyr_[checkID].win = ((plyr_[checkID].win).add(upperLimit)); plyr_[checkID].gen = 0; if(cleared >= number) break; } } } } /** * @dev calc Invalid Keys by rID&pId */ function calcInvalidKeys(uint256 _rID,uint256 _pID) private returns(uint256) { uint256 InvalidKeys = 0; uint256 upperLimit = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = ((plyrRnds_[_pID][_rID].keys).mul(105))/10000; if(plyr_[_pID].gen >= upperLimit) { InvalidKeys = InvalidKeys.add(plyrRnds_[_pID][_rID].keys); } } return(InvalidKeys); } /** * @dev return Invalid Keys * @return Invalid Keys * @return Total Keys * @return timestamp */ function getInvalidKeys() public view returns(uint256,uint256,uint256) { uint256 LastRID = rID_; uint256 LastPID = pID_; uint256 _rID = 0; uint256 _pID = 0; uint256 InvalidKeys = 0; uint256 TotalKeys = 0; for( _rID = 1 ; _rID <= LastRID ; _rID++) { TotalKeys = TotalKeys.add(round_[_rID].keys); for( _pID = 1 ; _pID <= LastPID ; _pID++) { InvalidKeys = InvalidKeys.add(calcInvalidKeys(_rID,_pID)); } } return ( InvalidKeys, //0 TotalKeys,   //1 now          //2 ); } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library SPCdatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 jionflag;   // player not jion round uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase uint256 attendNum; // number of players attend } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 p3d;    // % of buy in thats paid to p3d holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 p3d;    // % of pot thats paid to p3d holders } } //============================================================================== //  . _ _|_ _  _ |` _  _ _  _  . //  || | | (/_| ~|~(_|(_(/__\\  . //============================================================================== interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } /** * @title -Name Filter- v0.1.9 */ library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } } "}
{"sol name": "1809.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'TradingLife' token contract // // Deployed to : 0xCa6001488A5Cbc1B1fCDBd1A3B41ddE142F1C4bD // Symbol      : TLIFE // Name        : TradingLife // Total supply: 1000000000 // Decimals    : 0 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract TradingLife is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function TradingLife() public { symbol = \"TLIFE\"; name = \"TradingLife\"; decimals = 0; _totalSupply = 1000000000; balances[0xCa6001488A5Cbc1B1fCDBd1A3B41ddE142F1C4bD] = _totalSupply; Transfer(address(0), 0xCa6001488A5Cbc1B1fCDBd1A3B41ddE142F1C4bD, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "511.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** Copyright (c) 2018 The Ocean. Licensed under the MIT License: https://opensource.org/licenses/MIT. Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions: The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software. THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. **/ /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Whitelist * @dev The Whitelist contract has a whitelist of addresses, and provides basic authorization control functions. * @dev This simplifies the implementation of \"user permissions\". */ contract Whitelist is Ownable { mapping(address => bool) public whitelist; event WhitelistedAddressAdded(address addr); event WhitelistedAddressRemoved(address addr); /** * @dev Throws if called by any account that's not whitelisted. */ modifier onlyWhitelisted() { require(whitelist[msg.sender]); _; } /** * @dev add an address to the whitelist * @param addr address * @return true if the address was added to the whitelist, false if the address was already in the whitelist */ function addAddressToWhitelist(address addr) onlyOwner public returns(bool success) { if (!whitelist[addr]) { whitelist[addr] = true; WhitelistedAddressAdded(addr); success = true; } } /** * @dev add addresses to the whitelist * @param addrs addresses * @return true if at least one address was added to the whitelist, * false if all addresses were already in the whitelist */ function addAddressesToWhitelist(address[] addrs) onlyOwner public returns(bool success) { for (uint256 i = 0; i < addrs.length; i++) { if (addAddressToWhitelist(addrs[i])) { success = true; } } } /** * @dev remove an address from the whitelist * @param addr address * @return true if the address was removed from the whitelist, * false if the address wasn't in the whitelist in the first place */ function removeAddressFromWhitelist(address addr) onlyOwner public returns(bool success) { if (whitelist[addr]) { whitelist[addr] = false; WhitelistedAddressRemoved(addr); success = true; } } /** * @dev remove addresses from the whitelist * @param addrs addresses * @return true if at least one address was removed from the whitelist, * false if all addresses weren't in the whitelist in the first place */ function removeAddressesFromWhitelist(address[] addrs) onlyOwner public returns(bool success) { for (uint256 i = 0; i < addrs.length; i++) { if (removeAddressFromWhitelist(addrs[i])) { success = true; } } } } contract OceanTokenTransferManager is Ownable, Whitelist { /** * @dev check if transferFrom is possible * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to */ function canTransferFrom(address _from, address _to) public constant returns (bool success) { if (whitelist[_from] == true || whitelist[_to] == true) { return true; } else { return false; } } } "}
{"sol name": "764.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } // File: zeppelin-solidity/contracts/lifecycle/Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } // File: contracts/TokenFallback.sol /** * @title TokenFallback ERC 677 */ contract TokenFallback { function tokenFallback( address _from, uint256 _amount, bytes _data) public; } // File: contracts/CoinsdomCoin.sol /** * @title CoinsdomCoin Contract */ contract CoinsdomCoin is MintableToken, Pausable { using SafeMath for uint256; string public name = 'Coinsdom'; string public symbol = 'CSD'; uint256 public decimals = 18; mapping (address => bool) public tokenFallbackWhiteList; /** * @dev Constructor * @param _initialSupply Initial Supply **/ function CoinsdomCoin( uint256 _initialSupply ) public { totalSupply_ = _initialSupply; balances[owner] = totalSupply_; emit Transfer(0x0, owner, totalSupply_); } /** * @dev transfer function, revert if the contract is paused. **/ function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } /** * @dev transferFrom function, revert if the contract is paused. **/ function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } /** * @dev approve function, revert if the contract is paused. **/ function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } /** * @dev increaseApproval function, revert if the contract is paused. **/ function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } /** * @dev decreaseApproval function, revert if the contract is paused. **/ function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } /** * @dev Check if the given address is a contract address * @param _address Contract Address */ function _isContract( address _address ) internal constant returns (bool) { uint256 length; assembly { length := extcodesize(_address) } return (length > 0); } /** * @dev Add contract address to tokenFallbackWhiteList * @param _address Contract Address */ function addContractToTokenFallbackWhiteList( address _address ) onlyOwner public { require(_isContract(_address)); tokenFallbackWhiteList[_address] = true; } /** * @dev Remove contract address from tokenFallbackWhiteList * @param _address Contract Address */ function removeContractFromTokenFallbackWhiteList( address _address ) onlyOwner public { require(_isContract(_address)); delete tokenFallbackWhiteList[_address]; } function transferAndCall( address _receiver, uint _amount, bytes _data) public returns (bool _success) { require(_isContract(_receiver)); require(tokenFallbackWhiteList[_receiver]); transfer(_receiver, _amount); TokenFallback(_receiver).tokenFallback(msg.sender, _amount, _data); return true; } } "}
{"sol name": "274.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract Hacienda { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "139.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: ..\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: ..\\openzeppelin-solidity\\contracts\\introspection\\ERC165.sol /** * @title ERC165 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md */ interface ERC165 { /** * @notice Query if a contract implements an interface * @param _interfaceId The interface identifier, as specified in ERC-165 * @dev Interface identification is specified in ERC-165. This function * uses less than 30,000 gas. */ function supportsInterface(bytes4 _interfaceId) external view returns (bool); } // File: ..\\openzeppelin-solidity\\contracts\\introspection\\SupportsInterfaceWithLookup.sol /** * @title SupportsInterfaceWithLookup * @author Matt Condon (@shrugs) * @dev Implements ERC165 using a lookup table. */ contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; /** * 0x01ffc9a7 === *   bytes4(keccak256('supportsInterface(bytes4)')) */ /** * @dev a mapping of interface id to whether or not it's supported */ mapping(bytes4 => bool) internal supportedInterfaces; /** * @dev A contract implementing SupportsInterfaceWithLookup * implement ERC165 itself */ constructor() public { _registerInterface(InterfaceId_ERC165); } /** * @dev implement supportsInterface(bytes4) using a lookup table */ function supportsInterface(bytes4 _interfaceId) external view returns (bool) { return supportedInterfaces[_interfaceId]; } /** * @dev private method for registering an interface */ function _registerInterface(bytes4 _interfaceId) internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Basic.sol /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic is ERC165 { bytes4 internal constant InterfaceId_ERC721 = 0x80ac58cd; /* * 0x80ac58cd === *   bytes4(keccak256('balanceOf(address)')) ^ *   bytes4(keccak256('ownerOf(uint256)')) ^ *   bytes4(keccak256('approve(address,uint256)')) ^ *   bytes4(keccak256('getApproved(uint256)')) ^ *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^ *   bytes4(keccak256('isApprovedForAll(address,address)')) ^ *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) */ bytes4 internal constant InterfaceId_ERC721Enumerable = 0x780e9d63; /** * 0x780e9d63 === *   bytes4(keccak256('totalSupply()')) ^ *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^ *   bytes4(keccak256('tokenByIndex(uint256)')) */ bytes4 internal constant InterfaceId_ERC721Metadata = 0x5b5e139f; /** * 0x5b5e139f === *   bytes4(keccak256('name()')) ^ *   bytes4(keccak256('symbol()')) ^ *   bytes4(keccak256('tokenURI(uint256)')) */ event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public; } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721.sol /** * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex( address _owner, uint256 _index ) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } /** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Metadata is ERC721Basic { function name() external view returns (string _name); function symbol() external view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } /** * @title ERC-721 Non-Fungible Token Standard, full implementation interface * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } // File: ..\\openzeppelin-solidity\\contracts\\AddressUtils.sol /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, * as the code is not actually created until after the constructor finishes. * @param _account address of the account to check * @return whether the target address is a contract */ function isContract(address _account) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(_account) } return size > 0; } } // File: ..\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Receiver.sol /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */ contract ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 internal constant ERC721_RECEIVED = 0x150b7a02; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient * after a `safetransfer`. This function MAY throw to revert and reject the * transfer. Return of other than the magic value MUST result in the * transaction being reverted. * Note: the contract address is always the message sender. * @param _operator The address which called `safeTransferFrom` function * @param _from The address which previously owned the token * @param _tokenId The NFT identifier which is being transferred * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` */ function onERC721Received( address _operator, address _from, uint256 _tokenId, bytes _data ) public returns(bytes4); } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721BasicToken.sol /** * @title ERC721 Non-Fungible Token Standard basic implementation * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { using SafeMath for uint256; using AddressUtils for address; // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` bytes4 private constant ERC721_RECEIVED = 0x150b7a02; // Mapping from token ID to owner mapping (uint256 => address) internal tokenOwner; // Mapping from token ID to approved address mapping (uint256 => address) internal tokenApprovals; // Mapping from owner to number of owned token mapping (address => uint256) internal ownedTokensCount; // Mapping from owner to operator approvals mapping (address => mapping (address => bool)) internal operatorApprovals; constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721); } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } /** * @dev Approves another address to transfer the given token ID * The zero address indicates there is no approved address. * There can only be one approved address per token at a given time. * Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } /** * @dev Sets or unsets the approval of a given operator * An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll( address _owner, address _operator ) public view returns (bool) { return operatorApprovals[_owner][_operator]; } /** * @dev Transfers the ownership of a given token ID to another address * Usage of this method is discouraged, use `safeTransferFrom` whenever possible * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function transferFrom( address _from, address _to, uint256 _tokenId ) public { require(isApprovedOrOwner(msg.sender, _tokenId)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise, * the transfer is reverted. * * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function safeTransferFrom( address _from, address _to, uint256 _tokenId ) public { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise, * the transfer is reverted. * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existence of * @return whether the token exists */ function _exists(uint256 _tokenId) internal view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint256 _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Internal function to mint a new token * Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } /** * @dev Internal function to burn a specific token * Reverts if the token does not exist * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { clearApproval(_owner, _tokenId); removeTokenFrom(_owner, _tokenId); emit Transfer(_owner, address(0), _tokenId); } /** * @dev Internal function to clear current approval of a given token ID * Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); } } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } /** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( msg.sender, _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Token.sol /** * @title Full ERC721 Token * This implementation includes all the required and some optional functionality of the ERC721 standard * Moreover, it includes approve all functionality using operator terminology * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 { // Token name string internal name_; // Token symbol string internal symbol_; // Mapping from owner to list of owned token IDs mapping(address => uint256[]) internal ownedTokens; // Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; // Array with all token ids, used for enumeration uint256[] internal allTokens; // Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex; // Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs; /** * @dev Constructor function */ constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); } /** * @dev Gets the token name * @return string representing the token name */ function name() external view returns (string) { return name_; } /** * @dev Gets the token symbol * @return string representing the token symbol */ function symbol() external view returns (string) { return symbol_; } /** * @dev Returns an URI for a given token ID * Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ function tokenURI(uint256 _tokenId) public view returns (string) { require(_exists(_tokenId)); return tokenURIs[_tokenId]; } /** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ function tokenOfOwnerByIndex( address _owner, uint256 _index ) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } /** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ function totalSupply() public view returns (uint256) { return allTokens.length; } /** * @dev Gets the token ID at a given index of all the tokens in this contract * Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } /** * @dev Internal function to set the token URI for a given token * Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ function _setTokenURI(uint256 _tokenId, string _uri) internal { require(_exists(_tokenId)); tokenURIs[_tokenId] = _uri; } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); // To prevent a gap in the array, we store the last token in the index of the token to delete, and // then delete the last slot. uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; // This also deletes the contents at the last position of the array ownedTokens[_from].length--; // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping // the lastToken to the first position, and then dropping the element placed in the last position of the list ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } /** * @dev Internal function to mint a new token * Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { super._mint(_to, _tokenId); allTokensIndex[_tokenId] = allTokens.length; allTokens.push(_tokenId); } /** * @dev Internal function to burn a specific token * Reverts if the token does not exist * @param _owner owner of the token to burn * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { super._burn(_owner, _tokenId); // Clear metadata (if any) if (bytes(tokenURIs[_tokenId]).length != 0) { delete tokenURIs[_tokenId]; } // Reorg all tokens array uint256 tokenIndex = allTokensIndex[_tokenId]; uint256 lastTokenIndex = allTokens.length.sub(1); uint256 lastToken = allTokens[lastTokenIndex]; allTokens[tokenIndex] = lastToken; allTokens[lastTokenIndex] = 0; allTokens.length--; allTokensIndex[_tokenId] = 0; allTokensIndex[lastToken] = tokenIndex; } } // File: contracts\\RoyalStables.sol /** @title RoyalStables Holding HRSY token */ contract RoyalStables is Ownable,ERC721Token { /** @dev Structure to hold Horsey collectible information @dev should be as small as possible but since its already greater than 256 @dev lets keep it <= 512 */ struct Horsey { address race;       /// @dev Stores the original race address this horsey was claimed from bytes32 dna;        /// @dev Stores the horsey dna uint8 feedingCounter;   /// @dev Boils down to how many times has this horsey been fed uint8 tier;         /// @dev Used internaly to assess chances of a rare trait developing while feeding } /// @dev Maps all token ids to a unique Horsey mapping(uint256 => Horsey) public horseys; /// @dev Maps addresses to the amount of carrots they own mapping(address => uint32) public carrot_credits; /// @dev Maps a horsey token id to the horsey name mapping(uint256 => string) public names; /// @dev Master is the current Horsey contract using this library address public master; /** @dev Contracts constructor */ constructor() public Ownable() ERC721Token(\"HORSEY\",\"HRSY\") { } /** @dev Allows to change the address of the current Horsey contract @param newMaster Address of the current Horsey contract */ function changeMaster(address newMaster) public validAddress(newMaster) onlyOwner() { master = newMaster; } /** @dev Gets the complete list of token ids which belongs to an address @param eth_address The address you want to lookup owned tokens from @return List of all owned by eth_address tokenIds */ function getOwnedTokens(address eth_address) public view returns (uint256[]) { return ownedTokens[eth_address]; } /** @dev Stores a horsey name @param tokenId Horsey token id @param newName New horsey name */ function storeName(uint256 tokenId, string newName) public onlyMaster() { require(_exists(tokenId),\"token not found\"); names[tokenId] = newName; } /** @dev Stores carrot credits on the clients account @param client Client we need to update the balance of @param amount Amount of carrots to store */ function storeCarrotsCredit(address client, uint32 amount) public onlyMaster() validAddress(client) { carrot_credits[client] = amount; } function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public onlyMaster() validAddress(client) { //_mint checks if the token exists before minting already, so we dont have to here _mint(client,tokenId); modifyHorsey(tokenId,race,dna,feedingCounter,tier); } function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public onlyMaster() { Horsey storage hrsy = horseys[tokenId]; hrsy.race = race; hrsy.dna = dna; hrsy.feedingCounter = feedingCounter; hrsy.tier = tier; } function modifyHorseyDna(uint256 tokenId, bytes32 dna) public onlyMaster() { horseys[tokenId].dna = dna; } function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public onlyMaster() { horseys[tokenId].feedingCounter = feedingCounter; } function modifyHorseyTier(uint256 tokenId, uint8 tier) public onlyMaster() { horseys[tokenId].tier = tier; } function unstoreHorsey(uint256 tokenId) public onlyMaster() { require(_exists(tokenId),\"token not found\"); _burn(ownerOf(tokenId),tokenId); delete horseys[tokenId]; delete names[tokenId]; } /// @dev requires the address to be non null modifier validAddress(address addr) { require(addr != address(0),\"Address must be non zero\"); _; } /// @dev requires the caller to be the master modifier onlyMaster() { require(master == msg.sender,\"Address must be non zero\"); _; } } "}
{"sol name": "955.sol", "label": 0, "sol content": "pragma solidity 0.4.21; // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: contracts/IWasFirstServiceToken.sol contract IWasFirstServiceToken is StandardToken, Ownable { string public constant NAME = \"IWasFirstServiceToken\"; // solium-disable-line uppercase string public constant SYMBOL = \"IWF\"; // solium-disable-line uppercase uint8 public constant DECIMALS = 18; // solium-disable-line uppercase uint256 public constant INITIAL_SUPPLY = 10000000 * (10 ** uint256(DECIMALS)); address fungibleTokenAddress; address shareTokenAddress; /** * @dev Constructor that gives msg.sender all of existing tokens. */ function IWasFirstServiceToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } function getFungibleTokenAddress() public view returns (address) { return fungibleTokenAddress; } function setFungibleTokenAddress(address _address) onlyOwner() public { require(fungibleTokenAddress == address(0)); fungibleTokenAddress = _address; } function getShareTokenAddress() public view returns (address) { return shareTokenAddress; } function setShareTokenAddress(address _address) onlyOwner() public { require(shareTokenAddress == address(0)); shareTokenAddress = _address; } function transferByRelatedToken(address _from, address _to, uint256 _value) public returns (bool) { require(msg.sender == fungibleTokenAddress || msg.sender == shareTokenAddress); require(_to != address(0)); require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } } "}
{"sol name": "898.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract ERC20Token { uint256 public totalSupply; string public name; uint8 public decimals; string public symbol; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract LCToken is ERC20Token { function () public { require(false); } function LCToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits); balances[msg.sender] = totalSupply; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "963.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * ERC 20 token * * https://github.com/ethereum/EIPs/issues/20 */ contract MD  { using SafeMath for uint256; string public constant name = \"MD Token\"; string public constant symbol = \"MD\"; uint public constant decimals = 18; // Total supply is 3.5 billion uint256 _totalSupply = 3500000000 * 10**decimals; mapping(address => uint256) balances; //list of balance of each address mapping(address => mapping (address => uint256)) allowed; address public owner; modifier ownerOnly { require( msg.sender == owner, \"Sender not authorized.\" ); _; } function totalSupply() public view returns (uint256 supply) { return _totalSupply; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); //constructor constructor(address _owner) public{ owner = _owner; balances[owner] = _totalSupply; emit Transfer(0x0, _owner, _totalSupply); } /** * ERC 20 Standard Token interface transfer function * * Prevent transfers until lock period is over. */ function transfer(address _to, uint256 _value) public returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. if (balances[msg.sender] >= _value && balances[_to].add(_value) > balances[_to]) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } /** * ERC 20 Standard Token interface transfer function * * Prevent transfers until freeze period is over. */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to].add(_value) > balances[_to]) { balances[_to] = _value.add(balances[_to]); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } else { return false; } } /** * Change owner address (where ICO ETH is being forwarded). */ function changeOwner(address _newowner) public ownerOnly returns (bool success) { owner = _newowner; return true; } // only owner can kill function kill() public ownerOnly { selfdestruct(owner); } } "}
{"sol name": "446.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract lothlor { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1734.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Lyfecoin' token contract // // Deployed to : 0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e // Symbol      : LFC // Name        : Lyfecoin // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // Coding by Jarmo van de Seijp // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Lyfecoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Lyfecoin() public { symbol = \"LFC\"; name = \"Lyfecoin\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e] = _totalSupply; emit Transfer(address(0), 0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "719.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint256 a, uint256 b) public pure returns (uint256 c) { c = a + b; require(c >= a); } function safeSub(uint256 a, uint256 b) public pure returns (uint256 c) { require(b <= a); c = a - b; } function safeMul(uint256 a, uint256 b) public pure returns (uint256 c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint256 a, uint256 b) public pure returns (uint256 c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint256); function balanceOf(address tokenOwner) public constant returns (uint256 balance); function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining); function transfer(address to, uint256 tokens) public returns (bool success); function approve(address spender, uint256 tokens) public returns (bool success); function transferFrom(address from, address to, uint256 tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint256 tokens); event Approval(address indexed tokenOwner, address indexed spender, uint256 tokens); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; //address public newOwner; //event OwnershipTransferred(address indexed _from, address indexed _to); //event OwnershipTransferInitiated(address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } /* function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; OwnershipTransferInitiated(_newOwner); } function acceptOwnership() public { require(msg.sender == newOwner); owner = newOwner; OwnershipTransferred(owner, newOwner); newOwner = address(0); } function resetOwner() public onlyOwner{ newOwner = address(0); } */ } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract SatoExchange is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint256 public _totalSupply; mapping(address => uint256) internal balances; mapping (address => uint256) internal freezeOf; mapping(address => mapping(address => uint256)) internal allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function SatoExchange() public { symbol = 'SATX'; name = 'SatoExchange'; decimals = 8; _totalSupply = 30000000000000000; balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint256) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint256 balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint256 tokens) public returns (bool success) { if (to == 0x0) revert();                               // Prevent transfer to 0x0 address. Use burn() instead if (tokens <= 0) revert(); require(msg.sender != address(0) && msg.sender != to); require(to != address(0)); if (balances[msg.sender] < tokens) revert();           // Check if the sender has enough if (balances[to] + tokens < balances[to]) revert(); // Check for overflows balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint256 tokens) public returns (bool success) { require(tokens > 0); allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function burn(uint256 _value) public returns (bool success) { if (balances[msg.sender] < _value) revert();            // Check if the sender has enough if (_value <= 0) revert(); balances[msg.sender] = SafeMath.safeSub(balances[msg.sender], _value);                      // Subtract from the sender _totalSupply = SafeMath.safeSub(_totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } function freeze(uint256 _value) public returns (bool success) { if (balances[msg.sender] < _value) revert();            // Check if the sender has enough if (_value <= 0) revert(); balances[msg.sender] = SafeMath.safeSub(balances[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) public returns (bool success) { if (freezeOf[msg.sender] < _value) revert();            // Check if the sender has enough if (_value <= 0) revert(); freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balances[msg.sender] = SafeMath.safeAdd(balances[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint256 tokens) public returns (bool success) { if (to == 0x0) revert();                                // Prevent transfer to 0x0 address. Use burn() instead if (tokens <= 0) revert(); if (balances[from] < tokens) revert();                 // Check if the sender has enough if (balances[to] + tokens < balances[to]) revert();  // Check for overflows if (tokens > allowed[from][msg.sender]) revert();     // Check allowance balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint256 remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint256 tokens, bytes data) public returns (bool success) { require(tokens > 0); allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // can accept ether function() public payable { revert(); //disable receive ether } // transfer balance to owner /* function withdrawEther(uint256 amount)  public onlyOwner returns (bool success){ owner.transfer(amount); return true; }*/ // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint256 tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "841.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title LaraCrowdsale * @dev Crowdsale that locks tokens from withdrawal until it ends. */ contract LaraCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; // Map of all purchaiser's balances (doesn't include bounty amounts) mapping(address => uint256) public balances; // Amount of issued tokens uint256 public tokensIssued; // Bonus tokens rate multiplier x1000 (i.e. 1200 is 1.2 x 1000 = 120% x1000 = +20% bonus) uint256 public bonusMultiplier; // Is a crowdsale closed? bool public closed; /** * Event for token withdrawal logging * @param receiver who receive the tokens * @param amount amount of tokens sent */ event TokenDelivered(address indexed receiver, uint256 amount); /** * Event for token adding by referral program * @param beneficiary who got the tokens * @param amount amount of tokens added */ event TokenAdded(address indexed beneficiary, uint256 amount); /** * Init crowdsale by setting its params * * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold * @param _bonusMultiplier bonus tokens rate multiplier x1000 */ function LaraCrowdsale( uint256 _rate, address _wallet, ERC20 _token, uint256 _bonusMultiplier ) Crowdsale( _rate, _wallet, _token ) { bonusMultiplier = _bonusMultiplier; } /** * @dev Withdraw tokens only after crowdsale ends. */ function withdrawTokens() public { _withdrawTokensFor(msg.sender); } /** * @dev Overrides parent by storing balances instead of issuing tokens right away. * @param _beneficiary Token purchaser * @param _tokenAmount Amount of tokens purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { require(!hasClosed()); balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount); tokensIssued = tokensIssued.add(_tokenAmount); } /** * @dev Overrides the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate).mul(bonusMultiplier).div(1000); } /** * @dev Deliver tokens to receiver_ after crowdsale ends. */ function withdrawTokensFor(address receiver_) public onlyOwner { _withdrawTokensFor(receiver_); } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { return closed; } /** * @dev Closes the period in which the crowdsale is open. */ function closeCrowdsale(bool closed_) public onlyOwner { closed = closed_; } /** * @dev set the bonus multiplier. */ function setBonusMultiplier(uint256 bonusMultiplier_) public onlyOwner { bonusMultiplier = bonusMultiplier_; } /** * @dev set the rate for each stage. */ function setRate(uint256 rate_) public onlyOwner { rate = rate_; } /** * @dev set the wallet address in case of emergency. */ function setWallet(ERC20 wallet_) public onlyOwner { wallet = wallet_; } /** * @dev Withdraw tokens excess on the contract after crowdsale. */ function postCrowdsaleWithdraw(uint256 _tokenAmount) public onlyOwner { token.transfer(wallet, _tokenAmount); } /** * @dev Add tokens for specified beneficiary (referral system tokens, for example). * @param _beneficiary Token purchaser * @param _tokenAmount Amount of tokens added */ function addTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner { balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount); tokensIssued = tokensIssued.add(_tokenAmount); emit TokenAdded(_beneficiary, _tokenAmount); } /** * @dev Withdraw tokens for receiver_ after crowdsale ends. */ function _withdrawTokensFor(address receiver_) internal { require(hasClosed()); uint256 amount = balances[receiver_]; require(amount > 0); balances[receiver_] = 0; emit TokenDelivered(receiver_, amount); _deliverTokens(receiver_, amount); } } "}
{"sol name": "1941.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /* * Creator:GPH (Grapheneum) */ /* * Abstract Token Smart Contract * */ /* * Safe Math Smart Contract. * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * ERC-20 standard token interface, as defined * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>. */ contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * Abstract Token Smart Contract that could be used as a base contract for * ERC-20 token contracts. */ contract AbstractToken is Token, SafeMath { /** * Create new Abstract Token contract. */ function AbstractToken () { // Do nothing } /** * Get number of tokens currently belonging to given owner. * * @param _owner address to get number of tokens currently belonging to the *        owner of * @return number of tokens currently belonging to the owner of given address */ function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } /** * Transfer given number of tokens from message sender to given recipient. * * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } /** * Allow given spender to transfer given number of tokens from message sender. * @param _spender address to allow the owner of to transfer tokens from message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } /** * Tell how many tokens given spender is currently allowed to transfer from * given owner. * * @param _owner address to get number of tokens allowed to be transferred *        from the owner of * @param _spender address to get number of tokens allowed to be transferred *        by the owner of * @return number of tokens given spender is currently allowed to transfer *         from given owner */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } /** * Mapping from addresses of token holders to the numbers of tokens belonging * to these token holders. */ mapping (address => uint256) accounts; /** * Mapping from addresses of token holders to the mapping of addresses of * spenders to the allowances set by these token holders to these spenders. */ mapping (address => mapping (address => uint256)) private allowances; } /** * Grapheneum smart contract. */ contract GPHToken is AbstractToken { /** * Maximum allowed number of tokens in circulation. * tokenSupply = tokensIActuallyWant * (10 ^ decimals) */ uint256 constant MAX_TOKEN_COUNT = 500000000 * (10**18); /** * Address of the owner of this smart contract. */ address private owner; /** * Frozen account list holder */ mapping (address => bool) private frozenAccount; /** * Current number of tokens in circulation. */ uint256 tokenCount = 0; /** * True if tokens transfers are currently frozen, false otherwise. */ bool frozen = false; /** * Create new token smart contract and make msg.sender the * owner of this smart contract. */ function GPHToken () { owner = msg.sender; } /** * Get total number of tokens in circulation. * * @return total number of tokens in circulation */ function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"Grapheneum\"; string constant public symbol = \"GPH\"; uint8 constant public decimals = 18; /** * Transfer given number of tokens from message sender to given recipient. * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise */ function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } /** * Change how many tokens given spender is allowed to transfer from message * spender.  In order to prevent double spending of allowance, * To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender address to allow the owner of to transfer tokens from *        message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } /** * Create _value new tokens and give new created tokens to msg.sender. * May only be called by smart contract owner. * * @param _value number of tokens to create * @return true if tokens were created successfully, false otherwise */ function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); // adding transfer event and _from address as null address emit Transfer(0x0, msg.sender, _value); return true; } return false; } /** * Set new owner for the smart contract. * May only be called by smart contract owner. * * @param _newOwner address of new owner of the smart contract */ function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } /** * Freeze ALL token transfers. * May only be called by smart contract owner. */ function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } /** * Unfreeze ALL token transfers. * May only be called by smart contract owner. */ function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } /*A user is able to unintentionally send tokens to a contract * and if the contract is not prepared to refund them they will get stuck in the contract. * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to * prevent unintended Ether transfers. However, there\u2019s no such mechanism for token transfers. * so the below function is created */ function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } /** * Freeze specific account * May only be called by smart contract owner. */ function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } /** * Logged when token transfers were frozen. */ event Freeze (); /** * Logged when token transfers were unfrozen. */ event Unfreeze (); /** * Logged when a particular account is frozen. */ event FrozenFunds(address target, bool frozen); /** * when accidentally send other tokens are refunded */ event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "811.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } contract AirdropToken is BaseToken { uint256 public airAmount; uint256 public airBegintime; uint256 public airEndtime; address public airSender; uint32 public airLimitCount; mapping (address => uint32) public airCountOf; event Airdrop(address indexed from, uint32 indexed count, uint256 tokenValue); function airdrop() public payable { require(now >= airBegintime && now <= airEndtime); require(msg.value == 0); if (airLimitCount > 0 && airCountOf[msg.sender] >= airLimitCount) { revert(); } _transfer(airSender, msg.sender, airAmount); airCountOf[msg.sender] += 1; Airdrop(msg.sender, airCountOf[msg.sender], airAmount); } } contract CustomToken is BaseToken, BurnToken, AirdropToken { function CustomToken() public { totalSupply = 20000000000000000000000000000; name = 'DuduTechnology'; symbol = 'DUDU'; decimals = 18; balanceOf[0x828db0897afec00e04d77b4879082bcb7385a76a] = totalSupply; Transfer(address(0), 0x828db0897afec00e04d77b4879082bcb7385a76a, totalSupply); airAmount = 6666666600000000000000; airBegintime = 1520240400; airEndtime = 2215389600; airSender = 0xd686f4d45f96fb035de703206fc55fda8882d33b; airLimitCount = 1; } function() public payable { airdrop(); } } "}
{"sol name": "643.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT876984' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT876984 // Name        : ADZbuzz Arminvanbuuren.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT876984\"; name = \"ADZbuzz Arminvanbuuren.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1878.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: contracts/Ownable.sol /** * Copyright CENTRE SECZ 2018 * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is furnished to * do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract from https://github.com/zeppelinos/labs/blob/master/upgradeability_ownership/contracts/ownership/Ownable.sol * branch: master commit: 3887ab77b8adafba4a26ace002f3a684c1a3388b modified to: * 1) Add emit prefix to OwnershipTransferred event (7/13/18) * 2) Replace constructor with constructor syntax (7/13/18) * 3) consolidate OwnableStorage into this contract */ contract Ownable { // Owner of the contract address private _owner; /** * @dev Event to show ownership has been transferred * @param previousOwner representing the address of the previous owner * @param newOwner representing the address of the new owner */ event OwnershipTransferred(address previousOwner, address newOwner); /** * @dev The constructor sets the original owner of the contract to the sender account. */ constructor() public { setOwner(msg.sender); } /** * @dev Tells the address of the owner * @return the address of the owner */ function owner() public view returns (address) { return _owner; } /** * @dev Sets a new owner address */ function setOwner(address newOwner) internal { _owner = newOwner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner()); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner(), newOwner); setOwner(newOwner); } } // File: contracts/Blacklistable.sol /** * Copyright CENTRE SECZ 2018 * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is furnished to * do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.24; /** * @title Blacklistable Token * @dev Allows accounts to be blacklisted by a \"blacklister\" role */ contract Blacklistable is Ownable { address public blacklister; mapping(address => bool) internal blacklisted; event Blacklisted(address indexed _account); event UnBlacklisted(address indexed _account); event BlacklisterChanged(address indexed newBlacklister); /** * @dev Throws if called by any account other than the blacklister */ modifier onlyBlacklister() { require(msg.sender == blacklister); _; } /** * @dev Throws if argument account is blacklisted * @param _account The address to check */ modifier notBlacklisted(address _account) { require(blacklisted[_account] == false); _; } /** * @dev Checks if account is blacklisted * @param _account The address to check */ function isBlacklisted(address _account) public view returns (bool) { return blacklisted[_account]; } /** * @dev Adds account to blacklist * @param _account The address to blacklist */ function blacklist(address _account) public onlyBlacklister { blacklisted[_account] = true; emit Blacklisted(_account); } /** * @dev Removes account from blacklist * @param _account The address to remove from the blacklist */ function unBlacklist(address _account) public onlyBlacklister { blacklisted[_account] = false; emit UnBlacklisted(_account); } function updateBlacklister(address _newBlacklister) public onlyOwner { require(_newBlacklister != address(0)); blacklister = _newBlacklister; emit BlacklisterChanged(blacklister); } } // File: contracts/Pausable.sol /** * Copyright CENTRE SECZ 2018 * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is furnished to * do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.24; /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. * Based on openzeppelin tag v1.10.0 commit: feb665136c0dae9912e08397c1a21c4af3651ef3 * Modifications: * 1) Added pauser role, switched pause/unpause to be onlyPauser (6/14/2018) * 2) Removed whenNotPause/whenPaused from pause/unpause (6/14/2018) * 3) Removed whenPaused (6/14/2018) * 4) Switches ownable library to use zeppelinos (7/12/18) * 5) Remove constructor (7/13/18) */ contract Pausable is Ownable { event Pause(); event Unpause(); event PauserChanged(address indexed newAddress); address public pauser; bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev throws if called by any account other than the pauser */ modifier onlyPauser() { require(msg.sender == pauser); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyPauser public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyPauser public { paused = false; emit Unpause(); } /** * @dev update the pauser role */ function updatePauser(address _newPauser) onlyOwner public { require(_newPauser != address(0)); pauser = _newPauser; emit PauserChanged(pauser); } } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts/FiatTokenV1.sol /** * Copyright CENTRE SECZ 2018 * * Permission is hereby granted, free of charge, to any person obtaining a copy * of this software and associated documentation files (the \"Software\"), to deal * in the Software without restriction, including without limitation the rights * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell * copies of the Software, and to permit persons to whom the Software is furnished to * do so, subject to the following conditions: * * The above copyright notice and this permission notice shall be included in all * copies or substantial portions of the Software. * * THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN * CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE. */ pragma solidity ^0.4.24; /** * @title FiatToken * @dev ERC20 Token backed by fiat reserves */ contract FiatTokenV1 is Ownable, ERC20, Pausable, Blacklistable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; string public currency; address public masterMinter; bool internal initialized; mapping(address => uint256) internal balances; mapping(address => mapping(address => uint256)) internal allowed; uint256 internal totalSupply_ = 0; mapping(address => bool) internal minters; mapping(address => uint256) internal minterAllowed; event Mint(address indexed minter, address indexed to, uint256 amount); event Burn(address indexed burner, uint256 amount); event MinterConfigured(address indexed minter, uint256 minterAllowedAmount); event MinterRemoved(address indexed oldMinter); event MasterMinterChanged(address indexed newMasterMinter); function initialize( string _name, string _symbol, string _currency, uint8 _decimals, address _masterMinter, address _pauser, address _blacklister, address _owner ) public { require(!initialized); require(_masterMinter != address(0)); require(_pauser != address(0)); require(_blacklister != address(0)); require(_owner != address(0)); name = _name; symbol = _symbol; currency = _currency; decimals = _decimals; masterMinter = _masterMinter; pauser = _pauser; blacklister = _blacklister; setOwner(_owner); initialized = true; } /** * @dev Throws if called by any account other than a minter */ modifier onlyMinters() { require(minters[msg.sender] == true); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. Must be less than or equal to the minterAllowance of the caller. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) whenNotPaused onlyMinters notBlacklisted(msg.sender) notBlacklisted(_to) public returns (bool) { require(_to != address(0)); require(_amount > 0); uint256 mintingAllowedAmount = minterAllowed[msg.sender]; require(_amount <= mintingAllowedAmount); totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); minterAllowed[msg.sender] = mintingAllowedAmount.sub(_amount); emit Mint(msg.sender, _to, _amount); emit Transfer(0x0, _to, _amount); return true; } /** * @dev Throws if called by any account other than the masterMinter */ modifier onlyMasterMinter() { require(msg.sender == masterMinter); _; } /** * @dev Get minter allowance for an account * @param minter The address of the minter */ function minterAllowance(address minter) public view returns (uint256) { return minterAllowed[minter]; } /** * @dev Checks if account is a minter * @param account The address to check */ function isMinter(address account) public view returns (bool) { return minters[account]; } /** * @dev Get allowed amount for an account * @param owner address The account owner * @param spender address The account spender */ function allowance(address owner, address spender) public view returns (uint256) { return allowed[owner][spender]; } /** * @dev Get totalSupply of token */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Get token balance of an account * @param account address The account */ function balanceOf(address account) public view returns (uint256) { return balances[account]; } /** * @dev Adds blacklisted check to approve * @return True if the operation was successful. */ function approve(address _spender, uint256 _value) whenNotPaused notBlacklisted(msg.sender) notBlacklisted(_spender) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another. * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred * @return bool success */ function transferFrom(address _from, address _to, uint256 _value) whenNotPaused notBlacklisted(_to) notBlacklisted(msg.sender) notBlacklisted(_from) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. * @return bool success */ function transfer(address _to, uint256 _value) whenNotPaused notBlacklisted(msg.sender) notBlacklisted(_to) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Function to add/update a new minter * @param minter The address of the minter * @param minterAllowedAmount The minting amount allowed for the minter * @return True if the operation was successful. */ function configureMinter(address minter, uint256 minterAllowedAmount) whenNotPaused onlyMasterMinter public returns (bool) { minters[minter] = true; minterAllowed[minter] = minterAllowedAmount; emit MinterConfigured(minter, minterAllowedAmount); return true; } /** * @dev Function to remove a minter * @param minter The address of the minter to remove * @return True if the operation was successful. */ function removeMinter(address minter) onlyMasterMinter public returns (bool) { minters[minter] = false; minterAllowed[minter] = 0; emit MinterRemoved(minter); return true; } /** * @dev allows a minter to burn some of its own tokens * Validates that caller is a minter and that sender is not blacklisted * amount is less than or equal to the minter's account balance * @param _amount uint256 the amount of tokens to be burned */ function burn(uint256 _amount) whenNotPaused onlyMinters notBlacklisted(msg.sender) public { uint256 balance = balances[msg.sender]; require(_amount > 0); require(balance >= _amount); totalSupply_ = totalSupply_.sub(_amount); balances[msg.sender] = balance.sub(_amount); emit Burn(msg.sender, _amount); emit Transfer(msg.sender, address(0), _amount); } function updateMasterMinter(address _newMasterMinter) onlyOwner public { require(_newMasterMinter != address(0)); masterMinter = _newMasterMinter; emit MasterMinterChanged(masterMinter); } } "}
{"sol name": "761.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract MultiTransfer { function MultiTransfer() public { } function transfer(address token, address owner,address[] to, uint[] value) public { require(to.length == value.length); require(token != address(0)); ERC20 t = ERC20(token); for (uint i = 0; i < to.length; i++) { t.transferFrom(owner, to[i], value[i]); } } } "}
{"sol name": "901.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic  is Ownable { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ITGCToken is StandardToken { string  public name = \"Itgolds\"; string  public symbol = \"ITGC\"; uint8   public decimals = 8; uint    public totalSupply = (20 * 10 ** 8 + 50) * 10 ** 8; constructor() public { balances[msg.sender] = totalSupply; } function setName(string _name) public onlyOwner { name = _name; } function setSymbol(string _symbol) public onlyOwner { symbol = _symbol; } } "}
{"sol name": "802.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); uint256 c = _a / _b; return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function increaseApproval(address _spender, uint256 _addedValue) public returns (bool) { allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract HiBTCToken is PausableToken { string public constant name = \"HiBTCToken\"; string public constant symbol = \"HIBT\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "683.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { if (msg.sender != owner) { require(!paused); } _; } modifier whenPaused() { if (msg.sender != owner) { require(paused); } _; } function pause() onlyOwner public { paused = true; emit Pause(); } function unpause() onlyOwner public { paused = false; emit Unpause(); } } library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { if (a == 0) { return 0; } uint c = a * b; assert(c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } } contract ERC20 { string public name; string public symbol; uint8 public decimals; uint public totalSupply; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } function balanceOf(address who) public view returns (uint); function transfer(address to, uint value) public returns (bool); function allowance(address owner, address spender) public view returns (uint); function transferFrom(address from, address to, uint value) public returns (bool); function approve(address spender, uint value) public returns (bool); event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract Token is Pausable, ERC20 { using SafeMath for uint; event Burn(address indexed burner, uint256 value); mapping(address => uint) balances; mapping (address => mapping (address => uint)) internal allowed; mapping(address => uint) public balanceOfLocked; mapping(address => bool) public addressLocked; constructor() ERC20(\"OCP\", \"OCP\", 18) public { totalSupply = 10000000000 * 10 ** uint(decimals); balances[msg.sender] = totalSupply; } modifier lockCheck(address from, uint value) { require(addressLocked[from] == false); require(balances[from] >= balanceOfLocked[from]); require(value <= balances[from] - balanceOfLocked[from]); _; } function burn(uint _value) onlyOwner public { balances[owner] = balances[owner].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(msg.sender, _value); } function lockAddressValue(address _addr, uint _value) onlyOwner public { balanceOfLocked[_addr] = _value; } function lockAddress(address addr) onlyOwner public { addressLocked[addr] = true; } function unlockAddress(address addr) onlyOwner public { addressLocked[addr] = false; } function transfer(address _to, uint _value) lockCheck(msg.sender, _value) whenNotPaused public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint _value) public lockCheck(_from, _value) whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } "}
{"sol name": "379.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract MB { string public name = \"MircoChain\"; string public symbol = \"MB\"; uint public decimals = 18; uint public INITIAL_SUPPLY = 100000000000000000000000000000; mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint256 public _totalSupply; address public _creator; bool bIsFreezeAll = false; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function totalSupply() public constant returns (uint256 total) { total = _totalSupply; } function transfer(address _to, uint _value) public returns (bool success) { require(bIsFreezeAll == false); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { require(bIsFreezeAll == false); var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) public returns (bool success) { require(bIsFreezeAll == false); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint remaining) { return allowed[_owner][_spender]; } function freezeAll() public { require(msg.sender == _creator); bIsFreezeAll = !bIsFreezeAll; } function MB() public { _totalSupply = INITIAL_SUPPLY; _creator = 0xf2F91C1C681816eE275ce9b4366D5a906da6eBf5; balances[_creator] = INITIAL_SUPPLY; bIsFreezeAll = false; } function destroy() public  { require(msg.sender == _creator); selfdestruct(_creator); } } "}
{"sol name": "355.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/PeopleWaveToken.sol contract PeopleWaveToken is StandardToken { string public constant name = \"PeopleWave Token\"; string public constant symbol = \"PPL\"; uint8 public constant decimals = 18; uint public constant initialSupply = 1200000000000000000000000000; constructor() public { totalSupply_ = initialSupply; balances[msg.sender] = initialSupply; } } "}
{"sol name": "900.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: contracts/TxRegistry.sol /** * @title Transaction Registry for Customer * @dev Registry of customer's payments for MCW and payments for KWh. */ contract TxRegistry is Ownable { address public customer; // @dev Structure for TX data struct TxData { bytes32 txOrigMcwTransfer; uint256 amountMCW; uint256 amountKWh; uint256 timestampPaymentMCW; bytes32 txPaymentKWh; uint256 timestampPaymentKWh; } // @dev Customer's Tx of payment for MCW registry mapping (bytes32 => TxData) private txRegistry; // @dev Customer's list of Tx bytes32[] private txIndex; /** * @dev Constructor * @param _customer the address of a customer for whom the TxRegistry contract is creating */ constructor(address _customer) public { customer = _customer; } /** * @dev Owner can add a new Tx of payment for MCW to the customer's TxRegistry * @param _txPaymentForMCW the Tx of payment for MCW which will be added * @param _txOrigMcwTransfer the Tx of original MCW transfer in Ethereum network which acts as source for this Tx of payment for MCW * @param _amountMCW the amount of MCW tokens which will be recorded to the new Tx * @param _amountKWh the amount of KWh which will be recorded to the new Tx * @param _timestamp the timestamp of payment for MCW which will be recorded to the new Tx */ function addTxToRegistry( bytes32 _txPaymentForMCW, bytes32 _txOrigMcwTransfer, uint256 _amountMCW, uint256 _amountKWh, uint256 _timestamp ) public onlyOwner returns(bool) { require( _txPaymentForMCW != 0 && _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0 && _timestamp != 0, \"All parameters must be not empty.\" ); require( txRegistry[_txPaymentForMCW].timestampPaymentMCW == 0, \"Tx with such hash is already exist.\" ); txRegistry[_txPaymentForMCW].txOrigMcwTransfer = _txOrigMcwTransfer; txRegistry[_txPaymentForMCW].amountMCW = _amountMCW; txRegistry[_txPaymentForMCW].amountKWh = _amountKWh; txRegistry[_txPaymentForMCW].timestampPaymentMCW = _timestamp; txIndex.push(_txPaymentForMCW); return true; } /** * @dev Owner can mark a customer's Tx of payment for MCW as spent * @param _txPaymentForMCW the Tx of payment for MCW which will be marked as spent * @param _txPaymentForKWh the additional Tx of payment for KWh which will be recorded to the original Tx as proof of spend * @param _timestamp the timestamp of payment for KWh which will be recorded to the Tx */ function setTxAsSpent(bytes32 _txPaymentForMCW, bytes32 _txPaymentForKWh, uint256 _timestamp) public onlyOwner returns(bool) { require( _txPaymentForMCW != 0 && _txPaymentForKWh != 0 && _timestamp != 0, \"All parameters must be not empty.\" ); require( txRegistry[_txPaymentForMCW].timestampPaymentMCW != 0, \"Tx with such hash doesn't exist.\" ); require( txRegistry[_txPaymentForMCW].timestampPaymentKWh == 0, \"Tx with such hash is already spent.\" ); txRegistry[_txPaymentForMCW].txPaymentKWh = _txPaymentForKWh; txRegistry[_txPaymentForMCW].timestampPaymentKWh = _timestamp; return true; } /** * @dev Get the customer's Tx of payment for MCW amount */ function getTxCount() public view returns(uint256) { return txIndex.length; } /** * @dev Get the customer's Tx of payment for MCW from customer's Tx list by index * @param _index the index of a customer's Tx of payment for MCW in the customer's Tx list */ function getTxAtIndex(uint256 _index) public view returns(bytes32) { return txIndex[_index]; } /** * @dev Get the customer's Tx of payment for MCW data - Tx of original MCW transfer in Ethereum network which is recorded in the Tx * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getTxOrigMcwTransfer(bytes32 _txPaymentForMCW) public view returns(bytes32) { return txRegistry[_txPaymentForMCW].txOrigMcwTransfer; } /** * @dev Get the customer's Tx of payment for MCW data - amount of MCW tokens which is recorded in the Tx * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getTxAmountMCW(bytes32 _txPaymentForMCW) public view returns(uint256) { return txRegistry[_txPaymentForMCW].amountMCW; } /** * @dev Get the customer's Tx of payment for MCW data - amount of KWh which is recorded in the Tx * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getTxAmountKWh(bytes32 _txPaymentForMCW) public view returns(uint256) { return txRegistry[_txPaymentForMCW].amountKWh; } /** * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for MCW which is recorded in the Tx * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getTxTimestampPaymentMCW(bytes32 _txPaymentForMCW) public view returns(uint256) { return txRegistry[_txPaymentForMCW].timestampPaymentMCW; } /** * @dev Get the customer's Tx of payment for MCW data - Tx of payment for KWh which is recorded in the Tx * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getTxPaymentKWh(bytes32 _txPaymentForMCW) public view returns(bytes32) { return txRegistry[_txPaymentForMCW].txPaymentKWh; } /** * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for KWh which is recorded in the Tx * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getTxTimestampPaymentKWh(bytes32 _txPaymentForMCW) public view returns(uint256) { return txRegistry[_txPaymentForMCW].timestampPaymentKWh; } /** * @dev Check the customer's Tx of payment for MCW * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked */ function isValidTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) { bool isValid = false; if (txRegistry[_txPaymentForMCW].timestampPaymentMCW != 0) { isValid = true; } return isValid; } /** * @dev Check if the customer's Tx of payment for MCW is spent * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked */ function isSpentTxPaymentForMCW(bytes32 _txPaymentForMCW) public view returns(bool) { bool isSpent = false; if (txRegistry[_txPaymentForMCW].timestampPaymentKWh != 0) { isSpent = true; } return isSpent; } /** * @dev Check the customer's Tx of payment for KWh * @param _txPaymentForKWh the Tx of payment for KWh which need to be checked */ function isValidTxPaymentForKWh(bytes32 _txPaymentForKWh) public view returns(bool) { bool isValid = false; for (uint256 i = 0; i < getTxCount(); i++) { if (txRegistry[getTxAtIndex(i)].txPaymentKWh == _txPaymentForKWh) { isValid = true; break; } } return isValid; } /** * @dev Get the customer's Tx of payment for MCW by Tx payment for KWh * @param _txPaymentForKWh the Tx of payment for KWh */ function getTxPaymentMCW(bytes32 _txPaymentForKWh) public view returns(bytes32) { bytes32 txMCW = 0; for (uint256 i = 0; i < getTxCount(); i++) { if (txRegistry[getTxAtIndex(i)].txPaymentKWh == _txPaymentForKWh) { txMCW = getTxAtIndex(i); break; } } return txMCW; } } // File: contracts/McwCustomerRegistry.sol /** * @title Customers Registry * @dev Registry of all customers */ contract McwCustomerRegistry is Ownable { // @dev Key: address of customer wallet, Value: address of customer TxRegistry contract mapping (address => address) private registry; // @dev Customers list address[] private customerIndex; // @dev Events for dashboard event NewCustomer(address indexed customer, address indexed txRegistry); event NewCustomerTx( address indexed customer, bytes32 txPaymentForMCW, bytes32 txOrigMcwTransfer, uint256 amountMCW, uint256 amountKWh, uint256 timestamp ); event SpendCustomerTx(address indexed customer, bytes32 txPaymentForMCW, bytes32 txPaymentForKWh, uint256 timestamp); // @dev Constructor constructor() public {} /** * @dev Owner can add a new customer to registry * @dev Creates a related TxRegistry contract for the new customer * @dev Related event will be generated * @param _customer the address of a new customer to add */ function addCustomerToRegistry(address _customer) public onlyOwner returns(bool) { require( _customer != address(0), \"Parameter must be not empty.\" ); require( registry[_customer] == address(0), \"Customer is already in the registry.\" ); address txRegistry = new TxRegistry(_customer); registry[_customer] = txRegistry; customerIndex.push(_customer); emit NewCustomer(_customer, txRegistry); return true; } /** * @dev Owner can add a new Tx of payment for MCW to the customer's TxRegistry * @dev Generates the Tx of payment for MCW (hash as proof of payment) and writes the Tx data to the customer's TxRegistry * @dev Related event will be generated * @param _customer the address of a customer to whom to add a new Tx * @param _txOrigMcwTransfer the Tx of original MCW transfer in Ethereum network which acts as source for a new Tx of payment for MCW * @param _amountMCW the amount of MCW tokens which will be recorded to the new Tx * @param _amountKWh the amount of KWh which will be recorded to the new Tx */ function addTxToCustomerRegistry( address _customer, bytes32 _txOrigMcwTransfer, uint256 _amountMCW, uint256 _amountKWh ) public onlyOwner returns(bool) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txOrigMcwTransfer != 0 && _amountMCW != 0 && _amountKWh != 0, \"All parameters must be not empty.\" ); uint256 timestamp = now; bytes32 txPaymentForMCW = keccak256( abi.encodePacked( _customer, _amountMCW, _amountKWh, timestamp) ); TxRegistry txRegistry = TxRegistry(registry[_customer]); require( txRegistry.getTxTimestampPaymentMCW(txPaymentForMCW) == 0, \"Tx with such hash is already exist.\" ); if (!txRegistry.addTxToRegistry( txPaymentForMCW, _txOrigMcwTransfer, _amountMCW, _amountKWh, timestamp)) revert (\"Something went wrong.\"); emit NewCustomerTx( _customer, txPaymentForMCW, _txOrigMcwTransfer, _amountMCW, _amountKWh, timestamp); return true; } /** * @dev Owner can mark a customer's Tx of payment for MCW as spent * @dev Generates an additional Tx of paymant for KWh (hash as proof of spend), which connected to the original Tx. * @dev Related event will be generated * @param _customer the address of a customer to whom to spend a Tx * @param _txPaymentForMCW the Tx of payment for MCW which will be marked as spent */ function setCustomerTxAsSpent(address _customer, bytes32 _txPaymentForMCW) public onlyOwner returns(bool) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); require( txRegistry.getTxTimestampPaymentMCW(_txPaymentForMCW) != 0, \"Tx with such hash doesn't exist.\" ); require( txRegistry.getTxTimestampPaymentKWh(_txPaymentForMCW) == 0, \"Tx with such hash is already spent.\" ); uint256 timestamp = now; bytes32 txPaymentForKWh = keccak256( abi.encodePacked( _txPaymentForMCW, timestamp) ); if (!txRegistry.setTxAsSpent(_txPaymentForMCW, txPaymentForKWh, timestamp)) revert (\"Something went wrong.\"); emit SpendCustomerTx( _customer, _txPaymentForMCW, txPaymentForKWh, timestamp); return true; } /** * @dev Get the current amount of customers */ function getCustomerCount() public view returns(uint256) { return customerIndex.length; } /** * @dev Get the customer's address from customers list by index * @param _index the index of a customer in the customers list */ function getCustomerAtIndex(uint256 _index) public view returns(address) { return customerIndex[_index]; } /** * @dev Get the customer's TxRegistry contract * @param _customer the address of a customer for whom to get TxRegistry contract */ function getCustomerTxRegistry(address _customer) public view returns(address) { return registry[_customer]; } /** * @dev Check the customer's address * @param _customer the address of a customer which need to be checked */ function isValidCustomer(address _customer) public view returns(bool) { require( _customer != address(0), \"Parameter must be not empty.\" ); bool isValid = false; address txRegistry = registry[_customer]; if (txRegistry != address(0)) { isValid = true; } return isValid; } // wrappers on TxRegistry contract /** * @dev Get the customer's Tx of payment for MCW amount * @param _customer the address of a customer for whom to get */ function getCustomerTxCount(address _customer) public view returns(uint256) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); uint256 txCount = txRegistry.getTxCount(); return txCount; } /** * @dev Get the customer's Tx of payment for MCW from customer's Tx list by index * @param _customer the address of a customer for whom to get * @param _index the index of a customer's Tx of payment for MCW in the customer's Tx list */ function getCustomerTxAtIndex(address _customer, uint256 _index) public view returns(bytes32) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bytes32 txIndex = txRegistry.getTxAtIndex(_index); return txIndex; } /** * @dev Get the customer's Tx of payment for MCW data - Tx of original MCW transfer in Ethereum network which is recorded in the Tx * @param _customer the address of a customer for whom to get * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getCustomerTxOrigMcwTransfer(address _customer, bytes32 _txPaymentForMCW) public view returns(bytes32) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bytes32 txOrigMcwTransfer = txRegistry.getTxOrigMcwTransfer(_txPaymentForMCW); return txOrigMcwTransfer; } /** * @dev Get the customer's Tx of payment for MCW data - amount of MCW tokens which is recorded in the Tx * @param _customer the address of a customer for whom to get * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getCustomerTxAmountMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); uint256 amountMCW = txRegistry.getTxAmountMCW(_txPaymentForMCW); return amountMCW; } /** * @dev Get the customer's Tx of payment for MCW data - amount of KWh which is recorded in the Tx * @param _customer the address of a customer for whom to get * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getCustomerTxAmountKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); uint256 amountKWh = txRegistry.getTxAmountKWh(_txPaymentForMCW); return amountKWh; } /** * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for MCW which is recorded in the Tx * @param _customer the address of a customer for whom to get * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getCustomerTxTimestampPaymentMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); uint256 timestampPaymentMCW = txRegistry.getTxTimestampPaymentMCW(_txPaymentForMCW); return timestampPaymentMCW; } /** * @dev Get the customer's Tx of payment for MCW data - Tx of payment for KWh which is recorded in the Tx * @param _customer the address of a customer for whom to get * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getCustomerTxPaymentKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(bytes32) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bytes32 txPaymentKWh = txRegistry.getTxPaymentKWh(_txPaymentForMCW); return txPaymentKWh; } /** * @dev Get the customer's Tx of payment for MCW data - timestamp of payment for KWh which is recorded in the Tx * @param _customer the address of a customer for whom to get * @param _txPaymentForMCW the Tx of payment for MCW for which to get data */ function getCustomerTxTimestampPaymentKWh(address _customer, bytes32 _txPaymentForMCW) public view returns(uint256) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); uint256 timestampPaymentKWh = txRegistry.getTxTimestampPaymentKWh(_txPaymentForMCW); return timestampPaymentKWh; } /** * @dev Check the customer's Tx of payment for MCW * @param _customer the address of a customer for whom to check * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked */ function isValidCustomerTxPaymentForMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(bool) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bool isValid = txRegistry.isValidTxPaymentForMCW(_txPaymentForMCW); return isValid; } /** * @dev Check if the customer's Tx of payment for MCW is spent * @param _customer the address of a customer for whom to check * @param _txPaymentForMCW the Tx of payment for MCW which need to be checked */ function isSpentCustomerTxPaymentForMCW(address _customer, bytes32 _txPaymentForMCW) public view returns(bool) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForMCW != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bool isSpent = txRegistry.isSpentTxPaymentForMCW(_txPaymentForMCW); return isSpent; } /** * @dev Check the customer's Tx of payment for KWh * @param _customer the address of a customer for whom to check * @param _txPaymentForKWh the Tx of payment for KWh which need to be checked */ function isValidCustomerTxPaymentForKWh(address _customer, bytes32 _txPaymentForKWh) public view returns(bool) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForKWh != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bool isValid = txRegistry.isValidTxPaymentForKWh(_txPaymentForKWh); return isValid; } /** * @dev Get the customer's Tx of payment for MCW by Tx payment for KWh * @param _customer the address of a customer for whom to get * @param _txPaymentForKWh the Tx of payment for KWh */ function getCustomerTxPaymentMCW(address _customer, bytes32 _txPaymentForKWh) public view returns(bytes32) { require( isValidCustomer(_customer), \"Customer is not in the registry.\" ); require( _txPaymentForKWh != bytes32(0), \"Parameter must be not empty.\" ); TxRegistry txRegistry = TxRegistry(registry[_customer]); bytes32 txMCW = txRegistry.getTxPaymentMCW(_txPaymentForKWh); return txMCW; } } "}
{"sol name": "579.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract Planethereum  { string public name = \"Planethereum \";      //  token name string public symbol = \"PLNX\";           //  token symbol uint256 public decimals = 6;            //  token digit mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 21000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; } modifier isRunning { assert (!stopped); _; } modifier validAddress { assert(0x0 != msg.sender); _; } function Planethereum(address _addressFounder) { owner = msg.sender; totalSupply = valueFounder; balanceOf[_addressFounder] = valueFounder; Transfer(0x0, _addressFounder, valueFounder); } function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) { require(balanceOf[msg.sender] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) isRunning validAddress returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function stop() isOwner { stopped = true; } function start() isOwner { stopped = false; } function setName(string _name) isOwner { name = _name; } function burn(uint256 _value) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; Transfer(msg.sender, 0x0, _value); } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } "}
{"sol name": "1647.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TheGlobalBusinessChain { // Public variables of the token string public name; string public symbol; uint8 public decimals = 2; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = 100000000000;  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"TheGlobalBusinessChain\";                                   // Set the name for display purposes symbol = \"TGBC\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1930.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract GoatCash is StandardToken { string public name = \"GoatCash\"; string public symbol = \"GOAT\"; uint public decimals = 18; uint public INITIAL_SUPPLY = 450000000 * (10 ** decimals); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "1957.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract DeepToken is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function DeepToken() { totalSupply = 100*(10**8)*(10**18); balanceOf[msg.sender] = 100*(10**8)*(10**18);              // Give the creator all initial tokens name = \"DeepToken\";                                   // Set the name for display purposes symbol = \"DPT\";                               // Set the symbol for display purposes decimals = 18;                            // Amount of decimals for display purposes } /* Send coins */ function transfer(address _to, uint256 _value) { if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows if (_value > allowance[_from][msg.sender]) throw;     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } function freeze(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) returns (bool success) { if (freezeOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } // transfer balance to owner function withdrawEther(uint256 amount) { if(msg.sender != owner)throw; owner.transfer(amount); } // can accept ether function() payable { } } "}
{"sol name": "642.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // '0Vilz' token contract // // Deployed to : 0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A // Symbol      : 0VILZ // Name        : 0 Vilz Token // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract VilzToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function VilzToken() public { symbol = \"0VILZ\"; name = \"0 Vilz Token\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A] = _totalSupply; Transfer(address(0), 0x13c536BA3E45BE2bB79914D333b3fa95E9728E3A, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "49.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * SmartEth.co * ERC20 Token and ICO smart contracts development, smart contracts audit, ICO websites. * [email\u00a0protected] */ /** * @title Ownable */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = 0xbc0af2ca6846d835789e5c20282f15275af34fe4; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Airdrop is Ownable { ERC20 public token = ERC20(0xb09830db5B21167A5a27969aC3Ab01B129cf41a1); function airdrop(address[] recipient, uint256[] amount) public onlyOwner returns (uint256) { uint256 i = 0; while (i < recipient.length) { token.transfer(recipient[i], amount[i]); i += 1; } return(i); } function airdropSameAmount(address[] recipient, uint256 amount) public onlyOwner returns (uint256) { uint256 i = 0; while (i < recipient.length) { token.transfer(recipient[i], amount); i += 1; } return(i); } } "}
{"sol name": "1948.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Karma' token contract // // Deployed to : 0x62e8301aa4090329c8bd922fcf165e0063cf42d6 // Symbol      : KMAC // Name        : Karma Token // Total supply: 10000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract KarmaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function KarmaToken() public { symbol = \"KMAC\"; name = \"Karma Token\"; decimals = 18; _totalSupply = 10000000000000000000000000000 ; balances[0x2fD1fd25eE243103179bd046777928b0f4882E1A] = _totalSupply; Transfer(address(0), 0x2fD1fd25eE243103179bd046777928b0f4882E1A, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1838.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract UNGTToken is TokenERC20 { /* Initializes contract with initial supply tokens to the creator of the contract */ function UNGTToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} } "}
{"sol name": "1898.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract IERC20Token { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value)  public returns (bool success); function transferFrom(address _from, address _to, uint256 _value)  public returns (bool success); function approve(address _spender, uint256 _value)  public returns (bool success); function allowance(address _owner, address _spender)  public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address previousOwner, address newOwner); constructor(address _owner) public { owner = _owner == address(0) ? msg.sender : _owner; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != owner); newOwner = _newOwner; } function confirmOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = 0x0; } } contract AbyssBatchTransfer is Ownable { IERC20Token public token; constructor(address tokenAddress, address ownerAddress) public Ownable(ownerAddress) { token = IERC20Token(tokenAddress); } function batchTransfer(address[] recipients, uint256[] amounts) public onlyOwner { require(recipients.length == amounts.length); for(uint i = 0; i < recipients.length; i++) { require(token.transfer(recipients[i], amounts[i])); } } } "}
{"sol name": "351.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract CustomToken is BaseToken { function CustomToken() public { totalSupply = 10000000000000; name = 'Almighty Diamonds'; symbol = 'ADP'; decimals = 4; balanceOf[0x5ebc4B61A0E0187d9a72Da21bfb8b45F519cb530] = totalSupply; Transfer(address(0), 0x5ebc4B61A0E0187d9a72Da21bfb8b45F519cb530, totalSupply); } } "}
{"sol name": "5.sol", "label": 0, "sol content": "pragma solidity 0.4.24; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnboundedRegularToken is RegularToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract LingYanToken is UnboundedRegularToken { uint public totalSupply = 100000000000000000000000000; uint8 constant public decimals = 18; string constant public name = \"LingYanToken\"; string constant public symbol = \"LY\"; function LingYanToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "1889.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title The STT Token contract. * * By Nikita Fuchs * Credit: Taking ideas from BAT token, NET token and Nimiq token. */ /** * @title Safe math operations that throw error on overflow. * * Credit: Taking ideas from FirstBlood token */ library SafeMath { /** * @dev Safely add two numbers. * * @param x First operant. * @param y Second operant. * @return The result of x+y. */ function add(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; } /** * @dev Safely substract two numbers. * * @param x First operant. * @param y Second operant. * @return The result of x-y. */ function sub(uint256 x, uint256 y) internal pure returns(uint256) { assert(x >= y); uint256 z = x - y; return z; } /** * @dev Safely multiply two numbers. * * @param x First operant. * @param y Second operant. * @return The result of x*y. */ function mul(uint256 x, uint256 y) internal pure returns(uint256) { uint256 z = x * y; assert((x == 0) || (z/x == y)); return z; } } /** * @title The abstract ERC-20 Token Standard definition. * * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md */ contract Token { /// @dev Returns the total token supply. uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); /// @dev MUST trigger when tokens are transferred, including zero value transfers. event Transfer(address indexed _from, address indexed _to, uint256 _value); /// @dev MUST trigger on any successful call to approve(address _spender, uint256 _value). event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * @title Default implementation of the ERC-20 Token Standard. */ contract StandardToken is Token { mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfers _value amount of tokens to address _to, and MUST fire the Transfer event. * @dev The function SHOULD throw if the _from account balance does not have enough tokens to spend. * * @dev A token contract which creates new tokens SHOULD trigger a Transfer event with the _from address set to 0x0 when tokens are created. * * Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event. * * @param _to The receiver of the tokens. * @param _value The amount of tokens to send. * @return True on success, false otherwise. */ function transfer(address _to, uint256 _value) public returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } /** * @dev Transfers _value amount of tokens from address _from to address _to, and MUST fire the Transfer event. * * @dev The transferFrom method is used for a withdraw workflow, allowing contracts to transfer tokens on your behalf. * @dev This can be used for example to allow a contract to transfer tokens on your behalf and/or to charge fees in * @dev sub-currencies. The function SHOULD throw unless the _from account has deliberately authorized the sender of * @dev the message via some mechanism. * * Note Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event. * * @param _from The sender of the tokens. * @param _to The receiver of the tokens. * @param _value The amount of tokens to send. * @return True on success, false otherwise. */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0 && balances[_to] + _value > balances[_to]) { balances[_to] = SafeMath.add(balances[_to], _value); balances[_from] = SafeMath.sub(balances[_from], _value); allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value); emit Transfer(_from, _to, _value); return true; } else { return false; } } /** * @dev Returns the account balance of another account with address _owner. * * @param _owner The address of the account to check. * @return The account balance. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev Allows _spender to withdraw from your account multiple times, up to the _value amount. * @dev If this function is called again it overwrites the current allowance with _value. * * @dev NOTE: To prevent attack vectors like the one described in [1] and discussed in [2], clients * @dev SHOULD make sure to create user interfaces in such a way that they set the allowance first * @dev to 0 before setting it to another value for the same spender. THOUGH The contract itself * @dev shouldn't enforce it, to allow backwards compatilibilty with contracts deployed before. * @dev [1] https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/ * @dev [2] https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. * @return True on success, false otherwise. */ function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Returns the amount which _spender is still allowed to withdraw from _owner. * * @param _owner The address of the sender. * @param _spender The address of the receiver. * @return The allowed withdrawal amount. */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract RelocationToken { // function of possible new contract to recieve tokenbalance to relocate - to be protected by msg.sender == StarambaToken function recieveRelocation(address _creditor, uint _balance) external returns (bool); } /*is StandardToken */ contract StarambaToken is StandardToken { // Token metadata string public constant name = \"STARAMBA.Token\"; string public constant symbol = \"STT\"; uint256 public constant decimals = 18; string public constant version = \"1\"; uint256 public TOKEN_CREATION_CAP = 1000 * (10**6) * 10**decimals; // 1000 million STTs uint256 public constant TOKEN_MIN = 1 * 10**decimals;              // 1 STT address public STTadmin1;      // First administrator for multi-sig mechanism address public STTadmin2;      // Second administrator for multi-sig mechanism // Contracts current state (transactions still paused during sale or already publicly available) bool public transactionsActive; // Indicate if the token is in relocation mode bool public relocationActive; address public newTokenContractAddress; // How often was the supply adjusted ? (See STT Whitepaper Version 1.0 from 23. May 2018 ) uint8 supplyAdjustmentCount = 0; // Keep track of holders and icoBuyers mapping (address => bool) public isHolder; // track if a user is a known token holder to the smart contract - important for payouts later address[] public holders;                  // array of all known holders - important for payouts later // Store the hashes of admins' msg.data mapping (address => bytes32) private multiSigHashes; // Declare vendor keys mapping (address => bool) public vendors; // Count amount of vendors for easier verification of correct contract deployment uint8 public vendorCount; // Events used for logging event LogDeliverSTT(address indexed _to, uint256 _value); //event Log modifier onlyVendor() { require(vendors[msg.sender] == true); _; } modifier isTransferable() { require (transactionsActive == true); _; } modifier onlyOwner() { // check if transaction sender is admin. require (msg.sender == STTadmin1 || msg.sender == STTadmin2); // if yes, store his msg.data. multiSigHashes[msg.sender] = keccak256(msg.data); // check if his stored msg.data hash equals to the one of the other admin if ((multiSigHashes[STTadmin1]) == (multiSigHashes[STTadmin2])) { // if yes, both admins agreed - continue. _; // Reset hashes after successful execution multiSigHashes[STTadmin1] = 0x0; multiSigHashes[STTadmin2] = 0x0; } else { // if not (yet), return. return; } } /** * @dev Create a new STTToken contract. * *  _admin1 The first admin account that owns this contract. *  _admin2 The second admin account that owns this contract. *  _vendors List of exactly 10 addresses that are allowed to deliver tokens. */ constructor(address _admin1, address _admin2, address[] _vendors) public { // Check if the parameters make sense // admin1 and admin2 address must be set and must be different require (_admin1 != 0x0); require (_admin2 != 0x0); require (_admin1 != _admin2); // 10 vendor instances for delivering token purchases require (_vendors.length == 10); totalSupply = 0; // define state STTadmin1 = _admin1; STTadmin2 = _admin2; for (uint8 i = 0; i < _vendors.length; i++){ vendors[_vendors[i]] = true; vendorCount++; } } // Overridden method to check for end of fundraising before allowing transfer of tokens function transfer(address _to, uint256 _value) public isTransferable // Only allow token transfer after the fundraising has ended returns (bool success) { bool result = super.transfer(_to, _value); if (result) { trackHolder(_to); // track the owner for later payouts } return result; } // Overridden method to check for end of fundraising before allowing transfer of tokens function transferFrom(address _from, address _to, uint256 _value) public isTransferable // Only allow token transfer after the fundraising has ended returns (bool success) { bool result = super.transferFrom(_from, _to, _value); if (result) { trackHolder(_to); // track the owner for later payouts } return result; } // Allow for easier balance checking function getBalanceOf(address _owner) public view returns (uint256 _balance) { return balances[_owner]; } // Perform an atomic swap between two token contracts function relocate() external { // Check if relocation was activated require (relocationActive == true); // Define new token contract is RelocationToken newSTT = RelocationToken(newTokenContractAddress); // Burn the old balance uint256 balance = balances[msg.sender]; balances[msg.sender] = 0; // Perform the relocation of balances to new contract require(newSTT.recieveRelocation(msg.sender, balance)); } // Allows to figure out the amount of known token holders function getHolderCount() public view returns (uint256 _holderCount) { return holders.length; } // Allows for easier retrieval of holder by array index function getHolder(uint256 _index) public view returns (address _holder) { return holders[_index]; } function trackHolder(address _to) private returns (bool success) { // Check if the recipient is a known token holder if (isHolder[_to] == false) { // if not, add him to the holders array and mark him as a known holder holders.push(_to); isHolder[_to] = true; } return true; } /// @dev delivers STT tokens from Leondra (Leondrino Exchange Germany) function deliverTokens(address _buyer, uint256 _amount) external onlyVendor { require(_amount >= TOKEN_MIN); uint256 checkedSupply = SafeMath.add(totalSupply, _amount); require(checkedSupply <= TOKEN_CREATION_CAP); // Adjust the balance uint256 oldBalance = balances[_buyer]; balances[_buyer] = SafeMath.add(oldBalance, _amount); totalSupply = checkedSupply; trackHolder(_buyer); // Log the creation of these tokens emit LogDeliverSTT(_buyer, _amount); } /// @dev Creates new STT tokens function deliverTokensBatch(address[] _buyer, uint256[] _amount) external onlyVendor { require(_buyer.length == _amount.length); for (uint8 i = 0 ; i < _buyer.length; i++) { require(_amount[i] >= TOKEN_MIN); require(_buyer[i] != 0x0); uint256 checkedSupply = SafeMath.add(totalSupply, _amount[i]); require(checkedSupply <= TOKEN_CREATION_CAP); // Adjust the balance uint256 oldBalance = balances[_buyer[i]]; balances[_buyer[i]] = SafeMath.add(oldBalance, _amount[i]); totalSupply = checkedSupply; trackHolder(_buyer[i]); // Log the creation of these tokens emit LogDeliverSTT(_buyer[i], _amount[i]); } } // Allow / Deny transfer of tokens function transactionSwitch(bool _transactionsActive) external onlyOwner { transactionsActive = _transactionsActive; } // For eventual later moving to another token contract function relocationSwitch(bool _relocationActive, address _newTokenContractAddress) external onlyOwner { if (_relocationActive) { require(_newTokenContractAddress != 0x0); } else { require(_newTokenContractAddress == 0x0); } relocationActive = _relocationActive; newTokenContractAddress = _newTokenContractAddress; } // Adjust the cap according to the white paper terms (See STT Whitepaper Version 1.0 from 23. May 2018 ) function adjustCap() external onlyOwner { require (supplyAdjustmentCount < 4); TOKEN_CREATION_CAP = SafeMath.add(TOKEN_CREATION_CAP, 50 * (10**6) * 10**decimals); // 50 million STTs supplyAdjustmentCount++; } // Burn function - name indicating the burn of ALL owner's tokens function burnWholeBalance() external { require(balances[msg.sender] > 0); totalSupply = SafeMath.sub(totalSupply, balances[msg.sender]); balances[msg.sender] = 0; } } "}
{"sol name": "20.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) pure internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) pure internal returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) pure internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) pure internal returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract WPAYReward is StandardToken { string public constant name = \"WPAYReward\"; string public constant symbol = \"WRT\"; uint8 public constant decimals = 4; uint256 public constant INITIAL_SUPPLY = 300000000 * (10 ** uint256(decimals)); function WPAYReward() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "846.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract YeYingOil{ // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); uint256 public totalEthInWei; uint256 public transferCount; // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); address public admin; /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function YeYingOil( ) public { admin=msg.sender; totalSupply = 2100000000* 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"YeYingOil\";                                   // Set the name for display purposes symbol = \"YYO\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function()  payable public{ uint256 value=msg.value; if(value>0 && msg.value>0) { totalEthInWei = totalEthInWei + msg.value; uint256 amount = msg.value * 10000; require(balanceOf[admin] >= amount); balanceOf[admin] = balanceOf[admin]-amount; balanceOf[msg.sender] = balanceOf[msg.sender]+amount; admin.transfer(msg.value); Transfer(admin, msg.sender, amount); // Broadcast a message to the blockchain transferCount++; } } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "873.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * * Author: Iceman * Telegram: iceman_0 * * Token Details:- * Name: NoteChain * Symbol: NOTE * Decimals: 18 * Total Supply: 20 Billion * */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner)public onlyOwner { require(newOwner != address(0)); owner = newOwner; } } contract ERC20Basic is Ownable { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /** * @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens * @param target Address to be frozen * @param freeze either to freeze it or not */ function freezeAccount(address target, bool freeze)  public onlyOwner{ frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value)public returns (bool) { require(!frozenAccount[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner)public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(!frozenAccount[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract NoteChainToken is StandardToken { string public constant name = \"NoteChain\"; string public constant symbol = \"NOTE\"; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 20000000000 * 10**decimals; /** * @dev Upon deplyment the tokens will be credidet to 4 addresses */ constructor() public { totalSupply = INITIAL_SUPPLY; balances[address(0x750Da02fb96538AbAf5aDd7E09eAC25f1553109D)] = (INITIAL_SUPPLY.mul(20).div(100)); balances[address(0xb85e5Eb2C4F43fE44c1dF949c1c49F1638cb772B)] = (INITIAL_SUPPLY.mul(20).div(100)); balances[address(0xBd058b319A1355A271B732044f37BBF2Be07A0B1)] = (INITIAL_SUPPLY.mul(25).div(100)); balances[address(0x53da2841810e6886254B514d338146d209B164a2)] = (INITIAL_SUPPLY.mul(35).div(100)); } } "}
{"sol name": "1656.sol", "label": 0, "sol content": "pragma solidity ^0.4.22; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function toUINT112(uint256 a) internal pure returns(uint112) { assert(uint112(a) == a); return uint112(a); } function toUINT120(uint256 a) internal pure returns(uint120) { assert(uint120(a) == a); return uint120(a); } function toUINT128(uint256 a) internal pure returns(uint128) { assert(uint128(a) == a); return uint128(a); } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract HIGToken is StandardToken { string public constant name = \"Hash Incubator Global\"; string public constant symbol = \"HIG\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000 * (10 ** uint256(decimals));//10^18 /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "1997.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract EC { uint256 constant public gx = 0x79BE667EF9DCBBAC55A06295CE870B07029BFCDB2DCE28D959F2815B16F81798; uint256 constant public gy = 0x483ADA7726A3C4655DA4FBFC0E1108A8FD17B448A68554199C47D08FFB10D4B8; uint256 constant public n = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEFFFFFC2F; uint256 constant public a = 0; uint256 constant public b = 7; function _jAdd( uint256 x1, uint256 z1, uint256 x2, uint256 z2) public pure returns(uint256 x3, uint256 z3) { (x3, z3) = ( addmod( mulmod(z2, x1, n), mulmod(x2, z1, n), n ), mulmod(z1, z2, n) ); } function _jSub( uint256 x1, uint256 z1, uint256 x2, uint256 z2) public pure returns(uint256 x3, uint256 z3) { (x3, z3) = ( addmod( mulmod(z2, x1, n), mulmod(n - x2, z1, n), n ), mulmod(z1, z2, n) ); } function _jMul( uint256 x1, uint256 z1, uint256 x2, uint256 z2) public pure returns(uint256 x3, uint256 z3) { (x3, z3) = ( mulmod(x1, x2, n), mulmod(z1, z2, n) ); } function _jDiv( uint256 x1, uint256 z1, uint256 x2, uint256 z2) public pure returns(uint256 x3, uint256 z3) { (x3, z3) = ( mulmod(x1, z2, n), mulmod(z1, x2, n) ); } function _inverse(uint256 val) public pure returns(uint256 invVal) { uint256 t = 0; uint256 newT = 1; uint256 r = n; uint256 newR = val; uint256 q; while (newR != 0) { q = r / newR; (t, newT) = (newT, addmod(t, (n - mulmod(q, newT, n)), n)); (r, newR) = (newR, r - q * newR ); } return t; } function _ecAdd( uint256 x1, uint256 y1, uint256 z1, uint256 x2, uint256 y2, uint256 z2) public pure returns(uint256 x3, uint256 y3, uint256 z3) { uint256 lx; uint256 lz; uint256 da; uint256 db; if (x1 == 0 && y1 == 0) { return (x2, y2, z2); } if (x2 == 0 && y2 == 0) { return (x1, y1, z1); } if (x1 == x2 && y1 == y2) { (lx, lz) = _jMul(x1, z1, x1, z1); (lx, lz) = _jMul(lx, lz, 3, 1); (lx, lz) = _jAdd(lx, lz, a, 1); (da,db) = _jMul(y1, z1, 2, 1); } else { (lx, lz) = _jSub(y2, z2, y1, z1); (da, db) = _jSub(x2, z2, x1, z1); } (lx, lz) = _jDiv(lx, lz, da, db); (x3, da) = _jMul(lx, lz, lx, lz); (x3, da) = _jSub(x3, da, x1, z1); (x3, da) = _jSub(x3, da, x2, z2); (y3, db) = _jSub(x1, z1, x3, da); (y3, db) = _jMul(y3, db, lx, lz); (y3, db) = _jSub(y3, db, y1, z1); if (da != db) { x3 = mulmod(x3, db, n); y3 = mulmod(y3, da, n); z3 = mulmod(da, db, n); } else { z3 = da; } } function _ecDouble(uint256 x1, uint256 y1, uint256 z1) public pure returns(uint256 x3, uint256 y3, uint256 z3) { (x3, y3, z3) = _ecAdd(x1, y1, z1, x1, y1, z1); } function _ecMul(uint256 d, uint256 x1, uint256 y1, uint256 z1) public pure returns(uint256 x3, uint256 y3, uint256 z3) { uint256 remaining = d; uint256 px = x1; uint256 py = y1; uint256 pz = z1; uint256 acx = 0; uint256 acy = 0; uint256 acz = 1; if (d == 0) { return (0, 0, 1); } while (remaining != 0) { if ((remaining & 1) != 0) { (acx,acy,acz) = _ecAdd(acx, acy, acz, px, py, pz); } remaining = remaining / 2; (px, py, pz) = _ecDouble(px, py, pz); } (x3, y3, z3) = (acx, acy, acz); } function ecadd( uint256 x1, uint256 y1, uint256 x2, uint256 y2) public pure returns(uint256 x3, uint256 y3) { uint256 z; (x3, y3, z) = _ecAdd(x1, y1, 1, x2, y2, 1); z = _inverse(z); x3 = mulmod(x3, z, n); y3 = mulmod(y3, z, n); } function ecmul(uint256 x1, uint256 y1, uint256 scalar) public pure returns(uint256 x2, uint256 y2) { uint256 z; (x2, y2, z) = _ecMul(scalar, x1, y1, 1); z = _inverse(z); x2 = mulmod(x2, z, n); y2 = mulmod(y2, z, n); } function ecmulVerify(uint256 x1, uint256 y1, uint256 scalar, uint256 qx, uint256 qy) public pure returns(bool) { uint256 m = 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141; address signer = ecrecover(0, y1 % 2 != 0 ? 28 : 27, bytes32(x1), bytes32(mulmod(scalar, x1, m))); address xyAddress = address(uint256(keccak256(abi.encodePacked(qx, qy))) & 0x00FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF); return xyAddress == signer; } function publicKey(uint256 privKey) public pure returns(uint256 qx, uint256 qy) { return ecmul(gx, gy, privKey); } function publicKeyVerify(uint256 privKey, uint256 x, uint256 y) public pure returns(bool) { return ecmulVerify(gx, gy, privKey, x, y); } function deriveKey(uint256 privKey, uint256 pubX, uint256 pubY) public pure returns(uint256 qx, uint256 qy) { uint256 z; (qx, qy, z) = _ecMul(privKey, pubX, pubY, 1); z = _inverse(z); qx = mulmod(qx, z, n); qy = mulmod(qy, z, n); } } "}
{"sol name": "1825.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract OBDCoin is StandardToken { string public name; string public symbol; uint8 public decimals = 18; constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply_ = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = initialSupply * 10 ** uint256(decimals); name = tokenName; symbol = tokenSymbol; } } "}
{"sol name": "725.sol", "label": 0, "sol content": "pragma solidity ^0.4.22; // File: contracts/ERC223/ERC223_receiving_contract.sol /** * @title Contract that will work with ERC223 tokens. */ contract ERC223ReceivingContract { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data) public; } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: zeppelin-solidity/contracts/token/ERC20/CappedToken.sol /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } // File: contracts/SafeGuardsToken.sol contract SafeGuardsToken is CappedToken { string constant public name = \"SafeGuards Coin\"; string constant public symbol = \"SGCT\"; uint constant public decimals = 18; // address who can burn tokens address public canBurnAddress; // list with frozen addresses mapping (address => bool) public frozenList; // timestamp until investors in frozen list can't transfer tokens uint256 public frozenPauseTime = now + 180 days; // timestamp until investors can't burn tokens uint256 public burnPausedTime = now + 180 days; constructor(address _canBurnAddress) CappedToken(61 * 1e6 * 1e18) public { require(_canBurnAddress != 0x0); canBurnAddress = _canBurnAddress; } // ===--- Presale frozen functionality ---=== event ChangeFrozenPause(uint256 newFrozenPauseTime); /** * @dev Function to mint frozen tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mintFrozen(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { frozenList[_to] = true; return super.mint(_to, _amount); } function changeFrozenTime(uint256 _newFrozenPauseTime) onlyOwner public returns (bool) { require(_newFrozenPauseTime > now); frozenPauseTime = _newFrozenPauseTime; emit ChangeFrozenPause(_newFrozenPauseTime); return true; } // ===--- Override transfers with implementation of the ERC223 standard and frozen logic ---=== event Transfer(address indexed from, address indexed to, uint value, bytes data); /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint _value) public returns (bool) { bytes memory empty; return transfer(_to, _value, empty); } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. * @param _data Optional metadata. */ function transfer(address _to, uint _value, bytes _data) public returns (bool) { require(now > frozenPauseTime || !frozenList[msg.sender]); super.transfer(_to, _value); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); } return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint _value) public returns (bool) { bytes memory empty; return transferFrom(_from, _to, _value, empty); } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint the amount of tokens to be transferred * @param _data Optional metadata. */ function transferFrom(address _from, address _to, uint _value, bytes _data) public returns (bool) { require(now > frozenPauseTime || !frozenList[msg.sender]); super.transferFrom(_from, _to, _value); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(_from, _value, _data); } emit Transfer(_from, _to, _value, _data); return true; } function isContract(address _addr) private view returns (bool) { uint length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } // ===--- Burnable functionality ---=== event Burn(address indexed burner, uint256 value); event ChangeBurnPause(uint256 newBurnPauseTime); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(burnPausedTime < now || msg.sender == canBurnAddress); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); } function changeBurnPausedTime(uint256 _newBurnPauseTime) onlyOwner public returns (bool) { require(_newBurnPauseTime > burnPausedTime); burnPausedTime = _newBurnPauseTime; emit ChangeBurnPause(_newBurnPauseTime); return true; } } // File: zeppelin-solidity/contracts/crowdsale/Crowdsale.sol /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase(msg.sender, _beneficiary, weiAmount, tokens); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } // File: zeppelin-solidity/contracts/crowdsale/validation/TimedCrowdsale.sol /** * @title TimedCrowdsale * @dev Crowdsale accepting contributions only within a time frame. */ contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; /** * @dev Reverts if not in crowdsale time range. */ modifier onlyWhileOpen { require(now >= openingTime && now <= closingTime); _; } /** * @dev Constructor, takes crowdsale opening and closing times. * @param _openingTime Crowdsale opening time * @param _closingTime Crowdsale closing time */ constructor(uint256 _openingTime, uint256 _closingTime) public { require(_openingTime >= now); require(_closingTime >= _openingTime); openingTime = _openingTime; closingTime = _closingTime; } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { return now > closingTime; } /** * @dev Extend parent behavior requiring to be within contributing period * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } // File: zeppelin-solidity/contracts/crowdsale/distribution/FinalizableCrowdsale.sol /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is TimedCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal { } } // File: zeppelin-solidity/contracts/crowdsale/validation/CappedCrowdsale.sol /** * @title CappedCrowdsale * @dev Crowdsale with a limit for total contributions. */ contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; /** * @dev Constructor, takes maximum amount of wei accepted in the crowdsale. * @param _cap Max amount of wei to be contributed */ constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Checks whether the cap has been reached. * @return Whether the cap was reached */ function capReached() public view returns (bool) { return weiRaised >= cap; } /** * @dev Extend parent behavior requiring purchase to respect the funding cap. * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } } // File: contracts/SafeGuardsPreSale.sol contract SafeGuardsPreSale is FinalizableCrowdsale, CappedCrowdsale { using SafeMath for uint256; // amount of tokens that was sold on the crowdsale uint256 public tokensSold; // if minimumGoal will not be reached till _closingTime, buyers will be able to refund ETH uint256 public minimumGoal; // how much wei we have returned back to the contract after a failed crowdfund uint public loadedRefund; // how much wei we have given back to buyers uint public weiRefunded; // how much ETH each address has bought to this crowdsale mapping (address => uint) public boughtAmountOf; // minimum amount of wel, that can be contributed uint256 constant public minimumAmountWei = 1e16; // timestamp until presale investors can't transfer tokens uint256 public presaleTransfersPaused = now + 180 days; // timestamp until investors can't burn tokens uint256 public presaleBurnPaused = now + 180 days; // ---====== BONUSES for presale users ======--- // time presale bonuses uint constant public preSaleBonus1Time = 1535155200; // uint constant public preSaleBonus1Percent = 25; uint constant public preSaleBonus2Time = 1536019200; // uint constant public preSaleBonus2Percent = 15; uint constant public preSaleBonus3Time = 1536883200; // uint constant public preSaleBonus3Percent = 5; // amount presale bonuses uint constant public preSaleBonus1Amount = 155   * 1e15; uint constant public preSaleBonus2Amount = 387   * 1e15; uint constant public preSaleBonus3Amount = 1550  * 1e15; uint constant public preSaleBonus4Amount = 15500 * 1e15; // ---=== Addresses of founders, team and bounty ===--- address constant public w_futureDevelopment = 0x4b297AB09bF4d2d8107fAa03cFF5377638Ec6C83; address constant public w_Reserv = 0xbb67c6E089c7801ab3c7790158868970ea0d8a7C; address constant public w_Founders = 0xa3b331037e29540F8BD30f3DE4fF4045a8115ff4; address constant public w_Team = 0xa8324689c94eC3cbE9413C61b00E86A96978b4A7; address constant public w_Advisers = 0x2516998954440b027171Ecb955A4C01DfF610F2d; address constant public w_Bounty = 0x1792b603F233220e1E623a6ab3FEc68deFa15f2F; event AddBonus(address indexed addr, uint256 amountWei, uint256 date, uint bonusType); struct Bonus { address addr; uint256 amountWei; uint256 date; uint bonusType; } struct Bonuses { address addr; uint256 numBonusesInAddress; uint256[] indexes; } /** * @dev Get all bonuses by account address */ mapping(address => Bonuses) public bonuses; /** * @dev Bonuses list */ Bonus[] public bonusList; /** * @dev Count of bonuses in list */ function numBonuses() public view returns (uint256) { return bonusList.length; } /** * @dev Count of members in archive */ function getBonusByAddressAndIndex(address _addr, uint256 _index) public view returns (uint256) { return bonuses[_addr].indexes[_index]; } /** * @param _rate Number of token units a buyer gets per one ETH * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold * @param _openingTime Crowdsale opening time * @param _closingTime Crowdsale closing time * @param _minimumGoal Funding goal (soft cap) * @param _cap Max amount of ETH to be contributed (hard cap) */ constructor( uint256 _rate, address _wallet, ERC20 _token, uint256 _openingTime, uint256 _closingTime, uint256 _minimumGoal, uint256 _cap ) Crowdsale(_rate * 1 ether, _wallet, _token) TimedCrowdsale(_openingTime, _closingTime) CappedCrowdsale(_cap * 1 ether) public { require(_rate > 0); require(_wallet != address(0)); rate = _rate; wallet = _wallet; minimumGoal = _minimumGoal * 1 ether; } /** * @dev Allows the current owner to transfer token's control to a newOwner. * @param _newTokenOwner The address to transfer token's ownership to. */ function changeTokenOwner(address _newTokenOwner) external onlyOwner { require(_newTokenOwner != 0x0); require(hasClosed()); SafeGuardsToken(token).transferOwnership(_newTokenOwner); } /** * @dev finalization task, called when owner calls finalize() */ function finalization() internal { require(isMinimumGoalReached()); SafeGuardsToken(token).mint(w_futureDevelopment, tokensSold.mul(20).div(43)); SafeGuardsToken(token).mint(w_Reserv, tokensSold.mul(20).div(43)); SafeGuardsToken(token).mint(w_Founders, tokensSold.mul(7).div(43)); SafeGuardsToken(token).mint(w_Team, tokensSold.mul(5).div(43)); SafeGuardsToken(token).mint(w_Advisers, tokensSold.mul(3).div(43)); SafeGuardsToken(token).mint(w_Bounty, tokensSold.mul(2).div(43)); super.finalization(); } /** * @dev Validation of an incoming purchase. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_weiAmount >= minimumAmountWei); super._preValidatePurchase(_beneficiary, _weiAmount); } /** * @dev Overrides delivery by minting tokens upon purchase. * @param _beneficiary Token purchaser * @param _tokenAmount Number of tokens to be minted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { require(SafeGuardsToken(token).mintFrozen(_beneficiary, _tokenAmount)); tokensSold = tokensSold.add(_tokenAmount); } function changeTransfersPaused(uint256 _newFrozenPauseTime) onlyOwner public returns (bool) { require(_newFrozenPauseTime > now); presaleTransfersPaused = _newFrozenPauseTime; SafeGuardsToken(token).changeFrozenTime(_newFrozenPauseTime); return true; } function changeBurnPaused(uint256 _newBurnPauseTime) onlyOwner public returns (bool) { require(_newBurnPauseTime > presaleBurnPaused); presaleBurnPaused = _newBurnPauseTime; SafeGuardsToken(token).changeBurnPausedTime(_newBurnPauseTime); return true; } // ===--- Bonuses functionality ---=== /** * @dev add bonuses for users * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { require(_weiAmount >= minimumAmountWei); boughtAmountOf[msg.sender] = boughtAmountOf[msg.sender].add(_weiAmount); if (_weiAmount >= preSaleBonus1Amount) { if (_weiAmount >= preSaleBonus2Amount) { if (_weiAmount >= preSaleBonus3Amount) { if (_weiAmount >= preSaleBonus4Amount) { addBonusToUser(msg.sender, _weiAmount, preSaleBonus4Amount, 4); } else { addBonusToUser(msg.sender, _weiAmount, preSaleBonus3Amount, 3); } } else { addBonusToUser(msg.sender, _weiAmount, preSaleBonus2Amount, 2); } } else { addBonusToUser(msg.sender, _weiAmount, preSaleBonus1Amount, 1); } } } function addBonusToUser(address _addr, uint256 _weiAmount, uint256 _bonusAmount, uint _bonusType) internal { uint256 countBonuses = _weiAmount.div(_bonusAmount); Bonus memory b; b.addr = _addr; b.amountWei = _weiAmount; b.date = now; b.bonusType = _bonusType; for (uint256 i = 0; i < countBonuses; i++) { bonuses[_addr].addr = _addr; bonuses[_addr].numBonusesInAddress++; bonuses[_addr].indexes.push(bonusList.push(b) - 1); emit AddBonus(_addr, _weiAmount, now, _bonusType); } } /** * @dev Returns the rate of tokens per wei at the present time. * Note that, as price _increases_ with time, the rate _decreases_. * @return The number of tokens a buyer gets per wei at a given time */ function getCurrentRate() public view returns (uint256) { if (now > preSaleBonus3Time) { return rate; } if (now < preSaleBonus1Time) { return rate.add(rate.mul(preSaleBonus1Percent).div(100)); } if (now < preSaleBonus2Time) { return rate.add(rate.mul(preSaleBonus2Percent).div(100)); } if (now < preSaleBonus3Time) { return rate.add(rate.mul(preSaleBonus3Percent).div(100)); } return rate; } /** * @dev Overrides parent method taking into account variable rate. * @param _weiAmount The value in wei to be converted into tokens * @return The number of tokens _weiAmount wei will buy at present time */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { uint256 currentRate = getCurrentRate(); return currentRate.mul(_weiAmount); } // ===--- Refund functionality ---=== // a refund was processed for an buyer event Refund(address buyer, uint weiAmount); event RefundLoaded(uint amount); // return true if the crowdsale has raised enough money to be a successful. function isMinimumGoalReached() public constant returns (bool) { return weiRaised >= minimumGoal; } /** * Allow load refunds back on the contract for the refunding. * * The team can transfer the funds back on the smart contract in the case the minimum goal was not reached. */ function loadRefund() external payable { require(msg.sender == wallet); require(msg.value > 0); require(!isMinimumGoalReached()); loadedRefund = loadedRefund.add(msg.value); emit RefundLoaded(msg.value); } /** * Buyers can claim refund. * * Note that any refunds from proxy buyers should be handled separately, * and not through this contract. */ function refund() external { require(!isMinimumGoalReached() && loadedRefund > 0); uint weiValue = boughtAmountOf[msg.sender]; require(weiValue > 0); require(weiValue <= loadedRefund); boughtAmountOf[msg.sender] = 0; weiRefunded = weiRefunded.add(weiValue); msg.sender.transfer(weiValue); emit Refund(msg.sender, weiValue); } } "}
{"sol name": "91.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract OraclizeI { address public cbAddress; function query(uint _timestamp, string _datasource, string _arg) external payable returns (bytes32 _id); function query_withGasLimit(uint _timestamp, string _datasource, string _arg, uint _gaslimit) external payable returns (bytes32 _id); function query2(uint _timestamp, string _datasource, string _arg1, string _arg2) public payable returns (bytes32 _id); function query2_withGasLimit(uint _timestamp, string _datasource, string _arg1, string _arg2, uint _gaslimit) external payable returns (bytes32 _id); function queryN(uint _timestamp, string _datasource, bytes _argN) public payable returns (bytes32 _id); function queryN_withGasLimit(uint _timestamp, string _datasource, bytes _argN, uint _gaslimit) external payable returns (bytes32 _id); function getPrice(string _datasource) public returns (uint _dsprice); function getPrice(string _datasource, uint gaslimit) public returns (uint _dsprice); function setProofType(byte _proofType) external; function setCustomGasPrice(uint _gasPrice) external; function randomDS_getSessionPubKeyHash() external constant returns(bytes32); } contract OraclizeAddrResolverI { function getAddress() public returns (address _addr); } contract usingOraclize { uint constant day = 60*60*24; uint constant week = 60*60*24*7; uint constant month = 60*60*24*30; byte constant proofType_NONE = 0x00; byte constant proofType_TLSNotary = 0x10; byte constant proofType_Android = 0x20; byte constant proofType_Ledger = 0x30; byte constant proofType_Native = 0xF0; byte constant proofStorage_IPFS = 0x01; uint8 constant networkID_auto = 0; uint8 constant networkID_mainnet = 1; uint8 constant networkID_testnet = 2; uint8 constant networkID_morden = 2; uint8 constant networkID_consensys = 161; OraclizeAddrResolverI OAR; OraclizeI oraclize; modifier oraclizeAPI { if((address(OAR)==0)||(getCodeSize(address(OAR))==0)) oraclize_setNetwork(networkID_auto); if(address(oraclize) != OAR.getAddress()) oraclize = OraclizeI(OAR.getAddress()); _; } modifier coupon(string code){ oraclize = OraclizeI(OAR.getAddress()); _; } function oraclize_setNetwork(uint8 networkID) internal returns(bool){ return oraclize_setNetwork(); networkID; // silence the warning and remain backwards compatible } function oraclize_setNetwork() internal returns(bool){ if (getCodeSize(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed)>0){ //mainnet OAR = OraclizeAddrResolverI(0x1d3B2638a7cC9f2CB3D298A3DA7a90B67E5506ed); oraclize_setNetworkName(\"eth_mainnet\"); return true; } if (getCodeSize(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1)>0){ //ropsten testnet OAR = OraclizeAddrResolverI(0xc03A2615D5efaf5F49F60B7BB6583eaec212fdf1); oraclize_setNetworkName(\"eth_ropsten3\"); return true; } if (getCodeSize(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e)>0){ //kovan testnet OAR = OraclizeAddrResolverI(0xB7A07BcF2Ba2f2703b24C0691b5278999C59AC7e); oraclize_setNetworkName(\"eth_kovan\"); return true; } if (getCodeSize(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48)>0){ //rinkeby testnet OAR = OraclizeAddrResolverI(0x146500cfd35B22E4A392Fe0aDc06De1a1368Ed48); oraclize_setNetworkName(\"eth_rinkeby\"); return true; } if (getCodeSize(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475)>0){ //ethereum-bridge OAR = OraclizeAddrResolverI(0x6f485C8BF6fc43eA212E93BBF8ce046C7f1cb475); return true; } if (getCodeSize(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF)>0){ //ether.camp ide OAR = OraclizeAddrResolverI(0x20e12A1F859B3FeaE5Fb2A0A32C18F5a65555bBF); return true; } if (getCodeSize(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA)>0){ //browser-solidity OAR = OraclizeAddrResolverI(0x51efaF4c8B3C9AfBD5aB9F4bbC82784Ab6ef8fAA); return true; } return false; } function __callback(bytes32 myid, string result) public { __callback(myid, result, new bytes(0)); } function __callback(bytes32 myid, string result, bytes proof) public { return; myid; result; proof; // Silence compiler warnings } function oraclize_getPrice(string datasource) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource); } function oraclize_getPrice(string datasource, uint gaslimit) oraclizeAPI internal returns (uint){ return oraclize.getPrice(datasource, gaslimit); } function oraclize_query(string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(0, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query.value(price)(timestamp, datasource, arg); } function oraclize_query(uint timestamp, string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(timestamp, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query_withGasLimit.value(price)(0, datasource, arg, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(0, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price return oraclize.query2.value(price)(timestamp, datasource, arg1, arg2); } function oraclize_query(uint timestamp, string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(timestamp, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string arg1, string arg2, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price return oraclize.query2_withGasLimit.value(price)(0, datasource, arg1, arg2, gaslimit); } function oraclize_query(string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, string[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = stra2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, string[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { string[] memory dynargs = new string[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(0, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource); if (price > 1 ether + tx.gasprice*200000) return 0; // unexpectedly high price bytes memory args = ba2cbor(argN); return oraclize.queryN.value(price)(timestamp, datasource, args); } function oraclize_query(uint timestamp, string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(timestamp, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[] argN, uint gaslimit) oraclizeAPI internal returns (bytes32 id){ uint price = oraclize.getPrice(datasource, gaslimit); if (price > 1 ether + tx.gasprice*gaslimit) return 0; // unexpectedly high price bytes memory args = ba2cbor(argN); return oraclize.queryN_withGasLimit.value(price)(0, datasource, args, gaslimit); } function oraclize_query(string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[1] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](1); dynargs[0] = args[0]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[2] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](2); dynargs[0] = args[0]; dynargs[1] = args[1]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[3] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](3); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[4] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](4); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs); } function oraclize_query(uint timestamp, string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(timestamp, datasource, dynargs, gaslimit); } function oraclize_query(string datasource, bytes[5] args, uint gaslimit) oraclizeAPI internal returns (bytes32 id) { bytes[] memory dynargs = new bytes[](5); dynargs[0] = args[0]; dynargs[1] = args[1]; dynargs[2] = args[2]; dynargs[3] = args[3]; dynargs[4] = args[4]; return oraclize_query(datasource, dynargs, gaslimit); } function oraclize_cbAddress() oraclizeAPI internal returns (address){ return oraclize.cbAddress(); } function oraclize_setProof(byte proofP) oraclizeAPI internal { return oraclize.setProofType(proofP); } function oraclize_setCustomGasPrice(uint gasPrice) oraclizeAPI internal { return oraclize.setCustomGasPrice(gasPrice); } function oraclize_randomDS_getSessionPubKeyHash() oraclizeAPI internal returns (bytes32){ return oraclize.randomDS_getSessionPubKeyHash(); } function getCodeSize(address _addr) constant internal returns(uint _size) { assembly { _size := extcodesize(_addr) } } function parseAddr(string _a) internal pure returns (address){ bytes memory tmp = bytes(_a); uint160 iaddr = 0; uint160 b1; uint160 b2; for (uint i=2; i<2+2*20; i+=2){ iaddr *= 256; b1 = uint160(tmp[i]); b2 = uint160(tmp[i+1]); if ((b1 >= 97)&&(b1 <= 102)) b1 -= 87; else if ((b1 >= 65)&&(b1 <= 70)) b1 -= 55; else if ((b1 >= 48)&&(b1 <= 57)) b1 -= 48; if ((b2 >= 97)&&(b2 <= 102)) b2 -= 87; else if ((b2 >= 65)&&(b2 <= 70)) b2 -= 55; else if ((b2 >= 48)&&(b2 <= 57)) b2 -= 48; iaddr += (b1*16+b2); } return address(iaddr); } function strCompare(string _a, string _b) internal pure returns (int) { bytes memory a = bytes(_a); bytes memory b = bytes(_b); uint minLength = a.length; if (b.length < minLength) minLength = b.length; for (uint i = 0; i < minLength; i ++) if (a[i] < b[i]) return -1; else if (a[i] > b[i]) return 1; if (a.length < b.length) return -1; else if (a.length > b.length) return 1; else return 0; } function indexOf(string _haystack, string _needle) internal pure returns (int) { bytes memory h = bytes(_haystack); bytes memory n = bytes(_needle); if(h.length < 1 || n.length < 1 || (n.length > h.length)) return -1; else if(h.length > (2**128 -1)) return -1; else { uint subindex = 0; for (uint i = 0; i < h.length; i ++) { if (h[i] == n[0]) { subindex = 1; while(subindex < n.length && (i + subindex) < h.length && h[i + subindex] == n[subindex]) { subindex++; } if(subindex == n.length) return int(i); } } return -1; } } function strConcat(string _a, string _b, string _c, string _d, string _e) internal pure returns (string) { bytes memory _ba = bytes(_a); bytes memory _bb = bytes(_b); bytes memory _bc = bytes(_c); bytes memory _bd = bytes(_d); bytes memory _be = bytes(_e); string memory abcde = new string(_ba.length + _bb.length + _bc.length + _bd.length + _be.length); bytes memory babcde = bytes(abcde); uint k = 0; for (uint i = 0; i < _ba.length; i++) babcde[k++] = _ba[i]; for (i = 0; i < _bb.length; i++) babcde[k++] = _bb[i]; for (i = 0; i < _bc.length; i++) babcde[k++] = _bc[i]; for (i = 0; i < _bd.length; i++) babcde[k++] = _bd[i]; for (i = 0; i < _be.length; i++) babcde[k++] = _be[i]; return string(babcde); } function strConcat(string _a, string _b, string _c, string _d) internal pure returns (string) { return strConcat(_a, _b, _c, _d, \"\"); } function strConcat(string _a, string _b, string _c) internal pure returns (string) { return strConcat(_a, _b, _c, \"\", \"\"); } function strConcat(string _a, string _b) internal pure returns (string) { return strConcat(_a, _b, \"\", \"\", \"\"); } // parseInt function parseInt(string _a) internal pure returns (uint) { return parseInt(_a, 0); } // parseInt(parseFloat*10^_b) function parseInt(string _a, uint _b) internal pure returns (uint) { bytes memory bresult = bytes(_a); uint mint = 0; bool decimals = false; for (uint i=0; i<bresult.length; i++){ if ((bresult[i] >= 48)&&(bresult[i] <= 57)){ if (decimals){ if (_b == 0) break; else _b--; } mint *= 10; mint += uint(bresult[i]) - 48; } else if (bresult[i] == 46) decimals = true; } if (_b > 0) mint *= 10**_b; return mint; } function uint2str(uint i) internal pure returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); uint k = len - 1; while (i != 0){ bstr[k--] = byte(48 + i % 10); i /= 10; } return string(bstr); } function stra2cbor(string[] arr) internal pure returns (bytes) { uint arrlen = arr.length; // get correct cbor output length uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { // if there's a bug with larger strings, this may be the culprit if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } function ba2cbor(bytes[] arr) internal pure returns (bytes) { uint arrlen = arr.length; // get correct cbor output length uint outputlen = 0; bytes[] memory elemArray = new bytes[](arrlen); for (uint i = 0; i < arrlen; i++) { elemArray[i] = (bytes(arr[i])); outputlen += elemArray[i].length + (elemArray[i].length - 1)/23 + 3; //+3 accounts for paired identifier types } uint ctr = 0; uint cborlen = arrlen + 0x80; outputlen += byte(cborlen).length; bytes memory res = new bytes(outputlen); while (byte(cborlen).length > ctr) { res[ctr] = byte(cborlen)[ctr]; ctr++; } for (i = 0; i < arrlen; i++) { res[ctr] = 0x5F; ctr++; for (uint x = 0; x < elemArray[i].length; x++) { // if there's a bug with larger strings, this may be the culprit if (x % 23 == 0) { uint elemcborlen = elemArray[i].length - x >= 24 ? 23 : elemArray[i].length - x; elemcborlen += 0x40; uint lctr = ctr; while (byte(elemcborlen).length > ctr - lctr) { res[ctr] = byte(elemcborlen)[ctr - lctr]; ctr++; } } res[ctr] = elemArray[i][x]; ctr++; } res[ctr] = 0xFF; ctr++; } return res; } string oraclize_network_name; function oraclize_setNetworkName(string _network_name) internal { oraclize_network_name = _network_name; } function oraclize_getNetworkName() internal view returns (string) { return oraclize_network_name; } function oraclize_newRandomDSQuery(uint _delay, uint _nbytes, uint _customGasLimit) internal returns (bytes32){ require((_nbytes > 0) && (_nbytes <= 32)); // Convert from seconds to ledger timer ticks _delay *= 10; bytes memory nbytes = new bytes(1); nbytes[0] = byte(_nbytes); bytes memory unonce = new bytes(32); bytes memory sessionKeyHash = new bytes(32); bytes32 sessionKeyHash_bytes32 = oraclize_randomDS_getSessionPubKeyHash(); assembly { mstore(unonce, 0x20) mstore(add(unonce, 0x20), xor(blockhash(sub(number, 1)), xor(coinbase, timestamp))) mstore(sessionKeyHash, 0x20) mstore(add(sessionKeyHash, 0x20), sessionKeyHash_bytes32) } bytes memory delay = new bytes(32); assembly { mstore(add(delay, 0x20), _delay) } bytes memory delay_bytes8 = new bytes(8); copyBytes(delay, 24, 8, delay_bytes8, 0); bytes[4] memory args = [unonce, nbytes, sessionKeyHash, delay]; bytes32 queryId = oraclize_query(\"random\", args, _customGasLimit); bytes memory delay_bytes8_left = new bytes(8); assembly { let x := mload(add(delay_bytes8, 0x20)) mstore8(add(delay_bytes8_left, 0x27), div(x, 0x100000000000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x26), div(x, 0x1000000000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x25), div(x, 0x10000000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x24), div(x, 0x100000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x23), div(x, 0x1000000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x22), div(x, 0x10000000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x21), div(x, 0x100000000000000000000000000000000000000000000000000)) mstore8(add(delay_bytes8_left, 0x20), div(x, 0x1000000000000000000000000000000000000000000000000)) } oraclize_randomDS_setCommitment(queryId, keccak256(delay_bytes8_left, args[1], sha256(args[0]), args[2])); return queryId; } function oraclize_randomDS_setCommitment(bytes32 queryId, bytes32 commitment) internal { oraclize_randomDS_args[queryId] = commitment; } mapping(bytes32=>bytes32) oraclize_randomDS_args; mapping(bytes32=>bool) oraclize_randomDS_sessionKeysHashVerified; function verifySig(bytes32 tosignh, bytes dersig, bytes pubkey) internal returns (bool){ bool sigok; address signer; bytes32 sigr; bytes32 sigs; bytes memory sigr_ = new bytes(32); uint offset = 4+(uint(dersig[3]) - 0x20); sigr_ = copyBytes(dersig, offset, 32, sigr_, 0); bytes memory sigs_ = new bytes(32); offset += 32 + 2; sigs_ = copyBytes(dersig, offset+(uint(dersig[offset-1]) - 0x20), 32, sigs_, 0); assembly { sigr := mload(add(sigr_, 32)) sigs := mload(add(sigs_, 32)) } (sigok, signer) = safer_ecrecover(tosignh, 27, sigr, sigs); if (address(keccak256(pubkey)) == signer) return true; else { (sigok, signer) = safer_ecrecover(tosignh, 28, sigr, sigs); return (address(keccak256(pubkey)) == signer); } } function oraclize_randomDS_proofVerify__sessionKeyValidity(bytes proof, uint sig2offset) internal returns (bool) { bool sigok; // Step 6: verify the attestation signature, APPKEY1 must sign the sessionKey from the correct ledger app (CODEHASH) bytes memory sig2 = new bytes(uint(proof[sig2offset+1])+2); copyBytes(proof, sig2offset, sig2.length, sig2, 0); bytes memory appkey1_pubkey = new bytes(64); copyBytes(proof, 3+1, 64, appkey1_pubkey, 0); bytes memory tosign2 = new bytes(1+65+32); tosign2[0] = byte(1); //role copyBytes(proof, sig2offset-65, 65, tosign2, 1); bytes memory CODEHASH = hex\"fd94fa71bc0ba10d39d464d0d8f465efeef0a2764e3887fcc9df41ded20f505c\"; copyBytes(CODEHASH, 0, 32, tosign2, 1+65); sigok = verifySig(sha256(tosign2), sig2, appkey1_pubkey); if (sigok == false) return false; // Step 7: verify the APPKEY1 provenance (must be signed by Ledger) bytes memory LEDGERKEY = hex\"7fb956469c5c9b89840d55b43537e66a98dd4811ea0a27224272c2e5622911e8537a2f8e86a46baec82864e98dd01e9ccc2f8bc5dfc9cbe5a91a290498dd96e4\"; bytes memory tosign3 = new bytes(1+65); tosign3[0] = 0xFE; copyBytes(proof, 3, 65, tosign3, 1); bytes memory sig3 = new bytes(uint(proof[3+65+1])+2); copyBytes(proof, 3+65, sig3.length, sig3, 0); sigok = verifySig(sha256(tosign3), sig3, LEDGERKEY); return sigok; } modifier oraclize_randomDS_proofVerify(bytes32 _queryId, string _result, bytes _proof) { // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1) require((_proof[0] == \"L\") && (_proof[1] == \"P\") && (_proof[2] == 1)); bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); require(proofVerified); _; } function oraclize_randomDS_proofVerify__returnCode(bytes32 _queryId, string _result, bytes _proof) internal returns (uint8){ // Step 1: the prefix has to match 'LP\\x01' (Ledger Proof version 1) if ((_proof[0] != \"L\")||(_proof[1] != \"P\")||(_proof[2] != 1)) return 1; bool proofVerified = oraclize_randomDS_proofVerify__main(_proof, _queryId, bytes(_result), oraclize_getNetworkName()); if (proofVerified == false) return 2; return 0; } function matchBytes32Prefix(bytes32 content, bytes prefix, uint n_random_bytes) internal pure returns (bool){ bool match_ = true; require(prefix.length == n_random_bytes); for (uint256 i=0; i< n_random_bytes; i++) { if (content[i] != prefix[i]) match_ = false; } return match_; } function oraclize_randomDS_proofVerify__main(bytes proof, bytes32 queryId, bytes result, string context_name) internal returns (bool){ // Step 2: the unique keyhash has to match with the sha256 of (context name + queryId) uint ledgerProofLength = 3+65+(uint(proof[3+65+1])+2)+32; bytes memory keyhash = new bytes(32); copyBytes(proof, ledgerProofLength, 32, keyhash, 0); if (!(keccak256(keyhash) == keccak256(sha256(context_name, queryId)))) return false; bytes memory sig1 = new bytes(uint(proof[ledgerProofLength+(32+8+1+32)+1])+2); copyBytes(proof, ledgerProofLength+(32+8+1+32), sig1.length, sig1, 0); // Step 3: we assume sig1 is valid (it will be verified during step 5) and we verify if 'result' is the prefix of sha256(sig1) if (!matchBytes32Prefix(sha256(sig1), result, uint(proof[ledgerProofLength+32+8]))) return false; // Step 4: commitment match verification, keccak256(delay, nbytes, unonce, sessionKeyHash) == commitment in storage. // This is to verify that the computed args match with the ones specified in the query. bytes memory commitmentSlice1 = new bytes(8+1+32); copyBytes(proof, ledgerProofLength+32, 8+1+32, commitmentSlice1, 0); bytes memory sessionPubkey = new bytes(64); uint sig2offset = ledgerProofLength+32+(8+1+32)+sig1.length+65; copyBytes(proof, sig2offset-64, 64, sessionPubkey, 0); bytes32 sessionPubkeyHash = sha256(sessionPubkey); if (oraclize_randomDS_args[queryId] == keccak256(commitmentSlice1, sessionPubkeyHash)){ //unonce, nbytes and sessionKeyHash match delete oraclize_randomDS_args[queryId]; } else return false; // Step 5: validity verification for sig1 (keyhash and args signed with the sessionKey) bytes memory tosign1 = new bytes(32+8+1+32); copyBytes(proof, ledgerProofLength, 32+8+1+32, tosign1, 0); if (!verifySig(sha256(tosign1), sig1, sessionPubkey)) return false; // verify if sessionPubkeyHash was verified already, if not.. let's do it! if (oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] == false){ oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash] = oraclize_randomDS_proofVerify__sessionKeyValidity(proof, sig2offset); } return oraclize_randomDS_sessionKeysHashVerified[sessionPubkeyHash]; } // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license function copyBytes(bytes from, uint fromOffset, uint length, bytes to, uint toOffset) internal pure returns (bytes) { uint minLength = length + toOffset; // Buffer too small require(to.length >= minLength); // Should be a better way? // NOTE: the offset 32 is added to skip the `size` field of both bytes variables uint i = 32 + fromOffset; uint j = 32 + toOffset; while (i < (32 + fromOffset + length)) { assembly { let tmp := mload(add(from, i)) mstore(add(to, j), tmp) } i += 32; j += 32; } return to; } // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license // Duplicate Solidity's ecrecover, but catching the CALL return value function safer_ecrecover(bytes32 hash, uint8 v, bytes32 r, bytes32 s) internal returns (bool, address) { // We do our own memory management here. Solidity uses memory offset // 0x40 to store the current end of memory. We write past it (as // writes are memory extensions), but don't update the offset so // Solidity will reuse it. The memory used here is only needed for // this context. // FIXME: inline assembly can't access return values bool ret; address addr; assembly { let size := mload(0x40) mstore(size, hash) mstore(add(size, 32), v) mstore(add(size, 64), r) mstore(add(size, 96), s) // NOTE: we can reuse the request memory because we deal with //       the return code ret := call(3000, 1, 0, size, 128, size, 32) addr := mload(size) } return (ret, addr); } // the following function has been written by Alex Beregszaszi (@axic), use it under the terms of the MIT license function ecrecovery(bytes32 hash, bytes sig) internal returns (bool, address) { bytes32 r; bytes32 s; uint8 v; if (sig.length != 65) return (false, 0); // The signature format is a compact form of: //   {bytes32 r}{bytes32 s}{uint8 v} // Compact means, uint8 is not padded to 32 bytes. assembly { r := mload(add(sig, 32)) s := mload(add(sig, 64)) // Here we are loading the last 32 bytes. We exploit the fact that // 'mload' will pad with zeroes if we overread. // There is no 'mload8' to do this, but that would be nicer. v := byte(0, mload(add(sig, 96))) // Alternative solution: // 'byte' is not working due to the Solidity parser, so lets // use the second best option, 'and' // v := and(mload(add(sig, 65)), 255) } // albeit non-transactional signatures are not specified by the YP, one would expect it // to match the YP range of [27, 28] // // geth uses [0, 1] and some clients have followed. This might change, see: //  https://github.com/ethereum/go-ethereum/issues/2053 if (v < 27) v += 27; if (v != 27 && v != 28) return (false, 0); return safer_ecrecover(hash, v, r, s); } } library Strings { function concat(string _base, string _value) internal pure returns (string) { bytes memory _baseBytes = bytes(_base); bytes memory _valueBytes = bytes(_value); string memory _tmpValue = new string(_baseBytes.length + _valueBytes.length); bytes memory _newValue = bytes(_tmpValue); uint i; uint j; for(i=0; i<_baseBytes.length; i++) { _newValue[j++] = _baseBytes[i]; } for(i=0; i<_valueBytes.length; i++) { _newValue[j++] = _valueBytes[i++]; } return string(_newValue); } } contract Moon is usingOraclize{ using Strings for string; //check this is not a problem https://ethereum.stackexchange.com/questions/3373/how-to-clear-large-arrays-without-blowing-the-gas-limit struct Ticket { uint  amount; } //Global variables for all games uint gameNumber; uint allGameAmount; mapping(address => uint) earnings; //Dealing with Game sesssion tickets mapping (address => uint) tickets; mapping (address => uint) ticketsForGame; uint numElements; address[] gameAddresses; uint numSums; uint[] gameSums; //Beneficiaries address beneficiaryOne; address beneficiaryTwo; address winner; //Dealing with dates uint gameBegin; uint gameEnd; //Dealing with gamesessions uint totalAmount; uint numberOfPlayers; uint randomNumber; //Helpers To generate random number string concatFirst; string concatSecond; string concatRequest; function Moon() public { beneficiaryOne = 0x009a71cf732A6449a202A323AadE7a2BcFaAe3A8; beneficiaryTwo = 0x004e864e109fE8F3394CcDB74F64c160ac4C5ce4; gameBegin =  now; gameEnd = now + 1 days; totalAmount = 0; gameNumber = 1; allGameAmount = 0; numElements = 0; numberOfPlayers = 0; concatFirst = \"random number between 0 and \"; concatSecond = \"\"; concatRequest = \"\"; } /// Buy ticket of the lottery. Probability to win is proportional to your stake function buyTicket() public payable { require((now <= gameEnd) || (totalAmount == 0)); //Close to the dollar , Euro value require(msg.value > 1000000000000000); require(ticketsForGame[msg.sender] < gameNumber); require(msg.value + totalAmount < 2000000000000000000000); require(randomNumber == 0); //I add the address if necessary. I reset his participation if necessary ticketsForGame[msg.sender] = gameNumber; tickets[msg.sender] = 0; insertAddress(msg.sender); insertSums(totalAmount); //I set player participation to this lottery tickets[msg.sender] = msg.value; totalAmount += msg.value; numberOfPlayers += 1; } /// Withdraw game's earnings function withdraw() public returns (uint) { uint withdrawStatus = 0; uint amount = earnings[msg.sender]; if (amount > 0) { withdrawStatus = 1; earnings[msg.sender] = 0; if (!msg.sender.send(amount)) { earnings[msg.sender] = amount; withdrawStatus = 2; return withdrawStatus; } } return withdrawStatus; } function __callback(bytes32 myid, string result) public { require(msg.sender == oraclize_cbAddress()); require(randomNumber == 0); randomNumber = parseInt(result) * 10000000000000; return; myid; } function chooseRandomNumber() payable public { require(randomNumber == 0); //Comment in dev / uncomment in production: require((now > gameEnd) && (totalAmount > 0)); //So that the value is below 10^9 with wolfram alpha concatSecond = uint2str(totalAmount / 10000000000000); concatRequest = strConcat(concatFirst, concatSecond); oraclize_query(\"WolframAlpha\", concatRequest); } //Ending the game: // 1) we calculate the winner address // 2) We update earnings array // 3) We reset variables function endGame() public { // uncomment in production require(now > gameEnd); require(numElements > 0); require(randomNumber > 0); //STEP 1 //Dichotomy to get the winner (randomNumber has been previously calculated) uint cursor = 0; uint inf = 0; uint sup = numElements - 1; uint test = 0; if(numElements > 1){ //Winner is the last player if(randomNumber > gameSums[sup]){ winner = gameAddresses[sup]; } else{ //Takes up to O(ln(n)) gas where n is the number of player while(  (sup > inf + 1) && ( (randomNumber <= gameSums[cursor])  || ((cursor+1<numElements) && (randomNumber > gameSums[cursor+1])) ) ){ test = inf + (sup - inf) / 2; if(randomNumber > gameSums[test]){ inf = test; } else{ sup = test; } cursor = inf; } winner = gameAddresses[cursor]; } } else{ winner = gameAddresses[0]; } //STEP 2 //Send earnings uint amountOne = uint ( (4 * totalAmount) / 100 ); uint amountTwo = uint ( (1 * totalAmount) / 100 ); uint amountThree = totalAmount - amountOne - amountTwo; earnings[beneficiaryOne] += amountOne; earnings[beneficiaryTwo] += amountTwo; earnings[winner] += amountThree; //STEP 3 //Reset des variables gameNumber += 1; allGameAmount += totalAmount; gameBegin = now; gameEnd = now + 1 days; totalAmount = 0; randomNumber = 0; numberOfPlayers = 0; clearAddresses(); clearSums(); } //Getters function myEarnings() public view returns (uint){ return earnings[msg.sender]; } function getWinnerAddress() public view returns (address){ return winner; } function getGameBegin() public view returns (uint) { return gameBegin; } function getGameEnd() public view returns (uint) { return gameEnd; } function getTotalAmount() public view returns (uint){ return totalAmount; } function getGameAddresses(uint index) public view returns(address){ return gameAddresses[index]; } function getGameSums(uint index) public view returns(uint){ return gameSums[index]; } function getGameNumber() public view returns (uint) { return gameNumber; } function getNumberOfPlayers() public view returns (uint) { return numberOfPlayers; } function getAllGameAmount() public view returns (uint) { return allGameAmount; } function getRandomNumber() public view returns (uint){ return randomNumber; } function getMyStake() public view returns (uint){ return tickets[msg.sender]; } function getNumSums() public view returns (uint){ return numSums; } function getNumElements() public view returns (uint){ return numElements; } //Helpers: Cool way to manage big array with limited gas function insertAddress(address value) private { if(numElements == gameAddresses.length) { gameAddresses.length += 1; } gameAddresses[numElements++] = value; } function clearAddresses() private{ numElements = 0; } function insertSums(uint value) private{ if(numSums == gameSums.length) { gameSums.length += 1; } gameSums[numSums++] = value; } function clearSums() private{ numSums = 0; } } "}
{"sol name": "1924.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'EMJACTest' token contract // // Deployed to : 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF // Symbol      : EMJACTest // Name        : EMJACTestToken // Total supply: 2500000000000 // Decimals    : 4 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract EMJACTestToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function EMJACTestToken() public { symbol = \"EMJACTest\"; name = \"EMJACTestToken\"; decimals = 4; _totalSupply = 2500000000000; balances[0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF] = _totalSupply; Transfer(address(0), 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1976.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { revert(); } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract ERC20Basic { uint public totalSupply; function balanceOf(address who) constant returns (uint); function transfer(address to, uint value); event Transfer(address indexed from, address indexed to, uint value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint); function transferFrom(address from, address to, uint value); function approve(address spender, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract Airdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], 10**15 * values[i]); i += 1; } return(i); } } "}
{"sol name": "87.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: contracts/FarashaCoin.sol contract FarashaCoin is StandardToken,BurnableToken { string public constant name = \"Farasha\"; string public constant symbol = \"FLB\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 250000000 * (10 ** uint256(decimals)); // 250 Millions token remaining /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { // _mint(msg.sender, INITIAL_SUPPLY); totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "248.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) throw; } } contract AccessControl is SafeMath{ /// @dev Emited when contract is upgraded - See README.md for updgrade plan event ContractUpgrade(address newContract); // The addresses of the accounts (or contracts) that can execute actions within each roles. address public ceoAddress; address public cfoAddress; address public cooAddress; address newContractAddress; uint public tip_total = 0; uint public tip_rate = 10000000000000000; // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked bool public paused = false; /// @dev Access modifier for CEO-only functionality modifier onlyCEO() { require(msg.sender == ceoAddress); _; } /// @dev Access modifier for CFO-only functionality modifier onlyCFO() { require(msg.sender == cfoAddress); _; } /// @dev Access modifier for COO-only functionality modifier onlyCOO() { require(msg.sender == cooAddress); _; } modifier onlyCLevel() { require( msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress ); _; } function () public payable{ tip_total = safeAdd(tip_total, msg.value); } /// @dev Count amount with tip. /// @param amount The totalAmount function amountWithTip(uint amount) internal returns(uint){ uint tip = safeMul(amount, tip_rate) / (1 ether); tip_total = safeAdd(tip_total, tip); return safeSub(amount, tip); } /// @dev Withdraw Tip. function withdrawTip(uint amount) external onlyCFO { require(amount > 0 && amount <= tip_total); require(msg.sender.send(amount)); tip_total = tip_total - amount; } // updgrade function setNewAddress(address newContract) external onlyCEO whenPaused { newContractAddress = newContract; emit ContractUpgrade(newContract); } /// @dev Assigns a new address to act as the CEO. Only available to the current CEO. /// @param _newCEO The address of the new CEO function setCEO(address _newCEO) external onlyCEO { require(_newCEO != address(0)); ceoAddress = _newCEO; } /// @dev Assigns a new address to act as the CFO. Only available to the current CEO. /// @param _newCFO The address of the new CFO function setCFO(address _newCFO) external onlyCEO { require(_newCFO != address(0)); cfoAddress = _newCFO; } /// @dev Assigns a new address to act as the COO. Only available to the current CEO. /// @param _newCOO The address of the new COO function setCOO(address _newCOO) external onlyCEO { require(_newCOO != address(0)); cooAddress = _newCOO; } /*** Pausable functionality adapted from OpenZeppelin ***/ /// @dev Modifier to allow actions only when the contract IS NOT paused modifier whenNotPaused() { require(!paused); _; } /// @dev Modifier to allow actions only when the contract IS paused modifier whenPaused { require(paused); _; } /// @dev Called by any \"C-level\" role to pause the contract. Used only when ///  a bug or exploit is detected and we need to limit damage. function pause() external onlyCLevel whenNotPaused { paused = true; } /// @dev Unpauses the smart contract. Can only be called by the CEO, since ///  one reason we may pause the contract is when CFO or COO accounts are ///  compromised. /// @notice This is public rather than external so it can be called by ///  derived contracts. function unpause() public onlyCEO whenPaused { // can't unpause if contract was upgraded paused = false; } } contract RpsGame is SafeMath , AccessControl{ /// @dev Constant definition uint8 constant public NONE = 0; uint8 constant public ROCK = 10; uint8 constant public PAPER = 20; uint8 constant public SCISSORS = 30; uint8 constant public DEALERWIN = 201; uint8 constant public PLAYERWIN = 102; uint8 constant public DRAW = 101; /// @dev Emited when contract is upgraded - See README.md for updgrade plan event CreateGame(uint gameid, address dealer, uint amount); event JoinGame(uint gameid, address player, uint amount); event Reveal(uint gameid, address player, uint8 choice); event CloseGame(uint gameid,address dealer,address player, uint8 result); /// @dev struct of a game struct Game { uint expireTime; address dealer; uint dealerValue; bytes32 dealerHash; uint8 dealerChoice; address player; uint8 playerChoice; uint playerValue; uint8 result; bool closed; } /// @dev struct of a game mapping (uint => mapping(uint => uint8)) public payoff; mapping (uint => Game) public games; mapping (address => uint[]) public gameidsOf; /// @dev Current game maximum id uint public maxgame = 0; uint public expireTimeLimit = 30 minutes; /// @dev Initialization contract function RpsGame() { payoff[ROCK][ROCK] = DRAW; payoff[ROCK][PAPER] = PLAYERWIN; payoff[ROCK][SCISSORS] = DEALERWIN; payoff[PAPER][ROCK] = DEALERWIN; payoff[PAPER][PAPER] = DRAW; payoff[PAPER][SCISSORS] = PLAYERWIN; payoff[SCISSORS][ROCK] = PLAYERWIN; payoff[SCISSORS][PAPER] = DEALERWIN; payoff[SCISSORS][SCISSORS] = DRAW; payoff[NONE][NONE] = DRAW; payoff[ROCK][NONE] = DEALERWIN; payoff[PAPER][NONE] = DEALERWIN; payoff[SCISSORS][NONE] = DEALERWIN; payoff[NONE][ROCK] = PLAYERWIN; payoff[NONE][PAPER] = PLAYERWIN; payoff[NONE][SCISSORS] = PLAYERWIN; ceoAddress = msg.sender; cooAddress = msg.sender; cfoAddress = msg.sender; } /// @dev Create a game function createGame(bytes32 dealerHash, address player) public payable whenNotPaused returns (uint){ require(dealerHash != 0x0); maxgame += 1; Game storage game = games[maxgame]; game.dealer = msg.sender; game.player = player; game.dealerHash = dealerHash; game.dealerChoice = NONE; game.dealerValue = msg.value; game.expireTime = expireTimeLimit + now; gameidsOf[msg.sender].push(maxgame); emit CreateGame(maxgame, game.dealer, game.dealerValue); return maxgame; } /// @dev Join a game function joinGame(uint gameid, uint8 choice) public payable whenNotPaused returns (uint){ Game storage game = games[gameid]; require(msg.value == game.dealerValue && game.dealer != address(0) && game.dealer != msg.sender && game.playerChoice==NONE); require(game.player == address(0) || game.player == msg.sender); require(!game.closed); require(now < game.expireTime); require(checkChoice(choice)); game.player = msg.sender; game.playerChoice = choice; game.playerValue = msg.value; game.expireTime = expireTimeLimit + now; gameidsOf[msg.sender].push(gameid); emit JoinGame(gameid, game.player, game.playerValue); return gameid; } /// @dev Creator reveals game choice function reveal(uint gameid, uint8 choice, bytes32 randomSecret) public returns (bool) { Game storage game = games[gameid]; bytes32 proof = getProof(msg.sender, choice, randomSecret); require(!game.closed); require(now < game.expireTime); require(game.dealerHash != 0x0); require(checkChoice(choice)); require(checkChoice(game.playerChoice)); require(game.dealer == msg.sender && proof == game.dealerHash ); game.dealerChoice = choice; Reveal(gameid, msg.sender, choice); close(gameid); return true; } /// @dev Close game settlement rewards function close(uint gameid) public returns(bool) { Game storage game = games[gameid]; require(!game.closed); require(now > game.expireTime || (game.dealerChoice != NONE && game.playerChoice != NONE)); uint8 result = payoff[game.dealerChoice][game.playerChoice]; if(result == DEALERWIN){ require(game.dealer.send(amountWithTip(safeAdd(game.dealerValue, game.playerValue)))); }else if(result == PLAYERWIN){ require(game.player.send(amountWithTip(safeAdd(game.dealerValue, game.playerValue)))); }else if(result == DRAW){ require(game.dealer.send(game.dealerValue) && game.player.send(game.playerValue)); } game.closed = true; game.result = result; emit CloseGame(gameid, game.dealer, game.player, result); return game.closed; } function getProof(address sender, uint8 choice, bytes32 randomSecret) public view returns (bytes32){ return sha3(sender, choice, randomSecret); } function gameCountOf(address owner) public view returns (uint){ return gameidsOf[owner].length; } function checkChoice(uint8 choice) public view returns (bool){ return choice==ROCK||choice==PAPER||choice==SCISSORS; } } "}
{"sol name": "542.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // (c) BokkyPooBah / Bok Consulting Pty Ltd 2018. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract FixedSupplyToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"WT\"; name = \"Welcome Token\"; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "722.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Etheriumx{ /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; string public name = \"Etheriumx\"; string public symbol = \"ETHX\"; uint256 public max_supply = 4200000000000000; uint256 public unspent_supply = 0; uint256 public spendable_supply = 0; uint256 public circulating_supply = 0; uint256 public decimals = 18; uint256 public reward = 500000000000; uint256 public timeOfLastHalving = now; uint public timeOfLastIncrease = now; event Transfer(address indexed from, address indexed to, uint256 value); event Mint(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function howCoin() public { timeOfLastHalving = now; } function updateSupply() internal returns (uint256) { if (now - timeOfLastHalving >= 2100000 minutes) { reward /= 2; timeOfLastHalving = now; } if (now - timeOfLastIncrease >= 150 seconds) { uint256 increaseAmount = ((now - timeOfLastIncrease) / 150 seconds) * reward; spendable_supply += increaseAmount; unspent_supply += increaseAmount; timeOfLastIncrease = now; } circulating_supply = spendable_supply - unspent_supply; return circulating_supply; } /* Send coins */ function transfer(address _to, uint256 _value) public { require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] -= _value;                    // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient updateSupply(); /* Notify anyone listening that the transfer took place */ Transfer(msg.sender, _to, _value); } /* Mint new coins by sending ether */ function mint() public payable { require(balanceOf[msg.sender] + _value >= balanceOf[msg.sender]); // Check for overflows uint256 _value = msg.value / 100000000; updateSupply(); require(unspent_supply - _value <= unspent_supply); unspent_supply -= _value; // Remove from unspent supply balanceOf[msg.sender] += _value; // Add the same to the recipient updateSupply(); /* Notify anyone listening that the minting took place */ Mint(msg.sender, _value); } function withdraw(uint256 amountToWithdraw) public returns (bool) { // Balance given in HOW require(balanceOf[msg.sender] >= amountToWithdraw); require(balanceOf[msg.sender] - amountToWithdraw <= balanceOf[msg.sender]); // Balance checked in HOW, then converted into Wei balanceOf[msg.sender] -= amountToWithdraw; // Added back to supply in HOW unspent_supply += amountToWithdraw; // Converted into Wei amountToWithdraw *= 100000000; // Transfered in Wei msg.sender.transfer(amountToWithdraw); updateSupply(); return true; } } "}
{"sol name": "128.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20,Pausable { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) whenNotPaused public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) whenNotPaused public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Internal function that mints an amount of the token and assigns it to * an account. This encapsulates the modification of balances such that the * proper events are emitted. * @param _account The account that will receive the created tokens. * @param _amount The amount that will be created. */ function _mint(address _account, uint256 _amount) internal { require(_account != 0); totalSupply_ = totalSupply_.add(_amount); balances[_account] = balances[_account].add(_amount); emit Transfer(address(0), _account, _amount); } /** * @dev Internal function that burns an amount of the token of a given * account. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burn(address _account, uint256 _amount) internal { require(_account != 0); require(_amount <= balances[_account]); totalSupply_ = totalSupply_.sub(_amount); balances[_account] = balances[_account].sub(_amount); emit Transfer(_account, address(0), _amount); } /** * @dev Internal function that burns an amount of the token of a given * account, deducting from the sender's allowance for said account. Uses the * internal _burn function. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burnFrom(address _account, uint256 _amount) internal { require(_amount <= allowed[_account][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount); _burn(_account, _amount); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { _burnFrom(_from, _value); } /** * @dev Overrides StandardToken._burn in order for burn and burnFrom to emit * an additional Burn event. */ function _burn(address _who, uint256 _value) internal { super._burn(_who, _value); emit Burn(_who, _value); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is BurnableToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { _mint(_to, _amount); emit Mint(_to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract GUB is MintableToken { // If ether is sent to this address, send it back. function () public { revert(); } string public constant name = \"Ancient coins\u2019 chain\"; string public constant symbol = \"GUB\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } } "}
{"sol name": "202.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 6; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "393.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'VRF' '0xVerify' token contract // // Symbol      : VRF // Name        : 0xVerify // Decimals    : 18 // // A faucet distributed token, powered by ethverify.net // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event TokensClaimed(address indexed to, uint tokens); } contract EthVerifyCore{ mapping (address => bool) public verifiedUsers; } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // 0xVRF ERC20 Token // ---------------------------------------------------------------------------- contract VerifyToken is ERC20Interface { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public dailyDistribution; uint public timestep; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; mapping(address => uint) public lastClaimed; uint public claimedYesterday; uint public claimedToday; uint public dayStartTime; bool public activated=false; address public creator; EthVerifyCore public ethVerify=EthVerifyCore(0x1Ea6fAd76886fE0C0BF8eBb3F51678B33D24186c);//0x286A090b31462890cD9Bf9f167b610Ed8AA8bD1a); // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { timestep=24 hours;//10 minutes;//24 hours; symbol = \"VRF\"; name = \"0xVerify\"; decimals = 18; dailyDistribution=10000000 * 10**uint(decimals); claimedYesterday=20; claimedToday=0; dayStartTime=now; _totalSupply=14 * dailyDistribution; balances[msg.sender] = _totalSupply; creator=msg.sender; } function activate(){ require(!activated); require(msg.sender==creator); dayStartTime=now-1 minutes; activated=true; } // ------------------------------------------------------------------------ // Claim VRF tokens daily, requires an Eth Verify account // ------------------------------------------------------------------------ function claimTokens() public{ require(activated); //progress the day if needed if(dayStartTime<now.sub(timestep)){ uint daysPassed=(now.sub(dayStartTime)).div(timestep); dayStartTime=dayStartTime.add(daysPassed.mul(timestep)); claimedYesterday=claimedToday > 1 ? claimedToday : 1; //make 1 the minimum to avoid divide by zero claimedToday=0; } //requires each account to be verified with eth verify require(ethVerify.verifiedUsers(msg.sender)); //only allows each account to claim tokens once per day require(lastClaimed[msg.sender] <= dayStartTime); lastClaimed[msg.sender]=now; //distribute tokens based on the amount distributed the previous day; the goal is to shoot for an average equal to dailyDistribution. claimedToday=claimedToday.add(1); balances[msg.sender]=balances[msg.sender].add(dailyDistribution.div(claimedYesterday)); _totalSupply=_totalSupply.add(dailyDistribution.div(claimedYesterday)); emit TokensClaimed(msg.sender,dailyDistribution.div(claimedYesterday)); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } } // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } "}
{"sol name": "1906.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender ; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract CommunityCoin is Ownable{ using SafeMath for uint256; string public constant name       = \"Community Coin\"; string public constant symbol     = \"SQ\"; uint32 public constant decimals   = 4; uint256 public totalSupply        = 2100000000 * (10 ** uint256(decimals)); uint256 public currentTotalSupply = 0; uint256 startBalance              = 2000 * (10 ** uint256(decimals)); mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function  CommunityCoin()  public { balances[msg.sender] = startBalance * 1000000; currentTotalSupply = balances[msg.sender]; } event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); if( !touched[msg.sender] && currentTotalSupply < totalSupply ){ balances[msg.sender] = balances[msg.sender].add( startBalance ); touched[msg.sender] = true; currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= allowed[_from][msg.sender]); if( !touched[_from] && currentTotalSupply < totalSupply ){ touched[_from] = true; balances[_from] = balances[_from].add( startBalance ); currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function getBalance(address _a) internal constant returns(uint256) { if( currentTotalSupply < totalSupply ){ if( touched[_a] ) return balances[_a]; else return balances[_a].add( startBalance ); } else { return balances[_a]; } } function balanceOf(address _owner) public view returns (uint256 balance) { return getBalance( _owner ); } } "}
{"sol name": "18.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title arkcomchain * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. */ contract ArkComChain is StandardToken { string public constant name = \"arkcomchain\"; // solium-disable-line uppercase string public constant symbol =\"AKC\"; // solium-disable-line uppercase uint8 public constant decimals = 18; // solium-disable-line uppercase uint256 public constant INITIAL_SUPPLY = 50000000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "54.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; contract batchTransfer { address[] public myAddresses = [ 0x5b2DC3AB81D93e39Aff9E05eF649B43C66b0AeB0, 0x8C4412c464252BB94914E0F9E562Bb77Ab320263, 0x6607F967631d1e339FB85447E09B94ed5Cb1cBAA, 0xE9416d4938010655aC74AaD09B741E6f3081546f, 0xae764600b1Fb68a19EF8fbcC7ed67cE3165eFca5, 0x9384Da73FE4d1F1739FDA1d1452D2498cAC61BfF, 0xA342495D8b9a164056b3737AB6dB87222c0beE8d, 0xd4B6eBe8b39b388d4C02752e14C214665636C993, 0x28784F888Dd07489Be572ab81c27f729B7A5a787, 0x2fcDcCcF71D85E5BC7dCe9159432Dd7Fe1078BdE, 0xe3DB56Cc1720E2278aD2e5e7AFd3e888F6cb257D, 0x6F6dcF02818df07B8c928998633E3B0D1115B28c, 0x15b79b0DcDd2Fe24e57580bD46609bbef072F33E, 0xB030230F79d18BE989779E65E10193bb0c4460Eb, 0xE253A0D1906da7299c32fC80612C10797440Da32, 0xDAC7A83cbF4258DB09754B1fa4Da779d022c72b6, 0xFF9D966677Dec7eB913D8dEe6e69Ff61C28325eF, 0xabB695f58B38793D588a80352F7DFC68966Ec53E, 0xd401fD7F203F4Fad99571A37DC2E9Ae9644eef48, 0xaf9e8cd00ff7573eF0FdD949029F04fe2da8BFb3, 0x41cBC714250C5dB7E5877c831261aa3e228d0916, 0x9dd6586F5E8D648c4e2FA9C3FA07819041656dd7, 0x556Dd99B29AbaD4AC5c61ee36890A32a75783715, 0x1642791AaEf1C912707dC7F17e2147A5ADf9a839, 0x1D78d085C97dfF2bA774687b0DcffF4a67376011, 0x904c6dB89a798f87157f04F35c17fdcB652Ec8Fd, 0x34206e6f291b52756e623a6Beb55aFa4b22399b8, 0xc99Fb3d886ef3Ff71249ca22B21Ff83F6E64B606, 0x0C5D768b78ff431e3C27D4F3A88F6670Fc4E8610, 0x3625d83586Bc91BA8E8e79233C3D426739380B29, 0xE76331fb4DCC351633B98B9f5d42f5954Db446B1, 0xF088E97c3B9B7e0DD677aebe54848f0b4eb34e21, 0x7553D4a5a567087c1BcE9f96071CD51226833c3e, 0x782d8FaeBff4baAF86921ac431b260375c45063B, 0x0EA88658849a23ca5E20ce643f39BD7dc8Fd368B, 0xd2024B274B12dd95fbaC9392d208B0B7737154A5, 0x1d4E16E0D8f18947fa939008465D3129021e99cf, 0xD1e8fd033ca94f167eeF921a0F8dcBA2E7d01182, 0xcA1f83208B0efb6282e8f197880F299202FbA0fF, 0xa5150b4174519b6Eb206f4456A0bE66DA1A9e691, 0x9524fc8BC9E7Aaf986e1B0E5498BbaAE69808F89, 0xaAaaBf83a984BA644a8b4b1843B2ec08FaaeCA64, 0xde1CC0783905289f57dd2FceC1513293b8DD3ba4, 0x9d00b9FF2d6F82480FCF2C920FbE4E834c772E6b, 0x56EEDe921f823De0A470818fEFa051f6260013cD, 0x5F2c23ECe21ea6E8561ea0f567f31B937B6E28E4, 0xFa15fEDD4880c9cCe9856281FE4E539050a4569b, 0xf6626743272C1a9fb3955aFb4C4FF00a3a46497C, 0x9803b5734DE9Ea32D16Af965e94f07405322245b, 0xf104Fe12Bf041034DB29f63CaB36FbBd98281A43, 0xBE1895E63A71BbfC46e179ce56c14f519071095e, 0x52d2Cf5909cc6761BAbFAAc5440BdC82997D1bC4, 0xa0a1433420c2AFF66150FbB6D6A80B7048EEb1bA, 0xd6b86d2CE7c52CDc23a2886464885EBe382B0284, 0x71ac7d574934A5eDd915E5cDc6b8ac60dFccA61e, 0xa624cAcd35882525EC51C7cd17185879d60535e9, 0x856285311844641b7dbA81ab3c54A9c8bB8DE3dD, 0x6fd79C7c984FB6763E1938B0B7f28f94b9D384A2, 0xc90c58D88d9d5Cb053b05883262115899A4Ea7CB, 0x093Ca190B3C94E902AC5e6dEc8D1eD483e0321c5, 0x8E4fDa3c5f8d51D6C801D3Bd5Eb99a82aE87DF40, 0x380Ba482fd2c0FC66823b4dCCbCD47185E0d4fA0, 0x39e75384c376ffF58E42F2910E49E1338479D158, 0xaaAa1283244b24C44F533420050224E735946303, 0xbbAf3c51B495391373A2154D3e0E4299C59d1bEF, 0x6bCa329ad2d1bf95dbD5ad6c70d5fDddC915CA7B, 0x70D3F4208eFC02B05b7b5A3Fd217cdc2F4911704, 0x044A3C4A496BC6023Cb2F59d41E3Ab0217574E8C, 0x8DBeAb95B0FD027DA4D6353B7991289159Ba06C9, 0xe997DDBf27Cd4ACD1a88FA516fAA3c300c41b885, 0x7bBF311c73532ebb6571224744E75aF2fC0d9833, 0x117F52Eb3242607ab1a8c754Ea54014A1C8C52C9, 0x8E67D26AB3f5db50FaA18287cBd7Da72Ee56636d, 0x8542303022F1F7A81a6Df7f066D81a78D96f0F2f, 0xa53a3BE7A5b36Caaec14F4d00cD04F74eBF883eA, 0x668eab7df58907c2cABf441D7B6e3cea2F07B60A, 0x045F48abd4739A4d3704416B3ed362Af9cC27F69, 0x2DAf0a2fdaf9effc225841cBb8009FD09e3C47FC, 0xD3e12D6744E6abF7fcf4492EA9CD3B040C2428Ee, 0x6c02D148b163a93d579b286AbA6ce20c0B3B6Ae7, 0x6D6cdDF08938aD110d87542d3B55EF53E6ED26af, 0xa36e6188528173fA2Ecb8133d8Fe0C57df34E866, 0x582b439ced8627b4C2E69664e49564Bb7C4AD146, 0x97753864e455b9DF40a3d457688Dd0F739905B02, 0x855f7cf32bF65a5dd9e13024128fa1b74eACAdCF, 0xBCFEFfD1D7A034b095d707A05F0425cC10512989, 0x6Aa1D3598cF0F9Bf7643f69378eb7e5c1BAB0904, 0x0497456050ECa522071e4507d9A55c50E421ccFB, 0x683Ba23E874b50Cde4cd0A26878289464aEF84BD, 0x9cE40D91480B7457f1aaD0a478e546e93f6c499B, 0xaF77780496483E1b620cA073AB58d8993942591D, 0x754979e6727a216E8f3de1f9Ca2fF555ba3A889f, 0x665B2EEe02C08D9A952Edc7AFEd449a5596d1e2A, 0x262858b03a5dE771977c40e59466842B70cB708a, 0x890c79739a774E64C76b1210867a7CFDC203c861, 0x8c512d31b2553910c5704e8E87fd39f0e72C6Efe, 0x081e81977fAf6b3A2c645b44D76cA61bcB7851c7, 0xD42B9787eD96BB41Cd64499931703585555FB185, 0x54344711bdDc9B993feD8B0a07b01F31FbEB19Dd, 0x752BF4E2F7f4350c7DfC84B07b2262a8dbC5836C, 0x82E46988ec44EAb496FA02C8e54ebead03aD30DD, 0x1a64F4E3404e34487C8F0feFD6349FF77c220c49, 0xa42580Bc3cF5b6dBD641eA8d9d26c3F0165cC877, 0x58b804504Dde617986EaBD5fD570f1565f039A4B, 0x63815621a0EeA35Df10E49E7364a2c74b893c2ba, 0x4Aa984Fc7d8Ba47c22371AB4B43d386812D77365 ]; function () public payable { require(myAddresses.length>0); uint256 distr = msg.value/myAddresses.length; for(uint256 i=0;i<myAddresses.length;i++) { myAddresses[i].transfer(distr); } } } "}
{"sol name": "1642.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract GCA{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ uint256 public totalSupply; string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function GCA() public { balances[msg.sender] = 10000000000000;               // Give the creator all initial tokens totalSupply = 10000000000000;                        // Update total supply name = \"Gold chain assets\";                                   // Set the name for display purposes decimals =4;                            // Amount of decimals for display purposes symbol = \"GCA\";                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "602.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'GoodBoyPoints' token contract // // Deployed to : 0x065B31b52d899c7DA58B6196fBA8Ae47B9A5f952 // Symbol      : GBP // Name        : GoodBoyPoints // Total supply: 10000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract GoodBoyPoints is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function GoodBoyPoints() public { symbol = \"GBP\"; name = \"GoodBoyPoints\"; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0x065B31b52d899c7DA58B6196fBA8Ae47B9A5f952] = _totalSupply; Transfer(address(0), 0x065B31b52d899c7DA58B6196fBA8Ae47B9A5f952, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "598.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //\u5bcc\u52d2\u70ef\u592a\u7a7a\u94fe FULLERENE SPACE CHAIN string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "558.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /*-------------------------------------------------- ____                           ____              _ / ___| _   _ _ __   ___ _ __   / ___|__ _ _ __ __| | \\___ \\| | | | '_ \\ / _ \\ '__| | |   / _` | '__/ _` | ___) | |_| | |_) |  __/ |    | |__| (_| | | | (_| | |____/ \\__,_| .__/ \\___|_|     \\____\\__,_|_|  \\__,_| |_| 2018-08-08 V0.8 ---------------------------------------------------*/ contract SPCevents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit, add pot directly by admin to next round event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } //============================================================================== //   _ _  _ _|_ _ _  __|_   _ _ _|_    _   . //  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  . //====================================|========================================= contract SuperCard is SPCevents { using SafeMath for *; using NameFilter for string; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xbac825cdb506dcf917a7715a4bf3fa1b06abe3e4); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== address private admin = msg.sender; string constant public name   = \"SuperCard\"; string constant public symbol = \"SPC\"; uint256 private rndExtra_     = 0;     // length of the very first ICO uint256 private rndGap_ = 2 minutes;         // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 6 hours;           // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // last rID uint256 public pID_;    // last pID //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => SPCdatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => SPCdatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => SPCdatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id mapping (uint256 => uint256) public attend;   // (index => pID) player ID attend current round //**************** // TEAM FEE DATA //**************** mapping (uint256 => SPCdatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => SPCdatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { fees_[0] = SPCdatasets.TeamFee(80,2); fees_[1] = SPCdatasets.TeamFee(80,2); fees_[2] = SPCdatasets.TeamFee(80,2); fees_[3] = SPCdatasets.TeamFee(80,2); // how to split up the final pot based on which team was picked potSplit_[0] = SPCdatasets.PotSplit(20,10); potSplit_[1] = SPCdatasets.PotSplit(20,10); potSplit_[2] = SPCdatasets.PotSplit(20,10); potSplit_[3] = SPCdatasets.PotSplit(20,10); activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { if ( activated_ == false ){ if ( (now >= pre_active_time) &&  (pre_active_time > 0) ){ activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } require(activated_ == true, \"its not ready yet.\"); _; } /** * @dev prevents contracts from interacting with SuperCard */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // reload core, team set to 2, snake reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 myrID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 upperLimit = 0; uint256 usedGen = 0; // eth send to player uint256 ethout = 0; uint256 over_gen = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = (calceth(plyrRnds_[_pID][myrID].keys).mul(105))/100; if(plyr_[_pID].gen >= upperLimit) { over_gen = (plyr_[_pID].gen).sub(upperLimit); round_[myrID].keys = (round_[myrID].keys).sub(plyrRnds_[_pID][myrID].keys); plyrRnds_[_pID][myrID].keys = 0; round_[myrID].pot = (round_[myrID].pot).add(over_gen); usedGen = upperLimit; } else { plyrRnds_[_pID][myrID].keys = (plyrRnds_[_pID][myrID].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); round_[myrID].keys = (round_[myrID].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); usedGen = plyr_[_pID].gen; } ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); } else { ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)); } plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].addr.transfer(ethout); // check to see if round has ended and no one has run round end yet if (_now > round_[myrID].end && round_[myrID].ended == false && round_[myrID].plyr != 0) { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[myrID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit SPCevents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, ethout, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // fire withdraw event emit SPCevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, ethout, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // price 0.01 ETH return(10000000000000000); } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // if round has ended.  but round end has not been run (so contract has not distributed winnings) return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, 2, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } // put eth in players vault, to win vault plyr_[_pID].win = plyr_[_pID].win.add(msg.value); } } /** * @dev gen limit handle */ function genLimit(uint256 _pID) private returns(uint256) { // setup local rID uint256 myrID = rID_; uint256 upperLimit = 0; uint256 usedGen = 0; uint256 over_gen = 0; uint256 eth_can_use = 0; uint256 tempnum = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = ((plyrRnds_[_pID][myrID].keys).mul(105))/10000; if(plyr_[_pID].gen >= upperLimit) { over_gen = (plyr_[_pID].gen).sub(upperLimit); round_[myrID].keys = (round_[myrID].keys).sub(plyrRnds_[_pID][myrID].keys); plyrRnds_[_pID][myrID].keys = 0; round_[myrID].pot = (round_[myrID].pot).add(over_gen); usedGen = upperLimit; } else { tempnum = ((plyr_[_pID].gen).mul(10000))/105; plyrRnds_[_pID][myrID].keys = (plyrRnds_[_pID][myrID].keys).sub(tempnum); round_[myrID].keys = (round_[myrID].keys).sub(tempnum); usedGen = plyr_[_pID].gen; } eth_can_use = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } else { eth_can_use = (plyr_[_pID].win).add(plyr_[_pID].aff); plyr_[_pID].win = 0; plyr_[_pID].aff = 0; } return(eth_can_use); } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 myrID = rID_; // grab time uint256 _now = now; uint256 eth_can_use = 0; // if round is active if (_now > round_[myrID].strt + rndGap_ && (_now <= round_[myrID].end || (_now > round_[myrID].end && round_[myrID].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. eth_can_use = genLimit(_pID); if(eth_can_use > 0) { // call core core(myrID, _pID, eth_can_use, _affID, 2, _eventData_); } // if round is not active and end round needs to be ran } else if (_now > round_[myrID].end && round_[myrID].ended == false) { // end the round (distributes pot) & start new round round_[myrID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // if player is new to round\u3002 if (plyrRnds_[_pID][_rID].jionflag != 1) { _eventData_ = managePlayer(_pID, _eventData_); plyrRnds_[_pID][_rID].jionflag = 1; attend[round_[_rID].attendNum] = _pID; round_[_rID].attendNum  = (round_[_rID].attendNum).add(1); } if (_eth > 10000000000000000) { // mint the new keys uint256 _keys = calckeys(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; round_[_rID].team = 2; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][2] = _eth.add(rndTmEth_[_rID][2]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, 2, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, 2, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, 2, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { uint256 temp; temp = (round_[_rIDlast].mask).mul((plyrRnds_[_pID][_rIDlast].keys)/1000000000000000000); if(temp > plyrRnds_[_pID][_rIDlast].mask) { return( temp.sub(plyrRnds_[_pID][_rIDlast].mask) ); } else { return( 0 ); } } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { return ( calckeys(_eth) ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { return ( _keys/100 ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of SuperCard if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); pID_ = _pID; // save Last pID bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 temp_eth = 0; // if player has played a previous round, move their unmasked earnings // from that round to win vault. if (plyr_[_pID].lrnd != 0) { updateGenVault(_pID, plyr_[_pID].lrnd); temp_eth = ((plyr_[_pID].win).add((plyr_[_pID].gen))).add(plyr_[_pID].aff); plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].win = temp_eth; } // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(30)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards _com = _com.add(_p3d.sub(_p3d / 2)); admin.transfer(_com); _res = _res.add(_p3d / 2); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // pay 3% out to community rewards uint256 _p3d = (_eth/100).mul(3); // distribute share to affiliate // 5%:3%:2% uint256 _aff_cent = (_eth) / 100; uint256 tempID  = _affID; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered // 5% if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(5)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(5), now); } else { _p3d = _p3d.add(_aff_cent.mul(5)); } tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(3)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(3), now); } else { _p3d = _p3d.add(_aff_cent.mul(3)); } tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(2)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(2), now); } else { _p3d = _p3d.add(_aff_cent.mul(2)); } // pay out p3d _p3d = _p3d.add((_eth.mul(fees_[2].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); // set up event data _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } /** * @dev */ function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit SPCevents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // calculate gen share\uff0c80% uint256 _gen = (_eth.mul(fees_[2].gen)) / 100; // pot 5% uint256 _pot = (_eth.mul(5)) / 100; // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (2 * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit SPCevents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; //uint256 public pre_active_time = 0; uint256 public pre_active_time = now + 600 seconds; /** * @dev return active flag \u3001time * @return active flag * @return active time * @return system time */ function getRunInfo() public view returns(bool, uint256, uint256) { return ( activated_,      //0 pre_active_time, //1 now          //2 ); } function setPreActiveTime(uint256 _pre_time) public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); pre_active_time = _pre_time; } function activate() public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); // can only be ran once require(activated_ == false, \"SuperCard already activated\"); // activate the contract activated_ = true; //activated_ = false; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== function calckeys(uint256 _eth) pure public returns(uint256) { return ( (_eth).mul(100) ); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function calceth(uint256 _keys) pure public returns(uint256) { return( (_keys)/100 ); } function clearKeys(uint256 num) public { // setup local rID uint256 myrID = rID_; uint256 number = num; if(num == 1) { number = 10000; } uint256 over_gen; uint256 cleared = 0; uint256 checkID; uint256 upperLimit; uint256 i; for(i = 0; i< round_[myrID].attendNum; i++) { checkID = attend[i]; updateGenVault(checkID, plyr_[checkID].lrnd); if (plyr_[checkID].gen > 0) { upperLimit = ((plyrRnds_[checkID][myrID].keys).mul(105))/10000; if(plyr_[checkID].gen >= upperLimit) { over_gen = (plyr_[checkID].gen).sub(upperLimit); cleared = cleared.add(plyrRnds_[checkID][myrID].keys); round_[myrID].keys = (round_[myrID].keys).sub(plyrRnds_[checkID][myrID].keys); plyrRnds_[checkID][myrID].keys = 0; round_[myrID].pot = (round_[myrID].pot).add(over_gen); plyr_[checkID].win = ((plyr_[checkID].win).add(upperLimit)); plyr_[checkID].gen = 0; if(cleared >= number) break; } } } } /** * @dev calc Invalid Keys by rID&pId */ function calcInvalidKeys(uint256 _rID,uint256 _pID) private returns(uint256) { uint256 InvalidKeys = 0; uint256 upperLimit = 0; updateGenVault(_pID, plyr_[_pID].lrnd); if (plyr_[_pID].gen > 0) { upperLimit = ((plyrRnds_[_pID][_rID].keys).mul(105))/10000; if(plyr_[_pID].gen >= upperLimit) { InvalidKeys = InvalidKeys.add(plyrRnds_[_pID][_rID].keys); } } return(InvalidKeys); } /** * @dev return Invalid Keys * @return Invalid Keys * @return Total Keys * @return timestamp */ function getInvalidKeys() public view returns(uint256,uint256,uint256) { uint256 LastRID = rID_; uint256 LastPID = pID_; uint256 _rID = 0; uint256 _pID = 0; uint256 InvalidKeys = 0; uint256 TotalKeys = 0; for( _rID = 1 ; _rID <= LastRID ; _rID++) { TotalKeys = TotalKeys.add(round_[_rID].keys); for( _pID = 1 ; _pID <= LastPID ; _pID++) { InvalidKeys = InvalidKeys.add(calcInvalidKeys(_rID,_pID)); } } return ( InvalidKeys, //0 TotalKeys,   //1 now          //2 ); } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library SPCdatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 jionflag;   // player not jion round uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase uint256 attendNum; // number of players attend } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 p3d;    // % of buy in thats paid to p3d holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 p3d;    // % of pot thats paid to p3d holders } } //============================================================================== //  . _ _|_ _  _ |` _  _ _  _  . //  || | | (/_| ~|~(_|(_(/__\\  . //============================================================================== interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } /** * @title -Name Filter- v0.1.9 */ library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } } "}
{"sol name": "380.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract ERC20 { /// @return total amount of tokens function totalSupply() public constant returns (uint supply); /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public constant returns (uint balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) public returns (bool success); /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public constant returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract ODCToken is ERC20 { uint public _totalSupply = 100*10**26; uint8 constant public decimals = 18; string constant public name = \"OdcToken\"; string constant public symbol = \"ODC\"; mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; function ODCToken() public { balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); } function totalSupply() public constant returns (uint supply) { return _totalSupply; } function balanceOf(address _owner) public constant returns (uint) { return balances[_owner]; } function transfer(address _to, uint _value) public returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } function approve(address _spender, uint _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint) { return allowed[_owner][_spender]; } function () public { revert(); } } "}
{"sol name": "874.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 4;  // 4\u662f\u5efa\u8bae\u7684\u9ed8\u8ba4\u503c uint256 public totalSupply;  //\u603b\u91cf mapping (address => uint256) public balanceOf;  //\u5bf9\u5e94\u5730\u5740\u7684\u4f59\u989d mapping (address => mapping (address => uint256)) public allowance;//\u9650\u989d event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "1975.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1621.sol", "label": 0, "sol content": "pragma solidity 0.4.24; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnboundedRegularToken is RegularToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract LeajoeToken is UnboundedRegularToken { uint public totalSupply = 1000000000000000000000000000; uint8 constant public decimals = 18; string constant public name = \"LeajoeToken\"; string constant public symbol = \"LJT\"; function LeajoeToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "1901.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; contract ZethrUtils { using SafeMath for uint; Zethr constant internal              ZETHR = Zethr(0xD48B633045af65fF636F3c6edd744748351E020D); /*===================================== =            CONSTANTS                = =====================================*/ uint8 constant public                decimals              = 18; uint constant internal               tokenPriceInitial_    = 0.000653 ether; uint constant internal               magnitude             = 2**64; uint constant internal               icoHardCap            = 250 ether; uint constant internal               addressICOLimit       = 1   ether; uint constant internal               icoMinBuyIn           = 0.1 finney; uint constant internal               icoMaxGasPrice        = 50000000000 wei; uint constant internal               MULTIPLIER            = 9615; uint constant internal               MIN_ETH_BUYIN         = 0.0001 ether; uint constant internal               MIN_TOKEN_SELL_AMOUNT = 0.0001 ether; uint constant internal               MIN_TOKEN_TRANSFER    = 1e10; uint constant internal               referrer_percentage   = 25; /*======================================= =            PUBLIC FUNCTIONS           = =======================================*/ function tokensToEthereum_1(uint _tokens, uint tokenSupply) public view returns(uint, uint) { // First, separate out the sell into two segments: //  1) the amount of tokens selling at the ICO price. //  2) the amount of tokens selling at the variable (pyramid) price uint tokensToSellAtICOPrice = 0; uint tokensToSellAtVariablePrice = 0; uint tokensMintedDuringICO = ZETHR.tokensMintedDuringICO(); if (tokenSupply <= tokensMintedDuringICO) { // Option One: All the tokens sell at the ICO price. tokensToSellAtICOPrice = _tokens; } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens >= tokensMintedDuringICO) { // Option Two: All the tokens sell at the variable price. tokensToSellAtVariablePrice = _tokens; } else if (tokenSupply > tokensMintedDuringICO && tokenSupply - _tokens < tokensMintedDuringICO) { // Option Three: Some tokens sell at the ICO price, and some sell at the variable price. tokensToSellAtVariablePrice = tokenSupply.sub(tokensMintedDuringICO); tokensToSellAtICOPrice      = _tokens.sub(tokensToSellAtVariablePrice); } else { // Option Four: Should be impossible, and the compiler should optimize it out of existence. revert(); } // Sanity check: assert(tokensToSellAtVariablePrice + tokensToSellAtICOPrice == _tokens); return (tokensToSellAtICOPrice, tokensToSellAtVariablePrice); } function tokensToEthereum_2(uint tokensToSellAtICOPrice) public pure returns(uint) { // Track how much Ether we get from selling at each price function: uint ethFromICOPriceTokens = 0; // Now, actually calculate: if (tokensToSellAtICOPrice != 0) { /* Here, unlike the sister equation in ethereumToTokens, we DON'T need to multiply by 1e18, since we will be passed in an amount of tokens to sell that's already at the 18-decimal precision. We need to divide by 1e18 or we'll have too much Ether. */ ethFromICOPriceTokens = tokensToSellAtICOPrice.mul(tokenPriceInitial_).div(1e18); } return ethFromICOPriceTokens; } function tokensToEthereum_3(uint tokensToSellAtVariablePrice, uint tokenSupply) public pure returns(uint) { // Track how much Ether we get from selling at each price function: uint ethFromVarPriceTokens = 0; // Now, actually calculate: if (tokensToSellAtVariablePrice != 0) { /* Note: Unlike the sister function in ethereumToTokens, we don't have to calculate any \"virtual\" token count. This is because in sells, we sell the variable price tokens **first**, and then we sell the ICO-price tokens. Thus there isn't any weird stuff going on with the token supply. We have the equations for total investment above; note that this is for TOTAL. To get the eth received from this sell, we calculate the new total investment after this sell. Note that we divide by 1e6 here as the inverse of multiplying by 1e6 in ethereumToTokens. */ uint investmentBefore = toPowerOfThreeHalves(tokenSupply.div(MULTIPLIER * 1e6)).mul(2).div(3); uint investmentAfter  = toPowerOfThreeHalves((tokenSupply - tokensToSellAtVariablePrice).div(MULTIPLIER * 1e6)).mul(2).div(3); ethFromVarPriceTokens = investmentBefore.sub(investmentAfter); } return ethFromVarPriceTokens; } // How much Ether we get from selling N tokens function tokensToEthereum_(uint _tokens, uint tokenSupply) public view returns(uint) { require (_tokens >= MIN_TOKEN_SELL_AMOUNT, \"Tried to sell too few tokens.\"); /* *  i = investment, p = price, t = number of tokens * *  i_current = p_initial * t_current                   (for t_current <= t_initial) *  i_current = i_initial + (2/3)(t_current)^(3/2)      (for t_current >  t_initial) * *  t_current = i_current / p_initial                   (for i_current <= i_initial) *  t_current = t_initial + ((3/2)(i_current))^(2/3)    (for i_current >  i_initial) */ uint tokensToSellAtICOPrice; uint tokensToSellAtVariablePrice; (tokensToSellAtICOPrice, tokensToSellAtVariablePrice) = tokensToEthereum_1(_tokens, tokenSupply); uint ethFromICOPriceTokens = tokensToEthereum_2(tokensToSellAtICOPrice); uint ethFromVarPriceTokens = tokensToEthereum_3(tokensToSellAtVariablePrice, tokenSupply); uint totalEthReceived = ethFromVarPriceTokens + ethFromICOPriceTokens; assert(totalEthReceived > 0); return totalEthReceived; } /*======================= =   MATHS FUNCTIONS    = ======================*/ function toPowerOfThreeHalves(uint x) public pure returns (uint) { // m = 3, n = 2 // sqrt(x^3) return sqrt(x**3); } function toPowerOfTwoThirds(uint x) public pure returns (uint) { // m = 2, n = 3 // cbrt(x^2) return cbrt(x**2); } function sqrt(uint x) public pure returns (uint y) { uint z = (x + 1) / 2; y = x; while (z < y) { y = z; z = (x / z + z) / 2; } } function cbrt(uint x) public pure returns (uint y) { uint z = (x + 1) / 3; y = x; while (z < y) { y = z; z = (x / (z*z) + 2 * z) / 3; } } } /*======================= =     INTERFACES       = ======================*/ contract Zethr { uint public                          stakingRequirement; uint public                          tokensMintedDuringICO; } // Think it's safe to say y'all know what this is. library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { if (a == 0) { return 0; } uint c = a * b; assert(c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } } "}
{"sol name": "206.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply,string tokenName,    string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "929.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract Golem { // Public variables of the token string public name = \"Golem\"; string public symbol = \"ZNX\"; uint8 public decimals = 18; // 18 decimals is the strongly suggested default uint256 public totalSupply; uint256 public GolemSupply = 1000000000000000000000000000; uint256 public price ; address public creator; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function Gnosis() public { totalSupply = GolemSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;    // Give BicycleToken Mint the total created tokens creator = msg.sender; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to !=0x8c26348f63f9e008f0dd09a0ce1ed7caf6c1366b); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /// @notice Buy tokens from contract by sending ether function () payable internal { if (price == 0 ether){ uint ammount = 1;                  // calculates the amount, made it so you can get many BicycleMinth but to get MANY BicycleToken you have to spend ETH and not WEI uint ammountRaised; ammountRaised += msg.value;                            //many thanks Bicycle, couldnt do it without r/me_irl require(balanceOf[creator] >= 6000000); // checks if it has enough to sell require(msg.value < 0.5 ether); // so any person who wants to put more then 0.1 ETH has time to think about what they are doing require(balanceOf[msg.sender] == 0);     // one users doesn't collect more than once balanceOf[msg.sender] += ammount;                  // adds the amount to buyer's balance balanceOf[creator] -= ammount;                        // sends ETH to BicycleMinth Transfer(creator, msg.sender, ammount);               // execute an event reflecting the change creator.transfer(ammountRaised); } } } "}
{"sol name": "279.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PopConChain is StandardToken { string public name = 'PopConChain'; string public symbol = 'POPCON'; uint public decimals = 10; uint public INITIAL_SUPPLY = 44.63 * 100000000 * (10 ** decimals); address owner; bool public released = false; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; owner = msg.sender; } function release() public { require(owner == msg.sender); require(!released); released = true; } function lock() public { require(owner == msg.sender); require(released); released = false; } function get_Release() view public returns (bool) { return released; } modifier onlyReleased() { if (owner != msg.sender) require(released); _; } function transfer(address to, uint256 value) public onlyReleased returns (bool) { super.transfer(to, value); } function allowance(address _owner, address _spender) public onlyReleased view returns (uint256) { super.allowance(_owner, _spender); } function transferFrom(address from, address to, uint256 value) public onlyReleased returns (bool) { super.transferFrom(from, to, value); } function approve(address spender, uint256 value) public onlyReleased returns (bool) { super.approve(spender, value); } } "}
{"sol name": "228.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * GRP TOKEN Contract * ERC-20 Token Standard Compliant * @author Fares A. Akel C. [email\u00a0protected] */ /** * @title SafeMath by OpenZeppelin * @dev Math operations with safety checks that throw on error */ library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * Token contract interface for external use */ contract ERC20TokenInterface { function balanceOf(address _owner) public constant returns (uint256 value); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); } /** * @title Admin parameters * @dev Define administration parameters for this contract */ contract admined { //This token contract is administered address public admin; //Master address is public mapping(address => uint256) public level; //Admin level bool public lockSupply; //Burn Lock flag /** * @dev Contract constructor * define initial administrator */ constructor() public { admin = 0x6585b849371A40005F9dCda57668C832a5be1777; //Set initial admin level[admin] = 2; emit Admined(admin); } modifier onlyAdmin(uint8 _level) { //A modifier to define admin-only functions require(msg.sender == admin || level[msg.sender] >= _level); _; } modifier supplyLock() { //A modifier to lock burn transactions require(lockSupply == false); _; } /** * @dev Function to set new admin address * @param _newAdmin The address to transfer administration to */ function transferAdminship(address _newAdmin) onlyAdmin(2) public { //Admin can be transfered require(_newAdmin != address(0)); admin = _newAdmin; level[_newAdmin] = 2; emit TransferAdminship(admin); } function setAdminLevel(address _target, uint8 _level) onlyAdmin(2) public { level[_target] = _level; emit AdminLevelSet(_target,_level); } /** * @dev Function to set burn lock * @param _set boolean flag (true | false) */ function setSupplyLock(bool _set) onlyAdmin(2) public { //Only the admin can set a lock on supply lockSupply = _set; emit SetSupplyLock(_set); } //All admin actions have a log for public review event SetSupplyLock(bool _set); event TransferAdminship(address newAdminister); event Admined(address administer); event AdminLevelSet(address _target,uint8 _level); } /** * @title Token definition * @dev Define token paramters including ERC20 ones */ contract ERC20Token is ERC20TokenInterface, admined { //Standard definition of a ERC20Token using SafeMath for uint256; uint256 public totalSupply; mapping (address => uint256) balances; //A mapping of all balances per address mapping (address => mapping (address => uint256)) allowed; //A mapping of all allowances /** * @dev Get the balance of an specified address. * @param _owner The address to be query. */ function balanceOf(address _owner) public constant returns (uint256 value) { return balances[_owner]; } /** * @dev transfer token to a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool success) { require(_to != address(0)); //If you dont want that people destroy token balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev transfer token from an address to another specified address using allowance * @param _from The address where token comes. * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != address(0)); //If you dont want that people destroy token allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Assign allowance to an specified address to use the owner balance * @param _spender The address to be allowed to spend. * @param _value The amount to be allowed. */ function approve(address _spender, uint256 _value) public returns (bool success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); //exploit mitigation allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Get the allowance of an specified address to use another address balance. * @param _owner The address of the owner of the tokens. * @param _spender The address of the allowed spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * @dev Burn token of an specified address. * @param _target The address of the holder of the tokens. * @param _burnedAmount amount to burn. */ function burnToken(address _target, uint256 _burnedAmount) onlyAdmin(2) supplyLock public { balances[_target] = SafeMath.sub(balances[_target], _burnedAmount); totalSupply = SafeMath.sub(totalSupply, _burnedAmount); emit Burned(_target, _burnedAmount); } /** * @dev Log Events */ event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burned(address indexed _target, uint256 _value); event FrozenStatus(address _target,bool _flag); } /** * @title AssetGRP * @dev Initial supply creation */ contract AssetGRP is ERC20Token { string public name = 'Gripo'; uint8 public decimals = 18; string public symbol = 'GRP'; string public version = '1'; address writer = 0xA6bc924715A0B63C6E0a7653d3262D26F254EcFd; constructor() public { totalSupply = 200000000 * (10**uint256(decimals)); //initial token creation balances[writer] = totalSupply / 10000; //0.01% balances[admin] = totalSupply.sub(balances[writer]); emit Transfer(address(0), writer, balances[writer]); emit Transfer(address(0), admin, balances[admin]); } /** *@dev Function to handle callback calls */ function() public { revert(); } } "}
{"sol name": "427.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'utrToken' token contract // // Deployed to : 0xa718d72d0bc59fb61741f10450a6c1e8aade4253 // Symbol      : UTR // Name        : UTR Token // Total supply: 120,000,000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract utrToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function utrToken() public { symbol = \"UTR\"; name = \"UTR Token\"; decimals = 18; _totalSupply = 120000000000000000000000000; balances[0x8444b8bc20A1d93a252A9dED8187B95a121a16f1] = _totalSupply; Transfer(address(0), 0x8444b8bc20A1d93a252A9dED8187B95a121a16f1, _totalSupply); endDate = now + 365 days; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 290 UTRT per 1 ETH // ------------------------------------------------------------------------ function () public payable { uint tokens = msg.value * 290; balances[msg.sender] = safeAdd(balances[msg.sender], tokens); balances[0x8444b8bc20A1d93a252A9dED8187B95a121a16f1] = safeSub(balances[0x8444b8bc20A1d93a252A9dED8187B95a121a16f1],tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1834.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract CustomToken is BaseToken { function CustomToken() public { totalSupply = 1000000000000000000000000000; name = 'InfluenceChain'; symbol = 'INC'; decimals = 18; balanceOf[0xa8128722cb9c4e17ddc08ecb3706a74d962e153e] = totalSupply; Transfer(address(0), 0xa8128722cb9c4e17ddc08ecb3706a74d962e153e, totalSupply); } } "}
{"sol name": "149.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/lifecycle/Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/PausableToken.sol contract PausableToken is StandardToken, Pausable { address public allowedTransferWallet; constructor(address _allowedTransferWallet) public { allowedTransferWallet = _allowedTransferWallet; } modifier whenNotPausedOrOwnerOrAllowed() { require(!paused || msg.sender == owner || msg.sender == allowedTransferWallet); _; } function changeAllowTransferWallet(address _allowedTransferWallet) public onlyOwner { allowedTransferWallet = _allowedTransferWallet; } /** * @dev Transfer token for a specified address with pause feature for owner. * @dev Only applies when the transfer is allowed by the owner. * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public whenNotPausedOrOwnerOrAllowed returns (bool) { return super.transfer(_to, _value); } /** * @dev Transfer tokens from one address to another with pause feature for owner. * @dev Only applies when the transfer is allowed by the owner. * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public whenNotPausedOrOwnerOrAllowed returns (bool) { return super.transferFrom(_from, _to, _value); } } // File: zeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; function DetailedERC20(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } // File: contracts/AbacasToken.sol contract AbacasToken is DetailedERC20(\"AbacasXchange [Abacas] Token\", \"ABCS\", 9), PausableToken { constructor(address _allowedTransferWallet) PausableToken(_allowedTransferWallet) public { totalSupply_ = 100e6 * (uint256(10) ** decimals); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } } "}
{"sol name": "166.sol", "label": 0, "sol content": "pragma solidity ^0.4.13; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PredictToken is StandardToken{ address public owner; string public name = 'PredictToken'; string public symbol = 'PT'; uint8 public decimals = 8; uint256 constant total = 100000000000000000; // 1 billion constructor() public { owner = msg.sender; totalSupply_ = total; balances[owner] = total; } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } "}
{"sol name": "962.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"VK-X\"; decimals = 4; totalSupply = 100000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]);   // ?????? balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); // ??????? emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract is owned { string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } // constructor function SelfDesctructionContract() { owner = msg.sender; } // a simple setter function function setSomeValue(string value){ someValue = value; } // you can call it anything you want function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "799.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract BlockchainMoneyEngine is Pausable { address public owner; // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function BlockchainMoneyEngine( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes owner = msg.sender; } function setName(string _name) onlyOwner() public { name = _name; } function setSymbol(string _symbol) onlyOwner() public { symbol = _symbol; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function destruct() public { if (owner == msg.sender) { selfdestruct(owner); } } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public whenNotPaused { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "942.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface TokenReceiver { function tokenFallback(address from, uint256 qty, bytes data) external; function receiveApproval(address from, uint256 tokens, address token, bytes data) external; } library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } } contract DSWP { using SafeMath for uint256; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public decimals = 18; string public name = \"Darkswap\"; string public symbol = \"DSWP\"; uint256 public totalSupply = 10000e18; event Transfer(address indexed from, address indexed to, uint256 qty); event Approval(address indexed from, address indexed spender, uint256 qty); constructor() public { balanceOf[msg.sender] = totalSupply; } function isContract(address target) internal view returns (bool) { uint256 codeLength; assembly { codeLength := extcodesize(target) } return codeLength > 0; } function transfer(address target, uint256 qty, bytes data) public returns (bool) { balanceOf[msg.sender] = balanceOf[msg.sender].sub(qty); balanceOf[target] = balanceOf[target].add(qty); if (isContract(target)) { TokenReceiver(target).tokenFallback(target, qty, data); } emit Transfer(msg.sender, target, qty); return true; } function transfer(address target, uint256 qty) external returns (bool) { return transfer(target, qty, \"\"); } function transferFrom(address from, address to, uint256 qty) external returns (bool) { allowance[from][msg.sender] = allowance[from][msg.sender].sub(qty); balanceOf[from] = balanceOf[from].sub(qty); balanceOf[to] = balanceOf[to].add(qty); emit Transfer(from, to, qty); return true; } function approve(address spender, uint256 qty) public returns (bool) { allowance[msg.sender][spender] = qty; emit Approval(msg.sender, spender, qty); return true; } function approveAndCall(address spender, uint256 qty, bytes data) external returns (bool) { require(approve(spender, qty)); TokenReceiver(spender).receiveApproval(msg.sender, qty, this, data); return true; } } "}
{"sol name": "606.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //\u4e16\u754c\u4f5b\u798f\u94fe WORLD FOFU BLOCKCHAIN string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "671.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT222349' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT222349 // Name        : ADZbuzz Allroadsleadtothe.kitchen Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT222349\"; name = \"ADZbuzz Allroadsleadtothe.kitchen Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "431.sol", "label": 0, "sol content": "pragma solidity 0.4.24; // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/ParkadeCoin.sol /** @title A dividend-paying ERC20 token, @dev Based on https://programtheblockchain.com/posts/2018/02/07/writing-a-simple-dividend-token-contract/ and https://programtheblockchain.com/posts/2018/02/13/writing-a-robust-dividend-token-contract/ */ contract ParkadeCoin is StandardToken, Ownable { using SafeMath for uint256; string public name = \"Parkade Coin\"; string public symbol = \"PRKC\"; uint8 public decimals = 18; /** There are a total of 400,000,000 tokens * 10^18 = 4 * 10^26 token units total A scaling value of 1e10 means that a deposit of 0.04Eth will increase scaledDividendPerToken by 1. A scaling value of 1e10 means that investors must wait until their scaledDividendBalances is at least 1e10 before any withdrawals will credit their account. */ uint256 public scaling = uint256(10) ** 10; // Remainder value (in Wei) resulting from deposits uint256 public scaledRemainder = 0; // Amount of wei credited to an account, but not yet withdrawn mapping(address => uint256) public scaledDividendBalances; // Cumulative amount of Wei credited to an account, since the contract's deployment mapping(address => uint256) public scaledDividendCreditedTo; // Cumulative amount of Wei that each token has been entitled to. Independent of withdrawals uint256 public scaledDividendPerToken = 0; /** * @dev Throws if transaction size is greater than the provided amount * This is used to mitigate the Ethereum short address attack as described in https://tinyurl.com/y8jjvh8d */ modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } constructor() public { // Total INITAL SUPPLY of 400 million tokens totalSupply_ = uint256(400000000) * (uint256(10) ** decimals); // Initially assign all tokens to the contract's creator. balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } /** * @dev Update the dividend balances associated with an account * @param account The account address to update */ function update(address account) internal { // Calculate the amount \"owed\" to the account, in units of (wei / token) S // Subtract Wei already credited to the account (per token) from the total Wei per token uint256 owed = scaledDividendPerToken.sub(scaledDividendCreditedTo[account]); // Update the dividends owed to the account (in Wei) // # Tokens * (# Wei / token) = # Wei scaledDividendBalances[account] = scaledDividendBalances[account].add(balances[account].mul(owed)); // Update the total (wei / token) amount credited to the account scaledDividendCreditedTo[account] = scaledDividendPerToken; } event Transfer(address indexed from, address indexed to, uint256 value); event Deposit(uint256 value); event Withdraw(uint256 paidOut, address indexed to); mapping(address => mapping(address => uint256)) public allowance; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public onlyPayloadSize(2*32) returns (bool success) { require(balances[msg.sender] >= _value); // Added to transfer - update the dividend balances for both sender and receiver before transfer of tokens update(msg.sender); update(_to); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public onlyPayloadSize(3*32) returns (bool success) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); // Added to transferFrom - update the dividend balances for both sender and receiver before transfer of tokens update(_from); update(_to); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev deposit Ether into the contract for dividend splitting */ function deposit() public payable onlyOwner { // Scale the deposit and add the previous remainder uint256 available = (msg.value.mul(scaling)).add(scaledRemainder); // Compute amount of Wei per token scaledDividendPerToken = scaledDividendPerToken.add(available.div(totalSupply_)); // Compute the new remainder scaledRemainder = available % totalSupply_; emit Deposit(msg.value); } /** * @dev withdraw dividends owed to an address */ function withdraw() public { // Update the dividend amount associated with the account update(msg.sender); // Compute amount owed to the investor uint256 amount = scaledDividendBalances[msg.sender].div(scaling); // Put back any remainder scaledDividendBalances[msg.sender] %= scaling; // Send investor the Wei dividends msg.sender.transfer(amount); emit Withdraw(amount, msg.sender); } } "}
{"sol name": "390.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); uint256 c = _a / _b; return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } contract owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] = SafeMath.sub(balanceOf[_from],_value); // Add the same to the recipient balanceOf[_to] = SafeMath.add(balanceOf[_to],_value); emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] = SafeMath.sub(allowance[_from][msg.sender],_value); _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { require((_value == 0) || (allowance[msg.sender][_spender] == 0)); allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] = SafeMath.sub(balanceOf[msg.sender],_value);            // Subtract from the sender totalSupply = SafeMath.sub(totalSupply,_value);                                // Updates totalSupply emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                                                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);                                    // Check allowance balanceOf[_from] = SafeMath.sub(balanceOf[_from],_value);                           // Subtract from the targeted balance allowance[_from][msg.sender] = SafeMath.sub(allowance[_from][msg.sender],_value);   // Subtract from the sender's allowance totalSupply = SafeMath.sub(totalSupply,_value);                                     // Update totalSupply emit Burn(_from, _value); return true; } } contract AL is owned, TokenERC20 { mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                                              // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);                              // Check if the sender has enough require (balanceOf[_to] + _value > balanceOf[_to]);                // Check for overflows require(!frozenAccount[_from]);                                    // Check if sender is frozen require(!frozenAccount[_to]);                                      // Check if recipient is frozen balanceOf[_from] = SafeMath.sub(balanceOf[_from],_value);          // Subtract from the sender balanceOf[_to] = SafeMath.add(balanceOf[_to],_value);              // Add the same to the recipient emit Transfer(_from, _to, _value); } function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] = SafeMath.add(balanceOf[target],mintedAmount); totalSupply = SafeMath.add(totalSupply,mintedAmount); emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } } "}
{"sol name": "670.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract VDN is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function VDN( uint256 _totalSupply, string _name, uint8 _decimals, string _symbol ) { balanceOf[msg.sender] = _totalSupply;              // Give the creator all initial tokens totalSupply = _totalSupply;                        // Update total supply name = _name;                                   // Set the name for display purposes symbol = _symbol;                               // Set the symbol for display purposes decimals = _decimals;                            // Amount of decimals for display purposes owner = msg.sender; } /* Send coins */ function transfer(address _to, uint256 _value) { if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows if (_value > allowance[_from][msg.sender]) throw;     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } function freeze(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) returns (bool success) { if (freezeOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } // transfer balance to owner function withdrawEther(uint256 amount) { if(msg.sender != owner)throw; owner.transfer(amount); } // can accept ether function() payable { } } "}
{"sol name": "875.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /*-------------------------------------------------- ____                          ____              _ / ___| _   _ _ __   ___ _ __   / ___|__ _ _ __ __| | \\___ \\| | | | '_ \\ / _ \\ '__| | |   / _` | '__/ _` | ___) | |_| | |_) |  __/ |    | |__| (_| | | | (_| | |____/ \\__,_| .__/ \\___|_|     \\____\\__,_|_|  \\__,_| |_| 2018-08-08 ---------------------------------------------------*/ contract SPCevents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount, uint256 airDropPot ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (fomo3d short only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (fomo3d short only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit, add pot directly by admin to next round event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } //============================================================================== //   _ _  _ _|_ _ _  __|_   _ _ _|_    _   . //  (_(_)| | | | (_|(_ |   _\\(/_ | |_||_)  . //====================================|========================================= contract SuperCard is SPCevents { using SafeMath for *; using NameFilter for string; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xBac825cDB506dCF917A7715a4bF3fA1B06aBe3e4); //============================================================================== //     _ _  _  |`. _     _ _ |_ | _  _  . //    (_(_)| |~|~|(_||_|| (_||_)|(/__\\  .  (game settings) //=================_|=========================================================== address private admin = msg.sender; string constant public name   = \"SuperCard\"; string constant public symbol = \"SPC\"; uint256 private rndExtra_     = 0;     // length of the very first ICO uint256 private rndGap_ = 1 minutes;         // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 6 hours;           // round timer starts at this uint256 constant private rndInc_ = 30 seconds;              // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 24 hours;                // max length a round timer can be //============================================================================== //     _| _ _|_ _    _ _ _|_    _   . //    (_|(_| | (_|  _\\(/_ | |_||_)  .  (data used to store game info that changes) //=============================|================================================ uint256 public airDropPot_;             // person who gets the airdrop wins part of this pot uint256 public airDropTracker_ = 0;     // incremented each time a \"qualified\" tx occurs.  used to determine winning air drop uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => SPCdatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => SPCdatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => SPCdatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA //**************** mapping (uint256 => SPCdatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => SPCdatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team //============================================================================== //     _ _  _  __|_ _    __|_ _  _  . //    (_(_)| |_\\ | | |_|(_ | (_)|   .  (initial data setup upon contract deploy) //============================================================================== constructor() public { // Team allocation structures // 0 = whales // 1 = bears // 2 = sneks // 3 = bulls // Team allocation percentages // (F3D, P3D) + (Pot , Referrals, Community) // Referrals / Community rewards are mathematically designed to come from the winner's share of the pot. fees_[0] = SPCdatasets.TeamFee(80,2);   //50% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot fees_[1] = SPCdatasets.TeamFee(80,2);   //43% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot fees_[2] = SPCdatasets.TeamFee(80,2);  //5% to pot, 10% to aff, 2% to com, fees_[3] = SPCdatasets.TeamFee(80,2);   //35% to pot, 10% to aff, 2% to com, 1% to pot swap, 1% to air drop pot // how to split up the final pot based on which team was picked // (F3D, P3D) potSplit_[0] = SPCdatasets.PotSplit(20,10);  //48% to winner, 25% to next round, 2% to com potSplit_[1] = SPCdatasets.PotSplit(20,10);  //48% to winner, 25% to next round, 2% to com potSplit_[2] = SPCdatasets.PotSplit(20,10);  //48% to winner, 10% to next round, 2% to com potSplit_[3] = SPCdatasets.PotSplit(20,10);  //48% to winner, 10% to next round, 2% to com /* activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; */ } //============================================================================== //     _ _  _  _|. |`. _  _ _  . //    | | |(_)(_||~|~|(/_| _\\  .  (these are safety checks) //============================================================================== /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { // Add WangYi 2018-08-10 BEGIN if ( activated_ == false ) { if ( (now >= pre_active_time) &&  (pre_active_time > 0) ) { // \u81ea\u52a8\u6fc0\u6d3b activated_ = true; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } } // Add WangYi 2018-08-10 BEGIN require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } /** * @dev prevents contracts from interacting with fomo3d */ modifier isHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\"); _; } //============================================================================== //     _    |_ |. _   |`    _  __|_. _  _  _  . //    |_)|_||_)||(_  ~|~|_|| |(_ | |(_)| |_\\  .  (use these to interact with contract) //====|========================================================================= /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // buy core, team set to 2, snake buyCore(_pID, _affCode, 2, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not SPCdatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // buy core, team set to 2, snake buyCore(_pID, _affID, 2, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // reload core, team set to 2, snake reLoadCore(_pID, _affCode, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // reload core, team set to 2, snake reLoadCore(_pID, _affID, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 upperLimit = 0; uint256 usedGen = 0; // eth send to player uint256 ethout = 0; // \u8d85\u9650\u6536\u76ca uint256 over_gen = 0; // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // \u5f53\u524d\u73b0\u5b58\u6536\u76ca // \u5148\u89e6\u53d1\u9650\u6536\u68c0\u6d4b\u548c\u5904\u7406 if (plyr_[_pID].gen > 0) { upperLimit = (calceth(plyrRnds_[_pID][rID_].keys).mul(105))/100; if(plyr_[_pID].gen >= upperLimit) { // \u8d85\u9650\u6536\u76ca\u90e8\u5206 over_gen = (plyr_[_pID].gen).sub(upperLimit); // keys\u6e05\u96f6 round_[rID_].keys = (round_[rID_].keys).sub(plyrRnds_[_pID][rID_].keys); plyrRnds_[_pID][rID_].keys = 0; // \u8d85\u51fa\u90e8\u5206\u8f6c\u4ea4admin admin.transfer(over_gen); //\u53ef\u7528gen usedGen = upperLimit; } else { // keys\u4e00\u90e8\u5206\u6e05\u51cf\uff0c\u5bf9\u5e94\u5168\u90e8gen\u7684\u91cf plyrRnds_[_pID][rID_].keys = (plyrRnds_[_pID][rID_].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); round_[rID_].keys = (round_[rID_].keys).sub(calckeys(((plyr_[_pID].gen).mul(100))/105)); //\u53ef\u7528gen usedGen = plyr_[_pID].gen; } ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); } else { ethout = ((plyr_[_pID].win).add(plyr_[_pID].aff)); } plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].addr.transfer(ethout); // check to see if round has ended and no one has run round end yet if (_now > round_[rID_].end && round_[rID_].ended == false && round_[rID_].plyr != 0) { // set up our tx event data SPCdatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[rID_].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit SPCevents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, ethout, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // fire withdraw event emit SPCevents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, ethout, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit SPCevents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } //============================================================================== //     _  _ _|__|_ _  _ _  . //    (_|(/_ |  | (/_| _\\  . (for UI & viewing things on etherscan) //=====_|======================================================================= /** * @dev return the price buyer will pay for next 1 individual key. * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // price 0.01 ETH return(10000000000000000); } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; if (_now < round_[_rID].end) if (_now > round_[_rID].strt + rndGap_) return( (round_[_rID].end).sub(_now) ); else return( (round_[_rID].strt + rndGap_).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round * @return airdrop tracker # & airdrop pot */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3],             //12 airDropTracker_ + (airDropPot_ * 1000)              //13 ); } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player round eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].eth           //6 ); } //============================================================================== //     _ _  _ _   | _  _ . _  . //    (_(_)| (/_  |(_)(_||(_  . (this + tools + calcs + modules = our softwares engine) //=====================_|======================================================= /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // if round is active if (_now > round_[_rID].strt + rndGap_ && (_now <= round_[_rID].end || (_now > round_[_rID].end && round_[_rID].plyr == 0))) { // call core core(_rID, _pID, msg.value, _affID, 2, _eventData_); // if round is not active } else { // check to see if end round needs to be ran if (_now > round_[_rID].end && round_[_rID].ended == false) { // end the round (distributes pot) & start new round round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onBuyAndDistribute ( msg.sender, plyr_[_pID].name, msg.value, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } // \u672a\u5f00\u5c40\u65f6\u5019\u7684\u8d2d\u4e70\uff0c\u4e70\u4e0d\u5230\u6709\u6548key\u3002\u4f46\u4ecd\u7136\u662f\u5c5e\u4e8e\u73a9\u5bb6\u7684\u4ee3\u5e01\u3002put eth in players vault, \u653e\u5728win vault plyr_[_pID].win = plyr_[_pID].win.add(msg.value); } } /** * @dev gen limit handle */ function genLimit(uint256 _pID) private returns(uint256) { uint256 upperLimit = 0; uint256 usedGen = 0; // \u8d85\u9650\u6536\u76ca uint256 over_gen = 0; // \u5b9e\u9645\u80fd\u7528\u7684\u989d uint256 eth_can_use = 0; // \u4e2d\u95f4\u53d8\u91cf uint256 tempnum = 0; updateGenVault(_pID, plyr_[_pID].lrnd); // \u5f53\u524d\u73b0\u5b58\u6536\u76ca // \u5148\u89e6\u53d1\u9650\u6536\u68c0\u6d4b\u548c\u5904\u7406 if (plyr_[_pID].gen > 0) { upperLimit = ((plyrRnds_[_pID][rID_].keys).mul(105))/10000; if(plyr_[_pID].gen >= upperLimit) { // \u8d85\u9650\u6536\u76ca\u90e8\u5206 over_gen = (plyr_[_pID].gen).sub(upperLimit); // keys\u6e05\u96f6 round_[rID_].keys = (round_[rID_].keys).sub(plyrRnds_[_pID][rID_].keys); plyrRnds_[_pID][rID_].keys = 0; // \u8d85\u51fa\u90e8\u5206\u8f6c\u4ea4admin admin.transfer(over_gen); //\u53ef\u7528gen usedGen = upperLimit; } else { tempnum = ((plyr_[_pID].gen).mul(10000))/105; // keys\u4e00\u90e8\u5206\u6e05\u51cf\uff0c\u5bf9\u5e94\u5168\u90e8gen\u7684\u91cf plyrRnds_[_pID][rID_].keys = (plyrRnds_[_pID][rID_].keys).sub(tempnum); round_[rID_].keys = (round_[rID_].keys).sub(tempnum); //\u53ef\u7528gen\u4e3a\u5168\u90e8gen usedGen = plyr_[_pID].gen; } eth_can_use = ((plyr_[_pID].win).add(plyr_[_pID].aff)).add(usedGen); // \u6700\u591a\u8fd9\u4e48\u591a\u4ee3\u5e01\u53ef\u4ee5\u4e70keys, \u5e76\u4e14\u4e09\u4e2a\u5206\u7c7b\u8d26\u90fd\u51cf\u4e3a0 plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } else { // \u6ca1\u6709gen\u65f6\u5019\uff0c\u7528win\u548caff\u7684\u4ee3\u5e01\u989d\u7684\u91cf\u6765\u4e70\uff0c\u5e76\u4e14\u8fd9\u4e24\u4e2a\u5206\u7c7b\u8d26\u90fd\u51cf\u4e3a0 eth_can_use = (plyr_[_pID].win).add(plyr_[_pID].aff); plyr_[_pID].win = 0; plyr_[_pID].aff = 0; } return(eth_can_use); } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in an active round or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _eth, SPCdatasets.EventReturns memory _eventData_) private { // setup local rID // grab time uint256 _now = now; // \u5b9e\u9645\u80fd\u7528\u7684\u989d uint256 eth_can_use = 0; // if round is active if (_now > round_[rID_].strt + rndGap_ && (_now <= round_[rID_].end || (_now > round_[rID_].end && round_[rID_].plyr == 0))) { // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. // \u5bf9\u4e0a\u9650\u5904\u7406, \u73b0\u5728\u8981\u6c42all in\uff01 \u7528\u5206\u7ea2\u8d2d\u4e70\u65f6\uff0c\u4f1a\u4f7f\u7528\u5168\u90e8\u5df2\u6709\u6536\u76ca\u8d2d\u4e70\uff01 eth_can_use = genLimit(_pID); if(eth_can_use > 0) { // call core core(rID_, _pID, eth_can_use, _affID, 2, _eventData_); } // if round is not active and end round needs to be ran } else if (_now > round_[rID_].end && round_[rID_].ended == false) { // end the round (distributes pot) & start new round round_[rID_].ended = true; _eventData_ = endRound(_eventData_); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire buy and distribute event emit SPCevents.onReLoadAndDistribute ( msg.sender, plyr_[_pID].name, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); } } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private { // if player is new to round\uff0c\u53ea\u5728\u73a9\u5bb6\u5728\u672c\u5c40\u7b2c\u4e00\u6b21\u8d2dkeys\u65f6\u5904\u7406\u3002 if (plyrRnds_[_pID][_rID].jionflag != 1) { _eventData_ = managePlayer(_pID, _eventData_); plyrRnds_[_pID][_rID].jionflag = 1; } if (_eth > 10000000000000000) { // mint the new keys uint256 _keys = calckeys(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; // \u6539\u4e3a\u53ea\u6709\u4e00\u4e2a\u961f\u4f0d2 round_[_rID].team = 2; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); plyrRnds_[_pID][_rID].eth = _eth.add(plyrRnds_[_pID][_rID].eth); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][2] = _eth.add(rndTmEth_[_rID][2]); // distribute eth _eventData_ = distributeExternal(_rID, _pID, _eth, _affID, 2, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, 2, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_pID, 2, _eth, _keys, _eventData_); } } //============================================================================== //     _ _ | _   | _ _|_ _  _ _  . //    (_(_||(_|_||(_| | (_)| _\\  . //============================================================================== /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { uint256 temp; temp = (round_[_rIDlast].mask).mul((plyrRnds_[_pID][_rIDlast].keys)/1000000000000000000); if(temp > plyrRnds_[_pID][_rIDlast].mask) { return( temp.sub(plyrRnds_[_pID][_rIDlast].mask) ); } else { return( 0 ); } } /** * @dev returns the amount of keys you would get given an amount of eth. * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { return ( calckeys(_eth) ); } /** * @dev returns current eth price for X keys. * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { return ( _keys/100 ); } //============================================================================== //    _|_ _  _ | _  . //     | (_)(_)|_\\  . //============================================================================== /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of fomo3d if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function managePlayer(uint256 _pID, SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { uint256 temp_eth = 0; // if player has played a previous round, move their unmasked earnings // from that round to win vault. \u73a9\u5bb6\u65e9\u524d\u7684\u8de8\u5c40\u9057\u7559\u7684\u6536\u76ca\u8f6c\u5165\u5f53\u524dwin\u8d26\u6237\uff0c\u4e0d\u6df7\u5165\u5f53\u524d\u5c40\u7684gen\u8d26\u6237 if (plyr_[_pID].lrnd != 0) { updateGenVault(_pID, plyr_[_pID].lrnd); temp_eth = ((plyr_[_pID].win).add((plyr_[_pID].gen))).add(plyr_[_pID].aff); plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; plyr_[_pID].win = temp_eth; } // update player's last round played plyr_[_pID].lrnd = rID_; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(SPCdatasets.EventReturns memory _eventData_) private returns (SPCdatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(30)) / 100; uint256 _com = (_pot / 10); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _p3d = (_pot.mul(potSplit_[_winTID].p3d)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_com)).sub(_gen)).sub(_p3d); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // community rewards _com = _com.add(_p3d.sub(_p3d / 2)); admin.transfer(_com); _res = _res.add(_p3d / 2); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.P3DAmount = _p3d; _eventData_.newPot = _res; // start next round rID_++; _rID++; round_[_rID].strt = now; round_[_rID].end = now.add(rndInit_).add(rndGap_); round_[_rID].pot = _res; return(_eventData_); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // grab time uint256 _now = now; // calculate time based on number of keys bought uint256 _newTime; if (_now > round_[_rID].end && round_[_rID].plyr == 0) _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(_now); else _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // pay 3% out to community rewards uint256 _p3d = (_eth/100).mul(3); // ---------------------------------------- //  BEGIN  Modify by WangYi      2018-08-02 // ---------------------------------------- // // \u5f00\u59cb\u5904\u7406 3\u7ea7\u9080\u8bf7\u5206\u914d\u5236\u5ea6\uff0c\u89c4\u5219 // \u7b2c\u4e00\u7ea7 2% //   \u7b2c\u4e8c\u7ea7 3% //     \u7b2c\u4e09\u7ea7 5% // \u5982\u679c\u6ca1\u6709\uff0c\u5219\u76f4\u63a5\u8fdb\u5165 admin // // ---------------------------------------- // distribute share to affiliate // \u4e09\u7ea7\u5206\u914d\u6bd4\u4f8b 5%:3%:2% uint256 _aff_cent = (_eth) / 100; // \u4e09\u7ea7\u9080\u8bf7ID uint256 tempID  = _affID; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered //\u7b2c\u4e09\u7ea7 5% if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(5)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(5), now); } else { // \u5b58\u5165ADMIN \u7528\u6237 _p3d = _p3d.add(_aff_cent.mul(5)); } //\u67e5\u627e\u7b2c\u4e8c\u7ea7 tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(3)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(3), now); } else { // \u5b58\u5165ADMIN \u7528\u6237 _p3d = _p3d.add(_aff_cent.mul(3)); } //\u67e5\u627e\u7b2c\u4e00\u7ea7 tempID = PlayerBook.getPlayerID(plyr_[tempID].addr); tempID = PlayerBook.getPlayerLAff(tempID); if (tempID != _pID && plyr_[tempID].name != '') { plyr_[tempID].aff = (_aff_cent.mul(2)).add(plyr_[tempID].aff); emit SPCevents.onAffiliatePayout(tempID, plyr_[tempID].addr, plyr_[tempID].name, _rID, _pID, _aff_cent.mul(2), now); } else { // \u5b58\u5165ADMIN \u7528\u6237 _p3d = _p3d.add(_aff_cent.mul(2)); } // ---------------------------------------- // END     Modify by WangYi      2018-08-02 // ---------------------------------------- // pay out p3d _p3d = _p3d.add((_eth.mul(fees_[2].p3d)) / (100)); if (_p3d > 0) { admin.transfer(_p3d); // set up event data _eventData_.P3DAmount = _p3d.add(_eventData_.P3DAmount); } return(_eventData_); } /** * @dev \u7ba1\u7406\u53ef\u4ee5\u628a\u5916\u90e8\u8d44\u91d1\u6ce8\u5165\u4e0b\u4e00\u5c40\u5956\u6c60\uff0c\u6269\u5927\u5438\u5f15\u529b\u3002 */ function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit SPCevents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _team, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private returns(SPCdatasets.EventReturns) { // calculate gen share\uff0c\u672c\u7248\u672c\u4e3a80% uint256 _gen = (_eth.mul(fees_[2].gen)) / 100; // pot\u4efd\u989d\u4e3a 5% uint256 _pot = (_eth.mul(5)) / 100; // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); //if (_dust > 0) //    _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, SPCdatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (2 * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (rID_ * 10000000000000000000000000000000000000000000000000000); emit SPCevents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount, airDropPot_ ); } //============================================================================== //    (~ _  _    _._|_    . //    _)(/_(_|_|| | | \\/  . //====================/========================================================= /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; // ---------------------------------------- // Add WY 2018-8-10 BEGIN // ---------------------------------------- // \u9884\u6fc0\u6d3b\u65f6\u95f4 uint256 public pre_active_time = 0; /** * @dev return active flag \u3001time * @return active flag * @return active time * @return system time */ function getRunInfo() public view returns(bool, uint256, uint256) { return ( activated_,      //0 pre_active_time, //1 now          //2 ); } function setPreActiveTime(uint256 _pre_time) public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); pre_active_time = _pre_time; } // ---------------------------------------- // Add WY 2018-8-10 END // ---------------------------------------- function activate() public { // only team just can activate require(msg.sender == admin, \"only admin can activate\"); // can only be ran once require(activated_ == false, \"FOMO Short already activated\"); // activate the contract activated_ = true; //activated_ = false; // lets start first round rID_ = 1; round_[1].strt = now + rndExtra_ - rndGap_; round_[1].end = now + rndInit_ + rndExtra_; } //============================================================================== //  |  _      _ _ | _  . //  |<(/_\\/  (_(_||(_  . //=======/====================================================================== function calckeys(uint256 _eth) pure public returns(uint256) { return ( (_eth).mul(100) ); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function calceth(uint256 _keys) pure public returns(uint256) { return( (_keys)/100 ); } } //============================================================================== //   __|_ _    __|_ _  . //  _\\ | | |_|(_ | _\\  . //============================================================================== library SPCdatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 3-5 - air drop tracker (uint 0-999) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) // 31 - airdrop happened bool // 32 - airdrop tier // 33 - airdrop amount won //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 jionflag;   // player not jion round \u5c1a\u672a\u53c2\u52a0\u6b64\u5c40\u3002 uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round uint256 p3d;    // % of buy in thats paid to p3d holders } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round uint256 p3d;    // % of pot thats paid to p3d holders } } //============================================================================== //  . _ _|_ _  _ |` _  _ _  _  . //  || | | (/_| ~|~(_|(_(/__\\  . //============================================================================== interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } /** * @title -Name Filter- v0.1.9 */ library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } } "}
{"sol name": "1842.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract UNGT { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); function UNGT() public { totalSupply = 1000000000 * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = \"Universal Green Token\"; symbol = \"UNGT\"; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to].add(_value) > balanceOf[_to]); uint previousBalances = balanceOf[_from].add(balanceOf[_to]); balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(_from, _to, _value); assert(balanceOf[_from].add(balanceOf[_to]) == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool){ _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { require(balanceOf[msg.sender] >= _value); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender,_spender,_value); return true; } } "}
{"sol name": "966.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // import \"./SafeMath.sol\"; // import \"openzeppelin-solidity/contracts/math/SafeMath.sol\"; // import \"openzeppelin-solidity/contracts/token/ERC20/TokenTimelock.sol\"; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * ERC 20 token * * https://github.com/ethereum/EIPs/issues/20 */ contract MD  { using SafeMath for uint256; string public constant name = \"MD Token\"; string public constant symbol = \"MD\"; uint public constant decimals = 18; // Total supply is 3.5 billion uint256 _totalSupply = 3500000000 * 10**decimals; mapping(address => uint256) balances; //list of balance of each address mapping(address => mapping (address => uint256)) allowed; address public owner; modifier ownerOnly { require( msg.sender == owner, \"Sender not authorized.\" ); _; } function totalSupply() public view returns (uint256 supply) { return _totalSupply; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); //constructor constructor(address _owner) public{ owner = _owner; balances[owner] = _totalSupply; } /** * ERC 20 Standard Token interface transfer function * * Prevent transfers until lock period is over. */ function transfer(address _to, uint256 _value) public returns (bool success) { //Default assumes totalSupply can't be over max (2^256 - 1). //If your token leaves out totalSupply and can issue more tokens as time goes on, you need to check if it doesn't wrap. //Replace the if with this one instead. if (balances[msg.sender] >= _value && balances[_to].add(_value) > balances[_to]) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } /** * ERC 20 Standard Token interface transfer function * * Prevent transfers until freeze period is over. */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //same as above. Replace this line with the following if you want to protect against wrapping uints. if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to].add(_value) > balances[_to]) { balances[_to] = _value.add(balances[_to]); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } else { return false; } } /** * Change owner address (where ICO ETH is being forwarded). */ function changeOwner(address _newowner) public ownerOnly returns (bool success) { owner = _newowner; return true; } // only owner can kill function kill() public ownerOnly { selfdestruct(owner); } } "}
{"sol name": "553.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns(uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else{ uint256 z = x; for (uint256 i = 1; i < y; i++) z = mul(z,x); return (z); } } } interface shareProfit { function increaseProfit() external payable returns(bool); } contract RTB2 is shareProfit { using SafeMath for uint256; uint8 public decimals = 0; uint256 public totalSupply = 700; uint256 public totalSold = 0; uint256 public constant price = 1 ether; string public name = \"Retro Block Token 2\"; string public symbol = \"RTB2\"; address public owner; address public finance; mapping (address=>uint256) received; uint256 profit; address public jackpot; shareProfit public shareContract; mapping (address=>uint256) changeProfit; mapping (address=>uint256) balances; mapping (address=>mapping (address=>uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit); event Withdraw(address indexed _addr, uint256 _value); modifier onlyOwner() { require(msg.sender == owner, \"only owner\"); _; } modifier onlyHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } constructor(address _shareAddr) public { owner = msg.sender; finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0; jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC; shareContract = shareProfit(_shareAddr); balances[this] = 700; } function() public payable { require(msg.value > 0, \"Amount must be provided\"); profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); } function increaseProfit() external payable returns(bool){ if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); return true; }else{ return false; } } function totalSupply() external view returns (uint256){ return totalSupply; } function balanceOf(address _owner) external view returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { require(_value > 0 && allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) external returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) external returns (bool) { return _transfer(msg.sender, _to, _value); } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0), \"Receiver address cannot be null\"); require(_value > 0 && _value <= balances[_from]); uint256 newToVal = balances[_to] + _value; assert(newToVal >= balances[_to]); uint256 newFromVal = balances[_from] - _value; balances[_from] =  newFromVal; balances[_to] = newToVal; uint256 temp = _value.mul(profit); changeProfit[_from] = changeProfit[_from].add(temp); received[_to] = received[_to].add(temp); emit Transfer(_from, _to, _value); return true; } function buy(uint256 _amount) external payable{ require(_amount > 0); uint256 _money = _amount.mul(price); require(msg.value == _money); require(balances[this] >= _amount); require((totalSupply - totalSold) >= _amount, \"Sold out\"); _transfer(this, msg.sender, _amount); finance.transfer(_money.mul(60).div(100)); jackpot.transfer(_money.mul(20).div(100)); shareContract.increaseProfit.value(_money.mul(20).div(100))(); totalSold += _amount; } function withdraw() external { uint256 value = getProfit(msg.sender); require(value > 0, \"No cash available\"); emit Withdraw(msg.sender, value); received[msg.sender] = received[msg.sender].add(value); msg.sender.transfer(value); } function getProfit(address _addr) public view returns(uint256){ return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]); } function setJackpot(address _addr) public onlyOwner{ jackpot = _addr; } function setShare(address _addr) public onlyOwner{ shareContract = shareProfit(_addr); } function setFinance(address _addr) public onlyOwner{ finance = _addr; } } "}
{"sol name": "253.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeMul(uint a, uint b) internal returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) throw; } } contract AccessControl is SafeMath{ /// @dev Emited when contract is upgraded - See README.md for updgrade plan event ContractUpgrade(address newContract); // The addresses of the accounts (or contracts) that can execute actions within each roles. address public ceoAddress; address public cfoAddress; address public cooAddress; address newContractAddress; uint public tip_total = 0; uint public tip_rate = 20000000000000000; // @dev Keeps track whether the contract is paused. When that is true, most actions are blocked bool public paused = false; /// @dev Access modifier for CEO-only functionality modifier onlyCEO() { require(msg.sender == ceoAddress); _; } /// @dev Access modifier for CFO-only functionality modifier onlyCFO() { require(msg.sender == cfoAddress); _; } /// @dev Access modifier for COO-only functionality modifier onlyCOO() { require(msg.sender == cooAddress); _; } modifier onlyCLevel() { require( msg.sender == cooAddress || msg.sender == ceoAddress || msg.sender == cfoAddress ); _; } function () public payable{ tip_total = safeAdd(tip_total, msg.value); } /// @dev Count amount with tip. /// @param amount The totalAmount function amountWithTip(uint amount) internal returns(uint){ uint tip = safeMul(amount, tip_rate) / (1 ether); tip_total = safeAdd(tip_total, tip); return safeSub(amount, tip); } /// @dev Withdraw Tip. function withdrawTip(uint amount) external onlyCFO { require(amount > 0 && amount <= tip_total); require(msg.sender.send(amount)); tip_total = tip_total - amount; } // updgrade function setNewAddress(address newContract) external onlyCEO whenPaused { newContractAddress = newContract; emit ContractUpgrade(newContract); } /// @dev Assigns a new address to act as the CEO. Only available to the current CEO. /// @param _newCEO The address of the new CEO function setCEO(address _newCEO) external onlyCEO { require(_newCEO != address(0)); ceoAddress = _newCEO; } /// @dev Assigns a new address to act as the CFO. Only available to the current CEO. /// @param _newCFO The address of the new CFO function setCFO(address _newCFO) external onlyCEO { require(_newCFO != address(0)); cfoAddress = _newCFO; } /// @dev Assigns a new address to act as the COO. Only available to the current CEO. /// @param _newCOO The address of the new COO function setCOO(address _newCOO) external onlyCEO { require(_newCOO != address(0)); cooAddress = _newCOO; } /*** Pausable functionality adapted from OpenZeppelin ***/ /// @dev Modifier to allow actions only when the contract IS NOT paused modifier whenNotPaused() { require(!paused); _; } /// @dev Modifier to allow actions only when the contract IS paused modifier whenPaused { require(paused); _; } /// @dev Called by any \"C-level\" role to pause the contract. Used only when ///  a bug or exploit is detected and we need to limit damage. function pause() external onlyCLevel whenNotPaused { paused = true; } /// @dev Unpauses the smart contract. Can only be called by the CEO, since ///  one reason we may pause the contract is when CFO or COO accounts are ///  compromised. /// @notice This is public rather than external so it can be called by ///  derived contracts. function unpause() public onlyCEO whenPaused { // can't unpause if contract was upgraded paused = false; } } contract RpsGame is SafeMath , AccessControl{ /// @dev Constant definition uint8 constant public NONE = 0; uint8 constant public ROCK = 10; uint8 constant public PAPER = 20; uint8 constant public SCISSORS = 30; uint8 constant public DEALERWIN = 201; uint8 constant public PLAYERWIN = 102; uint8 constant public DRAW = 101; /// @dev Emited when contract is upgraded - See README.md for updgrade plan event CreateGame(uint gameid, address dealer, uint amount); event JoinGame(uint gameid, address player, uint amount); event Reveal(uint gameid, address player, uint8 choice); event CloseGame(uint gameid,address dealer,address player, uint8 result); /// @dev struct of a game struct Game { uint expireTime; address dealer; uint dealerValue; bytes32 dealerHash; uint8 dealerChoice; address player; uint8 playerChoice; uint playerValue; uint8 result; bool closed; } /// @dev struct of a game mapping (uint => mapping(uint => uint8)) public payoff; mapping (uint => Game) public games; mapping (address => uint[]) public gameidsOf; /// @dev Current game maximum id uint public maxgame = 0; uint public expireTimeLimit = 30 minutes; /// @dev Initialization contract function RpsGame() { payoff[ROCK][ROCK] = DRAW; payoff[ROCK][PAPER] = PLAYERWIN; payoff[ROCK][SCISSORS] = DEALERWIN; payoff[PAPER][ROCK] = DEALERWIN; payoff[PAPER][PAPER] = DRAW; payoff[PAPER][SCISSORS] = PLAYERWIN; payoff[SCISSORS][ROCK] = PLAYERWIN; payoff[SCISSORS][PAPER] = DEALERWIN; payoff[SCISSORS][SCISSORS] = DRAW; payoff[NONE][NONE] = DRAW; payoff[ROCK][NONE] = DEALERWIN; payoff[PAPER][NONE] = DEALERWIN; payoff[SCISSORS][NONE] = DEALERWIN; payoff[NONE][ROCK] = PLAYERWIN; payoff[NONE][PAPER] = PLAYERWIN; payoff[NONE][SCISSORS] = PLAYERWIN; ceoAddress = msg.sender; cooAddress = msg.sender; cfoAddress = msg.sender; } /// @dev Create a game function createGame(bytes32 dealerHash, address player) public payable whenNotPaused returns (uint){ require(dealerHash != 0x0); maxgame += 1; Game storage game = games[maxgame]; game.dealer = msg.sender; game.player = player; game.dealerHash = dealerHash; game.dealerChoice = NONE; game.dealerValue = msg.value; game.expireTime = expireTimeLimit + now; gameidsOf[msg.sender].push(maxgame); emit CreateGame(maxgame, game.dealer, game.dealerValue); return maxgame; } /// @dev Join a game function joinGame(uint gameid, uint8 choice) public payable whenNotPaused returns (uint){ Game storage game = games[gameid]; require(msg.value == game.dealerValue && game.dealer != address(0) && game.dealer != msg.sender && game.playerChoice==NONE); require(game.player == address(0) || game.player == msg.sender); require(!game.closed); require(now < game.expireTime); require(checkChoice(choice)); game.player = msg.sender; game.playerChoice = choice; game.playerValue = msg.value; game.expireTime = expireTimeLimit + now; gameidsOf[msg.sender].push(gameid); emit JoinGame(gameid, game.player, game.playerValue); return gameid; } /// @dev Creator reveals game choice function reveal(uint gameid, uint8 choice, bytes32 randomSecret) public returns (bool) { Game storage game = games[gameid]; bytes32 proof = getProof(msg.sender, choice, randomSecret); require(!game.closed); require(now < game.expireTime); require(game.dealerHash != 0x0); require(checkChoice(choice)); require(checkChoice(game.playerChoice)); require(game.dealer == msg.sender && proof == game.dealerHash ); game.dealerChoice = choice; Reveal(gameid, msg.sender, choice); close(gameid); return true; } /// @dev Close game settlement rewards function close(uint gameid) public returns(bool) { Game storage game = games[gameid]; require(!game.closed); require(now > game.expireTime || (game.dealerChoice != NONE && game.playerChoice != NONE)); uint8 result = payoff[game.dealerChoice][game.playerChoice]; if(result == DEALERWIN){ require(game.dealer.send(amountWithTip(safeAdd(game.dealerValue, game.playerValue)))); }else if(result == PLAYERWIN){ require(game.player.send(amountWithTip(safeAdd(game.dealerValue, game.playerValue)))); }else if(result == DRAW){ require(game.dealer.send(game.dealerValue) && game.player.send(game.playerValue)); } game.closed = true; game.result = result; emit CloseGame(gameid, game.dealer, game.player, result); return game.closed; } function getProof(address sender, uint8 choice, bytes32 randomSecret) public view returns (bytes32){ return sha3(sender, choice, randomSecret); } function gameCountOf(address owner) public view returns (uint){ return gameidsOf[owner].length; } function checkChoice(uint8 choice) public view returns (bool){ return choice==ROCK||choice==PAPER||choice==SCISSORS; } } "}
{"sol name": "1748.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* * Creator: CAS (CariOS) */ /* * Abstract Token Smart Contract * */ /* * Safe Math Smart Contract. * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * ERC-20 standard token interface, as defined * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>. */ contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * Abstract Token Smart Contract that could be used as a base contract for * ERC-20 token contracts. */ contract AbstractToken is Token, SafeMath { /** * Create new Abstract Token contract. */ function AbstractToken () { // Do nothing } /** * Get number of tokens currently belonging to given owner. * * @param _owner address to get number of tokens currently belonging to the *        owner of * @return number of tokens currently belonging to the owner of given address */ function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } /** * Transfer given number of tokens from message sender to given recipient. * * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } /** * Allow given spender to transfer given number of tokens from message sender. * @param _spender address to allow the owner of to transfer tokens from message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } /** * Tell how many tokens given spender is currently allowed to transfer from * given owner. * * @param _owner address to get number of tokens allowed to be transferred *        from the owner of * @param _spender address to get number of tokens allowed to be transferred *        by the owner of * @return number of tokens given spender is currently allowed to transfer *         from given owner */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } /** * Mapping from addresses of token holders to the numbers of tokens belonging * to these token holders. */ mapping (address => uint256) accounts; /** * Mapping from addresses of token holders to the mapping of addresses of * spenders to the allowances set by these token holders to these spenders. */ mapping (address => mapping (address => uint256)) private allowances; } /** * CariOS Token smart contract. */ contract CASToken is AbstractToken { /** * Maximum allowed number of tokens in circulation. * tokenSupply = tokensIActuallyWant * (10 ^ decimals) */ uint256 constant MAX_TOKEN_COUNT = 10000000000 * (10**18); /** * Address of the owner of this smart contract. */ address private owner; /** * Frozen account list holder */ mapping (address => bool) private frozenAccount; /** * Current number of tokens in circulation. */ uint256 tokenCount = 0; /** * True if tokens transfers are currently frozen, false otherwise. */ bool frozen = false; /** * Create new token smart contract and make msg.sender the * owner of this smart contract. */ function CASToken () { owner = msg.sender; } /** * Get total number of tokens in circulation. * * @return total number of tokens in circulation */ function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"CariOS\"; string constant public symbol = \"CAS\"; uint8 constant public decimals = 18; /** * Transfer given number of tokens from message sender to given recipient. * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise */ function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } /** * Change how many tokens given spender is allowed to transfer from message * spender.  In order to prevent double spending of allowance, * To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender address to allow the owner of to transfer tokens from *        message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } /** * Create _value new tokens and give new created tokens to msg.sender. * May only be called by smart contract owner. * * @param _value number of tokens to create * @return true if tokens were created successfully, false otherwise */ function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); // adding transfer event and _from address as null address emit Transfer(0x0, msg.sender, _value); return true; } return false; } /** * Set new owner for the smart contract. * May only be called by smart contract owner. * * @param _newOwner address of new owner of the smart contract */ function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } /** * Freeze ALL token transfers. * May only be called by smart contract owner. */ function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } /** * Unfreeze ALL token transfers. * May only be called by smart contract owner. */ function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } /*A user is able to unintentionally send tokens to a contract * and if the contract is not prepared to refund them they will get stuck in the contract. * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to * prevent unintended Ether transfers. However, there\u2019s no such mechanism for token transfers. * so the below function is created */ function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } /** * Freeze specific account * May only be called by smart contract owner. */ function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } /** * Logged when token transfers were frozen. */ event Freeze (); /** * Logged when token transfers were unfrozen. */ event Unfreeze (); /** * Logged when a particular account is frozen. */ event FrozenFunds(address target, bool frozen); /** * when accidentally send other tokens are refunded */ event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "1848.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "741.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'IUP' token contract // // Deployed to : 0x83673a1d24e2e257902b2eeb839fd5bee58407f7 // Symbol      : IUP // Name        : IUP Token // Total supply: 1000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract IUPToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function IUPToken() public { symbol = \"IUP\"; name = \"IUP Token\"; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x83673a1d24e2e257902b2eeb839fd5bee58407f7] = _totalSupply; Transfer(address(0), 0x83673a1d24e2e257902b2eeb839fd5bee58407f7, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "832.sol", "label": 0, "sol content": "pragma solidity 0.4.18; contract RigoBlock { string public symbol = \"RGC\"; string public name = \"Rigoblock\"; uint8 public constant decimals = 18; uint256 _totalSupply = 0; uint256 _MaxDistribPublicSupply = 0; uint256 _OwnerDistribSupply = 0; uint256 _CurrentDistribPublicSupply = 0; uint256 _FreeTokens = 0; uint256 _Multiplier1 = 2; uint256 _Multiplier2 = 3; uint256 _LimitMultiplier1 = 4e15; uint256 _LimitMultiplier2 = 8e15; uint256 _HighDonateLimit = 5e16; uint256 _BonusTokensPerETHdonated = 0; address _DistribFundsReceiverAddress = 0; address _remainingTokensReceiverAddress = 0; address owner = 0; bool setupDone = false; bool IsDistribRunning = false; bool DistribStarted = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _owner, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => bool) public Claimed; modifier onlyOwner() { require(msg.sender == owner); _; } function RigoBlock() public { owner = msg.sender; } function() public payable { if (IsDistribRunning) { uint256 _amount; if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert(); if (!_DistribFundsReceiverAddress.send(msg.value)) revert(); if (Claimed[msg.sender] == false) { _amount = _FreeTokens * 1e18; _CurrentDistribPublicSupply += _amount; balances[msg.sender] += _amount; _totalSupply += _amount; Transfer(this, msg.sender, _amount); Claimed[msg.sender] = true; } require(msg.value <= _HighDonateLimit); if (msg.value >= 1e15) { if (msg.value >= _LimitMultiplier2) { _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier2; } else { if (msg.value >= _LimitMultiplier1) { _amount = msg.value * _BonusTokensPerETHdonated * _Multiplier1; } else { _amount = msg.value * _BonusTokensPerETHdonated; } } _CurrentDistribPublicSupply += _amount; balances[msg.sender] += _amount; _totalSupply += _amount; Transfer(this, msg.sender, _amount); } } else { revert(); } } function SetupToken(string tokenName, string tokenSymbol, uint256 BonusTokensPerETHdonated, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeTokens) public { if (msg.sender == owner && !setupDone) { symbol = tokenSymbol; name = tokenName; _FreeTokens = FreeTokens; _BonusTokensPerETHdonated = BonusTokensPerETHdonated; _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18; if (OwnerDistribSupply > 0) { _OwnerDistribSupply = OwnerDistribSupply * 1e18; _totalSupply = _OwnerDistribSupply; balances[owner] = _totalSupply; _CurrentDistribPublicSupply += _totalSupply; Transfer(this, owner, _totalSupply); } _DistribFundsReceiverAddress = DistribFundsReceiverAddress; if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner; _remainingTokensReceiverAddress = remainingTokensReceiverAddress; setupDone = true; } } function SetupMultipliers(uint256 Multiplier1inX, uint256 Multiplier2inX, uint256 LimitMultiplier1inWei, uint256 LimitMultiplier2inWei, uint256 HighDonateLimitInWei) onlyOwner public { _Multiplier1 = Multiplier1inX; _Multiplier2 = Multiplier2inX; _LimitMultiplier1 = LimitMultiplier1inWei; _LimitMultiplier2 = LimitMultiplier2inWei; _HighDonateLimit = HighDonateLimitInWei; } function SetBonus(uint256 BonusTokensPerETHdonated) onlyOwner public { _BonusTokensPerETHdonated = BonusTokensPerETHdonated; } function SetFreeTokens(uint256 FreeTokens) onlyOwner public { _FreeTokens = FreeTokens; } function StartDistrib() public returns(bool success) { if (msg.sender == owner && !DistribStarted && setupDone) { DistribStarted = true; IsDistribRunning = true; } else { revert(); } return true; } function StopDistrib() public returns(bool success) { if (msg.sender == owner && IsDistribRunning) { if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) { uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply; if (_remainingAmount > 0) { balances[_remainingTokensReceiverAddress] += _remainingAmount; _totalSupply += _remainingAmount; Transfer(this, _remainingTokensReceiverAddress, _remainingAmount); } } DistribStarted = false; IsDistribRunning = false; } else { revert(); } return true; } function distribution(address[] addresses, uint256 _amount) onlyOwner public { uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply; require(addresses.length <= 255); require(_amount <= _remainingAmount); _amount = _amount * 1e18; for (uint i = 0; i < addresses.length; i++) { require(_amount <= _remainingAmount); _CurrentDistribPublicSupply += _amount; balances[addresses[i]] += _amount; _totalSupply += _amount; Transfer(this, addresses[i], _amount); } if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) { DistribStarted = false; IsDistribRunning = false; } } function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public { uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply; uint256 _amount; require(addresses.length <= 255); require(addresses.length == amounts.length); for (uint8 i = 0; i < addresses.length; i++) { _amount = amounts[i] * 1e18; require(_amount <= _remainingAmount); _CurrentDistribPublicSupply += _amount; balances[addresses[i]] += _amount; _totalSupply += _amount; Transfer(this, addresses[i], _amount); if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) { DistribStarted = false; IsDistribRunning = false; } } } function BurnTokens(uint256 amount) public returns(bool success) { uint256 _amount = amount * 1e18; if (balances[msg.sender] >= _amount) { balances[msg.sender] -= _amount; _totalSupply -= _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0, _amount); } else { revert(); } return true; } function totalSupply() public constant returns(uint256 totalSupplyValue) { return _totalSupply; } function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) { return _MaxDistribPublicSupply; } function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) { return _OwnerDistribSupply; } function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) { return _CurrentDistribPublicSupply; } function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) { return _remainingTokensReceiverAddress; } function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) { return _DistribFundsReceiverAddress; } function Owner() public constant returns(address ownerAddress) { return owner; } function SetupDone() public constant returns(bool setupDoneFlag) { return setupDone; } function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) { return IsDistribRunning; } function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) { return DistribStarted; } function balanceOf(address _owner) public constant returns(uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) public returns(bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) public returns(bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) public returns(bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) public constant returns(uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "336.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public ; event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract MultiTransfer is Ownable { function MultiTransfer() public { } function transfer(address token,address[] to, uint[] value) public onlyOwner { require(to.length == value.length); require(token != address(0)); ERC20 t = ERC20(token); for (uint i = 0; i < to.length; i++) { t.transfer(to[i], value[i]); } } } "}
{"sol name": "700.sol", "label": 0, "sol content": "pragma solidity 0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract InterbetCoin { // Public variables of the token string public name = \"Interbet Coin\"; string public symbol = \"IBC\"; uint8 public decimals = 18; uint256 public totalSupply = 1000000000 * (10 ** uint256(decimals)); // 1 billion IBC address public owner; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor() public { balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens owner = msg.sender; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } // transfer balance to owner function withdrawEther(uint256 amount) public { require(msg.sender == owner); owner.transfer(amount); } // can accept ether function() external payable { } } "}
{"sol name": "187.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; contract Owned { address public owner; function Owned() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function setOwner(address _newOwner) onlyOwner { if(_newOwner == 0x0)revert(); owner = _newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function toUINT112(uint256 a) internal constant returns(uint112) { assert(uint112(a) == a); return uint112(a); } function toUINT120(uint256 a) internal constant returns(uint120) { assert(uint120(a) == a); return uint120(a); } function toUINT128(uint256 a) internal constant returns(uint128) { assert(uint128(a) == a); return uint128(a); } } // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 contract Token { function totalSupply() public  returns (uint256 supply); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function burn( uint256 _value) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); } contract HealthyCoins is Token, Owned { using SafeMath for uint256; uint public  _totalSupply; string public   name;         //The Token's name uint8 public constant decimals = 4;    //Number of decimals of the smallest unit string public  symbol;    //The Token's symbol uint256 public mintCount; uint256 public deleteToken; uint256 public soldToken; mapping (address => uint256) public balanceOf; // Owner of account approves the transfer of an amount to another account mapping(address => mapping(address => uint256)) allowed; // Constructor function HealthyCoins(string coinName,string coinSymbol,uint initialSupply) { _totalSupply = initialSupply *10**uint256(decimals);                        // Update total supply balanceOf[msg.sender] = _totalSupply; name = coinName;                                   // Set the name for display purposes symbol =coinSymbol; } function totalSupply()  public  returns (uint256 totalSupply) { return _totalSupply; } // Send back ether sent to me function () { revert(); } // Transfer the balance from owner's account to another account function transfer(address _to, uint256 _amount) returns (bool success) { // according to AssetToken's total supply, never overflow here if (balanceOf[msg.sender] >= _amount && _amount > 0) { balanceOf[msg.sender] -= uint112(_amount); balanceOf[_to] = _amount.add(balanceOf[_to]).toUINT112(); soldToken = _amount.add(soldToken).toUINT112(); Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { // according to AssetToken's total supply, never overflow here if (balanceOf[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0) { balanceOf[_from] = balanceOf[_from].sub(_amount).toUINT112(); allowed[_from][msg.sender] -= _amount; balanceOf[_to] = _amount.add(balanceOf[_to]).toUINT112(); Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } //Mint tokens and assign to some one function mint(address _owner, uint256 _amount) onlyOwner{ balanceOf[_owner] = _amount.add(balanceOf[_owner]).toUINT112(); mintCount =  _amount.add(mintCount).toUINT112(); _totalSupply = _totalSupply.add(_amount).toUINT112(); } //Burn tokens from owner account function burn(uint256 _count) public returns (bool success) { balanceOf[msg.sender] -=uint112( _count); deleteToken = _count.add(deleteToken).toUINT112(); _totalSupply = _totalSupply.sub(_count).toUINT112(); Burn(msg.sender, _count); return true; } } "}
{"sol name": "788.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "648.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: openzeppelin-solidity/contracts/crowdsale/Crowdsale.sol /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } // File: contracts/CCCCrowdSale.sol contract CCCCrowdSale is Crowdsale { constructor(uint256 _rate, address _wallet, address _tokenAddress) Crowdsale(_rate,_wallet, ERC20(_tokenAddress)) public { } } "}
{"sol name": "1678.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract JTCCtoken { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function JTCCtoken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "22.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract XinCoin is StandardToken { address public admin; string public name = \"XinCoin\"; string public symbol = \"XC\"; uint8 public decimals = 8; uint256 public INITIAL_SUPPLY = 100000000000000000; mapping (address => bool) public frozenAccount; //\u65e0\u9650\u671f\u51bb\u7ed3\u7684\u8d26\u6237 mapping (address => uint256) public frozenTimestamp; // \u6709\u9650\u671f\u51bb\u7ed3\u7684\u8d26\u6237 event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply_ = INITIAL_SUPPLY; admin = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; } function() public payable { require(msg.value > 0); } function changeAdmin( address _newAdmin ) public returns (bool)  { require(msg.sender == admin); require(_newAdmin != address(0)); balances[_newAdmin] = balances[_newAdmin].add(balances[admin]); balances[admin] = 0; admin = _newAdmin; return true; } function generateToken( address _target, uint256 _amount ) public returns (bool)  { require(msg.sender == admin); require(_target != address(0)); balances[_target] = balances[_target].add(_amount); totalSupply_ = totalSupply_.add(_amount); INITIAL_SUPPLY = totalSupply_; return true; } function withdraw ( uint256 _amount ) public returns (bool) { require(msg.sender == admin); msg.sender.transfer(_amount); return true; } function freeze( address _target, bool _freeze ) public returns (bool) { require(msg.sender == admin); require(_target != address(0)); frozenAccount[_target] = _freeze; return true; } function freezeWithTimestamp( address _target, uint256 _timestamp ) public returns (bool) { require(msg.sender == admin); require(_target != address(0)); frozenTimestamp[_target] = _timestamp; return true; } function multiFreeze( address[] _targets, bool[] _freezes ) public returns (bool) { require(msg.sender == admin); require(_targets.length == _freezes.length); uint256 len = _targets.length; require(len > 0); for (uint256 i = 0; i < len; i = i.add(1)) { address _target = _targets[i]; require(_target != address(0)); bool _freeze = _freezes[i]; frozenAccount[_target] = _freeze; } return true; } function multiFreezeWithTimestamp( address[] _targets, uint256[] _timestamps ) public returns (bool) { require(msg.sender == admin); require(_targets.length == _timestamps.length); uint256 len = _targets.length; require(len > 0); for (uint256 i = 0; i < len; i = i.add(1)) { address _target = _targets[i]; require(_target != address(0)); uint256 _timestamp = _timestamps[i]; frozenTimestamp[_target] = _timestamp; } return true; } function multiTransfer( address[] _tos, uint256[] _values ) public returns (bool) { require(!frozenAccount[msg.sender]); require(now > frozenTimestamp[msg.sender]); require(_tos.length == _values.length); uint256 len = _tos.length; require(len > 0); uint256 amount = 0; for (uint256 i = 0; i < len; i = i.add(1)) { amount = amount.add(_values[i]); } require(amount <= balances[msg.sender]); for (uint256 j = 0; j < len; j = j.add(1)) { address _to = _tos[j]; require(_to != address(0)); balances[_to] = balances[_to].add(_values[j]); balances[msg.sender] = balances[msg.sender].sub(_values[j]); emit Transfer(msg.sender, _to, _values[j]); } return true; } function transfer( address _to, uint256 _value ) public returns (bool) { require(!frozenAccount[msg.sender]); require(now > frozenTimestamp[msg.sender]); require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(!frozenAccount[_from]); require(now > frozenTimestamp[msg.sender]); require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve( address _spender, uint256 _value ) public returns (bool) { require(_value <= balances[_spender]); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]);   // Check if the sender has enough balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender totalSupply_ = totalSupply_.sub(_value); INITIAL_SUPPLY = totalSupply_; emit Burn(msg.sender, _value); return true; } function getFrozenTimestamp( address _target ) public view returns (uint256) { require(_target != address(0)); return frozenTimestamp[_target]; } function getFrozenAccount( address _target ) public view returns (bool) { require(_target != address(0)); return frozenAccount[_target]; } function getBalance(address _owner) public view returns (uint256) { return balances[_owner]; } function setName ( string _value ) public returns (bool) { require(msg.sender == admin); name = _value; return true; } function setSymbol ( string _value ) public returns (bool) { require(msg.sender == admin); symbol = _value; return true; } function kill() public { require(msg.sender == admin); selfdestruct(admin); } } "}
{"sol name": "936.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * SmartEth.co * ERC20 Token and ICO smart contracts development, smart contracts audit, ICO websites. * [email\u00a0protected] */ /** * @title SafeMath */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = 0x96edbD4356309e21b72fA307BC7f20c7Aa30aA51; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PTG_Token is StandardToken, Ownable { string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; constructor() public { name = 'Petro.Global'; symbol = 'PTG'; decimals = 18; initialSupply = 5000000 * 10 ** uint256(decimals); totalSupply_ = initialSupply; balances[owner] = initialSupply; emit Transfer(0x0, owner, initialSupply); } } "}
{"sol name": "1919.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'TianTian' token contract // // Deployed to : 0x8cDe03F23651D86b915543cD014F4799038B847A // Symbol      : tiantian // Name        : TT Token // Total supply: 1000000000000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ttToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ttToken() public { symbol = \"tiantian\"; name = \"TT Token\"; decimals = 18; _totalSupply = 1000000000000000000; balances[0x8cDe03F23651D86b915543cD014F4799038B847A] = _totalSupply; Transfer(address(0), 0x8cDe03F23651D86b915543cD014F4799038B847A, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1644.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract BurnToken is BaseToken { event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } contract CustomToken is BaseToken, BurnToken { function CustomToken() public { totalSupply = 2100000000000000; name = 'NBTworld'; symbol = 'NBT'; decimals = 8; balanceOf[0xae3d6f1346d4567fa3a84a371f934844059c683a] = totalSupply; Transfer(address(0), 0xae3d6f1346d4567fa3a84a371f934844059c683a, totalSupply); } } "}
{"sol name": "930.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; /** test */ contract SafeMath { function mul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract RegularToken is Token, SafeMath { function transfer(address _to, uint256 _value) returns (bool) { require(balances[msg.sender] >= _value); require(balances[_to] + _value >= balances[_to]); balances[msg.sender] = sub(balances[msg.sender], _value); balances[_to] = add(balances[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool) { require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); require(allowed[_from][msg.sender] >= _value); balances[_from] = sub(balances[_from], _value); balances[_to] = add(balances[_to], _value); allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value); emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract MyTestToken is RegularToken { uint256 public totalSupply = 100*10**(18+8); uint8 constant public decimals = 18; string constant public name = \"Mytest\"; string constant public symbol = \"MT\"; function MyTestToken() { balances[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "331.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error. */ library SafeMath { // Multiplies two numbers, throws on overflow./ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) return 0; c = a * b; assert(c / a == b); return c; } // Integer division of two numbers, truncating the quotient. function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } // Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } // Adds two numbers, throws on overflow. function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title _1010_Mining_ distribution-contract (50/25/25) */ contract _1010_Mining_ { using SafeMath for uint256; // ------------------------------------------------------------------------- // Variables // ------------------------------------------------------------------------- struct Member { uint256 share;                               // Percent of mining profits uint256 unpaid;                              // Available Wei for withdrawal, + 1 in storage for gas optimization } mapping (address => Member) public members;      // All contract members as 'Member'-struct uint16    public memberCount;                    // Count of all members address[] public memberIndex;                    // Lookuptable of all member addresses to iterate on deposit over and assign unpaid Ether to members // ------------------------------------------------------------------------- // Private functions, can only be called by this contract // ------------------------------------------------------------------------- function _addMember (address _member, uint256 _share) private { emit AddMember(_member, _share); members[_member].share = _share; members[_member].unpaid = 1; memberIndex.push(_member); memberCount++; } // ------------------------------------------------------------------------- // Constructor // ------------------------------------------------------------------------- constructor () public { // Initialize members with their share (total 100) and trigger 'AddMember'-event _addMember(0xd2Ce719a0d00f4f8751297aD61B0E936970282E1, 50); _addMember(0xE517CB63e4dD36533C26b1ffF5deB893E63c3afA, 25); _addMember(0x430e1dd1ab2E68F201B53056EF25B9e116979D9b, 25); } // ------------------------------------------------------------------------- // Events // ------------------------------------------------------------------------- event AddMember(address indexed member, uint256 share); event Withdraw(address indexed member, uint256 value); event Deposit(address indexed from, uint256 value); // ------------------------------------------------------------------------- // Public external interface // ------------------------------------------------------------------------- function () external payable { // Distribute deposited Ether to all members related to their profit-share for (uint i=0; i<memberIndex.length; i++) { members[memberIndex[i]].unpaid = // Adding current deposit to members unpaid Wei amount members[memberIndex[i]].unpaid.add( // MemberShare * DepositedWei / 100 = WeiAmount of member-share to be added to members unpaid holdings members[memberIndex[i]].share.mul(msg.value).div(100) ); } // Trigger 'Deposit'-event emit Deposit(msg.sender, msg.value); } function withdraw () external { // Pre-validate withdrawal require(members[msg.sender].unpaid > 1, \"No unpaid balance or not a member account\"); // Remember members unpaid amount but remove it from his contract holdings before initiating the withdrawal for security reasons uint256 unpaid = members[msg.sender].unpaid.sub(1); members[msg.sender].unpaid = 1; // Trigger 'Withdraw'-event emit Withdraw(msg.sender, unpaid); // Transfer the unpaid Wei amount to member address msg.sender.transfer(unpaid); } function unpaid () public view returns (uint256) { // Get unpaid Wei amount of member return members[msg.sender].unpaid.sub(1); } function member () public view returns (bool) { // Get member-state (true or false) return members[msg.sender].unpaid >= 1; } } "}
{"sol name": "230.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Ethershift' token contract // // Deployed to : 0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302 // Symbol      : ESH // Name        : Ethershift // Total supply: 1500000000000000000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Ethershift is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Ethershift() public { symbol = \"ESH\"; name = \"Ethershift\"; decimals = 18; _totalSupply = 15000000000000000000000000; balances[0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302] = _totalSupply; Transfer(address(0), 0xB81420ae4cb01aEfA91E6A69a3a749B48Ba71302, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "716.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract OkLive { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function OkLive( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "387.sol", "label": 0, "sol content": "library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract TPSToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"TPS\"; name = \"TRUSTPAY SHARE\"; decimals = 0; _totalSupply = 200000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "845.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract GCA1{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ uint256 public totalSupply; string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function GCA1() public { balances[msg.sender] = 10000000000000;               // Give the creator all initial tokens totalSupply = 10000000000000;                        // Update total supply name = \"Gold chain assets one\";                                   // Set the name for display purposes decimals =4;                            // Amount of decimals for display purposes symbol = \"GCA1\";                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "283.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract BTRS is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function BTRS() public { symbol = \"BTRS\"; name = \"BitBall Treasure\"; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992] = _totalSupply; Transfer(address(0), 0x6a29063DD421Bf38a18b5a7455Fb6fE5f36F7992, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "381.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract MultiTransfer is Ownable { function MultiTransfer() public { } function transfer(address token,address[] to, uint[] value) public onlyOwner { require(to.length == value.length); require(token != address(0)); ERC20 t = ERC20(token); for (uint i = 0; i < to.length; i++) { t.transfer(to[i], value[i]); } } } "}
{"sol name": "600.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(a >= b); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Owned * @dev Ownership model */ contract Owned { address public owner; event OwnershipTransfered(address indexed owner); constructor() public { owner = msg.sender; emit OwnershipTransfered(owner); } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; emit OwnershipTransfered(owner); } } /** * @title ERC20Token * @dev Interface for erc20 standard */ contract ERC20Token { using SafeMath for uint256; string public constant name = \"Ansforce Intelligence Token\"; string public constant symbol = \"AIT\"; uint8 public constant decimals = 18; uint256 public totalSupply = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed from, uint256 value, address indexed to, bytes extraData); constructor() public { } /** * Internal transfer, only can be called by this contract */ function _transfer(address from, address to, uint256 value) internal { // Check if the sender has enough balance require(balanceOf[from] >= value); // Check for overflow require(balanceOf[to] + value > balanceOf[to]); // Save this for an amount double check assertion uint256 previousBalances = balanceOf[from].add(balanceOf[to]); balanceOf[from] = balanceOf[from].sub(value); balanceOf[to] = balanceOf[to].add(value); emit Transfer(from, to, value); // Asserts for duplicate check. Should never fail. assert(balanceOf[from].add(balanceOf[to]) == previousBalances); } /** * Transfer tokens * * Send `value` tokens to `to` from your account * * @param to The address of the recipient * @param value the amount to send */ function transfer(address to, uint256 value) public { _transfer(msg.sender, to, value); } /** * Transfer tokens from other address * * Send `value` tokens to `to` in behalf of `from` * * @param from The address of the sender * @param to The address of the recipient * @param value the amount to send */ function transferFrom(address from, address to, uint256 value) public returns (bool success) { require(value <= allowance[from][msg.sender]); allowance[from][msg.sender] = allowance[from][msg.sender].sub(value); _transfer(from, to, value); return true; } /** * Set allowance for other address * * Allows `spender` to spend no more than `value` tokens in your behalf * * @param spender The address authorized to spend * @param value the max amount they can spend * @param extraData some extra information to send to the approved contract */ function approve(address spender, uint256 value, bytes extraData) public returns (bool success) { allowance[msg.sender][spender] = value; emit Approval(msg.sender, value, spender, extraData); return true; } } contract AnsforceIntelligenceToken is Owned, ERC20Token { constructor() public { } function init(uint256 _supply, address _vault) public onlyOwner { require(totalSupply == 0); require(_supply > 0); require(_vault != address(0)); totalSupply = _supply; balanceOf[_vault] = totalSupply; } bool public stopped = false; modifier isRunning { require (!stopped); _; } function transfer(address to, uint256 value) isRunning public { ERC20Token.transfer(to, value); } function stop() public onlyOwner { stopped = true; } function start() public onlyOwner { stopped = false; } mapping (address => uint256) public freezeOf; /* This notifies clients about the amount frozen */ event Freeze(address indexed target, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed target, uint256 value); function freeze(address target, uint256 _value) public onlyOwner returns (bool success) { require( _value > 0 ); balanceOf[target] = SafeMath.sub(balanceOf[target], _value); freezeOf[target] = SafeMath.add(freezeOf[target], _value); emit Freeze(target, _value); return true; } function unfreeze(address target, uint256 _value) public onlyOwner returns (bool success) { require( _value > 0 ); freezeOf[target] = SafeMath.sub(freezeOf[target], _value); balanceOf[target] = SafeMath.add(balanceOf[target], _value); emit Unfreeze(target, _value); return true; } } "}
{"sol name": "645.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT695058' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT695058 // Name        : ADZbuzz Architecture.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT695058\"; name = \"ADZbuzz Architecture.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "925.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // **************************************************************************** // Safe math // **************************************************************************** library SafeMath { function mul(uint _a, uint _b) internal pure returns (uint c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function div(uint _a, uint _b) internal pure returns (uint) { return _a / _b; } function sub(uint _a, uint _b) internal pure returns (uint) { assert(_b <= _a); return _a - _b; } function add(uint _a, uint _b) internal pure returns (uint c) { c = _a + _b; assert(c >= _a); return c; } } // **************************************************************************** // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md // **************************************************************************** contract ERC20 { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // **************************************************************************** // Contract function to receive approval and execute function // **************************************************************************** contract ApproveAndCallFallBack { function receiveApproval(address from, uint tokens, address token, bytes data) public; } // **************************************************************************** // Owned contract // **************************************************************************** contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // **************************************************************************** // TTTC Token, with the addition of symbol, name and decimals and a fixed supply // **************************************************************************** contract TTTCToken is ERC20, Owned { using SafeMath for uint; event Pause(); event Unpause(); event ReleasedTokens(uint tokens); event AllocateTokens(address to, uint tokens); bool public paused = false; string public symbol; string public name; uint8 public decimals; uint private _totalSupply;              //total supply uint private _initialRelease;           //initial release uint private _locked;                   //locked tokens uint private _released = 0;             //alloced tokens uint private _allocated = 0; uint private _startTime = 1534233600 + 180 days;    //release start time:2018-08-15 00:00:00(UTC) + 180 days mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ************************************************************************ // Modifier to make a function callable only when the contract is not paused. // ************************************************************************ modifier whenNotPaused() { require(!paused); _; } // ************************************************************************ // Modifier to make a function callable only when the contract is paused. // ************************************************************************ modifier whenPaused() { require(paused); _; } // ************************************************************************ // Constructor // ************************************************************************ constructor() public { symbol = \"TTTC\"; name = \"TTTC\"; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); _initialRelease = _totalSupply * 7 / 10; _locked = _totalSupply * 3 / 10; balances[owner] = _initialRelease; emit Transfer(address(0), owner, _initialRelease); } // ************************************************************************ // Total supply // ************************************************************************ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ************************************************************************ // Get the token balance for account `tokenOwner` // ************************************************************************ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ************************************************************************ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ************************************************************************ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { require(address(0) != to && tokens <= balances[msg.sender] && 0 <= tokens); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ************************************************************************ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // ************************************************************************ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { require(address(0) != spender && 0 <= tokens); allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ************************************************************************ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ************************************************************************ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { require(address(0) != to && tokens <= balances[from] && tokens <= allowed[from][msg.sender] && 0 <= tokens); balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ************************************************************************ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ************************************************************************ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ************************************************************************ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ************************************************************************ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ************************************************************************ // Don't accept ETH // ************************************************************************ function () public payable { revert(); } // ************************************************************************ // Owner can transfer out any accidentally sent ERC20 tokens // ************************************************************************ function transferERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20(tokenAddress).transfer(owner, tokens); } // ************************************************************************ // called by the owner to pause, triggers stopped state // ************************************************************************ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } // ************************************************************************ // called by the owner to unpause, returns to normal state // ************************************************************************ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } // ************************************************************************ // return free Tokens // ************************************************************************ function freeBalance() public view returns (uint tokens) { return _released.sub(_allocated); } // ************************************************************************ // return released Tokens // ************************************************************************ function releasedBalance() public view returns (uint tokens) { return _released; } // ************************************************************************ // return allocated Tokens // ************************************************************************ function allocatedBalance() public view returns (uint tokens) { return _allocated; } // ************************************************************************ // calculate released Tokens by the owner // ************************************************************************ function calculateReleased() public onlyOwner returns (uint tokens) { require(now > _startTime); uint _monthDiff = (now.sub(_startTime)).div(30 days); if (_monthDiff >= 10 ) { _released = _locked; } else { _released = _monthDiff.mul(_locked.div(10)); } emit ReleasedTokens(_released); return _released; } // ************************************************************************ // called by the owner to alloc the released tokens // ************************************************************************ function allocateTokens(address to, uint tokens) public onlyOwner returns (bool success){ require(address(0) != to && 0 <= tokens && tokens <= _released.sub(_allocated)); balances[to] = balances[to].add(tokens); _allocated = _allocated.add(tokens); emit AllocateTokens(to, tokens); return true; } } "}
{"sol name": "1847.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract birthdayTest { uint originalTime; constructor() public{ originalTime = now; } //prints a birthday message and then becomes impossible to execute after 23 hours function BirthdayBoyClickHere() public view returns(string) { require(now < originalTime + 23 hours); return \"Happy Birthday Harrison! I know this contract is noobish but I will get better.\"; } } "}
{"sol name": "480.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract MyanmarGoldToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; string public constant name = \"MyanmarGoldToken\"; // solium-disable-line uppercase string public constant symbol = \"MGC\"; // solium-disable-line uppercase uint8 public constant decimals = 18; // solium-disable-line uppercase event Burn(address indexed burner, uint256 value); constructor(address _icoAddress) public { totalSupply_ = 1000000000 * (10 ** uint256(decimals)); balances[_icoAddress] = totalSupply_; emit Transfer(address(0), _icoAddress, totalSupply_); } /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev batchTransfer token for a specified addresses * @param _tos The addresses to transfer to. * @param _values The amounts to be transferred. */ function batchTransfer(address[] _tos, uint256[] _values) public returns (bool) { require(_tos.length == _values.length); uint256 arrayLength = _tos.length; for(uint256 i = 0; i < arrayLength; i++) { transfer(_tos[i], _values[i]); } return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } "}
{"sol name": "779.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint public totalSupply; function balanceOf(address who) public view returns (uint); function transfer(address to, uint value) public returns (bool); event Transfer(address indexed from, address indexed to, uint value); } contract BasicToken is ERC20Basic { using SafeMath for uint; mapping(address => uint) balances; function transfer(address _to, uint _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint); function transferFrom(address from, address to, uint value) public returns (bool); function approve(address spender, uint value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint)) allowed; function transferFrom(address _from, address _to, uint _value) public returns (bool) { require(_to != address(0)); uint _allowance = allowed[_from][msg.sender]; require (_value <= _allowance); require(_value > 0); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract GOENT is StandardToken { string public constant name = \"GOEN TOKEN\"; string public constant symbol = \"GOENT\"; uint   public constant decimals = 8; uint   public constant INITIAL_SUPPLY =  10000000000 * (10 ** decimals); constructor() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "1927.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; //*************** SafeMath *************** library SafeMath { function mul(uint256 a, uint256 b) internal pure  returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure  returns (uint256) { assert(b > 0); uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure  returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure  returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } //*************** Ownable *************** contract Ownable { address public owner; address public admin; function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyOwnerAdmin() { require(msg.sender == owner || msg.sender == admin); _; } function transferOwnership(address newOwner)public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } function setAdmin(address _admin)public onlyOwner { admin = _admin; } } //************* ERC20 *************** contract ERC20 { function balanceOf(address who)public constant returns (uint256); function transfer(address to, uint256 value)public returns (bool); function transferFrom(address from, address to, uint256 value)public returns (bool); function allowance(address owner, address spender)public constant returns (uint256); function approve(address spender, uint256 value)public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract UtradeToken is ERC20,Ownable { using SafeMath for uint256; // Token Info. string public name; string public symbol; uint256 public totalSupply; uint256 public constant decimals = 8; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) allowed; event FundTransfer(address fundWallet, uint256 amount); event Logs(string); constructor( ) public { name=\"UTP FOUNDATION\"; symbol=\"UTP\"; totalSupply = 1000000000*(10**decimals); balanceOf[msg.sender] = totalSupply; } function balanceOf(address _who)public constant returns (uint256 balance) { return balanceOf[_who]; } function _transferFrom(address _from, address _to, uint256 _value)  internal { require(_from != 0x0); require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint256 previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool){ _transferFrom(msg.sender,_to,_value); return true; } function transferLog(address _to, uint256 _value,string logs) public returns (bool){ _transferFrom(msg.sender,_to,_value); emit Logs(logs); return true; } function ()public { } function allowance(address _owner, address _spender)public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function approve(address _spender, uint256 _value)public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value)public returns (bool) { require(_from != 0x0); require(_to != 0x0); require(_value > 0); require (allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function mintToken(address _target, uint256 _mintedAmount) onlyOwner public { require(_target != 0x0); require(_mintedAmount > 0); require(totalSupply + _mintedAmount > totalSupply); require(balanceOf[_target] + _mintedAmount > balanceOf[_target]); balanceOf[_target] = balanceOf[_target].add(_mintedAmount); totalSupply = totalSupply.add(_mintedAmount); emit Transfer(0, this, _mintedAmount); emit Transfer(this, _target, _mintedAmount); } function transferA2B(address _from ,address _to) onlyOwnerAdmin public { require(_from != 0x0); require(_to != 0x0); require(balanceOf[_from] > 0); //require(balanceOf[_to] == 0); _transferFrom(_from,_to,balanceOf[_from]); } } "}
{"sol name": "717.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: ..\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Basic.sol /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic { event Transfer( address indexed _from, address indexed _to, uint256 _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public; } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721.sol /** * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex( address _owner, uint256 _index ) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } /** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Metadata is ERC721Basic { function name() public view returns (string _name); function symbol() public view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } /** * @title ERC-721 Non-Fungible Token Standard, full implementation interface * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } // File: ..\\openzeppelin-solidity\\contracts\\AddressUtils.sol /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, *  as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(addr) } return size > 0; } } // File: ..\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Receiver.sol /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers *  from ERC721 asset contracts. */ contract ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient *  after a `safetransfer`. This function MAY throw to revert and reject the *  transfer. This function MUST use 50,000 gas or less. Return of other *  than the magic value MUST result in the transaction being reverted. *  Note: the contract address is always the message sender. * @param _from The sending address * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` */ function onERC721Received( address _from, uint256 _tokenId, bytes _data ) public returns(bytes4); } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721BasicToken.sol /** * @title ERC721 Non-Fungible Token Standard basic implementation * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721BasicToken is ERC721Basic { using SafeMath for uint256; using AddressUtils for address; // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; // Mapping from token ID to owner mapping (uint256 => address) internal tokenOwner; // Mapping from token ID to approved address mapping (uint256 => address) internal tokenApprovals; // Mapping from owner to number of owned token mapping (address => uint256) internal ownedTokensCount; // Mapping from owner to operator approvals mapping (address => mapping (address => bool)) internal operatorApprovals; /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint256 ID of the token to validate */ modifier canTransfer(uint256 _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existence of * @return whether the token exists */ function exists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * @dev The zero address indicates there is no approved address. * @dev There can only be one approved address per token at a given time. * @dev Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); if (getApproved(_tokenId) != address(0) || _to != address(0)) { tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } /** * @dev Sets or unsets the approval of a given operator * @dev An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll( address _owner, address _operator ) public view returns (bool) { return operatorApprovals[_owner][_operator]; } /** * @dev Transfers the ownership of a given token ID to another address * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function transferFrom( address _from, address _to, uint256 _tokenId ) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function safeTransferFrom( address _from, address _to, uint256 _tokenId ) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint256 _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } /** * @dev Internal function to burn a specific token * @dev Reverts if the token does not exist * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { clearApproval(_owner, _tokenId); removeTokenFrom(_owner, _tokenId); emit Transfer(_owner, address(0), _tokenId); } /** * @dev Internal function to clear current approval of a given token ID * @dev Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); emit Approval(_owner, address(0), _tokenId); } } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } /** * @dev Internal function to invoke `onERC721Received` on a target address * @dev The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } // File: ..\\openzeppelin-solidity\\contracts\\token\\ERC721\\ERC721Token.sol /** * @title Full ERC721 Token * This implementation includes all the required and some optional functionality of the ERC721 standard * Moreover, it includes approve all functionality using operator terminology * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Token is ERC721, ERC721BasicToken { // Token name string internal name_; // Token symbol string internal symbol_; // Mapping from owner to list of owned token IDs mapping(address => uint256[]) internal ownedTokens; // Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; // Array with all token ids, used for enumeration uint256[] internal allTokens; // Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex; // Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs; /** * @dev Constructor function */ constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; } /** * @dev Gets the token name * @return string representing the token name */ function name() public view returns (string) { return name_; } /** * @dev Gets the token symbol * @return string representing the token symbol */ function symbol() public view returns (string) { return symbol_; } /** * @dev Returns an URI for a given token ID * @dev Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ function tokenURI(uint256 _tokenId) public view returns (string) { require(exists(_tokenId)); return tokenURIs[_tokenId]; } /** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ function tokenOfOwnerByIndex( address _owner, uint256 _index ) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } /** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ function totalSupply() public view returns (uint256) { return allTokens.length; } /** * @dev Gets the token ID at a given index of all the tokens in this contract * @dev Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } /** * @dev Internal function to set the token URI for a given token * @dev Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ function _setTokenURI(uint256 _tokenId, string _uri) internal { require(exists(_tokenId)); tokenURIs[_tokenId] = _uri; } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; ownedTokens[_from][lastTokenIndex] = 0; // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping // the lastToken to the first position, and then dropping the element placed in the last position of the list ownedTokens[_from].length--; ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { super._mint(_to, _tokenId); allTokensIndex[_tokenId] = allTokens.length; allTokens.push(_tokenId); } /** * @dev Internal function to burn a specific token * @dev Reverts if the token does not exist * @param _owner owner of the token to burn * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { super._burn(_owner, _tokenId); // Clear metadata (if any) if (bytes(tokenURIs[_tokenId]).length != 0) { delete tokenURIs[_tokenId]; } // Reorg all tokens array uint256 tokenIndex = allTokensIndex[_tokenId]; uint256 lastTokenIndex = allTokens.length.sub(1); uint256 lastToken = allTokens[lastTokenIndex]; allTokens[tokenIndex] = lastToken; allTokens[lastTokenIndex] = 0; allTokens.length--; allTokensIndex[_tokenId] = 0; allTokensIndex[lastToken] = tokenIndex; } } // File: contracts\\RoyalStables.sol /** @title RoyalStables Holding HRSY token */ contract RoyalStables is Ownable,ERC721Token { /** @dev Structure to hold Horsey collectible information @dev should be as small as possible but since its already greater than 256 @dev lets keep it <= 512 */ struct Horsey { address race;       /// @dev Stores the original race address this horsey was claimed from bytes32 dna;        /// @dev Stores the horsey dna uint8 feedingCounter;   /// @dev Boils down to how many times has this horsey been fed uint8 tier;         /// @dev Used internaly to assess chances of a rare trait developing while feeding } /// @dev Maps all token ids to a unique Horsey mapping(uint256 => Horsey) public horseys; /// @dev Maps addresses to the amount of carrots they own mapping(address => uint32) public carrot_credits; /// @dev Maps a horsey token id to the horsey name mapping(uint256 => string) public names; /// @dev Master is the current Horsey contract using this library address public master; /** @dev Contracts constructor */ constructor() public Ownable() ERC721Token(\"HORSEY\",\"HRSY\") { } /** @dev Allows to change the address of the current Horsey contract @param newMaster Address of the current Horsey contract */ function changeMaster(address newMaster) public validAddress(newMaster) onlyOwner() { master = newMaster; } /** @dev Gets the complete list of token ids which belongs to an address @param eth_address The address you want to lookup owned tokens from @return List of all owned by eth_address tokenIds */ function getOwnedTokens(address eth_address) public view returns (uint256[]) { return ownedTokens[eth_address]; } /** @dev Stores a horsey name @param tokenId Horsey token id @param newName New horsey name */ function storeName(uint256 tokenId, string newName) public onlyMaster() { require(exists(tokenId),\"token not found\"); names[tokenId] = newName; } /** @dev Stores carrot credits on the clients account @param client Client we need to update the balance of @param amount Amount of carrots to store */ function storeCarrotsCredit(address client, uint32 amount) public onlyMaster() validAddress(client) { carrot_credits[client] = amount; } function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public onlyMaster() validAddress(client) { //_mint checks if the token exists before minting already, so we dont have to here _mint(client,tokenId); modifyHorsey(tokenId,race,dna,feedingCounter,tier); } function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public onlyMaster() { require(exists(tokenId),\"token not found\"); Horsey storage hrsy = horseys[tokenId]; hrsy.race = race; hrsy.dna = dna; hrsy.feedingCounter = feedingCounter; hrsy.tier = tier; } function modifyHorseyDna(uint256 tokenId, bytes32 dna) public onlyMaster() { require(exists(tokenId),\"token not found\"); horseys[tokenId].dna = dna; } function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public onlyMaster() { require(exists(tokenId),\"token not found\"); horseys[tokenId].feedingCounter = feedingCounter; } function modifyHorseyTier(uint256 tokenId, uint8 tier) public onlyMaster() { require(exists(tokenId),\"token not found\"); horseys[tokenId].tier = tier; } function unstoreHorsey(uint256 tokenId) public onlyMaster() { require(exists(tokenId),\"token not found\"); _burn(ownerOf(tokenId),tokenId); delete horseys[tokenId]; delete names[tokenId]; } /// @dev requires the address to be non null modifier validAddress(address addr) { require(addr != address(0),\"Address must be non zero\"); _; } /// @dev requires the caller to be the master modifier onlyMaster() { require(master == msg.sender,\"Address must be non zero\"); _; } } "}
{"sol name": "983.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"CONG\"; decimals = 4; totalSupply = 100000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]);   // ?????? balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); // ??????? emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract { address public owner; string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } // constructor function SelfDesctructionContract() { owner = msg.sender; } // a simple setter function function setSomeValue(string value){ someValue = value; } // you can call it anything you want function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "813.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TbookToken { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TbookToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "766.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract MultiTransfer is Ownable { ERC20 public tkcAddress; function MultiTransfer() public { } function setTKC(address tkc) public onlyOwner { require(tkcAddress == address(0)); tkcAddress = ERC20(tkc); } function transfer(address[] to, uint[] value) public onlyOwner { require(to.length == value.length); for (uint i = 0; i < to.length; i++) { tkcAddress.transferFrom(owner, to[i], value[i]); } } } "}
{"sol name": "462.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: openzeppelin-solidity/contracts/lifecycle/Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } // File: contracts/lib/ApprovalAndCallFallBack.sol contract ApprovalAndCallFallBack { function receiveApproval(address _owner, uint256 _amount, address _token, bytes _data) public returns (bool); } // File: contracts/lib/TransferAndCallFallBack.sol contract TransferAndCallFallBack { function receiveToken(address _owner, uint256 _amount, address _token, bytes _data) public returns (bool); } // File: contracts/token/MuzikaCoin.sol contract MuzikaCoin is MintableToken, Pausable { string public name = 'Muzika'; string public symbol = 'MZK'; uint8 public decimals = 18; event Burn(address indexed burner, uint256 value); constructor(uint256 initialSupply) public { totalSupply_ = initialSupply; balances[msg.sender] = initialSupply; emit Transfer(address(0), msg.sender, initialSupply); } /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public onlyOwner { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function increaseApprovalAndCall(address _spender, uint _addedValue, bytes _data) public returns (bool) { require(_spender != address(this)); increaseApproval(_spender, _addedValue); require( ApprovalAndCallFallBack(_spender).receiveApproval( msg.sender, _addedValue, address(this), _data ) ); return true; } function transferAndCall(address _to, uint _value, bytes _data) public returns (bool) { require(_to != address(this)); transfer(_to, _value); require( TransferAndCallFallBack(_to).receiveToken( msg.sender, _value, address(this), _data ) ); return true; } function tokenDrain(ERC20 _token, uint256 _amount) public onlyOwner { _token.transfer(owner, _amount); } } "}
{"sol name": "804.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; library BobbySafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BobbyERC20Base { address public ceoAddress; address public cfoAddress; //\u662f\u5426\u6682\u505c\u667a\u80fd\u5408\u7ea6\u7684\u8fd0\u884c bool public paused = false; constructor(address cfoAddr) public { ceoAddress = msg.sender; cfoAddress = cfoAddr; } modifier onlyCEO() { require(msg.sender == ceoAddress); _; } function setCEO(address _newCEO) public onlyCEO { require(_newCEO != address(0)); ceoAddress = _newCEO; } modifier onlyCFO() { require(msg.sender == cfoAddress); _; } modifier allButCFO() { require(msg.sender != cfoAddress); _; } function setCFO(address _newCFO) public onlyCEO { require(_newCFO != address(0)); cfoAddress = _newCFO; } modifier whenNotPaused() { require(!paused); _; } modifier whenPaused { require(paused); _; } function pause() external onlyCEO whenNotPaused { paused = true; } function unpause() public onlyCEO whenPaused { paused = false; } } contract ERC20Interface { //ERC20\u6307\u5b9a\u63a5\u53e3 event Approval(address indexed src, address indexed guy, uint wad); event Transfer(address indexed src, address indexed dst, uint wad); //extend event event Grant(address indexed src, address indexed dst, uint wad);    //\u53d1\u653e\u4ee3\u5e01\uff0c\u6709\u89e3\u7981\u671f event Unlock(address indexed user, uint wad);                       //\u89e3\u7981\u4ee3\u5e01 function name() public view returns (string n); function symbol() public view returns (string s); function decimals() public view returns (uint8 d); function totalSupply() public view returns (uint256 t); function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); } //Erc\u667a\u80fd\u5408\u7ea6 contract ERC20 is ERC20Interface, BobbyERC20Base { using BobbySafeMath for uint256; uint private _Thousand = 1000; uint private _Billion = _Thousand * _Thousand * _Thousand; //\u4ee3\u5e01\u57fa\u672c\u4fe1\u606f string private _name = \"BOBBYTest\";     //\u4ee3\u5e01\u540d\u79f0 string private _symbol = \"BOBBYTest\";   //\u4ee3\u5e01\u6807\u8bc6 uint8 private _decimals = 9;        //\u5c0f\u6570\u70b9\u540e\u4f4d\u6570 uint256 private _totalSupply = 10 * _Billion * (10 ** uint256(_decimals)); //\u89e3\u5c01\u7528\u6237\u4ee3\u5e01\u7ed3\u6784 struct UserToken { uint index;              //\u653e\u5728\u6570\u7ec4\u4e2d\u7684\u4e0b\u6807 address addr;            //\u7528\u6237\u8d26\u53f7 uint256 tokens;          //\u901a\u8bc1\u6570\u91cf uint256 unlockUnit;     // \u6bcf\u6b21\u89e3\u9501\u6570\u91cf uint256 unlockPeriod;   // \u89e3\u9501\u65f6\u95f4\u95f4\u9694 uint256 unlockLeft;     // \u672a\u89e3\u9501\u901a\u8bc1\u6570\u91cf uint256 unlockLastTime; // \u4e0a\u6b21\u89e3\u9501\u65f6\u95f4 } mapping(address=>UserToken) private _balancesMap;           //\u7528\u6237\u53ef\u7528\u4ee3\u5e01\u6620\u5c04 address[] private _balancesArray;                           //\u7528\u6237\u53ef\u7528\u4ee3\u5e01\u6570\u7ec4,from 1 uint32 private actionTransfer = 0; uint32 private actionGrant = 1; uint32 private actionUnlock = 2; struct LogEntry { uint256 time; uint32  action;       // 0 \u8f6c\u8d26 1 \u53d1\u653e 2 \u89e3\u9501 address from; address to; uint256 v1; uint256 v2; uint256 v3; } LogEntry[] private _logs; //\u6784\u9020\u65b9\u6cd5\uff0c\u5c06\u4ee3\u5e01\u7684\u521d\u59cb\u603b\u4f9b\u7ed9\u90fd\u5206\u914d\u7ed9\u5408\u7ea6\u7684\u90e8\u7f72\u8d26\u6237\u3002\u5408\u7ea6\u7684\u6784\u9020\u65b9\u6cd5\u53ea\u5728\u5408\u7ea6\u90e8\u7f72\u65f6\u6267\u884c\u4e00\u6b21 constructor(address cfoAddr) BobbyERC20Base(cfoAddr) public { //placeholder _balancesArray.push(address(0)); //\u6b64\u5904\u9700\u8981\u6ce8\u610f\uff0c\u8bf7\u4f7f\u7528CEO\u7684\u5730\u5740,\u56e0\u4e3a\u521d\u59cb\u5316\u540e\uff0c\u5c06\u4f1a\u4f7f\u7528\u8fd9\u4e2a\u5730\u5740\u4f5c\u4e3aCEO\u5730\u5740 //\u6ce8\u610f\uff0c\u4e00\u5b9a\u8981\u4f7f\u7528memory\u7c7b\u578b\uff0c\u5426\u5219\uff0c\u540e\u9762\u7684\u8d4b\u503c\u4f1a\u5f71\u54cd\u5176\u5b83\u6210\u5458\u53d8\u91cf UserToken memory userCFO; userCFO.index = _balancesArray.length; userCFO.addr = cfoAddr; userCFO.tokens = _totalSupply; userCFO.unlockUnit = 0; userCFO.unlockPeriod = 0; userCFO.unlockLeft = 0; userCFO.unlockLastTime = 0; _balancesArray.push(cfoAddr); _balancesMap[cfoAddr] = userCFO; } //\u8fd4\u56de\u5408\u7ea6\u540d\u79f0\u3002view\u5173\u952e\u5b50\u8868\u793a\u51fd\u6570\u53ea\u67e5\u8be2\u72b6\u6001\u53d8\u91cf\uff0c\u800c\u4e0d\u5199\u5165 function name() public view returns (string n){ n = _name; } //\u8fd4\u56de\u5408\u7ea6\u6807\u8bc6\u7b26 function symbol() public view returns (string s){ s = _symbol; } //\u8fd4\u56de\u5408\u7ea6\u5c0f\u6570\u4f4d function decimals() public view returns (uint8 d){ d = _decimals; } //\u8fd4\u56de\u5408\u7ea6\u603b\u4f9b\u7ed9\u989d function totalSupply() public view returns (uint256 t){ t = _totalSupply; } //\u67e5\u8be2\u8d26\u6237_owner\u7684\u8d26\u6237\u4f59\u989d function balanceOf(address _owner) public view returns (uint256 balance){ UserToken storage user = _balancesMap[_owner]; balance = user.tokens.add(user.unlockLeft); } //\u4ece\u4ee3\u5e01\u5408\u7ea6\u7684\u8c03\u7528\u8005\u5730\u5740\u4e0a\u8f6c\u79fb_value\u7684\u6570\u91cftoken\u5230\u7684\u5730\u5740_to\uff0c\u5e76\u4e14\u5fc5\u987b\u89e6\u53d1Transfer\u4e8b\u4ef6 function transfer(address _to, uint256 _value) public returns (bool success){ require(!paused); require(msg.sender != cfoAddress); require(msg.sender != _to); //\u5148\u5224\u65ad\u662f\u5426\u6709\u53ef\u4ee5\u89e3\u7981 if(_balancesMap[msg.sender].unlockLeft > 0){ UserToken storage sender = _balancesMap[msg.sender]; uint256 diff = now.sub(sender.unlockLastTime); uint256 round = diff.div(sender.unlockPeriod); if(round > 0) { uint256 unlocked = sender.unlockUnit.mul(round); if (unlocked > sender.unlockLeft) { unlocked = sender.unlockLeft; } sender.unlockLeft = sender.unlockLeft.sub(unlocked); sender.tokens = sender.tokens.add(unlocked); sender.unlockLastTime = sender.unlockLastTime.add(sender.unlockPeriod.mul(round)); emit Unlock(msg.sender, unlocked); log(actionUnlock, msg.sender, 0, unlocked, 0, 0); } } require(_balancesMap[msg.sender].tokens >= _value); _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value); uint index = _balancesMap[_to].index; if(index == 0){ UserToken memory user; user.index = _balancesArray.length; user.addr = _to; user.tokens = _value; user.unlockUnit = 0; user.unlockPeriod = 0; user.unlockLeft = 0; user.unlockLastTime = 0; _balancesMap[_to] = user; _balancesArray.push(_to); } else{ _balancesMap[_to].tokens = _balancesMap[_to].tokens.add(_value); } emit Transfer(msg.sender, _to, _value); log(actionTransfer, msg.sender, _to, _value, 0, 0); success = true; } function transferFrom(address, address, uint256) public returns (bool success){ require(!paused); success = true; } function approve(address, uint256) public returns (bool success){ require(!paused); success = true; } function allowance(address, address) public view returns (uint256 remaining){ require(!paused); remaining = 0; } function grant(address _to, uint256 _value, uint256 _duration, uint256 _periods) public returns (bool success){ require(msg.sender != _to); require(_balancesMap[msg.sender].tokens >= _value); require(_balancesMap[_to].unlockLastTime == 0); _balancesMap[msg.sender].tokens = _balancesMap[msg.sender].tokens.sub(_value); if(_balancesMap[_to].index == 0){ UserToken memory user; user.index = _balancesArray.length; user.addr = _to; user.tokens = 0; user.unlockUnit = _value.div(_periods); // user.unlockPeriod = _duration.mul(30).mul(1 days).div(_periods); user.unlockPeriod = _duration.mul(1 days).div(_periods); //for test user.unlockLeft = _value; user.unlockLastTime = now; _balancesMap[_to] = user; _balancesArray.push(_to); } else{ _balancesMap[_to].unlockUnit = _value.div(_periods); // _balancesMap[_to].unlockPeriod = _duration.mul(30).mul(1 days).div(_periods); _balancesMap[_to].unlockPeriod = _duration.mul(1 days).div(_periods); //for test _balancesMap[_to].unlockLeft = _value; _balancesMap[_to].unlockLastTime = now; } emit Grant(msg.sender, _to, _value); log(actionGrant, msg.sender, _to, _value, _duration, _periods); success = true; } function getBalanceAddr(uint256 _index) public view returns(address addr){ require(_index < _balancesArray.length); require(_index >= 0); addr = _balancesArray[_index]; } function getBalanceSize() public view returns(uint256 size){ size = _balancesArray.length; } function getLockInfo(address addr) public view returns (uint256 unlocked, uint256 unit, uint256 period, uint256 last) { UserToken storage user = _balancesMap[addr]; unlocked = user.unlockLeft; unit = user.unlockUnit; period = user.unlockPeriod; last = user.unlockLastTime; } function log(uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3) private { LogEntry memory entry; entry.action = action; entry.time = now; entry.from = from; entry.to = to; entry.v1 = _v1; entry.v2 = _v2; entry.v3 = _v3; _logs.push(entry); } function getLogSize() public view returns(uint256 size){ size = _logs.length; } function getLog(uint256 _index) public view returns(uint time, uint32 action, address from, address to, uint256 _v1, uint256 _v2, uint256 _v3){ require(_index < _logs.length); require(_index >= 0); LogEntry storage entry = _logs[_index]; action = entry.action; time = entry.time; from = entry.from; to = entry.to; _v1 = entry.v1; _v2 = entry.v2; _v3 = entry.v3; } } "}
{"sol name": "1662.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event PausePublic(bool newState); event PauseOwnerAdmin(bool newState); bool public pausedPublic = false; bool public pausedOwnerAdmin = false; address public admin; /** * @dev Modifier to make a function callable based on pause states. */ modifier whenNotPaused() { if(pausedPublic) { if(!pausedOwnerAdmin) { require(msg.sender == admin || msg.sender == owner); } else { revert(); } } _; } /** * @dev called by the owner to set new pause flags * pausedPublic can't be false while pausedOwnerAdmin is true */ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract PUCOINToken is PausableToken { string  public  constant name = \"PUCOIN\"; string  public  constant symbol = \"PUB\"; uint8   public  constant decimals = 18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; } function PUCOINToken( address _admin, uint _totalTokenAmount ) { // assign the admin account admin = _admin; // assign the total tokens to PUCOIN totalSupply = _totalTokenAmount; balances[msg.sender] = _totalTokenAmount; Transfer(address(0x0), msg.sender, _totalTokenAmount); } function transfer(address _to, uint _value) validDestination(_to) returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) { return super.transferFrom(_from, _to, _value); } event Burn(address indexed _burner, uint _value); function burn(uint _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); Burn(msg.sender, _value); Transfer(msg.sender, address(0x0), _value); return true; } // save some gas by making only one contract call function burnFrom(address _from, uint256 _value) returns (bool) { assert( transferFrom( _from, msg.sender, _value ) ); return burn(_value); } function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner { // owner can drain tokens that are sent here by mistake token.transfer( owner, amount ); } event AdminTransferred(address indexed previousAdmin, address indexed newAdmin); function changeAdmin(address newAdmin) onlyOwner { // owner can re-assign the admin AdminTransferred(admin, newAdmin); admin = newAdmin; } } "}
{"sol name": "675.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; modifier onlyPayloadSize(uint256 numwords) { assert(msg.data.length >= numwords * 32 + 4); _; } /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * @dev Implementation of the basic standard token. */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) onlyPayloadSize(2) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title Claimable * @dev Extension for the Ownable contract, where the ownership needs to be claimed. * This allows the new owner to accept the transfer. */ contract Claimable is Ownable { address public pendingOwner; /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation */ contract MintableToken is PausableToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } address public saleAgent = address(0); address public saleAgent2 = address(0); function setSaleAgent(address newSaleAgent) onlyOwner public { saleAgent = newSaleAgent; } function setSaleAgent2(address newSaleAgent) onlyOwner public { saleAgent2 = newSaleAgent; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) canMint public returns (bool) { require(msg.sender == saleAgent || msg.sender == saleAgent2 || msg.sender == owner); totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(this), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract LEAD is MintableToken, Claimable { string public constant name = \"LEADEX\"; string public constant symbol = \"LEAD\"; uint public constant decimals = 8; } "}
{"sol name": "357.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* * @title String & slice utility library for Solidity contracts. * @author Nick Johnson <[email\u00a0protected]> * * @dev Functionality in this library is largely implemented using an *      abstraction called a 'slice'. A slice represents a part of a string - *      anything from the entire string to a single character, or even no *      characters at all (a 0-length slice). Since a slice only has to specify *      an offset and a length, copying and manipulating slices is a lot less *      expensive than copying and manipulating the strings they reference. * *      To further reduce gas costs, most functions on slice that need to return *      a slice modify the original one instead of allocating a new one; for *      instance, `s.split(\".\")` will return the text up to the first '.', *      modifying s to only contain the remainder of the string after the '.'. *      In situations where you do not want to modify the original slice, you *      can make a copy first with `.copy()`, for example: *      `s.copy().split(\".\")`. Try and avoid using this idiom in loops; since *      Solidity has no memory management, it will result in allocating many *      short-lived slices that are later discarded. * *      Functions that return two slices come in two versions: a non-allocating *      version that takes the second slice as an argument, modifying it in *      place, and an allocating version that allocates and returns the second *      slice; see `nextRune` for example. * *      Functions that have to copy string data will return strings rather than *      slices; these can be cast back to slices for further processing if *      required. * *      For convenience, some functions are provided with non-modifying *      variants that create a new slice and return both; for instance, *      `s.splitNew('.')` leaves s unmodified, and returns two values *      corresponding to the left and right parts of the string. */ library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private pure { // Copy word-length chunks while possible for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } // Copy remaining bytes uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } /* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ function toSlice(string memory self) internal pure returns (slice memory) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } /* * @dev Returns the length of a null-terminated bytes32 string. * @param self The value to find the length of. * @return The length of the string, from 0 to 32. */ function len(bytes32 self) internal pure returns (uint) { uint ret; if (self == 0) return 0; if (self & 0xffffffffffffffffffffffffffffffff == 0) { ret += 16; self = bytes32(uint(self) / 0x100000000000000000000000000000000); } if (self & 0xffffffffffffffff == 0) { ret += 8; self = bytes32(uint(self) / 0x10000000000000000); } if (self & 0xffffffff == 0) { ret += 4; self = bytes32(uint(self) / 0x100000000); } if (self & 0xffff == 0) { ret += 2; self = bytes32(uint(self) / 0x10000); } if (self & 0xff == 0) { ret += 1; } return 32 - ret; } /* * @dev Returns a slice containing the entire bytes32, interpreted as a *      null-terminated utf-8 string. * @param self The bytes32 value to convert to a slice. * @return A new slice containing the value of the input argument up to the *         first null. */ function toSliceB32(bytes32 self) internal pure returns (slice memory ret) { // Allocate space for `self` in memory, copy it there, and point ret at it assembly { let ptr := mload(0x40) mstore(0x40, add(ptr, 0x20)) mstore(ptr, self) mstore(add(ret, 0x20), ptr) } ret._len = len(self); } /* * @dev Returns a new slice containing the same data as the current slice. * @param self The slice to copy. * @return A new slice containing the same data as `self`. */ function copy(slice memory self) internal pure returns (slice memory) { return slice(self._len, self._ptr); } /* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ function toString(slice memory self) internal pure returns (string memory) { string memory ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } /* * @dev Returns the length in runes of the slice. Note that this operation *      takes time proportional to the length of the slice; avoid using it *      in loops, and call `slice.empty()` if you only need to know whether *      the slice is empty or not. * @param self The slice to operate on. * @return The length of the slice in runes. */ function len(slice memory self) internal pure returns (uint l) { // Starting at ptr-31 means the LSB will be the byte we care about uint ptr = self._ptr - 31; uint end = ptr + self._len; for (l = 0; ptr < end; l++) { uint8 b; assembly { b := and(mload(ptr), 0xFF) } if (b < 0x80) { ptr += 1; } else if(b < 0xE0) { ptr += 2; } else if(b < 0xF0) { ptr += 3; } else if(b < 0xF8) { ptr += 4; } else if(b < 0xFC) { ptr += 5; } else { ptr += 6; } } } /* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ function empty(slice memory self) internal pure returns (bool) { return self._len == 0; } /* * @dev Returns a positive number if `other` comes lexicographically after *      `self`, a negative number if it comes before, or zero if the *      contents of the two slices are equal. Comparison is done per-rune, *      on unicode codepoints. * @param self The first slice to compare. * @param other The second slice to compare. * @return The result of the comparison. */ function compare(slice memory self, slice memory other) internal pure returns (int) { uint shortest = self._len; if (other._len < self._len) shortest = other._len; uint selfptr = self._ptr; uint otherptr = other._ptr; for (uint idx = 0; idx < shortest; idx += 32) { uint a; uint b; assembly { a := mload(selfptr) b := mload(otherptr) } if (a != b) { // Mask out irrelevant bytes and check again uint256 mask = uint256(-1); // 0xffff... if(shortest < 32) { mask = ~(2 ** (8 * (32 - shortest + idx)) - 1); } uint256 diff = (a & mask) - (b & mask); if (diff != 0) return int(diff); } selfptr += 32; otherptr += 32; } return int(self._len) - int(other._len); } /* * @dev Returns true if the two slices contain the same text. * @param self The first slice to compare. * @param self The second slice to compare. * @return True if the slices are equal, false otherwise. */ function equals(slice memory self, slice memory other) internal pure returns (bool) { return compare(self, other) == 0; } /* * @dev Extracts the first rune in the slice into `rune`, advancing the *      slice to point to the next rune and returning `self`. * @param self The slice to operate on. * @param rune The slice that will contain the first rune. * @return `rune`. */ function nextRune(slice memory self, slice memory rune) internal pure returns (slice memory) { rune._ptr = self._ptr; if (self._len == 0) { rune._len = 0; return rune; } uint l; uint b; // Load the first byte of the rune into the LSBs of b assembly { b := and(mload(sub(mload(add(self, 32)), 31)), 0xFF) } if (b < 0x80) { l = 1; } else if(b < 0xE0) { l = 2; } else if(b < 0xF0) { l = 3; } else { l = 4; } // Check for truncated codepoints if (l > self._len) { rune._len = self._len; self._ptr += self._len; self._len = 0; return rune; } self._ptr += l; self._len -= l; rune._len = l; return rune; } /* * @dev Returns the first rune in the slice, advancing the slice to point *      to the next rune. * @param self The slice to operate on. * @return A slice containing only the first rune from `self`. */ function nextRune(slice memory self) internal pure returns (slice memory ret) { nextRune(self, ret); } /* * @dev Returns the number of the first codepoint in the slice. * @param self The slice to operate on. * @return The number of the first codepoint in the slice. */ function ord(slice memory self) internal pure returns (uint ret) { if (self._len == 0) { return 0; } uint word; uint length; uint divisor = 2 ** 248; // Load the rune into the MSBs of b assembly { word:= mload(mload(add(self, 32))) } uint b = word / divisor; if (b < 0x80) { ret = b; length = 1; } else if(b < 0xE0) { ret = b & 0x1F; length = 2; } else if(b < 0xF0) { ret = b & 0x0F; length = 3; } else { ret = b & 0x07; length = 4; } // Check for truncated codepoints if (length > self._len) { return 0; } for (uint i = 1; i < length; i++) { divisor = divisor / 256; b = (word / divisor) & 0xFF; if (b & 0xC0 != 0x80) { // Invalid UTF-8 sequence return 0; } ret = (ret * 64) | (b & 0x3F); } return ret; } /* * @dev Returns the keccak-256 hash of the slice. * @param self The slice to hash. * @return The hash of the slice. */ function keccak(slice memory self) internal pure returns (bytes32 ret) { assembly { ret := keccak256(mload(add(self, 32)), mload(self)) } } /* * @dev Returns true if `self` starts with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function startsWith(slice memory self, slice memory needle) internal pure returns (bool) { if (self._len < needle._len) { return false; } if (self._ptr == needle._ptr) { return true; } bool equal; assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } return equal; } /* * @dev If `self` starts with `needle`, `needle` is removed from the *      beginning of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function beyond(slice memory self, slice memory needle) internal pure returns (slice memory) { if (self._len < needle._len) { return self; } bool equal = true; if (self._ptr != needle._ptr) { assembly { let length := mload(needle) let selfptr := mload(add(self, 0x20)) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } } if (equal) { self._len -= needle._len; self._ptr += needle._len; } return self; } /* * @dev Returns true if the slice ends with `needle`. * @param self The slice to operate on. * @param needle The slice to search for. * @return True if the slice starts with the provided text, false otherwise. */ function endsWith(slice memory self, slice memory needle) internal pure returns (bool) { if (self._len < needle._len) { return false; } uint selfptr = self._ptr + self._len - needle._len; if (selfptr == needle._ptr) { return true; } bool equal; assembly { let length := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } return equal; } /* * @dev If `self` ends with `needle`, `needle` is removed from the *      end of `self`. Otherwise, `self` is unmodified. * @param self The slice to operate on. * @param needle The slice to search for. * @return `self` */ function until(slice memory self, slice memory needle) internal pure returns (slice memory) { if (self._len < needle._len) { return self; } uint selfptr = self._ptr + self._len - needle._len; bool equal = true; if (selfptr != needle._ptr) { assembly { let length := mload(needle) let needleptr := mload(add(needle, 0x20)) equal := eq(keccak256(selfptr, length), keccak256(needleptr, length)) } } if (equal) { self._len -= needle._len; } return self; } // Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } // Returns the memory address of the first byte after the last occurrence of // `needle` in `self`, or the address of `self` if not found. function rfindPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } ptr = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr <= selfptr) return selfptr; ptr--; assembly { ptrdata := and(mload(ptr), mask) } } return ptr + needlelen; } else { // For long needles, use hashing bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } ptr = selfptr + (selflen - needlelen); while (ptr >= selfptr) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr + needlelen; ptr -= 1; } } } return selfptr; } /* * @dev Modifies `self` to contain everything from the first occurrence of *      `needle` to the end of the slice. `self` is set to the empty slice *      if `needle` is not found. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function find(slice memory self, slice memory needle) internal pure returns (slice memory) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); self._len -= ptr - self._ptr; self._ptr = ptr; return self; } /* * @dev Modifies `self` to contain the part of the string from the start of *      `self` to the end of the first occurrence of `needle`. If `needle` *      is not found, `self` is set to the empty slice. * @param self The slice to search and modify. * @param needle The text to search for. * @return `self`. */ function rfind(slice memory self, slice memory needle) internal pure returns (slice memory) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); self._len = ptr - self._ptr; return self; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ function split(slice memory self, slice memory needle) internal pure returns (slice memory token) { split(self, needle, token); } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and `token` to everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function rsplit(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) { uint ptr = rfindPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = ptr; token._len = self._len - (ptr - self._ptr); if (ptr == self._ptr) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything before the last *      occurrence of `needle`, and returning everything after it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` after the last occurrence of `delim`. */ function rsplit(slice memory self, slice memory needle) internal pure returns (slice memory token) { rsplit(self, needle, token); } /* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ function count(slice memory self, slice memory needle) internal pure returns (uint cnt) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { cnt++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } /* * @dev Returns True if `self` contains `needle`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return True if `needle` is found in `self`, false otherwise. */ function contains(slice memory self, slice memory needle) internal pure returns (bool) { return rfindPtr(self._len, self._ptr, needle._len, needle._ptr) != self._ptr; } /* * @dev Returns a newly allocated string containing the concatenation of *      `self` and `other`. * @param self The first slice to concatenate. * @param other The second slice to concatenate. * @return The concatenation of the two strings. */ function concat(slice memory self, slice memory other) internal pure returns (string memory) { string memory ret = new string(self._len + other._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); memcpy(retptr + self._len, other._ptr, other._len); return ret; } /* * @dev Joins an array of slices, using `self` as a delimiter, returning a *      newly allocated string. * @param self The delimiter to use. * @param parts A list of slices to join. * @return A newly allocated string containing all the slices in `parts`, *         joined with `self`. */ function join(slice memory self, slice[] memory parts) internal pure returns (string memory) { if (parts.length == 0) return \"\"; uint length = self._len * (parts.length - 1); for(uint i = 0; i < parts.length; i++) length += parts[i]._len; string memory ret = new string(length); uint retptr; assembly { retptr := add(ret, 32) } for(i = 0; i < parts.length; i++) { memcpy(retptr, parts[i]._ptr, parts[i]._len); retptr += parts[i]._len; if (i < parts.length - 1) { memcpy(retptr, self._ptr, self._len); retptr += self._len; } } return ret; } } contract Control { using strings for *; uint constant REWARD_BASE = 100; uint constant REWARD_TAX = 8; uint constant REWARD_GET = REWARD_BASE - REWARD_TAX; uint constant MAX_ALLBET = 2**120;//avoid bet overflow uint constant MIN_BET = 0.001 ether; bytes32 constant SHA_DEUCE = keccak256(\"DEUCE\"); address internal creator; address internal owner; uint public destroy_time; constructor(address target) public { creator = msg.sender; owner = target; // this contract's exists time is one year destroy_time = now + 365 * 24 * 60 * 60; } function kill() external payable { require(now >= destroy_time); selfdestruct(owner); } struct PlayerBet { uint bet0; //bet to deuce uint bet1; uint bet2; bool drawed; } struct MatchBet { uint betDeadline; uint allbet; uint allbet0;//allbet to deuce uint allbet1; uint allbet2; bool ownerDrawed; bytes32 SHA_WIN; bytes32 SHA_T1; bytes32 SHA_T2; mapping(address => PlayerBet) list; } MatchBet[] public MatchList; modifier onlyOwner() { require(msg.sender == creator || msg.sender == owner); _; } modifier MatchExist(uint index) { require(index < MatchList.length); _; } function AddMatch(string troop1, string troop2, uint deadline) external onlyOwner { MatchList.push(MatchBet({ betDeadline :deadline, allbet      :0, allbet0     :0, allbet1     :0, allbet2     :0, ownerDrawed :false, SHA_T1      :keccak256(bytes(troop1)), SHA_T2      :keccak256(bytes(troop2)), SHA_WIN     :bytes32(0) })); } //urgency situation function MatchResetDeadline(uint index,uint time) external onlyOwner MatchExist(index) { MatchBet storage oMatch = MatchList[index]; oMatch.betDeadline = time; } function MatchEnd(uint index,string winTroop) external onlyOwner MatchExist(index) { MatchBet storage oMatch = MatchList[index]; require(oMatch.SHA_WIN == 0); bytes32 shaWin = keccak256(bytes(winTroop)); require(shaWin == SHA_DEUCE || shaWin == oMatch.SHA_T1 || shaWin == oMatch.SHA_T2 ); oMatch.SHA_WIN = shaWin; } function Bet(uint index, string troop) external payable MatchExist(index) { //check bet require(msg.value >= MIN_BET); MatchBet storage oMatch = MatchList[index]; //check timeout or match over require(oMatch.SHA_WIN == 0 && oMatch.betDeadline >= now); uint tempAllBet = oMatch.allbet + msg.value; //check if allbet overflow require(tempAllBet > oMatch.allbet && tempAllBet <= MAX_ALLBET); PlayerBet storage oBet = oMatch.list[msg.sender]; oMatch.allbet = tempAllBet; bytes32 shaBetTroop = keccak256(bytes(troop)); if ( shaBetTroop == oMatch.SHA_T1 ) { oBet.bet1 += msg.value; oMatch.allbet1 += msg.value; } else if ( shaBetTroop == oMatch.SHA_T2 ) { oBet.bet2 += msg.value; oMatch.allbet2 += msg.value; } else { require( shaBetTroop == SHA_DEUCE ); oBet.bet0 += msg.value; oMatch.allbet0 += msg.value; } } function CalReward(MatchBet storage oMatch,PlayerBet storage oBet) internal view returns(uint) { uint myWinBet; uint allWinBet; if ( oMatch.SHA_WIN == oMatch.SHA_T1) { myWinBet = oBet.bet1; allWinBet = oMatch.allbet1; } else if ( oMatch.SHA_WIN == oMatch.SHA_T2 ) { myWinBet = oBet.bet2; allWinBet = oMatch.allbet2; } else { myWinBet = oBet.bet0; allWinBet = oMatch.allbet0; } if (myWinBet == 0) return 0; return myWinBet + (oMatch.allbet - allWinBet) * myWinBet / allWinBet * REWARD_GET / REWARD_BASE; } function Withdraw(uint index,address target) public payable MatchExist(index) { MatchBet storage oMatch = MatchList[index]; PlayerBet storage oBet = oMatch.list[target]; if (oBet.drawed) return; if (oMatch.SHA_WIN == 0) return; uint reward = CalReward(oMatch,oBet); if (reward == 0) return; oBet.drawed = true; target.transfer(reward); } function WithdrawAll(address target) external payable { for (uint i=0; i<MatchList.length; i++) { Withdraw(i,target); } } function CreatorWithdraw(uint index) internal { MatchBet storage oMatch = MatchList[index]; if (oMatch.ownerDrawed) return; if (oMatch.SHA_WIN == 0) return; oMatch.ownerDrawed = true; uint allWinBet; if ( oMatch.SHA_WIN == oMatch.SHA_T1) { allWinBet = oMatch.allbet1; } else if ( oMatch.SHA_WIN == oMatch.SHA_T2 ) { allWinBet = oMatch.allbet2; } else { allWinBet = oMatch.allbet0; } if (oMatch.allbet == allWinBet) return; if (allWinBet == 0) { //nobody win, get all bet owner.transfer(oMatch.allbet); } else { //somebody win, withdraw tax uint alltax = (oMatch.allbet - allWinBet) * REWARD_TAX / REWARD_BASE; owner.transfer(alltax); } } function CreatorWithdrawAll() external payable { for (uint i=0; i<MatchList.length; i++) { CreatorWithdraw(i); } } function GetMatchLength() external view returns(uint) { return MatchList.length; } function uint2str(uint i) internal pure returns (string){ if (i == 0) return \"0\"; uint j = i; uint len; while (j != 0){ len++; j /= 10; } bytes memory bstr = new bytes(len); while (i != 0){ bstr[--len] = byte(48 + i % 10); i /= 10; } return string(bstr); } function GetInfo(MatchBet storage obj,uint idx,address target) internal view returns(string){ PlayerBet storage oBet = obj.list[target]; string memory info = \"#\"; info = info.toSlice().concat(uint2str(idx).toSlice()); info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(uint2str(oBet.bet1).toSlice()); info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(uint2str(obj.allbet1).toSlice()); info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(uint2str(oBet.bet2).toSlice()); info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(uint2str(obj.allbet2).toSlice()); info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(uint2str(oBet.bet0).toSlice()); info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(uint2str(obj.allbet0).toSlice()); if (oBet.drawed) { info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(\"1\".toSlice()); } else { info = info.toSlice().concat(\",\".toSlice()).toSlice().concat(\"0\".toSlice()); } return info; } function GetDetail(address target) external view returns(string) { string memory res; for (uint i=0; i<MatchList.length; i++){ res = res.toSlice().concat(GetInfo(MatchList[i],i,target).toSlice()); } return res; } } "}
{"sol name": "1759.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // THX token contract // // Deployed to : 0xcc8446Bad1225717EFeF5e1015DFfc98E23274B5 // Symbol      : THX // Name        : Thrill // Total supply: 800000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Thrill is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Thrill() public { symbol = \"THX\"; name = \"Thrill\"; decimals = 18; _totalSupply = 800000000000000000000000000; balances[0xcc8446Bad1225717EFeF5e1015DFfc98E23274B5] = _totalSupply; Transfer(address(0), 0xcc8446Bad1225717EFeF5e1015DFfc98E23274B5, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "795.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract Golem { // Public variables of the token string public name = \"Golem\"; string public symbol = \"GNT\"; uint8 public decimals = 0; // 18 decimals is the strongly suggested default uint256 public totalSupply; uint256 public GolemSupply = 1000000000; uint256 public price ; address public creator; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); event FundTransfer(address backer, uint amount, bool isContribution); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function Golem() public { totalSupply = GolemSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;    // Give BicycleToken Mint the total created tokens creator = msg.sender; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x8c26348f63f9e008f0dd09a0ce1ed7caf6c1366b); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /// @notice Buy tokens from contract by sending ether function () payable internal { if (price == 0 ether){ uint ammount = 1;                  // calculates the amount, made it so you can get many BicycleMinth but to get MANY BicycleToken you have to spend ETH and not WEI uint ammountRaised; ammountRaised += msg.value;                            //many thanks Bicycle, couldnt do it without r/me_irl require(balanceOf[creator] >= 10); // checks if it has enough to sell require(msg.value < 0.5 ether); // so any person who wants to put more then 0.1 ETH has time to think about what they are doing require(balanceOf[msg.sender] == 0);     // one users doesn't collect more than once balanceOf[msg.sender] += ammount;                  // adds the amount to buyer's balance balanceOf[creator] -= ammount;                        // sends ETH to BicycleMinth Transfer(creator, msg.sender, ammount);               // execute an event reflecting the change creator.transfer(ammountRaised); } } } "}
{"sol name": "556.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; contract batchTransfer { address[] public myAddresses = [ 0x8880fb5256BDEEF0DCA5eB80bD0b2d9D215F6e01, 0xFC860367fc940717B06f2cA8132B7251BF09d877, 0x6dd07aF02a1dD0557C1f597C3cF91223aDdcB1a8, 0x4E720E71eF444B2913166DC1eA9aA1bA62498B9c, 0x6CA64b8110a6212f30E63365FA3C11eD2091b374, 0x153FD6721EcF7F645BD788Cb178d8183AA7707C1, 0xD3FF0A21b19B51E18E5616D3444114E8FEec1206, 0x984BC243f10d02550d97Ab5313F19421E9733121, 0x77AA5f31Db4a9FF29A9984DD983568962A9B9732, 0xe9AE915679A3c2b50859c4D22D71023C317a84c5, 0xE557f76D21749b1958dC80bEAB1d7B9Bc4bAd7a6, 0x28c9492643c9bdEAa2666cb6DDBBaB87F0FDaad6, 0xABBB154Ca02b60Bdb198AeEa1D77f64a4a49DE15, 0x24a3F658503cB358DD0fa4bA410a930fbD8cCBDE, 0x59470D1263DdA7430EBa4b35609151CF3828c7DF, 0x773DbcB1300dAfE3456c5d6924A49b54a1F25328, 0xA43064260Fc45c12f753aa12B84917369AE7BC5c, 0xBA553Abcb318b62282748f8BdB80FA3d4E0f98FE, 0x6D3F4cdd5029D4eAE820Feb321d1aF956D39179f, 0xae11020842Cc661B646148081a8D3d73431D4a1F, 0xDD78153d5e411583F45f4f70B067d9CEA74D0cE9, 0xcff7E591316235Ca1406E696eaB534edABE70959, 0xe8df77Fa2b1900984430aE22df6F665Aa8007051, 0xfA91183437719C48e2173e9392A8Eb1a2023d10e, 0xf37e6900d846ae1f7A7C991A74890d172b922c86, 0xb6E214a0EB842fde64BeE49FB4B281a4A970249D, 0x249dd61ad43277eF5684A60d714b497506BAdc04, 0xC3C4184F2d2f8086872747e5a93A144EB4C37aB9, 0x8c909BB671Dc318B23EB5c8c0d295A29Bc8513ac, 0x73B3aC387B3A3B498C8AEe7eD34bBe67526Cfb14, 0xFD20c55f31b23275E16D95A0D1194b85F8b07f14, 0x2700960504d9f19691765453C7ca1E595FD8dDDC, 0xc35A4Bf03bB3735a5A481BBbe45f9AD655b0Fb0d, 0xC25BC30Fe18b25cE14FB928011CFB4a7a6C04BDa, 0xa20D891411F2a7115bfaaF8CAb3B8826A5aC91FE, 0xf1e00aEAE28173abA71FF896eCA5129F5A5D030a, 0x1a14d92A9fB343C28b55a6bb2bdE4932781B8043, 0x2369DFa2f3B017ED0BD0670F097246dCf3218Ff1, 0xf15FB6E2404B099798ace9AE75BED5113c4550bB, 0x0453dE881b79d2CF7aaBEf6DB43aAF56756E8B2a, 0xa7F04CdEcD668AC0E69C22f7104D1aBA3FFeCE93, 0x93b0C19f6cd40f0321Eb012e1378AB77e0F3A425, 0xf13A66F7E1F52eDEfD02d48fC896611f13147905, 0x9A0f65B1A02DC693CCEF873575e7235cB2e873F4, 0x8F9c9F29754A5bAbf9D37361565532f3063E825d, 0x53581aFC8fb8DdeE3881bB1062777BAEbAEb16B4, 0xdf4Ed25fff3b8A66e33475e8d595586d95F4cBa7, 0x28CF3eC0bD5de9e593676F7bEd9910D4a2a143d2, 0xFF60eDa05681f75B7e2341af65dd4b1853162070, 0x5b56EE1504363fde2e61D0fb53c2C22B63f89d36, 0x177b74a4035b356c4EeE2a2a1CD3b999Abe0d659, 0x43c9B31dB639B3455fF969BAcf4b852901c9E1bf, 0x3B9183Ed5C14460A0131174a74c4836Cd27c457A, 0x178bF5b639D0B6c8F096035df534600996C6126E, 0x925938C0fD05779c187C1993a4DBdf0484b22431, 0x1B4A27aD020403895Ef0851E406E8e1d49485ed4, 0x52090aD4e3a82D87FB145C91551CFc9637be38Bc, 0xF98F2212fa6B44E5425205946082D190E938B91d, 0x8D914F2451ab522eE03A2f8829E079E67601cC3A, 0xCF57AC96EAEc6aF79247deB2565C5c97d9E7372e, 0xc77d4D5A73F4f4D369e59DCCbEe96b7FC7c4fAaB, 0xa2a3268bbA862F7d132702151B9B9853A0D7BC9d, 0xAF89052a8096D5faCF32460728F1b5501f0ABaa0, 0xcCfcCfAFb8bAEF2528B66e9091eF5726128D26e9, 0x6b01F18FBbD42b328B6fd0D9514eE42bEbe6c3d0, 0x48579aB5F0632D021AcF17161cA374d59179C163, 0x52657a269372ba612a1536470E29B20F2AAE41D7, 0x014EB6201c6d10E3783e66734EbD85fe5Ca2305E, 0xd1f2dB8b6D64B3a1984D09B2a8bF9b79F5C10abf, 0x0e1BA829f72923fCea16Eacb28246385D4cd019e, 0xBf80ABd9259E96CFA653ABfb12cD7E2E850119B9, 0xc3cAf15BC2455037Aa179CD776a3A2F48f2bc61A, 0x90Da65b78872376023276F672b8911a23143c4a6, 0xf7Ec32745F87f7d0D28da577c5AF866C8aD7Bd8c, 0x0786B72093ff3f3298542013D3cf4ADB3237A8fd, 0x66aa2249D0B7eBA4636758EBfaD20bcf9d1072Bd, 0x1C0845De4a9603b05d3D896635449590CF669187, 0x874257e5d2B99B0D73b22566Ff8a2aE4D6d64824, 0xAA056fF43114F9b15e892AF5513c42018369AB0c, 0x80141E961B54Bd434d5aBa9033a99a7FB8f472Ac, 0xB3ed31487b0236dF489070108c42543ce04deaAB, 0x4666fD5e251abC1FCf86c87384b7395c78fF907D, 0x4eb20C872222ECA2112652d1625099d377071AA6, 0xB59174C98176F3F74ea9Cd4A4c7fd560b461D4B9, 0x10B9E2f091b479E0e1D5223a80C2E9022F02c13d, 0x6900568f97F76BfB0Aa3458EF93a006e4255C9B0, 0x0F1B26C94aF060a8c671AaD030b35503F97A13D4, 0xe2dD99850247Ad4B51A5369491643DAaA92B16b9, 0x34e8C1a0a5D7104fcC59e964CFDc283587f38fdE, 0xc29f90cadD5B78F844B156bcE0F5F6cCD3644ca0, 0xC63b515f08AC8409b60286bE6652cC846390b079, 0x2789284AF52e22dcDF0F92D37B66a526B9dac9eb, 0x3A894CdAC78a4C3b9C1AE00e8aC29CD9E8458eFC, 0xe0Ee2477d2dB2ae9509890c1dcD521b8b19f0C1C, 0xD432145a097c4521DC3C9C775F53A744B848f269, 0x8ed39212d1852ba5131f5442Ca03b5339FB00a4c, 0x6C74C75f1Bc792e2db7923be5b1fBEC38C446C5A, 0x8E10B0b7dBa8975550609f2321B987c4aBAaCC06, 0xd67F66e4b395883614CE4d5e405fB7C9A3e74Af0, 0xC68bdAA53AB68c3DC1D1515Ba4D2E88BB2efA6E1, 0xd6a9897903dF0d4eC2dF039A6206fc6629aFB664 ]; function () public payable { require(myAddresses.length>0); uint256 distr = msg.value/myAddresses.length; for(uint256 i=0;i<myAddresses.length;i++) { myAddresses[i].transfer(distr); } } } "}
{"sol name": "1964.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> /// modified by Juwita Winadwiastuti - <juwita.winadwiastuti[at]hara.ag> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint value; bool executed; } /* *  Modifiers */ modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } /// @dev Fallback function allows to deposit ether. function() public payable { if (msg.value > 0) emit Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. constructor() public { owners = [msg.sender]; isOwner[msg.sender] = true; required = 1; } /// @dev Allows to add a new owner. Transaction has to be sent by owner. /// @param owner Address of new owner. function addOwner(address owner) public ownerExists(msg.sender) ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) { isOwner[owner] = true; owners.push(owner); emit OwnerAddition(owner); uint halfOwner = uint(owners.length)/2; changeRequirement(halfOwner + 1); } /// @dev Allows to remove an owner. Transaction has to be sent by owner. /// @param owner Address of owner. function removeOwner(address owner) public ownerExists(owner) ownerExists(msg.sender) { isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; uint halfOwner = uint(owners.length)/2; changeRequirement(halfOwner + 1); emit OwnerRemoval(owner); } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by owner. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public ownerExists(msg.sender) ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; emit OwnerRemoval(owner); emit OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by owner. /// @param _required Number of required confirmations. function changeRequirement(uint _required) private ownerExists(msg.sender) validRequirement(owners.length, _required) { required = _required; emit RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a withdraw transaction. /// @param destination Withdraw destination address. /// @param value Number of ether to withdraw. /// @return Returns transaction ID. function submitWithdrawTransaction(address destination, uint value) public ownerExists(msg.sender) returns (uint transactionId) { transactionId = addTransaction(destination, value); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; emit Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (withdraw(txn.destination, txn.value)) emit Execution(transactionId); else { emit ExecutionFailure(transactionId); txn.executed = false; } } } /// @dev FUnction to send ether to address. /// @param destination Address destination to send ether. /// @param value Amount of ether to send. /// @return Confirmation status. function withdraw(address destination, uint value) ownerExists(msg.sender) private returns (bool) { destination.transfer(value); return true; } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction ether value. /// @return Returns transaction ID. function addTransaction(address destination, uint value) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, value: value, executed: false }); transactionCount += 1; emit Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } /// @dev Returns list of transaction IDs in defined range. /// @param from Index start position of transaction array. /// @param to Index end position of transaction array. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Returns array of transaction IDs. function getTransactionIds(uint from, uint to, bool pending, bool executed) public constant returns (uint[] _transactionIds) { uint[] memory transactionIdsTemp = new uint[](transactionCount); uint count = 0; uint i; for (i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) { transactionIdsTemp[count] = i; count += 1; } _transactionIds = new uint[](to - from); for (i=from; i<to; i++) _transactionIds[i - from] = transactionIdsTemp[i]; } } "}
{"sol name": "595.sol", "label": 0, "sol content": "library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract TDCToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"TDC\"; name = \"TRUSTDEX TOKEN\"; decimals = 0; _totalSupply = 150000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1745.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract Whitelist is Ownable { mapping(address => uint256) public whitelist; event Whitelisted(address indexed who); uint256 public nextUserId = 1; function addAddress(address who) external onlyOwner { require(who != address(0)); require(whitelist[who] == 0); whitelist[who] = nextUserId; nextUserId++; emit Whitelisted(who); // solhint-disable-line } function addAddresses(address[] addresses) external onlyOwner { require(addresses.length <= 100); address who; uint256 userId = nextUserId; for (uint256 i = 0; i < addresses.length; i++) { who = addresses[i]; require(whitelist[who] == 0); whitelist[who] = userId; userId++; emit Whitelisted(who); // solhint-disable-line } nextUserId = userId; } } "}
{"sol name": "1634.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract LuckGameToken is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; } modifier onlyOwner { require(msg.sender == owner); _; } modifier isLock { require(!lock); _; } function setLock(bool _lock) onlyOwner public{ lock = _lock; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function _transfer(address _from, address _to, uint _value) isLock internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } function mintToken(address target, uint256 mintedAmount) onlyOwner public { uint256 _amount = mintedAmount * 10 ** uint256(decimals); balanceOf[target] += _amount; totalSupply += _amount; emit Transfer(this, target, _amount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transferBatch(address[] _to, uint256 _value) public returns (bool success) { for (uint i=0; i<_to.length; i++) { _transfer(msg.sender, _to[i], _value); } return true; } } "}
{"sol name": "674.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT256005' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT256005 // Name        : ADZbuzz Allaboutbirds.org Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT256005\"; name = \"ADZbuzz Allaboutbirds.org Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1830.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event PausePublic(bool newState); event PauseOwnerAdmin(bool newState); bool public pausedPublic = true; bool public pausedOwnerAdmin = false; address public admin; /** * @dev Modifier to make a function callable based on pause states. */ modifier whenNotPaused() { if (pausedPublic) { if (!pausedOwnerAdmin) { require(msg.sender == admin || msg.sender == owner); } else { revert(); } } _; } /** * @dev called by the owner to set new pause flags * pausedPublic can't be false while pausedOwnerAdmin is true */ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; emit PausePublic(newPausedPublic); emit PauseOwnerAdmin(newPausedOwnerAdmin); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract NiuNiuTestToken is PausableToken { // ERC20 variables string public name = \"NiuNiuTestToken\"; string public symbol = \"NNTT\"; uint32 public decimals = 18; uint32 public batchLimit = 1000; // constants address owner = 0x0; uint256 public constant INITIAL_SUPPLY = 10000000000; constructor() public { owner = msg.sender; admin = owner; totalSupply = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply; } // batch send coins function batchTransfer(address[] _tos, uint256[] _values) public whenNotPaused returns (bool success) { require(_tos.length > 0); require(_values.length > 0); require(_tos.length == _values.length); require(_tos.length <= batchLimit); bool isAllSuccess = false; for (uint256 i = 0;i < _tos.length;i++) { isAllSuccess = super.transfer(_tos[i], _values[i]); require(isAllSuccess); } return isAllSuccess; } function setBatchLimit(uint32 _batchLimit) public onlyOwner { batchLimit = _batchLimit; } } "}
{"sol name": "835.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */ interface ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ ///bytes4 internal constant ERC721_RECEIVED = 0x150b7a02; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient * after a `safetransfer`. This function MAY throw to revert and reject the * transfer. Return of other than the magic value MUST result in the * transaction being reverted. * Note: the contract address is always the message sender. * @param _operator The address which called `safeTransferFrom` function * @param _from The address which previously owned the token * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))` */ function onERC721Received( address _operator, address _from, uint _tokenId, bytes _data ) public returns(bytes4); } /** * @title ERC165 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md */ interface ERC165 { /** * @notice Query if a contract implements an interface * @param _interfaceId The interface identifier, as specified in ERC-165 * @dev Interface identification is specified in ERC-165. This function * uses less than 30,000 gas. */ function supportsInterface(bytes4 _interfaceId) external view returns (bool); } /** * @title SupportsInterfaceWithLookup * @author Matt Condon (@shrugs) * @dev Implements ERC165 using a lookup table. */ contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; /** * 0x01ffc9a7 === *   bytes4(keccak256('supportsInterface(bytes4)')) */ /** * @dev a mapping of interface id to whether or not it's supported */ mapping(bytes4 => bool) internal supportedInterfaces; /** * @dev A contract implementing SupportsInterfaceWithLookup * implement ERC165 itself */ constructor() public { _registerInterface(InterfaceId_ERC165); } /** * @dev implement supportsInterface(bytes4) using a lookup table */ function supportsInterface(bytes4 _interfaceId) external view returns (bool) { return supportedInterfaces[_interfaceId]; } /** * @dev private method for registering an interface */ function _registerInterface(bytes4 _interfaceId) internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } } contract MyCryptoChampCore{ struct Champ { uint id; uint attackPower; uint defencePower; uint cooldownTime; uint readyTime; uint winCount; uint lossCount; uint position; uint price; uint withdrawCooldown; uint eq_sword; uint eq_shield; uint eq_helmet; bool forSale; } struct AddressInfo { uint withdrawal; uint champsCount; uint itemsCount; string name; } struct Item { uint id; uint8 itemType; uint8 itemRarity; uint attackPower; uint defencePower; uint cooldownReduction; uint price; uint onChampId; bool onChamp; bool forSale; } Champ[] public champs; Item[] public items; mapping (uint => uint) public leaderboard; mapping (address => AddressInfo) public addressInfo; mapping (bool => mapping(address => mapping (address => bool))) public tokenOperatorApprovals; mapping (bool => mapping(uint => address)) public tokenApprovals; mapping (bool => mapping(uint => address)) public tokenToOwner; mapping (uint => string) public champToName; mapping (bool => uint) public tokensForSaleCount; uint public pendingWithdrawal = 0; function addWithdrawal(address _address, uint _amount) public; function clearTokenApproval(address _from, uint _tokenId, bool _isTokenChamp) public; function setChampsName(uint _champId, string _name) public; function setLeaderboard(uint _x, uint _value) public; function setTokenApproval(uint _id, address _to, bool _isTokenChamp) public; function setTokenOperatorApprovals(address _from, address _to, bool _approved, bool _isTokenChamp) public; function setTokenToOwner(uint _id, address _owner, bool _isTokenChamp) public; function setTokensForSaleCount(uint _value, bool _isTokenChamp) public; function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) public; function newChamp(uint _attackPower,uint _defencePower,uint _cooldownTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale,address _owner) public returns (uint); function newItem(uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale,address _owner) public returns (uint); function updateAddressInfo(address _address, uint _withdrawal, bool _updatePendingWithdrawal, uint _champsCount, bool _updateChampsCount, uint _itemsCount, bool _updateItemsCount, string _name, bool _updateName) public; function updateChamp(uint _champId, uint _attackPower,uint _defencePower,uint _cooldownTime,uint _readyTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _withdrawCooldown,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale) public; function updateItem(uint _id,uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale) public; function getChampStats(uint256 _champId) public view returns(uint256,uint256,uint256); function getChampsByOwner(address _owner) external view returns(uint256[]); function getTokensForSale(bool _isTokenChamp) view external returns(uint256[]); function getItemsByOwner(address _owner) external view returns(uint256[]); function getTokenCount(bool _isTokenChamp) external view returns(uint); function getTokenURIs(uint _tokenId, bool _isTokenChamp) public view returns(string); function onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp) external view returns(bool); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address internal contractOwner; constructor () internal { if(contractOwner == address(0)){ contractOwner = msg.sender; } } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == contractOwner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); contractOwner = newOwner; } } /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, * as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(addr) } return size > 0; } } contract ERC721 is Ownable, SupportsInterfaceWithLookup { using AddressUtils for address; string private _ERC721name = \"Item\"; string private _ERC721symbol = \"MXI\"; bool private tokenIsChamp = false; address private controllerAddress; MyCryptoChampCore core; function setCore(address newCoreAddress) public onlyOwner { core = MyCryptoChampCore(newCoreAddress); } function setController(address _address) external onlyOwner { controllerAddress = _address; } function emitTransfer(address _from, address _to, uint _tokenId) external { require(msg.sender == controllerAddress); emit Transfer(_from, _to, _tokenId); } //ERC721 START event Transfer(address indexed _from, address indexed _to, uint indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd; /** * 0x80ac58cd === *   bytes4(keccak256('balanceOf(address)')) ^ *   bytes4(keccak256('ownerOf(uint256)')) ^ *   bytes4(keccak256('approve(address,uint256)')) ^ *   bytes4(keccak256('getApproved(uint256)')) ^ *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^ *   bytes4(keccak256('isApprovedForAll(address,address)')) ^ *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) */ bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79; /** * 0x4f558e79 === *   bytes4(keccak256('exists(uint256)')) */ /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 private constant ERC721_RECEIVED = 0x150b7a02; bytes4 constant InterfaceId_ERC721Enumerable = 0x780e9d63; /** bytes4(keccak256('totalSupply()')) ^ bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^ bytes4(keccak256('tokenByIndex(uint256)')); */ bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; /** * 0x5b5e139f === *   bytes4(keccak256('name()')) ^ *   bytes4(keccak256('symbol()')) ^ *   bytes4(keccak256('tokenURI(uint256)')) */ constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721); _registerInterface(InterfaceId_ERC721Exists); _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); } /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint ID of the token to validate */ modifier canTransfer(uint _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint) { require(_owner != address(0)); uint balance; if(tokenIsChamp){ (,balance,,) = core.addressInfo(_owner); }else{ (,,balance,) = core.addressInfo(_owner); } return balance; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint _tokenId) public view returns (address) { address owner = core.tokenToOwner(tokenIsChamp,_tokenId); require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint ID of the token to query the existence of * @return whether the token exists */ function exists(uint _tokenId) public view returns (bool) { address owner = core.tokenToOwner(tokenIsChamp,_tokenId); return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * The zero address indicates there is no approved address. * There can only be one approved address per token at a given time. * Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint ID of the token to be approved */ function approve(address _to, uint _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); core.setTokenApproval(_tokenId, _to,tokenIsChamp); emit Approval(owner, _to, _tokenId); } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint _tokenId) public view returns (address) { return core.tokenApprovals(tokenIsChamp,_tokenId); } /** * @dev Sets or unsets the approval of a given operator * An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); core.setTokenOperatorApprovals(msg.sender,_to,_approved,tokenIsChamp); emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll( address _owner, address _operator ) public view returns (bool) { return core.tokenOperatorApprovals(tokenIsChamp, _owner,_operator); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Transfers the ownership of a given token ID to another address * Usage of this method is discouraged, use `safeTransferFrom` whenever possible * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint ID of the token to be transferred */ function transferFrom( address _from, address _to, uint _tokenId ) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); core.clearTokenApproval(_from, _tokenId, tokenIsChamp); core.transferToken(_from, _to, _tokenId, tokenIsChamp); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`; otherwise, * the transfer is reverted. * * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint ID of the token to be transferred */ function safeTransferFrom( address _from, address _to, uint _tokenId ) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`; otherwise, * the transfer is reverted. * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom( address _from, address _to, uint _tokenId, bytes _data ) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( msg.sender, _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } /// /// ERC721Enumerable /// /// @notice Count NFTs tracked by this contract /// @return A count of valid NFTs tracked by this contract, where each one of ///  them has an assigned and queryable owner not equal to the zero address function totalSupply() external view returns (uint){ return core.getTokenCount(tokenIsChamp); } /// @notice Enumerate valid NFTs /// @dev Throws if `_index` >= `totalSupply()`. /// @param _index A counter less than `totalSupply()` /// @return The token identifier for the `_index`th NFT, ///  (sort order not specified) function tokenByIndex(uint _index) external view returns (uint){ uint tokenIndexesLength = this.totalSupply(); require(_index < tokenIndexesLength); return _index; } /// @notice Enumerate NFTs assigned to an owner /// @dev Throws if `_index` >= `balanceOf(_owner)` or if ///  `_owner` is the zero address, representing invalid NFTs. /// @param _owner An address where we are interested in NFTs owned by them /// @param _index A counter less than `balanceOf(_owner)` /// @return The token identifier for the `_index`th NFT assigned to `_owner`, ///   (sort order not specified) function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint){ require(_index >= balanceOf(_owner)); require(_owner!=address(0)); uint[] memory tokens; uint tokenId; if(tokenIsChamp){ tokens = core.getChampsByOwner(_owner); }else{ tokens = core.getItemsByOwner(_owner); } for(uint i = 0; i < tokens.length; i++){ if(i + 1 == _index){ tokenId = tokens[i]; break; } } return tokenId; } /// /// ERC721Metadata /// /// @notice A descriptive name for a collection of NFTs in this contract function name() external view returns (string _name){ return _ERC721name; } /// @notice An abbreviated name for NFTs in this contract function symbol() external view returns (string _symbol){ return _ERC721symbol; } /// @notice A distinct Uniform Resource Identifier (URI) for a given asset. /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC ///  3986. The URI may point to a JSON file that conforms to the \"ERC721 ///  Metadata JSON Schema\". function tokenURI(uint _tokenId) external view returns (string){ require(exists(_tokenId)); return core.getTokenURIs(_tokenId,tokenIsChamp); } } "}
{"sol name": "546.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns(uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else{ uint256 z = x; for (uint256 i = 1; i < y; i++) z = mul(z,x); return (z); } } } interface shareProfit { function increaseProfit() external payable returns(bool); } contract RTB1 is shareProfit{ using SafeMath for uint256; uint8 public decimals = 0; uint256 public totalSupply = 300; uint256 public totalSold = 0; uint256 public price = 1 ether; string public name = \"Retro Block Token 1\"; string public symbol = \"RTB1\"; address public owner; address public finance; mapping (address=>uint256) received; uint256 profit; address public jackpot; mapping (address=>uint256) changeProfit; mapping (address=>uint256) balances; mapping (address=>mapping (address=>uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit); event Withdraw(address indexed _addr, uint256 _value); modifier onlyOwner() { require(msg.sender == owner, \"only owner\"); _; } modifier onlyHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } constructor() public { owner = msg.sender; finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0; jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC; balances[this] = 300; } function() public payable { if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); } } function increaseProfit() external payable returns(bool){ if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); return true; }else{ return false; } } function totalSupply() external view returns (uint256){ return totalSupply; } function balanceOf(address _owner) external view returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { require(_value > 0 && allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) external returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) external returns (bool) { return _transfer(msg.sender, _to, _value); } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0), \"Receiver address cannot be null\"); require(_value > 0 && _value <= balances[_from]); uint256 newToVal = balances[_to] + _value; assert(newToVal >= balances[_to]); uint256 newFromVal = balances[_from] - _value; balances[_from] =  newFromVal; balances[_to] = newToVal; uint256 temp = _value.mul(profit); changeProfit[_from] = changeProfit[_from].add(temp); received[_to] = received[_to].add(temp); emit Transfer(_from, _to, _value); return true; } function buy(uint256 _amount) external onlyHuman payable{ require(_amount > 0); uint256 _money = _amount.mul(price); require(msg.value == _money); require(balances[this] >= _amount); require((totalSupply - totalSold) >= _amount, \"Sold out\"); finance.transfer(_money.mul(80).div(100)); _transfer(this, msg.sender, _amount); jackpot.transfer(_money.mul(20).div(100)); totalSold += _amount; } function withdraw() external { uint256 value = getProfit(msg.sender); require(value > 0, \"No cash available\"); emit Withdraw(msg.sender, value); received[msg.sender] = received[msg.sender].add(value); msg.sender.transfer(value); } function getProfit(address _addr) public view returns(uint256){ return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]); } function setJackpot(address _addr) public onlyOwner{ jackpot = _addr; } function setFinance(address _addr) public onlyOwner{ finance = _addr; } } "}
{"sol name": "275.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract AobcToken is StandardToken { uint public totalSupply = 100*10**26; uint8 constant public decimals = 18; string constant public name = \"Aobc Token\"; string constant public symbol = \"AOT\"; function AobcToken() public { balances[msg.sender] = totalSupply; } } "}
{"sol name": "373.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title SCAVOToken * @dev ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. * Version: 1.1 */ contract SCAVOToken is StandardToken, MintableToken, PausableToken, BurnableToken { string public constant name = \"SCAVO Token\"; string public constant symbol = \"SCAVO\"; string public constant version = \"1.1\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 200000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "190.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; contract Owned { address public owner; function Owned() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function setOwner(address _newOwner) onlyOwner { if(_newOwner == 0x0)revert(); owner = _newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function toUINT112(uint256 a) internal constant returns(uint112) { assert(uint112(a) == a); return uint112(a); } function toUINT120(uint256 a) internal constant returns(uint120) { assert(uint120(a) == a); return uint120(a); } function toUINT128(uint256 a) internal constant returns(uint128) { assert(uint128(a) == a); return uint128(a); } } // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 contract Token { function totalSupply() public  returns (uint256 supply); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); function burn( uint256 _value) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); } contract TongTong is Token, Owned { using SafeMath for uint256; uint public  _totalSupply; string public   name;         //The Token's name uint8 public constant decimals = 8;    //Number of decimals of the smallest unit string public  symbol;    //The Token's symbol uint256 public mintCount; uint256 public deleteToken; uint256 public soldToken; mapping (address => uint256) public balanceOf; // Owner of account approves the transfer of an amount to another account mapping(address => mapping(address => uint256)) allowed; // Constructor function TongTong(string coinName,string coinSymbol,uint initialSupply) { _totalSupply = initialSupply *10**uint256(decimals);                        // Update total supply balanceOf[msg.sender] = _totalSupply; name = coinName;                                   // Set the name for display purposes symbol =coinSymbol; } function totalSupply()  public  returns (uint256 totalSupply) { return _totalSupply; } // Send back ether sent to me function () { revert(); } // Transfer the balance from owner's account to another account function transfer(address _to, uint256 _amount) returns (bool success) { // according to AssetToken's total supply, never overflow here if (balanceOf[msg.sender] >= _amount && _amount > 0) { balanceOf[msg.sender] -= uint112(_amount); balanceOf[_to] = _amount.add(balanceOf[_to]).toUINT112(); soldToken = _amount.add(soldToken).toUINT112(); Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { // according to AssetToken's total supply, never overflow here if (balanceOf[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0) { balanceOf[_from] = balanceOf[_from].sub(_amount).toUINT112(); allowed[_from][msg.sender] -= _amount; balanceOf[_to] = _amount.add(balanceOf[_to]).toUINT112(); Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } //Mint tokens and assign to some one function mint(address _owner, uint256 _amount) onlyOwner{ balanceOf[_owner] = _amount.add(balanceOf[_owner]).toUINT112(); mintCount =  _amount.add(mintCount).toUINT112(); _totalSupply = _totalSupply.add(_amount).toUINT112(); } //Burn tokens from owner account function burn(uint256 _count) public returns (bool success) { balanceOf[msg.sender] -=uint112( _count); deleteToken = _count.add(deleteToken).toUINT112(); _totalSupply = _totalSupply.sub(_count).toUINT112(); Burn(msg.sender, _count); return true; } } "}
{"sol name": "433.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract Token{ uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Inflat(address indexed from, uint256 value); } contract FeibeiContract is Token { uint8 constant public decimals = 18; string constant public name = \"FeibeiContract\"; string constant public symbol = \"FB\"; uint public totalSupply = 1000000000 * 10 ** uint256(decimals); address contract_creator; function FeibeiContract() public { balances[msg.sender] = totalSupply; contract_creator=msg.sender; } function inflat(uint256 _value) public returns(bool success){ require(msg.sender == contract_creator); require(_value > 0); totalSupply += _value; balances[contract_creator] +=_value; Inflat(contract_creator, _value); return true; } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(_to != 0x0); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] -= _value; totalSupply -=_value; Burn(burner, _value); } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } "}
{"sol name": "424.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title DetailedERC20 token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract ShawnCoin is DetailedERC20, StandardToken { /** * @dev Constructor function */ constructor() public DetailedERC20(\"Shawn Coin\", \"SHAWN\", 18) { totalSupply_ = 1000000000000000000000000000; // 1 Billion tokens balances[msg.sender] = totalSupply_; } } "}
{"sol name": "232.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "994.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* * Creator: XERA */ /* * Abstract Token Smart Contract * */ /* * Safe Math Smart Contract. * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * ERC-20 standard token interface, as defined * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>. */ contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * Abstract Token Smart Contract that could be used as a base contract for * ERC-20 token contracts. */ contract AbstractToken is Token, SafeMath { /** * Create new Abstract Token contract. */ function AbstractToken () { // Do nothing } /** * Get number of tokens currently belonging to given owner. * * @param _owner address to get number of tokens currently belonging to the *        owner of * @return number of tokens currently belonging to the owner of given address */ function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } /** * Transfer given number of tokens from message sender to given recipient. * * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } /** * Allow given spender to transfer given number of tokens from message sender. * @param _spender address to allow the owner of to transfer tokens from message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } /** * Tell how many tokens given spender is currently allowed to transfer from * given owner. * * @param _owner address to get number of tokens allowed to be transferred *        from the owner of * @param _spender address to get number of tokens allowed to be transferred *        by the owner of * @return number of tokens given spender is currently allowed to transfer *         from given owner */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } /** * Mapping from addresses of token holders to the numbers of tokens belonging * to these token holders. */ mapping (address => uint256) accounts; /** * Mapping from addresses of token holders to the mapping of addresses of * spenders to the allowances set by these token holders to these spenders. */ mapping (address => mapping (address => uint256)) private allowances; } /** * XERA Token Smart Contract. */ contract XERA is AbstractToken { /** * Maximum allowed number of tokens in circulation. * tokenSupply = tokensIActuallyWant * (10 ^ decimals) */ uint256 constant MAX_TOKEN_COUNT = 95000000 * (10**18); /** * Address of the owner of this smart contract. */ address private owner; /** * Frozen account list holder */ mapping (address => bool) private frozenAccount; /** * Burning account list holder */ mapping (address => bool) private burningAccount; /** * Current number of tokens in circulation. */ uint256 tokenCount = 0; /** * True if tokens transfers are currently frozen, false otherwise. */ bool frozen = false; /** * Create new token smart contract and make msg.sender the * owner of this smart contract. */ function XERA () { owner = msg.sender; } /** * Get total number of tokens in circulation. * * @return total number of tokens in circulation */ function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"XERA\"; string constant public symbol = \"XERA\"; uint8 constant public decimals = 18; /** * Transfer given number of tokens from message sender to given recipient. * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise */ function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } /** * Change how many tokens given spender is allowed to transfer from message * spender.  In order to prevent double spending of allowance, * To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender address to allow the owner of to transfer tokens from *        message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } /** * Create _value new tokens and give new created tokens to msg.sender. * Only be called by smart contract owner. * * @param _value number of tokens to create * @return true if tokens were created successfully, false otherwise */ function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); // adding transfer event and _from address as null address emit Transfer(0x0, msg.sender, _value); return true; } return false; } /** * Burning capable account * Only be called by smart contract owner. */ function burningCapableAccount(address[] _target) { require (msg.sender == owner); for (uint i = 0; i < _target.length; i++) { burningAccount[_target[i]] = true; } } /** * Burn intended tokens. * Only be called by by burnable addresses. * * @param _value number of tokens to burn * @return true if burnt successfully, false otherwise */ function burn(uint256 _value) public returns (bool success) { require(accounts[msg.sender] >= _value); require(burningAccount[msg.sender]); accounts [msg.sender] = safeSub (accounts [msg.sender], _value); tokenCount = safeSub (tokenCount, _value); emit Burn(msg.sender, _value); return true; } /** * Set new owner for the smart contract. * Only be called by smart contract owner. * * @param _newOwner address of new owner of the smart contract */ function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } /** * Freeze ALL token transfers. * Only be called by smart contract owner. */ function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } /** * Unfreeze ALL token transfers. * Only be called by smart contract owner. */ function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } /*A user is able to unintentionally send tokens to a contract * and if the contract is not prepared to refund them they will get stuck in the contract. * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to * prevent unintended Ether transfers. However, there\u2019s no such mechanism for token transfers. * so the below function is created */ function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } /** * Freeze specific account * Only be called by smart contract owner. */ function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } /** * Logged when token transfers were frozen. */ event Freeze (); /** * Logged when token transfers were unfrozen. */ event Unfreeze (); /** * Logged when a particular account is frozen. */ event FrozenFunds(address target, bool frozen); /** * Logged when a token is burnt. */ event Burn(address target,uint256 _value); /** * when accidentally send other tokens are refunded */ event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "1951.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // \u672ctoken\u7684\u516c\u5171\u53d8\u91cf string public name; string public symbol; uint8 public decimals = 18; // 18\u4f4d\u5c0f\u6570\u70b9\uff0c\u5c3d\u91cf\u4e0d\u4fee\u6539 uint256 public totalSupply; // \u4f59\u989d\u6570\u7ec4 mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; //2\u7ef4\u6570\u7ec4\u9650\u989d //Token\u8f6c\u79fb\u4e8b\u4ef6 This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // \u84b8\u53d1\u67d0\u4e2a\u8d26\u6237\u7684token This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * \u521d\u59cb\u5316 \u5408\u7ea6 Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // \u5c0f\u6570\u53d8\u6574\u6570 \u4e5818\u4e2a0   Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // \u521d\u59cbtoken\u6570\u91cf Give the creator all initial tokens name = tokenName;                                   // \u8bbe\u7f6etoken\u540d\u79f0  Set the name for display purposes symbol = tokenSymbol;                               // \u8bbe\u7f6etoken\u7b26\u53f7 Set the symbol for display purposes } /** * \u8d60\u9001\u8d27\u5e01 Internal transfer, only can be called by this contract \u4ed8\u6b3e\u5730\u5740\uff0c\u6536\u6b3e\u5730\u5740\uff0c\u6570\u91cf */ function _transfer(address _from, address _to, uint _value) internal { // \u786e\u5b9a\u6536\u6b3e\u5730\u5740\u5b58\u5728  Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // \u68c0\u67e5\u4ed8\u6b3e\u5730\u5740\u662f\u5426\u6709\u8db3\u591f\u7684\u4f59\u989d Check if the sender has enough require(balanceOf[_from] >= _value); //\u68c0\u67e5\u6536\u6b3e\u5730\u5740\u6536\u5230\u7684\u91d1\u989d\u662f\u5426\u662f\u8d1f\u6570  Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); //\u6536\u6b3e\u5730\u5740\u548c\u4ed8\u6b3e\u5730\u5740\u7684\u603b\u989d  Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // \u4ed8\u6b3e\u5730\u5740\u4e2d\u7684\u4f59\u989d-\u4ed8\u6b3e\u91d1\u989d  Subtract from the sender balanceOf[_from] -= _value; // \u6536\u6b3e\u5730\u5740\u4e2d\u7684\u4f59\u989d+\u4ed8\u6b3e\u91d1\u989d Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // \u5224\u65ad\u4ed8\u6b3e\u884c\u4e3a\u540e\u4e24\u4e2a\u8d26\u6237\u7684\u603b\u989d\u662f\u5426\u53d1\u751f\u53d8\u5316   Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens *\u4ece\u5f53\u524d\u8d26\u6237\u5411\u5176\u4ed6\u8d26\u6237\u53d1\u9001token * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // \u68c0\u67e5\u9650\u989d Check allowance allowance[_from][msg.sender] -= _value;  //\u51cf\u5c11\u76f8\u5e94\u7684\u9650\u989d _transfer(_from, _to, _value);  //\u8c03\u7528\u8c03\u7528\u4ea4\u6613\uff0c\u5b8c\u6210\u4ea4\u6613 return true; } /** * \u8bbe\u7f6e\u8d26\u6237\u9650\u989d  Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * \u8bbe\u7f6e\u5176\u4ed6\u8d26\u6237\u9650\u989d Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens *\u84b8\u53d1\u81ea\u5df1\u7684token * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   //\u5224\u65ad\u4f7f\u7528\u8005\u7684\u4f59\u989d\u662f\u5426\u5145\u8db3 Check if the sender has enough balanceOf[msg.sender] -= _value;            //\u51cf\u6389token Subtract from the sender totalSupply -= _value;                      //\u51cf\u6389\u603btaoken\u6570 Updates totalSupply emit Burn(msg.sender, _value);              //\u89e6\u53d1Burn\u4e8b\u4ef6 return true; } /** * Destroy tokens from other account *\u84b8\u53d1\u522b\u4eba\u7684token * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // \u68c0\u67e5\u522b\u4eba\u7684\u4f59\u989d\u662f\u5426\u5145\u8db3  Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // \u68c0\u67e5\u9650\u989d\u662f\u5426\u5145\u8db3 Check allowance balanceOf[_from] -= _value;                         // \u84b8\u53d1token Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // \u53bb\u9664\u9650\u989d Subtract from the sender's allowance totalSupply -= _value;                              // \u51cf\u6389\u603btaoken\u6570Update totalSupply emit Burn(_from, _value);\t\t\t    //\u89e6\u53d1Burn\u4e8b\u4ef6 return true; } } contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } contract stsc is owned, TokenERC20{ bool public freeze=true; function stsc() TokenERC20(20000000000,\"StarbullCoin\",\"STSC\") public {} function _transfer(address _from, address _to, uint _value) internal { require (freeze); require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows uint previousBalances = balanceOf[_from] + balanceOf[_to]; // \u4ed8\u6b3e\u5730\u5740\u4e2d\u7684\u4f59\u989d-\u4ed8\u6b3e\u91d1\u989d  Subtract from the sender balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); // \u5224\u65ad\u4ed8\u6b3e\u884c\u4e3a\u540e\u4e24\u4e2a\u8d26\u6237\u7684\u603b\u989d\u662f\u5426\u53d1\u751f\u53d8\u5316   Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function setfreeze(bool state) onlyOwner public{ freeze=state; } } "}
{"sol name": "958.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor(address _owner) public { owner = _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Whitelist is Ownable { mapping(address => bool) internal investorMap; /** * event for investor approval logging * @param investor approved investor */ event Approved(address indexed investor); /** * event for investor disapproval logging * @param investor disapproved investor */ event Disapproved(address indexed investor); constructor(address _owner) public Ownable(_owner) { } /** @param _investor the address of investor to be checked * @return true if investor is approved */ function isInvestorApproved(address _investor) external view returns (bool) { require(_investor != address(0)); return investorMap[_investor]; } /** @dev approve an investor * @param toApprove investor to be approved */ function approveInvestor(address toApprove) external onlyOwner { investorMap[toApprove] = true; emit Approved(toApprove); } /** @dev approve investors in bulk * @param toApprove array of investors to be approved */ function approveInvestorsInBulk(address[] toApprove) external onlyOwner { for (uint i = 0; i < toApprove.length; i++) { investorMap[toApprove[i]] = true; emit Approved(toApprove[i]); } } /** @dev disapprove an investor * @param toDisapprove investor to be disapproved */ function disapproveInvestor(address toDisapprove) external onlyOwner { delete investorMap[toDisapprove]; emit Disapproved(toDisapprove); } /** @dev disapprove investors in bulk * @param toDisapprove array of investors to be disapproved */ function disapproveInvestorsInBulk(address[] toDisapprove) external onlyOwner { for (uint i = 0; i < toDisapprove.length; i++) { delete investorMap[toDisapprove[i]]; emit Disapproved(toDisapprove[i]); } } } /** * @title Validator * @dev The Validator contract has a validator address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Validator { address public validator; event NewValidatorSet(address indexed previousOwner, address indexed newValidator); /** * @dev The Validator constructor sets the original `validator` of the contract to the sender * account. */ constructor() public { validator = msg.sender; } /** * @dev Throws if called by any account other than the validator. */ modifier onlyValidator() { require(msg.sender == validator); _; } /** * @dev Allows the current validator to transfer control of the contract to a newValidator. * @param newValidator The address to become next validator. */ function setNewValidator(address newValidator) public onlyValidator { require(newValidator != address(0)); emit NewValidatorSet(validator, newValidator); validator = newValidator; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } constructor(address _owner) public Ownable(_owner) { } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract DetailedERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** @title Compliant Token */ contract CompliantToken is Validator, DetailedERC20, MintableToken { Whitelist public whiteListingContract; struct TransactionStruct { address from; address to; uint256 value; uint256 fee; address spender; } mapping (uint => TransactionStruct) public pendingTransactions; mapping (address => mapping (address => uint256)) public pendingApprovalAmount; uint256 public currentNonce = 0; uint256 public transferFee; address public feeRecipient; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } modifier checkIsValueValid(uint256 _value) { require(_value > 0); _; } /** * event for rejected transfer logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ event TransferRejected( address indexed from, address indexed to, uint256 value, uint256 indexed nonce, uint256 reason ); /** * event for transfer tokens logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens */ event TransferWithFee( address indexed from, address indexed to, uint256 value, uint256 fee ); /** * event for transfer/transferFrom request logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens * @param spender The address which will spend the tokens * @param nonce request recorded at this particular nonce */ event RecordedPendingTransaction( address indexed from, address indexed to, uint256 value, uint256 fee, address indexed spender, uint256 nonce ); /** * event for whitelist contract update logging * @param _whiteListingContract address of the new whitelist contract */ event WhiteListingContractSet(address indexed _whiteListingContract); /** * event for fee update logging * @param previousFee previous fee * @param newFee new fee */ event FeeSet(uint256 indexed previousFee, uint256 indexed newFee); /** * event for fee recipient update logging * @param previousRecipient address of the old fee recipient * @param newRecipient address of the new fee recipient */ event FeeRecipientSet(address indexed previousRecipient, address indexed newRecipient); /** @dev Constructor * @param _owner Token contract owner * @param _name Token name * @param _symbol Token symbol * @param _decimals number of decimals in the token(usually 18) * @param whitelistAddress Ethereum address of the whitelist contract * @param recipient Ethereum address of the fee recipient * @param fee token fee for approving a transfer */ constructor( address _owner, string _name, string _symbol, uint8 _decimals, address whitelistAddress, address recipient, uint256 fee ) public MintableToken(_owner) DetailedERC20(_name, _symbol, _decimals) Validator() { setWhitelistContract(whitelistAddress); setFeeRecipient(recipient); setFee(fee); } /** @dev Updates whitelist contract address * @param whitelistAddress New whitelist contract address */ function setWhitelistContract(address whitelistAddress) public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } /** @dev Updates token fee for approving a transfer * @param fee New token fee */ function setFee(uint256 fee) public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } /** @dev Updates fee recipient address * @param recipient New whitelist contract address */ function setFeeRecipient(address recipient) public onlyValidator checkIsAddressValid(recipient) { emit FeeRecipientSet(feeRecipient, recipient); feeRecipient = recipient; } /** @dev Updates token name * @param _name New token name */ function updateName(string _name) public onlyOwner { require(bytes(_name).length != 0); name = _name; } /** @dev Updates token symbol * @param _symbol New token name */ function updateSymbol(string _symbol) public onlyOwner { require(bytes(_symbol).length != 0); symbol = _symbol; } /** @dev transfer request * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transfer(address _to, uint256 _value) public checkIsInvestorApproved(msg.sender) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 pendingAmount = pendingApprovalAmount[msg.sender][address(0)]; if (msg.sender == feeRecipient) { require(_value.add(pendingAmount) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( msg.sender, _to, _value, transferFee, address(0) ); emit RecordedPendingTransaction(msg.sender, _to, _value, transferFee, address(0), currentNonce); currentNonce++; return true; } /** @dev transferFrom request * @param _from address from which the tokens have to be transferred * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public checkIsInvestorApproved(_from) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 allowedTransferAmount = allowed[_from][msg.sender]; uint256 pendingAmount = pendingApprovalAmount[_from][msg.sender]; if (_from == feeRecipient) { require(_value.add(pendingAmount) <= balances[_from]); require(_value.add(pendingAmount) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[_from]); require(_value.add(pendingAmount).add(transferFee) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( _from, _to, _value, transferFee, msg.sender ); emit RecordedPendingTransaction(_from, _to, _value, transferFee, msg.sender, currentNonce); currentNonce++; return true; } /** @dev approve transfer/transferFrom request * @param nonce request recorded at this particular nonce */ function approveTransfer(uint256 nonce) external onlyValidator checkIsInvestorApproved(pendingTransactions[nonce].from) checkIsInvestorApproved(pendingTransactions[nonce].to) checkIsValueValid(pendingTransactions[nonce].value) returns (bool) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; address to = pendingTransactions[nonce].to; uint256 value = pendingTransactions[nonce].value; uint256 allowedTransferAmount = allowed[from][spender]; uint256 pendingAmount = pendingApprovalAmount[from][spender]; uint256 fee = pendingTransactions[nonce].fee; uint256 balanceFrom = balances[from]; uint256 balanceTo = balances[to]; delete pendingTransactions[nonce]; if (from == feeRecipient) { fee = 0; balanceFrom = balanceFrom.sub(value); balanceTo = balanceTo.add(value); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value); } pendingAmount = pendingAmount.sub(value); } else { balanceFrom = balanceFrom.sub(value.add(fee)); balanceTo = balanceTo.add(value); balances[feeRecipient] = balances[feeRecipient].add(fee); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value).sub(fee); } pendingAmount = pendingAmount.sub(value).sub(fee); } emit TransferWithFee( from, to, value, fee ); emit Transfer( from, to, value ); balances[from] = balanceFrom; balances[to] = balanceTo; allowed[from][spender] = allowedTransferAmount; pendingApprovalAmount[from][spender] = pendingAmount; return true; } /** @dev reject transfer/transferFrom request * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ function rejectTransfer(uint256 nonce, uint256 reason) external onlyValidator checkIsAddressValid(pendingTransactions[nonce].from) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; if (from == feeRecipient) { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value); } else { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value).sub(pendingTransactions[nonce].fee); } emit TransferRejected( from, pendingTransactions[nonce].to, pendingTransactions[nonce].value, nonce, reason ); delete pendingTransactions[nonce]; } } "}
{"sol name": "634.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract INCRYPTHEDGE is owned, TokenERC20 { mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ function INCRYPTHEDGE( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); } /// @notice Create `mintedAmount` tokens and send it to `target` /// @param target Address to receive the tokens /// @param mintedAmount the amount of tokens it will receive function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens /// @param target Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } } "}
{"sol name": "1840.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken, Ownable { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) onlyOwner public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); } } contract ZEEWANTtoken is BurnableToken  { string public constant name = \"Zeewant Token\"; string public constant symbol = \"ZEE\"; uint public constant decimals = 6; // there is no problem in using * here instead of .mul() uint256 public constant initialSupply = 1500000000 * (10 ** uint256(decimals)); // Constructors function ZEEWANTtoken () { totalSupply = initialSupply; balances[msg.sender] = initialSupply; // Send all tokens to owner } } "}
{"sol name": "1680.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor(address _owner) public { owner = _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Whitelist is Ownable { mapping(address => bool) internal investorMap; /** * event for investor approval logging * @param investor approved investor */ event Approved(address indexed investor); /** * event for investor disapproval logging * @param investor disapproved investor */ event Disapproved(address indexed investor); constructor(address _owner) public Ownable(_owner) { } /** @param _investor the address of investor to be checked * @return true if investor is approved */ function isInvestorApproved(address _investor) external view returns (bool) { require(_investor != address(0)); return investorMap[_investor]; } /** @dev approve an investor * @param toApprove investor to be approved */ function approveInvestor(address toApprove) external onlyOwner { investorMap[toApprove] = true; emit Approved(toApprove); } /** @dev approve investors in bulk * @param toApprove array of investors to be approved */ function approveInvestorsInBulk(address[] toApprove) external onlyOwner { for (uint i = 0; i < toApprove.length; i++) { investorMap[toApprove[i]] = true; emit Approved(toApprove[i]); } } /** @dev disapprove an investor * @param toDisapprove investor to be disapproved */ function disapproveInvestor(address toDisapprove) external onlyOwner { delete investorMap[toDisapprove]; emit Disapproved(toDisapprove); } /** @dev disapprove investors in bulk * @param toDisapprove array of investors to be disapproved */ function disapproveInvestorsInBulk(address[] toDisapprove) external onlyOwner { for (uint i = 0; i < toDisapprove.length; i++) { delete investorMap[toDisapprove[i]]; emit Disapproved(toDisapprove[i]); } } } /** * @title Validator * @dev The Validator contract has a validator address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Validator { address public validator; event NewValidatorSet(address indexed previousOwner, address indexed newValidator); /** * @dev The Validator constructor sets the original `validator` of the contract to the sender * account. */ constructor() public { validator = msg.sender; } /** * @dev Throws if called by any account other than the validator. */ modifier onlyValidator() { require(msg.sender == validator); _; } /** * @dev Allows the current validator to transfer control of the contract to a newValidator. * @param newValidator The address to become next validator. */ function setNewValidator(address newValidator) public onlyValidator { require(newValidator != address(0)); emit NewValidatorSet(validator, newValidator); validator = newValidator; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } constructor(address _owner) public Ownable(_owner) { } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract DetailedERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** @title Compliant Token */ contract CompliantToken is Validator, DetailedERC20, MintableToken { Whitelist public whiteListingContract; struct TransactionStruct { address from; address to; uint256 value; uint256 fee; address spender; } mapping (uint => TransactionStruct) public pendingTransactions; mapping (address => mapping (address => uint256)) public pendingApprovalAmount; uint256 public currentNonce = 0; uint256 public transferFee; address public feeRecipient; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } modifier checkIsValueValid(uint256 _value) { require(_value > 0); _; } /** * event for rejected transfer logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ event TransferRejected( address indexed from, address indexed to, uint256 value, uint256 indexed nonce, uint256 reason ); /** * event for transfer tokens logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens */ event TransferWithFee( address indexed from, address indexed to, uint256 value, uint256 fee ); /** * event for transfer/transferFrom request logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens * @param spender The address which will spend the tokens */ event RecordedPendingTransaction( address indexed from, address indexed to, uint256 value, uint256 fee, address indexed spender ); /** * event for whitelist contract update logging * @param _whiteListingContract address of the new whitelist contract */ event WhiteListingContractSet(address indexed _whiteListingContract); /** * event for fee update logging * @param previousFee previous fee * @param newFee new fee */ event FeeSet(uint256 indexed previousFee, uint256 indexed newFee); /** * event for fee recipient update logging * @param previousRecipient address of the old fee recipient * @param newRecipient address of the new fee recipient */ event FeeRecipientSet(address indexed previousRecipient, address indexed newRecipient); /** @dev Constructor * @param _owner Token contract owner * @param _name Token name * @param _symbol Token symbol * @param _decimals number of decimals in the token(usually 18) * @param whitelistAddress Ethereum address of the whitelist contract * @param recipient Ethereum address of the fee recipient * @param fee token fee for approving a transfer */ constructor( address _owner, string _name, string _symbol, uint8 _decimals, address whitelistAddress, address recipient, uint256 fee ) public MintableToken(_owner) DetailedERC20(_name, _symbol, _decimals) Validator() { setWhitelistContract(whitelistAddress); setFeeRecipient(recipient); setFee(fee); } /** @dev Updates whitelist contract address * @param whitelistAddress New whitelist contract address */ function setWhitelistContract(address whitelistAddress) public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } /** @dev Updates token fee for approving a transfer * @param fee New token fee */ function setFee(uint256 fee) public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } /** @dev Updates fee recipient address * @param recipient New whitelist contract address */ function setFeeRecipient(address recipient) public onlyValidator checkIsAddressValid(recipient) { emit FeeRecipientSet(feeRecipient, recipient); feeRecipient = recipient; } /** @dev Updates token name * @param _name New token name */ function updateName(string _name) public onlyOwner { require(bytes(_name).length != 0); name = _name; } /** @dev Updates token symbol * @param _symbol New token name */ function updateSymbol(string _symbol) public onlyOwner { require(bytes(_symbol).length != 0); symbol = _symbol; } /** @dev transfer request * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transfer(address _to, uint256 _value) public checkIsInvestorApproved(msg.sender) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 pendingAmount = pendingApprovalAmount[msg.sender][address(0)]; if (msg.sender == feeRecipient) { require(_value.add(pendingAmount) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( msg.sender, _to, _value, transferFee, address(0) ); emit RecordedPendingTransaction(msg.sender, _to, _value, transferFee, address(0)); currentNonce++; return true; } /** @dev transferFrom request * @param _from address from which the tokens have to be transferred * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public checkIsInvestorApproved(_from) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 allowedTransferAmount = allowed[_from][msg.sender]; uint256 pendingAmount = pendingApprovalAmount[_from][msg.sender]; if (_from == feeRecipient) { require(_value.add(pendingAmount) <= balances[_from]); require(_value.add(pendingAmount) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[_from]); require(_value.add(pendingAmount).add(transferFee) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( _from, _to, _value, transferFee, msg.sender ); emit RecordedPendingTransaction(_from, _to, _value, transferFee, msg.sender); currentNonce++; return true; } /** @dev approve transfer/transferFrom request * @param nonce request recorded at this particular nonce */ function approveTransfer(uint256 nonce) external onlyValidator checkIsInvestorApproved(pendingTransactions[nonce].from) checkIsInvestorApproved(pendingTransactions[nonce].to) checkIsValueValid(pendingTransactions[nonce].value) returns (bool) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; address to = pendingTransactions[nonce].to; uint256 value = pendingTransactions[nonce].value; uint256 allowedTransferAmount = allowed[from][spender]; uint256 pendingAmount = pendingApprovalAmount[from][spender]; uint256 fee = pendingTransactions[nonce].fee; uint256 balanceFrom = balances[from]; uint256 balanceTo = balances[to]; delete pendingTransactions[nonce]; if (from == feeRecipient) { fee = 0; balanceFrom = balanceFrom.sub(value); balanceTo = balanceTo.add(value); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value); } pendingAmount = pendingAmount.sub(value); } else { balanceFrom = balanceFrom.sub(value.add(fee)); balanceTo = balanceTo.add(value); balances[feeRecipient] = balances[feeRecipient].add(fee); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value).sub(fee); } pendingAmount = pendingAmount.sub(value).sub(fee); } emit TransferWithFee( from, to, value, fee ); emit Transfer( from, to, value ); balances[from] = balanceFrom; balances[to] = balanceTo; allowed[from][spender] = allowedTransferAmount; pendingApprovalAmount[from][spender] = pendingAmount; return true; } /** @dev reject transfer/transferFrom request * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ function rejectTransfer(uint256 nonce, uint256 reason) external onlyValidator checkIsAddressValid(pendingTransactions[nonce].from) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; if (from == feeRecipient) { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value); } else { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value).sub(pendingTransactions[nonce].fee); } emit TransferRejected( from, pendingTransactions[nonce].to, pendingTransactions[nonce].value, nonce, reason ); delete pendingTransactions[nonce]; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale. * Crowdsales have a start and end timestamps, where investors can make * token purchases and the crowdsale will assign them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. The contract requires a MintableToken that will be * minted as contributions arrive, note that the crowdsale contract * must be owner of the token in order to be able to mint it. */ contract Crowdsale { using SafeMath for uint256; // The token being sold MintableToken public token; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // address where funds are collected address public wallet; // how many token units a buyer gets per wei uint256 public rate; // amount of raised money in wei uint256 public weiRaised; // amount of tokens sold uint256 public totalSupply; // maximum amount of tokens that can be sold uint256 public tokenCap; /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor(uint256 _startTime, uint256 _endTime, uint256 _tokenCap, uint256 _rate, address _wallet, MintableToken _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; tokenCap = _tokenCap; rate = _rate; wallet = _wallet; token = _token; } // fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender); } // low level token purchase function function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); totalSupply = totalSupply.add(tokens); token.mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { return now > endTime; } // Override this method to have a way to add business logic to your crowdsale when buying function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { return weiAmount.mul(rate); } // send ether to the fund collection wallet // override to create custom fund forwarding mechanisms function forwardFunds() internal { wallet.transfer(msg.value); } // @return true if the transaction can buy tokens function validPurchase() internal view returns (bool) { uint256 tokens = msg.value.mul(rate); require(totalSupply.add(tokens) <= tokenCap); bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } } /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); constructor(address _owner) public Ownable(_owner) {} /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); emit Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal {} } /** @title Compliant Crowdsale */ contract CompliantCrowdsale is Validator, FinalizableCrowdsale { Whitelist public whiteListingContract; struct MintStruct { address to; uint256 tokens; uint256 weiAmount; } mapping (uint => MintStruct) public pendingMints; uint256 public currentMintNonce; mapping (address => uint) public rejectedMintBalance; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } /** * event for rejected mint logging * @param to address for which buy tokens got rejected * @param value number of tokens * @param amount number of ethers invested * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ event MintRejected( address indexed to, uint256 value, uint256 amount, uint256 indexed nonce, uint256 reason ); /** * event for buy tokens request logging * @param beneficiary address for which buy tokens is requested * @param tokens number of tokens * @param weiAmount number of ethers invested * @param nonce request recorded at this particular nonce */ event ContributionRegistered( address beneficiary, uint256 tokens, uint256 weiAmount, uint256 nonce ); /** * event for whitelist contract update logging * @param _whiteListingContract address of the new whitelist contract */ event WhiteListingContractSet(address indexed _whiteListingContract); /** * event for claimed ether logging * @param account user claiming the ether * @param amount ether claimed */ event Claimed(address indexed account, uint256 amount); /** @dev Constructor * @param whitelistAddress Ethereum address of the whitelist contract * @param _startTime crowdsale start time * @param _endTime crowdsale end time * @param _tokenCap maximum number of tokens to be sold in the crowdsale * @param _rate number of tokens to be sold per ether * @param _wallet Ethereum address of the wallet * @param _token Ethereum address of the token contract * @param _owner Ethereum address of the owner */ constructor( address whitelistAddress, uint256 _startTime, uint256 _endTime, uint256 _tokenCap, uint256 _rate, address _wallet, MintableToken _token, address _owner ) public FinalizableCrowdsale(_owner) Crowdsale(_startTime, _endTime, _tokenCap, _rate, _wallet, _token) { setWhitelistContract(whitelistAddress); } /** @dev Updates whitelist contract address * @param whitelistAddress address of the new whitelist contract */ function setWhitelistContract(address whitelistAddress) public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } /** @dev buy tokens request * @param beneficiary the address to which the tokens have to be minted */ function buyTokens(address beneficiary) public payable checkIsInvestorApproved(beneficiary) { require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = weiAmount.mul(rate); pendingMints[currentMintNonce] = MintStruct(beneficiary, tokens, weiAmount); emit ContributionRegistered(beneficiary, tokens, weiAmount, currentMintNonce); currentMintNonce++; } /** @dev approve buy tokens request * @param nonce request recorded at this particular nonce */ function approveMint(uint256 nonce) external onlyValidator checkIsInvestorApproved(pendingMints[nonce].to) returns (bool) { // update state weiRaised = weiRaised.add(pendingMints[nonce].weiAmount); totalSupply = totalSupply.add(pendingMints[nonce].tokens); //No need to use mint-approval on token side, since the minting is already approved in the crowdsale side token.mint(pendingMints[nonce].to, pendingMints[nonce].tokens); emit TokenPurchase( msg.sender, pendingMints[nonce].to, pendingMints[nonce].weiAmount, pendingMints[nonce].tokens ); forwardFunds(pendingMints[nonce].weiAmount); delete pendingMints[nonce]; return true; } /** @dev reject buy tokens request * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ function rejectMint(uint256 nonce, uint256 reason) external onlyValidator checkIsAddressValid(pendingMints[nonce].to) { rejectedMintBalance[pendingMints[nonce].to] = rejectedMintBalance[pendingMints[nonce].to].add(pendingMints[nonce].weiAmount); emit MintRejected( pendingMints[nonce].to, pendingMints[nonce].tokens, pendingMints[nonce].weiAmount, nonce, reason ); delete pendingMints[nonce]; } /** @dev claim back ether if buy tokens request is rejected */ function claim() external { require(rejectedMintBalance[msg.sender] > 0); uint256 value = rejectedMintBalance[msg.sender]; rejectedMintBalance[msg.sender] = 0; msg.sender.transfer(value); emit Claimed(msg.sender, value); } function finalization() internal { transferTokenOwnership(validator); super.finalization(); } /** @dev Updates token contract address * @param newToken New token contract address */ function setTokenContract(address newToken) external onlyOwner checkIsAddressValid(newToken) { token = CompliantToken(newToken); } /** @dev transfers ownership of the token contract * @param newOwner New owner of the token contract */ function transferTokenOwnership(address newOwner) public onlyOwner checkIsAddressValid(newOwner) { token.transferOwnership(newOwner); } function forwardFunds(uint256 amount) internal { wallet.transfer(amount); } } "}
{"sol name": "1971.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* Created By Daniel Pittman Qwoyn.io 2018 CryptoCaps A smartcontract that mints unique bottle caps and slammers in order to play the infamous game Pogs on the blockchain! ERC721 */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC165 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md */ interface ERC165 { /** * @notice Query if a contract implements an interface * @param _interfaceId The interface identifier, as specified in ERC-165 * @dev Interface identification is specified in ERC-165. This function * uses less than 30,000 gas. */ function supportsInterface(bytes4 _interfaceId) external view returns (bool); } /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */ contract ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 internal constant ERC721_RECEIVED = 0x150b7a02; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient * after a `safetransfer`. This function MAY throw to revert and reject the * transfer. Return of other than the magic value MUST result in the * transaction being reverted. * Note: the contract address is always the message sender. * @param _operator The address which called `safeTransferFrom` function * @param _from The address which previously owned the token * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` */ function onERC721Received( address _operator, address _from, uint256 _tokenId, bytes _data ) public returns(bytes4); } /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, * as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(addr) } return size > 0; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title SupportsInterfaceWithLookup * @author Matt Condon (@shrugs) * @dev Implements ERC165 using a lookup table. */ contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; /** * 0x01ffc9a7 === *   bytes4(keccak256('supportsInterface(bytes4)')) */ /** * @dev a mapping of interface id to whether or not it's supported */ mapping(bytes4 => bool) internal supportedInterfaces; /** * @dev A contract implementing SupportsInterfaceWithLookup * implement ERC165 itself */ constructor() public { _registerInterface(InterfaceId_ERC165); } /** * @dev implement supportsInterface(bytes4) using a lookup table */ function supportsInterface(bytes4 _interfaceId) external view returns (bool) { return supportedInterfaces[_interfaceId]; } /** * @dev private method for registering an interface */ function _registerInterface(bytes4 _interfaceId) internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } } /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic is ERC165 { event Transfer( address indexed _from, address indexed _to, uint256 indexed _tokenId ); event Approval( address indexed _owner, address indexed _approved, uint256 indexed _tokenId ); event ApprovalForAll( address indexed _owner, address indexed _operator, bool _approved ); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public; } /** * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex( address _owner, uint256 _index ) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } /** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Metadata is ERC721Basic { function name() external view returns (string _name); function symbol() external view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } /** * @title ERC-721 Non-Fungible Token Standard, full implementation interface * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } /** * @title ERC721 Non-Fungible Token Standard basic implementation * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd; /* * 0x80ac58cd === *   bytes4(keccak256('balanceOf(address)')) ^ *   bytes4(keccak256('ownerOf(uint256)')) ^ *   bytes4(keccak256('approve(address,uint256)')) ^ *   bytes4(keccak256('getApproved(uint256)')) ^ *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^ *   bytes4(keccak256('isApprovedForAll(address,address)')) ^ *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) */ bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79; /* * 0x4f558e79 === *   bytes4(keccak256('exists(uint256)')) */ using SafeMath for uint256; using AddressUtils for address; // Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))` // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` bytes4 private constant ERC721_RECEIVED = 0x150b7a02; // Mapping from token ID to owner mapping (uint256 => address) internal tokenOwner; // Mapping from token ID to approved address mapping (uint256 => address) internal tokenApprovals; // Mapping from owner to number of owned token mapping (address => uint256) internal ownedTokensCount; // Mapping from owner to operator approvals mapping (address => mapping (address => bool)) internal operatorApprovals; /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint256 ID of the token to validate */ modifier canTransfer(uint256 _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721); _registerInterface(InterfaceId_ERC721Exists); } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existence of * @return whether the token exists */ function exists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * The zero address indicates there is no approved address. * There can only be one approved address per token at a given time. * Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } /** * @dev Sets or unsets the approval of a given operator * An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll( address _owner, address _operator ) public view returns (bool) { return operatorApprovals[_owner][_operator]; } /** * @dev Transfers the ownership of a given token ID to another address * Usage of this method is discouraged, use `safeTransferFrom` whenever possible * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function transferFrom( address _from, address _to, uint256 _tokenId ) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise, * the transfer is reverted. * * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function safeTransferFrom( address _from, address _to, uint256 _tokenId ) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint256,bytes)\"))`; otherwise, * the transfer is reverted. * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint256 _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Internal function to mint a new token * Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } /** * @dev Internal function to burn a specific token * Reverts if the token does not exist * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { clearApproval(_owner, _tokenId); removeTokenFrom(_owner, _tokenId); emit Transfer(_owner, address(0), _tokenId); } /** * @dev Internal function to clear current approval of a given token ID * Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); } } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } /** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( msg.sender, _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } /** * @title Full ERC721 Token * This implementation includes all the required and some optional functionality of the ERC721 standard * Moreover, it includes approve all functionality using operator terminology * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Token is SupportsInterfaceWithLookup, ERC721BasicToken, ERC721 { bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63; /** * 0x780e9d63 === *   bytes4(keccak256('totalSupply()')) ^ *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^ *   bytes4(keccak256('tokenByIndex(uint256)')) */ bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; /** * 0x5b5e139f === *   bytes4(keccak256('name()')) ^ *   bytes4(keccak256('symbol()')) ^ *   bytes4(keccak256('tokenURI(uint256)')) */ // Token name string internal name_; // Token symbol string internal symbol_; // Mapping from owner to list of owned token IDs mapping(address => uint256[]) internal ownedTokens; // Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; // Array with all token ids, used for enumeration uint256[] internal allTokens; // Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex; // Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs; /** * @dev Constructor function */ constructor(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); } /** * @dev Gets the token name * @return string representing the token name */ function name() external view returns (string) { return name_; } /** * @dev Gets the token symbol * @return string representing the token symbol */ function symbol() external view returns (string) { return symbol_; } /** * @dev Returns an URI for a given token ID * Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ function tokenURI(uint256 _tokenId) public view returns (string) { require(exists(_tokenId)); return tokenURIs[_tokenId]; } /** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ function tokenOfOwnerByIndex( address _owner, uint256 _index ) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } /** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ function totalSupply() public view returns (uint256) { return allTokens.length; } /** * @dev Gets the token ID at a given index of all the tokens in this contract * Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } /** * @dev Internal function to set the token URI for a given token * Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ function _setTokenURI(uint256 _tokenId, string _uri) internal { require(exists(_tokenId)); tokenURIs[_tokenId] = _uri; } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; ownedTokens[_from][lastTokenIndex] = 0; // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping // the lastToken to the first position, and then dropping the element placed in the last position of the list ownedTokens[_from].length--; ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } /** * @dev Internal function to mint a new token * Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { super._mint(_to, _tokenId); allTokensIndex[_tokenId] = allTokens.length; allTokens.push(_tokenId); } /** * @dev Internal function to burn a specific token * Reverts if the token does not exist * @param _owner owner of the token to burn * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { super._burn(_owner, _tokenId); // Clear metadata (if any) if (bytes(tokenURIs[_tokenId]).length != 0) { delete tokenURIs[_tokenId]; } // Reorg all tokens array uint256 tokenIndex = allTokensIndex[_tokenId]; uint256 lastTokenIndex = allTokens.length.sub(1); uint256 lastToken = allTokens[lastTokenIndex]; allTokens[tokenIndex] = lastToken; allTokens[lastTokenIndex] = 0; allTokens.length--; allTokensIndex[_tokenId] = 0; allTokensIndex[lastToken] = tokenIndex; } } contract CryptoCaps is ERC721Token, Ownable { /*** EVENTS ***/ /// The event emitted (useable by web3) when a token is purchased event BoughtToken(address indexed buyer, uint256 tokenId); /*** CONSTANTS ***/ uint8 constant TITLE_MIN_LENGTH = 1; uint8 constant TITLE_MAX_LENGTH = 64; uint256 constant DESCRIPTION_MIN_LENGTH = 1; uint256 constant DESCRIPTION_MAX_LENGTH = 10000; /*** DATA TYPES ***/ /// Price set by contract owner for each token in Wei. /// @dev If you'd like a different price for each token type, you will ///   need to use a mapping like: `mapping(uint256 => uint256) tokenTypePrices;` uint256 currentPrice = 0; /// The token type (1 for idea, 2 for belonging, etc) mapping(uint256 => uint256) tokenTypes; /// The title of the token mapping(uint256 => string) tokenTitles; /// The description of the token mapping(uint256 => string) tokenDescription; constructor() ERC721Token(\"CryptoCaps\", \"QCC\") public { // any init code when you deploy the contract would run here } /// Requires the amount of Ether be at least or more of the currentPrice /// @dev Creates an instance of an token and mints it to the purchaser /// @param _type The token type as an integer /// @param _title The short title of the token /// @param _description Description of the token function buyToken ( uint256 _type, string _title, string _description ) external payable { bytes memory _titleBytes = bytes(_title); require(_titleBytes.length >= TITLE_MIN_LENGTH, \"Title is too short\"); require(_titleBytes.length <= TITLE_MAX_LENGTH, \"Title is too long\"); bytes memory _descriptionBytes = bytes(_description); require(_descriptionBytes.length >= DESCRIPTION_MIN_LENGTH, \"Description is too short\"); require(_descriptionBytes.length <= DESCRIPTION_MAX_LENGTH, \"Description is too long\"); require(msg.value >= currentPrice, \"Amount of Ether sent too small\"); uint256 index = allTokens.length + 1; _mint(msg.sender, index); tokenTypes[index] = _type; tokenTitles[index] = _title; tokenDescription[index] = _description; emit BoughtToken(msg.sender, index); } /** * @dev Returns all of the tokens that the user owns * @return An array of token indices */ function myTokens() external view returns ( uint256[] ) { return ownedTokens[msg.sender]; } /// @notice Returns all the relevant information about a specific token /// @param _tokenId The ID of the token of interest function viewToken(uint256 _tokenId) external view returns ( uint256 tokenType_, string tokenTitle_, string tokenDescription_ ) { tokenType_ = tokenTypes[_tokenId]; tokenTitle_ = tokenTitles[_tokenId]; tokenDescription_ = tokenDescription[_tokenId]; } /// @notice Allows the owner of this contract to set the currentPrice for each token function setCurrentPrice(uint256 newPrice) public onlyOwner { currentPrice = newPrice; } /// @notice Returns the currentPrice for each token function getCurrentPrice() external view returns ( uint256 price ) { price = currentPrice; } /// @notice allows the owner of this contract to destroy the contract function kill() public { if(msg.sender == owner) selfdestruct(owner); } } "}
{"sol name": "281.sol", "label": 0, "sol content": "pragma solidity ^0.4.22; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } /** * @title Haltable * * @dev Abstract contract that allows children to implement an * emergency stop mechanism. Differs from Pausable by requiring a state. * * * Originally envisioned in FirstBlood ICO contract. */ contract Haltable is Ownable { bool public halted; modifier inNormalState { assert(!halted); _; } modifier inEmergencyState { assert(halted); _; } // called by the owner on emergency, triggers stopped state function halt() external onlyOwner inNormalState { halted = true; } // called by the owner on end of emergency, returns to normal state function resume() external onlyOwner inEmergencyState { halted = false; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) public balances; /* Transfer token for a specified address */ function transfer(address _to, uint256 _value) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return A uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping(address => mapping(address => uint256)) public allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 _allowance; _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Burnable * * @dev Standard ERC20 token */ contract Burnable is StandardToken { using SafeMath for uint; /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); function burn(uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); // Check if the sender has enough balances[msg.sender] = balances[msg.sender].sub(_value); // Subtract from the sender totalSupply = totalSupply.sub(_value); // Updates totalSupply emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balances[_from] >= _value); // Check if the sender has enough require(_value <= allowed[_from][msg.sender]); // Check allowance balances[_from] = balances[_from].sub(_value); // Subtract from the sender totalSupply = totalSupply.sub(_value); // Updates totalSupply allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Burn(_from, _value); return true; } function transfer(address _to, uint _value) public returns (bool success) { require(_to != 0x0); //use burn return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { require(_to != 0x0); //use burn return super.transferFrom(_from, _to, _value); } } /** * @title Centive Token * * @dev Burnable Ownable ERC20 token */ contract Centive is Burnable, Ownable { string public name; string public symbol; uint8 public decimals = 18; /* The finalizer contract that removes the transfer restrictions imposed by the lockout period */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. * If false we are are in transfer lock up period. * */ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. * These are crowdsale contracts and possible the team multisig itself. * */ mapping(address => bool) public transferAgents; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { require(transferAgents[_sender] || released); _; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { require(releaseState == released); _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { require(msg.sender == releaseAgent); _; } /** @dev Constructor that gives msg.sender all of existing tokens. */ constructor(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply with the decimal amount balances[msg.sender] = totalSupply; // Give the creator all initial tokens name = tokenName; // Set the name for display purposes symbol = tokenSymbol; // Set the symbol for display purposes } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) external onlyOwner inReleaseState(false) { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } function release() external onlyReleaseAgent inReleaseState(false) { released = true; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) external onlyOwner inReleaseState(false) { transferAgents[addr] = state; } function transfer(address _to, uint _value) public canTransfer(msg.sender) returns (bool success) { // Call Burnable.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) public canTransfer(_from) returns (bool success) { // Call Burnable.transferForm() return super.transferFrom(_from, _to, _value); } function burn(uint256 _value) public onlyOwner returns (bool success) { return super.burn(_value); } function burnFrom(address _from, uint256 _value) public onlyOwner returns (bool success) { return super.burnFrom(_from, _value); } } "}
{"sol name": "651.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: zeppelin-solidity/contracts/lifecycle/Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } // File: zeppelin-solidity/contracts/token/ERC20/PausableToken.sol /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } // File: contracts/TestCoin.sol contract TangguoTaoToken is PausableToken{ string public name = \"TangguoTao Token\"; string public symbol = \"TCA\"; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 60000000000000000000000000000; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "457.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract CustomToken is BaseToken { function CustomToken() public { totalSupply = 84000000000000000000000000; name = 'LiCoinGold'; symbol = 'LCGD'; decimals = 18; balanceOf[0xf588d792fa8a634162760482a7b61dd1ab99b1f1] = totalSupply; Transfer(address(0), 0xf588d792fa8a634162760482a7b61dd1ab99b1f1, totalSupply); } } "}
{"sol name": "473.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract DateTime { struct _DateTime { uint16 year; uint8 month; uint8 day; } uint constant DAY_IN_SECONDS = 86400; uint constant YEAR_IN_SECONDS = 31536000; uint constant LEAP_YEAR_IN_SECONDS = 31622400; uint16 constant ORIGIN_YEAR = 1970; uint constant GMT_TO_LOCAL = 19800; function toTimestamp(uint16 year, uint8 month, uint8 day) public returns (uint timestamp) { uint16 i; // Year for (i = ORIGIN_YEAR; i < year; i++) { if (isLeapYear(i)) { timestamp += LEAP_YEAR_IN_SECONDS; } else { timestamp += YEAR_IN_SECONDS; } } // Month uint8[12] memory monthDayCounts; monthDayCounts[0] = 31; if (isLeapYear(year)) { monthDayCounts[1] = 29; } else { monthDayCounts[1] = 28; } monthDayCounts[2] = 31; monthDayCounts[3] = 30; monthDayCounts[4] = 31; monthDayCounts[5] = 30; monthDayCounts[6] = 31; monthDayCounts[7] = 31; monthDayCounts[8] = 30; monthDayCounts[9] = 31; monthDayCounts[10] = 30; monthDayCounts[11] = 31; for (i = 1; i < month; i++) { timestamp += DAY_IN_SECONDS * monthDayCounts[i - 1]; } // Day timestamp += DAY_IN_SECONDS * (day - 1); timestamp-=GMT_TO_LOCAL; return timestamp; } function isLeapYear(uint16 year) public pure returns (bool) { if (year % 4 != 0) { return false; } if (year % 100 != 0) { return true; } if (year % 400 != 0) { return false; } return true; } } contract ApcrdaZebichain is Ownable{ mapping (uint256 =>string ) event_details; // timestamp to hash DateTime public dt; function ApcrdaZebichain() public{ } function viewMerkleHash(uint16 year, uint8 month, uint8 day)  public view returns(string hash) { uint  time = dt.toTimestamp(year,month,day); hash= event_details[time]; } function insertHash(uint16 year, uint8 month, uint8 day, string hash) onlyOwner public{ dt = new DateTime(); uint  t = dt.toTimestamp(year,month,day); event_details[t]=hash; } } "}
{"sol name": "1736.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } interface ERC20 { function balanceOf(address who) external view returns (uint256); function transfer(address to, uint256 value) external returns (bool); function allowance(address owner, address spender) external view returns (uint256); function transferFrom(address from, address to, uint256 value) external returns (bool); function approve(address spender, uint256 value) external returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } interface ERC223 { function transfer(address to, uint value, bytes data) public; event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data) public; } contract MarketplaceToken is ERC20, ERC223 { using SafeMath for uint; address creator; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; event Burn(address indexed from, uint256 value); constructor() public { _symbol = \"MKTP\"; _name = \"Marketplace Token\"; _decimals = 5; _totalSupply = 70000000 * 10 ** uint256(_decimals); balances[msg.sender] = _totalSupply; creator = msg.sender; } modifier onlyCreator() { if(msg.sender != creator){ revert(); } _; } function name() public view returns (string) { return _name; } function symbol() public view returns (string) { return _symbol; } function decimals() public view returns (uint8) { return _decimals; } function totalSupply() public view returns (uint256) { return _totalSupply; } function changeCreator(address _newCreator) onlyCreator public returns (bool) { if(creator != _newCreator) { creator = _newCreator; return true; } else { revert(); } } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = SafeMath.sub(balances[_from], _value); balances[_to] = SafeMath.add(balances[_to], _value); allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value); emit Transfer(_from, _to, _value); return true; } function forceTransferFrom(address _from, address _to, uint256 _value) onlyCreator public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); balances[_from] = SafeMath.sub(balances[_from], _value); balances[_to] = SafeMath.add(balances[_to], _value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function transfer(address _to, uint _value, bytes _data) public { require(_value > 0 ); if(isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value, _data); } function isContract(address _addr) private view returns (bool is_contract) { uint length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } function burn(uint256 _value) onlyCreator public returns (bool success) { require(balances[msg.sender] >= _value);   // Check if the sender has enough balances[msg.sender] -= _value;            // Subtract from the sender _totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "817.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //\u4e2d\u56fd\u5140\u724c\u4e3b\u94fe china pai brands blockchain string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "782.sol", "label": 0, "sol content": "pragma solidity ^0.4.22; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; address delegate; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; emit OwnershipTransferred(address(0), owner); } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); delegate = newOwner; } function confirmChangeOwnership() public { require(msg.sender == delegate); emit OwnershipTransferred(owner, delegate); owner = delegate; delegate = 0; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract TransferFilter is Ownable { bool public isTransferable; mapping( address => bool ) public mapAddressPass; mapping( address => bool ) public mapAddressBlock; event LogFilterPass(address indexed target, bool status); event LogFilterBlock(address indexed target, bool status); // if Token transfer modifier checkTokenTransfer(address source) { if (isTransferable == true) { require(mapAddressBlock[source] == false); } else { require(mapAddressPass[source] == true); } _; } constructor() public { isTransferable = true; } function setTransferable(bool status) public onlyOwner { isTransferable = status; } function isInPassFilter(address user) public view returns (bool) { return mapAddressPass[user]; } function isInBlockFilter(address user) public view returns (bool) { return mapAddressBlock[user]; } function addressToPass(address[] target, bool status) public onlyOwner { for( uint i = 0 ; i < target.length ; i++ ) { address targetAddress = target[i]; bool old = mapAddressPass[targetAddress]; if (old != status) { if (status == true) { mapAddressPass[targetAddress] = true; emit LogFilterPass(targetAddress, true); } else { delete mapAddressPass[targetAddress]; emit LogFilterPass(targetAddress, false); } } } } function addressToBlock(address[] target, bool status) public onlyOwner { for( uint i = 0 ; i < target.length ; i++ ) { address targetAddress = target[i]; bool old = mapAddressBlock[targetAddress]; if (old != status) { if (status == true) { mapAddressBlock[targetAddress] = true; emit LogFilterBlock(targetAddress, true); } else { delete mapAddressBlock[targetAddress]; emit LogFilterBlock(targetAddress, false); } } } } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, TransferFilter { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; modifier onlyPayloadSize(uint size) { require(msg.data.length >= size + 4); _; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) onlyPayloadSize(2 * 32) checkTokenTransfer(msg.sender) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3 * 32) checkTokenTransfer(_from) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) onlyPayloadSize(2 * 32) checkTokenTransfer(msg.sender) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender,0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } } contract BurnableToken is StandardToken { event Burn(address indexed from, uint256 value); function burn(address _from, uint256 _amount) public onlyOwner { require(_amount <= balances[_from]); totalSupply = totalSupply.sub(_amount); balances[_from] = balances[_from].sub(_amount); emit Transfer(_from, address(0), _amount); emit Burn(_from, _amount); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is BurnableToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; address public minter; constructor() public { minter = msg.sender; } modifier canMint() { require(!mintingFinished); _; } modifier hasPermission() { require(msg.sender == owner || msg.sender == minter); _; } function () public payable { require(false); } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) canMint hasPermission public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() canMint onlyOwner public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract VoltraCoin is MintableToken { string public constant name = \"VoltraCoin\"; // solium-disable-line uppercase string public constant symbol = \"VLT\"; // solium-disable-line uppercase uint8 public constant decimals = 18; // solium-disable-line uppercase /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply = 0; } } "}
{"sol name": "1633.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused returns(bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused returns(bool) { paused = false; emit Unpause(); return true; } } contract ERC20 { uint256 public totalSupply; function transfer(address _to, uint256 _value) public returns(bool success); function transferFrom(address _from, address _to, uint256 _value) public returns(bool success); function balanceOf(address _owner) constant public returns(uint256 balance); function approve(address _spender, uint256 _value) public returns(bool success); function allowance(address _owner, address _spender) constant public returns(uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract BasicToken is ERC20, Pausable { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function _transfer(address _from, address _to, uint256 _value) internal returns(bool success) { require(_to != 0x0); require(_value > 0); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } function transfer(address _to, uint256 _value) public whenNotPaused returns(bool success) { require(balances[msg.sender] >= _value); return _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns(bool success) { require(balances[_from] >= _value); require(allowed[_from][msg.sender] >= _value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); return _transfer(_from, _to, _value); } function balanceOf(address _owner) constant public returns(uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns(bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns(uint256 remaining) { return allowed[_owner][_spender]; } } contract PayChainCoin is BasicToken { string public constant name = \"PayChainCoin\"; string public constant symbol = \"PCC\"; uint256 public constant decimals = 18; constructor() public { _assign(0xa3f351bD8A2cB33822DeFE13e0efB968fc22A186, 690); _assign(0xd3C72E4D0EAdab0Eb7A4f416b67754185F72A1fa, 10); _assign(0x32A2594Ba3af6543E271e5749Dc39Dd85cFbE1e8, 150); _assign(0x7c3db3C5862D32A97a53BFEbb34C384a4b52C2Cc, 150); } function _assign(address _address, uint256 _value) private { uint256 amount = _value * (10 ** 6) * (10 ** decimals); balances[_address] = amount; totalSupply = totalSupply.add(amount); } } "}
{"sol name": "95.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: contracts\\token\\ERC20\\ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: contracts\\math\\SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } // File: contracts\\token\\ERC20\\StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Internal function that mints an amount of the token and assigns it to * an account. This encapsulates the modification of balances such that the * proper events are emitted. * @param _account The account that will receive the created tokens. * @param _amount The amount that will be created. */ function _mint(address _account, uint256 _amount) internal { require(_account != 0); totalSupply_ = totalSupply_.add(_amount); balances[_account] = balances[_account].add(_amount); emit Transfer(address(0), _account, _amount); } /** * @dev Internal function that burns an amount of the token of a given * account. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burn(address _account, uint256 _amount) internal { require(_account != 0); require(balances[_account] > _amount); totalSupply_ = totalSupply_.sub(_amount); balances[_account] = balances[_account].sub(_amount); emit Transfer(_account, address(0), _amount); } /** * @dev Internal function that burns an amount of the token of a given * account, deducting from the sender's allowance for said account. Uses the * internal _burn function. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burnFrom(address _account, uint256 _amount) internal { require(allowed[_account][msg.sender] > _amount); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount); _burn(_account, _amount); } } // File: contracts\\token\\ERC20\\BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { _burnFrom(_from, _value); } /** * @dev Overrides StandardToken._burn in order for burn and burnFrom to emit * an additional Burn event. */ function _burn(address _who, uint256 _value) internal { super._burn(_who, _value); emit Burn(_who, _value); } } // File: contracts\\ownership\\Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: contracts\\lifecycle\\Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } // File: contracts\\token\\ERC20\\PausableToken.sol /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is BurnableToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title KWATT_Token Token * @dev Token that can be irreversibly burned (destroyed). */ contract KWATT_Token is PausableToken { string public name = \"4NEW\"; string public symbol = \"KWATT\"; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 300000000000000000000000000; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = totalSupply_; } } "}
{"sol name": "594.sol", "label": 0, "sol content": "library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract IZIToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"IZI\"; name = \"IZI TOKEN\"; decimals = 0; _totalSupply = 100000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "850.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // IINE token contract // // Deployed to : 0x88d591d9e7229c6994449E456E215AF812D3cf3C // Symbol      : IINE // Name        : IINE Token // Total supply: 500000000 // Decimals    : 18 // // Enjoy. // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract IINEToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function IINEToken() public { symbol = \"IINE\"; name = \"IINE Token\"; decimals = 18; _totalSupply = 500000000000000000000000000; balances[0x88d591d9e7229c6994449E456E215AF812D3cf3C] = _totalSupply; Transfer(address(0), 0x88d591d9e7229c6994449E456E215AF812D3cf3C, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "263.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /* suport  tocoin.com * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510 \u252c \u250c\u2500\u2510    \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510 *  \u2502 \u2502 \u2502\u2502  \u2502 \u2502 \u2502 \u2502 \u2502     \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502 *  \u2534 \u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534 \u2534 \u2534     \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534 */ interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } } "}
{"sol name": "763.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // File: contracts/SafeMath.sol /* Copyright 2018, All rights reserved. _      _ \\ \\    / / ___   ___  _ __ \\ \\  / / / _ \\ / _ \\| '_ \\ \\ \\/ / |  __/|  __/| | | | \\__/   \\___| \\___||_| |_| @title SafeMath @author OpenZeppelin @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: contracts/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); using SafeMath for uint256; uint256 public startdate; function Ownable() public { owner = msg.sender; startdate = now; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: contracts/Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); mapping(address => uint256) private _lock_list_period; mapping(address => bool) private _lock_list; bool public paused = false; mapping(address => uint256) internal _balances; uint256 internal _tokenSupply; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * */ modifier isLockAddress() { check_lock_period(msg.sender); if(_lock_list[msg.sender]){ revert(); } _; } function check_lock_period(address check_address) { if(now > _lock_list_period[check_address] && _lock_list[check_address]){ _lock_list[check_address] = false; _tokenSupply = _tokenSupply.add(_balances[check_address]); } } function check_period(address check_address) constant public returns(uint256){ return _lock_list_period[check_address]; } function check_lock(address check_address) constant public returns(bool){ return _lock_list[check_address]; } /** * */ function set_lock_list(address lock_address, uint period) onlyOwner external { _lock_list_period[lock_address] = startdate + (period * 1 minutes); _lock_list[lock_address]  = true; _tokenSupply = _tokenSupply.sub(_balances[lock_address]); } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } // File: contracts/ERC20Token.sol /* Copyright 2018, All rights reserved. _      _ \\ \\    / / ___   ___  _ __ \\ \\  / / / _ \\ / _ \\| '_ \\ \\ \\/ / |  __/|  __/| | | | \\__/   \\___| \\___||_| |_| @title Veen Token Contract. @description ERC-20 Interface */ interface ERC20Token { function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // File: contracts/ERC223.sol interface ERC223 { function totalSupply() public constant returns (uint); function balanceOf(address who) public constant returns (uint); function transfer(address to, uint value) public returns (bool); } // File: contracts/Receiver_Interface.sol /* * Contract that is working with ERC223 tokens */ contract ContractReceiver { struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); /* tkn variable is analogue of msg variable of Ether transaction *  tkn.sender is person who initiated this token transaction   (analogue of msg.sender) *  tkn.value the number of tokens that were sent   (analogue of msg.value) *  tkn.data is data of token transaction   (analogue of msg.data) *  tkn.sig is 4 bytes signature of function *  if data of token transaction is a function execution */ } } // File: contracts/Veen.sol /* Copyright 2018, All rights reserved. _      _ \\ \\    / / ___   ___  _ __ \\ \\  / / / _ \\ / _ \\| '_ \\ \\ \\/ / |  __/|  __/| | | | \\__/   \\___| \\___||_| |_| @title Veen Token Contract. @description Veen token is a ERC20-compliant token. */ contract Veen is ERC20Token, Pausable, ERC223{ using SafeMath for uint; string public constant name = \"Veen\"; string public constant symbol = \"VEEN\"; uint8 public constant decimals = 18; uint private _totalSupply; mapping(address => mapping(address => uint256)) private _allowed; event MintedLog(address to, uint256 amount); event Transfer(address indexed from, address indexed to, uint value); function Veen() public { _tokenSupply = 0; _totalSupply = 15000000000 * (uint256(10) ** decimals); } function totalSupply() public constant returns (uint256) { return _tokenSupply; } function mint(address to, uint256 amount) onlyOwner public returns (bool){ amount = amount * (uint256(10) ** decimals); if(_totalSupply + 1 > (_tokenSupply+amount)){ _tokenSupply = _tokenSupply.add(amount); _balances[to]= _balances[to].add(amount); emit MintedLog(to, amount); return true; } return false; } function dist_list_set(address[] dist_list, uint256[] token_list) onlyOwner external{ for(uint i=0; i < dist_list.length ;i++){ transfer(dist_list[i],token_list[i]); } } function balanceOf(address tokenOwner) public constant returns (uint256 balance) { return _balances[tokenOwner]; } function transfer(address to, uint tokens) whenNotPaused isLockAddress public returns(bool success){ bytes memory empty; if(isContract(to)) { return transferToContract(to, tokens, empty); } else { return transferToAddress(to, tokens, empty); } } function approve(address spender, uint256 tokens) public returns (bool success) { if (tokens > 0 && balanceOf(msg.sender) >= tokens) { _allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } return false; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return _allowed[tokenOwner][spender]; } function transferFrom(address from, address to, uint256 tokens) public returns (bool success) { if (tokens > 0 && balanceOf(from) >= tokens && _allowed[from][msg.sender] >= tokens) { _balances[from] = _balances[from].sub(tokens); _allowed[from][msg.sender] = _allowed[from][msg.sender].sub(tokens); _balances[to] = _balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } return false; } function burn(uint256 tokens) public returns (bool success) { if ( tokens > 0 && balanceOf(msg.sender) >= tokens ) { _balances[msg.sender] = _balances[msg.sender].sub(tokens); _tokenSupply = _tokenSupply.sub(tokens); return true; } return false; } function transferToAddress(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); _balances[msg.sender] = balanceOf(msg.sender).sub(_value); _balances[_to] = balanceOf(_to).add(_value); emit Transfer(msg.sender, _to, _value); return true; } //function that is called when transaction target is a contract function transferToContract(address _to, uint _value, bytes _data) private returns (bool success) { if (balanceOf(msg.sender) < _value) revert(); _balances[msg.sender] = balanceOf(msg.sender).sub(_value); _balances[_to] = balanceOf(_to).add(_value); ContractReceiver receiver = ContractReceiver(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value); return true; } function isContract(address _addr) view returns (bool is_contract){ uint length; assembly { length := extcodesize(_addr) } return (length>0); } function () public payable { throw; } } "}
{"sol name": "810.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'FAKENEWS' token contract // // Deployed to : 0xA91e24CE3736B2723015C109eb82447430bcC3A5 // Symbol      : NEWS // Name        : Fake News Token // Total supply: 70000000 // Decimals    : 18 // // // // We are the eyes of the internet // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract FakeNewsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function FakeNewsToken() public { symbol = \"NEWS\"; name = \"Fake News Token\"; decimals = 18; _totalSupply = 70000000000000000000000000; balances[0xA91e24CE3736B2723015C109eb82447430bcC3A5] = _totalSupply; Transfer(address(0), 0xA91e24CE3736B2723015C109eb82447430bcC3A5, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1791.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;                       //\u865a\u62df\u6c34\u8d38\u6613\u94feVirtual water trade chain string public symbol; uint8 public decimals = 18; uint256 public totalSupply;                 // \u865a\u62df\u6c34\u8d38\u6613\u94feVirtual water trade chain mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "445.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Tcoin' token contract // // Deployed to : 0xd6b72d0e2D99565f67a18e2235a8Ac595cbcE55A // Symbol      : EMC // Name        : EduMetrix // Total supply: 1000000000000000000000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract EduMetrix is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function EduMetrix() public { symbol = \"EMC\"; name = \"EduMetrix\"; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xd6b72d0e2D99565f67a18e2235a8Ac595cbcE55A] = _totalSupply; Transfer(address(0), 0xd6b72d0e2D99565f67a18e2235a8Ac595cbcE55A, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "678.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT232493' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT232493 // Name        : ADZbuzz 24ur.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT232493\"; name = \"ADZbuzz 24ur.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "660.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract DragonLifeChain is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; } modifier onlyOwner { require(msg.sender == owner); _; } modifier isLock { require(!lock); _; } function setLock(bool _lock) onlyOwner public{ lock = _lock; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function _transfer(address _from, address _to, uint _value) isLock internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } function mintToken(address target, uint256 mintedAmount) onlyOwner public { uint256 _amount = mintedAmount * 10 ** uint256(decimals); balanceOf[target] += _amount; totalSupply += _amount; emit Transfer(this, target, _amount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transferBatch(address[] _to, uint256 _value) public returns (bool success) { for (uint i=0; i<_to.length; i++) { _transfer(msg.sender, _to[i], _value); } return true; } } "}
{"sol name": "557.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract ptxToken { using SafeMath for uint256; string public constant symbol = \"PTX\"; string public constant name = \"ptx Token\"; uint8 public constant decimals = 18; uint256 _totalSupply = 1000000000 * 10 ** uint256(decimals); // Owner of this contract address public owner; // Balances for each account mapping(address => uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address => mapping (address => uint256)) allowed; // Constructor function ptxToken() public { owner = msg.sender; balances[owner] = _totalSupply; } // ERC20 function totalSupply() public constant returns (uint256) { return _totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) public returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0) { balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) public returns (bool success) { if(balances[msg.sender]>=_amount && _amount>0) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } else { return false; } } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); // custom function getMyBalance() public view returns (uint) { return balances[msg.sender]; } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "1727.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a * b; assert(c >= a); return c; } } contract Token { function transferFrom(address from, address to, uint256 tokens) public returns (bool success); function transfer(address to, uint256 tokens) public returns (bool success); } contract TokenLiquidityContract { using SafeMath for uint256; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; } modifier trading_activated() { require(trading_deactivated == false); _; } constructor(address _traded_token,uint256 _eth_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public { admin = msg.sender; traded_token = _traded_token; eth_seed_amount = _eth_seed_amount; traded_token_seed_amount = _traded_token_seed_amount; commission_ratio = _commission_ratio; } function transferTokensThroughProxyToContract(address _from, address _to, uint256 _amount) private { traded_token_balance = traded_token_balance.add(_amount); require(Token(traded_token).transferFrom(_from,_to,_amount)); } function transferTokensFromContract(address _to, uint256 _amount) private { traded_token_balance = traded_token_balance.sub(_amount); require(Token(traded_token).transfer(_to,_amount)); } function transferETHToContract() private { eth_balance = eth_balance.add(msg.value); } function transferETHFromContract(address _to, uint256 _amount) private { eth_balance = eth_balance.sub(_amount); _to.transfer(_amount); } function deposit_token(uint256 _amount) private { transferTokensThroughProxyToContract(msg.sender, this, _amount); } function deposit_eth() private { transferETHToContract(); } function withdraw_token(uint256 _amount) public only_admin { transferTokensFromContract(admin, _amount); } function withdraw_eth(uint256 _amount) public only_admin { transferETHFromContract(admin, _amount); } function set_traded_token_as_seeded() private { traded_token_is_seeded = true; } function set_eth_as_seeded() private { eth_is_seeded = true; } function seed_traded_token() public only_admin { require(!traded_token_is_seeded); set_traded_token_as_seeded(); deposit_token(traded_token_seed_amount); } function seed_eth() public payable only_admin { require(!eth_is_seeded); require(msg.value == eth_seed_amount); set_eth_as_seeded(); deposit_eth(); } function seed_additional_token(uint256 _amount) public only_admin { require(market_is_open()); deposit_token(_amount); } function seed_additional_eth() public payable only_admin { require(market_is_open()); deposit_eth(); } function market_is_open() private view returns(bool) { return (eth_is_seeded && traded_token_is_seeded); } function deactivate_trading() public only_admin { require(!trading_deactivated); trading_deactivated = true; } function reactivate_trading() public only_admin { require(trading_deactivated); trading_deactivated = false; } /// buyAmount*amountTokenA/(amountTokenB + buyAmount) /// buy: (tokenAmountInContract*_ethAmountFromBuyer)/(contract_eth_balamce + _ethAmountFromBuyer) /// sell: sellAmount*(contract_eth_balance)/(tokenAmount + sellAmount) function get_amount_sell(uint256 _amount) public view returns(uint256) { return eth_balance.mul(_amount) / traded_token_balance.add(_amount); } function get_amount_buy(uint256 _amount) public view returns(uint256) { return traded_token_balance.mul(_amount) / eth_balance.add(_amount); } function get_amount_minus_commission(uint256 _amount) private view returns(uint256) { return (_amount*(1 ether - commission_ratio))/(1 ether); } function activate_admin_commission() public only_admin { require(!admin_commission_activated); admin_commission_activated = true; } function deactivate_admin_comission() public only_admin { require(admin_commission_activated); admin_commission_activated = false; } function change_admin_commission(uint256 _new_commission_ratio) public only_admin { require(_new_commission_ratio != commission_ratio); commission_ratio = _new_commission_ratio; } function complete_sell_exchange(uint256 _amount_give) private { uint256 amount_get_ = get_amount_sell(_amount_give); // this is the amount that is transferred to the seller -minus the commision ANYWAY (even if admin_commission_activated is False) uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_); transferTokensThroughProxyToContract(msg.sender,this,_amount_give); // the commission is transferred to admin only if admin_commission_activated, but the commission is subtracted anyway if(admin_commission_activated) { transferETHFromContract(msg.sender,amount_get_minus_commission_); uint256 admin_commission_ = amount_get_ - amount_get_minus_commission_; transferETHFromContract(admin, admin_commission_); } else { transferETHFromContract(msg.sender,amount_get_); } } function complete_buy_exchange() private { // SAME problem that is in complete_sell_exchange uint256 amount_give_ = msg.value; uint256 amount_get_ = get_amount_buy(amount_give_); uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_); transferETHToContract(); if(admin_commission_activated) { transferTokensFromContract(msg.sender, amount_get_minus_commission_); // minus commision anyway? uint256 admin_commission_ = amount_get_ - amount_get_minus_commission_; // not safe if commision is calculated in a weird way? transferTokensFromContract(admin, admin_commission_); } else { transferTokensFromContract(msg.sender, amount_get_); } } function sell_tokens(uint256 _amount_give) public trading_activated { require(market_is_open()); complete_sell_exchange(_amount_give); } function buy_tokens() private trading_activated { require(market_is_open()); complete_buy_exchange(); } function() public payable { buy_tokens(); } } "}
{"sol name": "1648.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract NOIATOKEN { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "937.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; // openzeppelin-solidity: 1.9.0 /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract FrameCoin is PausableToken { string public constant name = \"FrameCoin\"; string public constant symbol = \"FRAC\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 265e6 * 10**uint256(decimals); function FrameCoin() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(0x0, msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "548.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /* * Creator: IDX (INDEX TOKEN) */ /* * Abstract Token Smart Contract * */ /* * Safe Math Smart Contract. * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * ERC-20 standard token interface, as defined * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>. */ contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * Abstract Token Smart Contract that could be used as a base contract for * ERC-20 token contracts. */ contract AbstractToken is Token, SafeMath { /** * Create new Abstract Token contract. */ function AbstractToken () { // Do nothing } /** * Get number of tokens currently belonging to given owner. * * @param _owner address to get number of tokens currently belonging to the *        owner of * @return number of tokens currently belonging to the owner of given address */ function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } /** * Transfer given number of tokens from message sender to given recipient. * * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } /** * Allow given spender to transfer given number of tokens from message sender. * @param _spender address to allow the owner of to transfer tokens from message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } /** * Tell how many tokens given spender is currently allowed to transfer from * given owner. * * @param _owner address to get number of tokens allowed to be transferred *        from the owner of * @param _spender address to get number of tokens allowed to be transferred *        by the owner of * @return number of tokens given spender is currently allowed to transfer *         from given owner */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } /** * Mapping from addresses of token holders to the numbers of tokens belonging * to these token holders. */ mapping (address => uint256) accounts; /** * Mapping from addresses of token holders to the mapping of addresses of * spenders to the allowances set by these token holders to these spenders. */ mapping (address => mapping (address => uint256)) private allowances; } /** * INDEX TOKEN smart contract. */ contract IDXToken is AbstractToken { /** * Maximum allowed number of tokens in circulation. * tokenSupply = tokensIActuallyWant * (10 ^ decimals) */ uint256 constant MAX_TOKEN_COUNT = 50000000 * (10**18); /** * Address of the owner of this smart contract. */ address private owner; /** * Frozen account list holder */ mapping (address => bool) private frozenAccount; /** * Current number of tokens in circulation. */ uint256 tokenCount = 0; /** * True if tokens transfers are currently frozen, false otherwise. */ bool frozen = false; /** * Create new token smart contract and make msg.sender the * owner of this smart contract. */ function IDXToken () { owner = msg.sender; } /** * Get total number of tokens in circulation. * * @return total number of tokens in circulation */ function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"INDEX TOKEN\"; string constant public symbol = \"IDX\"; uint8 constant public decimals = 18; /** * Transfer given number of tokens from message sender to given recipient. * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise */ function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } /** * Change how many tokens given spender is allowed to transfer from message * spender.  In order to prevent double spending of allowance, * To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender address to allow the owner of to transfer tokens from *        message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } /** * Create _value new tokens and give new created tokens to msg.sender. * May only be called by smart contract owner. * * @param _value number of tokens to create * @return true if tokens were created successfully, false otherwise */ function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); // adding transfer event and _from address as null address emit Transfer(0x0, msg.sender, _value); return true; } return false; } /** * Set new owner for the smart contract. * May only be called by smart contract owner. * * @param _newOwner address of new owner of the smart contract */ function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } /** * Freeze ALL token transfers. * May only be called by smart contract owner. */ function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } /** * Unfreeze ALL token transfers. * May only be called by smart contract owner. */ function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } /*A user is able to unintentionally send tokens to a contract * and if the contract is not prepared to refund them they will get stuck in the contract. * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to * prevent unintended Ether transfers. However, there\u2019s no such mechanism for token transfers. * so the below function is created */ function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } /** * Freeze specific account * May only be called by smart contract owner. */ function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } /** * Logged when token transfers were frozen. */ event Freeze (); /** * Logged when token transfers were unfrozen. */ event Unfreeze (); /** * Logged when a particular account is frozen. */ event FrozenFunds(address target, bool frozen); /** * when accidentally send other tokens are refunded */ event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "86.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BitFast is StandardToken, BurnableToken { string public constant name = \"BitFast\"; string public constant symbol = \"FAST\"; uint32 public constant decimals = 8; uint256 public INITIAL_SUPPLY = 5000000000000000; address public CrowdsaleAddress; bool public lockTransfers = true; event AcceptToken(address indexed from, uint256 value); constructor(address _CrowdsaleAddress) public { CrowdsaleAddress = _CrowdsaleAddress; totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } modifier onlyOwner() { // only Crowdsale contract require(msg.sender == CrowdsaleAddress); _; } // Override function transfer(address _to, uint256 _value) public returns(bool){ if (msg.sender != CrowdsaleAddress){ require(!lockTransfers, \"Transfers are prohibited in Crowdsale period\"); } return super.transfer(_to,_value); } // Override function transferFrom(address _from, address _to, uint256 _value) public returns(bool){ if (msg.sender != CrowdsaleAddress){ require(!lockTransfers, \"Transfers are prohibited in Crowdsale period\"); } return super.transferFrom(_from,_to,_value); } /** * @dev function accept tokens from users as a payment for servises and burn their * @dev can run only from crowdsale contract */ function acceptTokens(address _from, uint256 _value) public onlyOwner returns (bool){ require (balances[_from] >= _value); balances[_from] = balances[_from].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit AcceptToken(_from, _value); return true; } /** * @dev function transfer tokens from special address to users * @dev can run only from crowdsale contract */ function transferTokensFromSpecialAddress(address _from, address _to, uint256 _value) public onlyOwner returns (bool){ require (balances[_from] >= _value); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } function lockTransfer(bool _lock) public onlyOwner { lockTransfers = _lock; } function() external payable { revert(\"The token contract don`t receive ether\"); } } "}
{"sol name": "192.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract ETHHToken is TokenERC20 { /* Initializes contract with initial supply tokens to the creator of the contract */ function ETHHToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} } "}
{"sol name": "1987.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'CryptoSports' CROWDSALE token contract // // Deployed to : 0x5a3f767f1e3c6855c746f1563a17aafc8a361189 // Symbol      : SPORTS // Name        : CryptoSports // Total supply: 1000000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto & Daniel Bar with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // Forked by JorgeArturo. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract CryptoSportsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"SPORTS\"; name = \"CryptoSports\"; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 5,000 SPORTS Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 5200; } else { tokens = msg.value * 5000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); emit Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1914.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping(address => mapping(address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract PassportToken is PausableToken { string public name = \"Passport\"; string public symbol = \"PSPT\"; uint8 public decimals = 18; uint public INITIAL_SUPPLY = 10000000000; constructor() public{ totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "1978.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; contract TimeCard { string public suicaId; uint[] public timeList; uint[] public workTimeList; constructor(string mySuicaId) public { suicaId = mySuicaId; } function setTimeStamp(string mySuicaId, uint timeStamp) public { require(keccak256(abi.encodePacked(suicaId)) == keccak256(abi.encodePacked(mySuicaId))); timeList.push(timeStamp); if((timeList.length % 2 ) == 0 ) { uint startTime = timeList[timeList.length -2]; uint endTime = timeList[timeList.length -1]; uint workTime = getWorkTime(startTime, endTime); workTimeList.push(workTime); } } function getWorkTime(uint startTime, uint endTime) internal pure returns(uint){ uint workTime = endTime - startTime; return workTime; } } "}
{"sol name": "638.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract AMeiToken is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; } modifier onlyOwner { require(msg.sender == owner); _; } modifier isLock { require(!lock); _; } function setLock(bool _lock) onlyOwner public{ lock = _lock; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function _transfer(address _from, address _to, uint _value) isLock internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } function mintToken(address target, uint256 mintedAmount) onlyOwner public { uint256 _amount = mintedAmount * 10 ** uint256(decimals); balanceOf[target] += _amount; totalSupply += _amount; emit Transfer(this, target, _amount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transferBatch(address[] _to, uint256 _value) public returns (bool success) { for (uint i=0; i<_to.length; i++) { _transfer(msg.sender, _to[i], _value); } return true; } } "}
{"sol name": "174.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Common { event Pause(); event Unpause(); event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); bool public paused = false; address public owner; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } modifier onlyOwner() { require(msg.sender == owner); _; } constructor() public { owner = msg.sender; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract ERC20 { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract MagnetChain is Common,ERC20 { using SafeMath for uint256; event Burn(address indexed burner, uint256 value); mapping (address => mapping (address => uint256)) internal allowed; mapping(address => uint256) balances; uint256 totalSupply_; string public name = \"Magnet Chain\"; string public symbol = \"MTC\"; uint256 public decimals = 18; constructor() public { totalSupply_ = 100 * 100000000  * ( 10** decimals ); balances[msg.sender] = totalSupply_; emit Transfer(address(0x0), msg.sender, totalSupply_); } function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool){ allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool){ uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function burn(uint256 _value) onlyOwner public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } function() payable public { revert(); } } "}
{"sol name": "1733.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'RxI' token contract // // Deployed to : 0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e // Symbol      : RxI // Name        : RxI // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // Coding by Jarmo van de Seijp // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract RxI is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function RxI() public { symbol = \"RxI\"; name = \"RxI\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e] = _totalSupply; emit Transfer(address(0), 0x907bFacE9510bb8Ae9b3ff755266D4E4e255452e, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "646.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT238509' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT238509 // Name        : ADZbuzz Archdaily.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT238509\"; name = \"ADZbuzz Archdaily.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1820.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal pure returns (uint) { require(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; require(c >= a); return c; } function max(uint a, uint b) internal pure returns (uint) { return a >= b ? a : b; } function min(uint a, uint b) internal pure returns (uint) { return a < b ? a : b; } } // @title The Contract is Mongolian National MDEX Token Issue. // // @Author: Tim Wars // @Date: 2018.8.1 // @Seealso: ERC20 // contract MntToken { // === Event === event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event Burn(address indexed from, uint value); event TransferLocked(address indexed from, address indexed to, uint value, uint8 locktype); event Purchased(address indexed recipient, uint purchase, uint amount); // === Defined === using SafeMath for uint; // --- Owner Section --- address public owner; bool public frozen = false; // // --- ERC20 Token Section --- uint8 constant public decimals = 6; uint public totalSupply = 100*10**(8+uint256(decimals));  // ***** 100 * 100 Million string constant public name = \"MDEX Token | Mongolia National Blockchain Digital Assets Exchange Token\"; string constant public symbol = \"MNT\"; mapping(address => uint) ownerance; // Owner Balance mapping(address => mapping(address => uint)) public allowance; // Allower Balance // --- Locked Section --- uint8 LOCKED_TYPE_MAX = 2; // ***** Max locked type uint private constant RELEASE_BASE_TIME = 1533686888; // ***** (2018-08-08 08:08:08) Private Lock phase start datetime (UTC seconds) address[] private lockedOwner; mapping(address => uint) public lockedance; // Lockeder Balance mapping(address => uint8) public lockedtype; // Locked Type mapping(address => uint8) public unlockedstep; // Unlocked Step uint public totalCirculating; // Total circulating token amount // === Modifier === // --- Owner Section --- modifier isOwner() { require(msg.sender == owner); _; } modifier isNotFrozen() { require(!frozen); _; } // --- ERC20 Section --- modifier hasEnoughBalance(uint _amount) { require(ownerance[msg.sender] >= _amount); _; } modifier overflowDetected(address _owner, uint _amount) { require(ownerance[_owner] + _amount >= ownerance[_owner]); _; } modifier hasAllowBalance(address _owner, address _allower, uint _amount) { require(allowance[_owner][_allower] >= _amount); _; } modifier isNotEmpty(address _addr, uint _value) { require(_addr != address(0)); require(_value != 0); _; } modifier isValidAddress { assert(0x0 != msg.sender); _; } // --- Locked Section --- modifier hasntLockedBalance(address _checker) { require(lockedtype[_checker] == 0); _; } modifier checkLockedType(uint8 _locktype) { require(_locktype > 0 && _locktype <= LOCKED_TYPE_MAX); _; } // === Constructor === constructor() public { owner = msg.sender; ownerance[msg.sender] = totalSupply; totalCirculating = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); } // --- ERC20 Token Section --- function approve(address _spender, uint _value) isNotFrozen isValidAddress public returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); // must spend to 0 where pre approve balance. allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint _value) isNotFrozen isValidAddress overflowDetected(_to, _value) public returns (bool success) { require(ownerance[_from] >= _value); require(allowance[_from][msg.sender] >= _value); ownerance[_to] = ownerance[_to].add(_value); ownerance[_from] = ownerance[_from].sub(_value); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint balance) { balance = ownerance[_owner] + lockedance[_owner]; return balance; } function available(address _owner) public constant returns (uint) { return ownerance[_owner]; } function transfer(address _to, uint _value) public isNotFrozen isValidAddress isNotEmpty(_to, _value) hasEnoughBalance(_value) overflowDetected(_to, _value) returns (bool success) { ownerance[msg.sender] = ownerance[msg.sender].sub(_value); ownerance[_to] = ownerance[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } // --- Owner Section --- function transferOwner(address _newOwner) isOwner public returns (bool success) { if (_newOwner != address(0)) { owner = _newOwner; } return true; } function freeze() isOwner public returns (bool success) { frozen = true; return true; } function unfreeze() isOwner public returns (bool success) { frozen = false; return true; } function burn(uint _value) isNotFrozen isValidAddress hasEnoughBalance(_value) public returns (bool success) { ownerance[msg.sender] = ownerance[msg.sender].sub(_value); ownerance[0x0] = ownerance[0x0].add(_value); totalSupply = totalSupply.sub(_value); totalCirculating = totalCirculating.sub(_value); emit Burn(msg.sender, _value); return true; } // --- Locked Section --- function transferLocked(address _to, uint _value, uint8 _locktype) public isNotFrozen isOwner isValidAddress isNotEmpty(_to, _value) hasEnoughBalance(_value) hasntLockedBalance(_to) checkLockedType(_locktype) returns (bool success) { require(msg.sender != _to); ownerance[msg.sender] = ownerance[msg.sender].sub(_value); if (_locktype == 1) { lockedance[_to] = _value; lockedtype[_to] = _locktype; lockedOwner.push(_to); totalCirculating = totalCirculating.sub(_value); emit TransferLocked(msg.sender, _to, _value, _locktype); } else if (_locktype == 2) { uint _first = _value / 100 * 8; // prevent overflow ownerance[_to] = ownerance[_to].add(_first); lockedance[_to] = _value.sub(_first); lockedtype[_to] = _locktype; lockedOwner.push(_to); totalCirculating = totalCirculating.sub(_value.sub(_first)); emit Transfer(msg.sender, _to, _first); emit TransferLocked(msg.sender, _to, _value.sub(_first), _locktype); } return true; } // ***** // Because too many unlocking steps * accounts, it will burn lots of GAS !!!!!!!!!!!!!!!!!!!!!!!!!!! // Because too many unlocking steps * accounts, it will burn lots of GAS !!!!!!!!!!!!!!!!!!!!!!!!!!! // // LockedType 1 : after 6 monthes / release 10 % per month; 10 steps // LockedType 2 :  before 0 monthes / release 8 % per month; 11 steps / 1 step has release real balance init. function unlock(address _locker, uint _delta, uint8 _locktype) private returns (bool success) { if (_locktype == 1) { if (_delta < 6 * 30 days) { return false; } uint _more1 = _delta.sub(6 * 30 days); uint _step1 = _more1 / 30 days; for(uint8 i = 0; i < 10; i++) { if (unlockedstep[_locker] == i && i < 9 && i <= _step1 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (10 - i)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (10 - i)); unlockedstep[_locker] = i + 1; } else if (i == 9 && unlockedstep[_locker] == 9 && _step1 == 9){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } else if (_locktype == 2) { if (_delta < 30 days) { return false; } uint _more2 = _delta - 30 days; uint _step2 = _more2 / 30 days; for(uint8 j = 0; j < 11; j++) { if (unlockedstep[_locker] == j && j < 10 && j <= _step2 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (11 - j)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (11 - j)); unlockedstep[_locker] = j + 1; } else if (j == 10 && unlockedstep[_locker] == 10 && _step2 == 10){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } return true; } function lockedCounts() public view returns (uint counts) { return lockedOwner.length; } function releaseLocked() public isNotFrozen returns (bool success) { require(now > RELEASE_BASE_TIME); uint delta = now - RELEASE_BASE_TIME; uint lockedAmount; for (uint i = 0; i < lockedOwner.length; i++) { if ( lockedance[lockedOwner[i]] > 0) { lockedAmount = lockedance[lockedOwner[i]]; unlock(lockedOwner[i], delta, lockedtype[lockedOwner[i]]); totalCirculating = totalCirculating.add(lockedAmount - lockedance[lockedOwner[i]]); } } return true; } } "}
{"sol name": "1668.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Atomz Token * @dev atomz.io token contract. */ contract ATZToken is StandardToken { string public constant name = \"Atomz Token\"; string public constant symbol = \"ATZ\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 25000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "812.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract BeatProfitMembership{ address owner= 0x6A3CACAbaA5958A0cA73bd3908445d81852F3A7E; uint256 [] priceOfPeriod = [10000000000000000, 30000000000000000,300000000000000000,2000000000000000000, 5000000000000000000]; uint256 [] TimeInSec = [3600, 86400,2592000,31536000]; mapping (address => uint256) public DueTime; mapping (address => bool) public Premium; constructor() public { DueTime[owner] = 4689878400; DueTime[0x491cFe3e5eF0C093971DaDdaBce7747EA69A991E] = 4689878400; DueTime[0x2ECc452E01f748183d697be4cb1db0531cc8F38F] = 4689878400; DueTime[0x353507473A89184e28E8F13e156Dc8055fD62A2C] = 4689878400; Premium[0x491cFe3e5eF0C093971DaDdaBce7747EA69A991E] = true; Premium[0x2ECc452E01f748183d697be4cb1db0531cc8F38F] = true; Premium[0x353507473A89184e28E8F13e156Dc8055fD62A2C] = true; } function extendMembership(uint256 _type) public payable{ // Type:[0]:hour, [1]:day, [2]:month, [3]:year, [4]:premium require(msg.value >= priceOfPeriod[_type], \"Payment Amount Wrong.\"); if(_type==4){ // Premium Membership Premium[msg.sender] = true; DueTime[msg.sender] = 4689878400; } else if(DueTime[msg.sender]>now){ DueTime[msg.sender] += mul(div(msg.value, priceOfPeriod[_type]), TimeInSec[_type]); } else{ DueTime[msg.sender] = now + mul(div(msg.value, priceOfPeriod[_type]), TimeInSec[_type]); } owner.transfer(msg.value); } function setPrice(uint256 [] new_prices) public{ require(msg.sender == owner, \"Only Available to BeatProfit Core Team\"); priceOfPeriod[0] = new_prices[0]; priceOfPeriod[1] = new_prices[1]; priceOfPeriod[2] = new_prices[2]; priceOfPeriod[3] = new_prices[3]; priceOfPeriod[4] = new_prices[4]; } function setMemberShip(address user, uint256 _timestamp) public { require(msg.sender==owner); DueTime[user]=_timestamp; } //   Safe Math Functions function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) {return a / b;} function sub(uint256 a, uint256 b) internal pure returns (uint256) {assert(b <= a); return a - b;} function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } "}
{"sol name": "920.sol", "label": 0, "sol content": "// // //  Quantumpay Airdropper // // (c) Quantumpay 2018 // // pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; function Ownable() { owner = msg.sender; } modifier onlyOwner() { if (msg.sender != owner) { revert(); } _; } function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract ERC20Basic { uint public totalSupply; function balanceOf(address who) constant returns (uint); function transfer(address to, uint value); event Transfer(address indexed from, address indexed to, uint value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint); function transferFrom(address from, address to, uint value); function approve(address spender, uint value); event Approval(address indexed owner, address indexed spender, uint value); } contract QuantumpayAirdropper is Ownable { function multisend(address _tokenAddr, address[] dests, uint256[] values) onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { ERC20(_tokenAddr).transfer(dests[i], values[i]); i += 1; } return(i); } } "}
{"sol name": "997.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused returns(bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused returns(bool) { paused = false; emit Unpause(); return true; } } contract ERC20 { uint256 public totalSupply; function transfer(address _to, uint256 _value) public returns(bool success); function transferFrom(address _from, address _to, uint256 _value) public returns(bool success); function balanceOf(address _owner) constant public returns(uint256 balance); function approve(address _spender, uint256 _value) public returns(bool success); function allowance(address _owner, address _spender) constant public returns(uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract BasicToken is ERC20, Pausable { using SafeMath for uint256; event Frozen(address indexed _address, bool _value); mapping(address => uint256) balances; mapping(address => bool) public frozens; mapping(address => mapping(address => uint256)) allowed; function _transfer(address _from, address _to, uint256 _value) internal returns(bool success) { require(_to != 0x0); require(_value > 0); require(frozens[_from] == false); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); emit Transfer(_from, _to, _value); return true; } function transfer(address _to, uint256 _value) public whenNotPaused returns(bool success) { require(balances[msg.sender] >= _value); return _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns(bool success) { require(balances[_from] >= _value); require(allowed[_from][msg.sender] >= _value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); return _transfer(_from, _to, _value); } function balanceOf(address _owner) constant public returns(uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns(bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns(uint256 remaining) { return allowed[_owner][_spender]; } function freeze(address[] _targets, bool _value) public onlyOwner returns(bool success) { require(_targets.length > 0); require(_targets.length <= 255); for (uint8 i = 0; i < _targets.length; i++) { assert(_targets[i] != 0x0); frozens[_targets[i]] = _value; emit Frozen(_targets[i], _value); } return true; } function transferMulti(address[] _to, uint256[] _value) public whenNotPaused returns(bool success) { require(_to.length > 0); require(_to.length <= 255); require(_to.length == _value.length); require(frozens[msg.sender] == false); uint8 i; uint256 amount; for (i = 0; i < _to.length; i++) { assert(_to[i] != 0x0); assert(_value[i] > 0); amount = amount.add(_value[i]); } require(balances[msg.sender] >= amount); balances[msg.sender] = balances[msg.sender].sub(amount); for (i = 0; i < _to.length; i++) { balances[_to[i]] = balances[_to[i]].add(_value[i]); emit Transfer(msg.sender, _to[i], _value[i]); } return true; } } contract UCToken is BasicToken { string public constant name = \"UnityChainToken\"; string public constant symbol = \"UCT\"; uint256 public constant decimals = 18; constructor() public { // \u79c1\u52df _assign(0x490657f65380fe9e47ab46671B9CE7d02a06dF40, 1500); // \u56e2\u961f _assign(0xA0d5366E74E56Be39542BD6125897E30775C7bd8, 1500); // \u5546\u57ce\u8fd4\u5229 _assign(0xDdb844341f70DC7FB45Ca27E26cB5a131823AE74, 1000); // \u63a8\u5e7f\u5206\u7ea2 _assign(0xfdE4884AD60012b80c1E57cCf4526d38746899a0, 250); // \u6301\u4ed3\u5206\u7ea2 _assign(0xf5Cfb87CAe4bC2D314D824De5B1B7a9F00Ef30Ee, 250); // \u4ea4\u6613\u5206\u7ea2 _assign(0xbbFc3e1Fc45fEDaA9FaB4fF1f74374ED4f217b4c, 250); // \u4e8c\u6b21\u5206\u7ea2 _assign(0x2EAdc466b18bAb66369C52CF8F37DAf383F793a7, 250); } function _assign(address _address, uint256 _value) private { uint256 amount = _value * (10 ** 6) * (10 ** decimals); balances[_address] = amount; allowed[_address][owner] = amount; totalSupply = totalSupply.add(amount); } } "}
{"sol name": "133.sol", "label": 0, "sol content": "/* ==================================================================== */ /* Copyright (c) 2018 The TokenTycoon Project.  All rights reserved. /* /* https://tokentycoon.io /* /* authors [email\u00a0protected] /*         [email\u00a0protected] /* ==================================================================== */ pragma solidity ^0.4.23; /// @title ERC-165 Standard Interface Detection /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md interface ERC165 { function supportsInterface(bytes4 interfaceID) external view returns (bool); } /// @title ERC-721 Non-Fungible Token Standard /// @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md contract ERC721 is ERC165 { event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) external view returns (uint256); function ownerOf(uint256 _tokenId) external view returns (address); function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external; function safeTransferFrom(address _from, address _to, uint256 _tokenId) external; function transferFrom(address _from, address _to, uint256 _tokenId) external; function approve(address _approved, uint256 _tokenId) public; function setApprovalForAll(address _operator, bool _approved) external; function getApproved(uint256 _tokenId) external view returns (address); function isApprovedForAll(address _owner, address _operator) external view returns (bool); } /// @title ERC-721 Non-Fungible Token Standard interface ERC721TokenReceiver { function onERC721Received(address _from, uint256 _tokenId, bytes data) external returns(bytes4); } /// @title ERC-721 Non-Fungible Token Standard, optional metadata extension interface ERC721Metadata /* is ERC721 */ { function name() external pure returns (string _name); function symbol() external pure returns (string _symbol); function tokenURI(uint256 _tokenId) external view returns (string); } /// @title ERC-721 Non-Fungible Token Standard, optional enumeration extension interface ERC721Enumerable /* is ERC721 */ { function totalSupply() external view returns (uint256); function tokenByIndex(uint256 _index) external view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256); } interface ERC721MetadataProvider { function tokenURI(uint256 _tokenId) external view returns (string); } contract AccessAdmin { bool public isPaused = false; address public addrAdmin; event AdminTransferred(address indexed preAdmin, address indexed newAdmin); constructor() public { addrAdmin = msg.sender; } modifier onlyAdmin() { require(msg.sender == addrAdmin); _; } modifier whenNotPaused() { require(!isPaused); _; } modifier whenPaused { require(isPaused); _; } function setAdmin(address _newAdmin) external onlyAdmin { require(_newAdmin != address(0)); emit AdminTransferred(addrAdmin, _newAdmin); addrAdmin = _newAdmin; } function doPause() external onlyAdmin whenNotPaused { isPaused = true; } function doUnpause() external onlyAdmin whenPaused { isPaused = false; } } interface TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract ManagerToken is ERC721, ERC721Metadata, ERC721Enumerable, AccessAdmin { /// @dev All manangers array(tokenId => gene) uint256[] public managerArray; /// @dev Mananger tokenId vs owner address mapping (uint256 => address) tokenIdToOwner; /// @dev Manangers owner by the owner (array) mapping (address => uint256[]) ownerToManagerArray; /// @dev Mananger token ID search in owner array mapping (uint256 => uint256) tokenIdToOwnerIndex; /// @dev The authorized address for each TTM mapping (uint256 => address) tokenIdToApprovals; /// @dev The authorized operators for each address mapping (address => mapping (address => bool)) operatorToApprovals; /// @dev Trust contract mapping (address => bool) safeContracts; /// @dev Metadata provider ERC721MetadataProvider public providerContract; /// @dev This emits when the approved address for an TTM is changed or reaffirmed. event Approval ( address indexed _owner, address indexed _approved, uint256 _tokenId ); /// @dev This emits when an operator is enabled or disabled for an owner. event ApprovalForAll ( address indexed _owner, address indexed _operator, bool _approved ); /// @dev This emits when the equipment ownership changed event Transfer ( address indexed from, address indexed to, uint256 tokenId ); constructor() public { addrAdmin = msg.sender; managerArray.length += 1; } // modifier /// @dev Check if token ID is valid modifier isValidToken(uint256 _tokenId) { require(_tokenId >= 1 && _tokenId <= managerArray.length, \"TokenId out of range\"); require(tokenIdToOwner[_tokenId] != address(0), \"Token have no owner\"); _; } modifier canTransfer(uint256 _tokenId) { address owner = tokenIdToOwner[_tokenId]; require(msg.sender == owner || msg.sender == tokenIdToApprovals[_tokenId] || operatorToApprovals[owner][msg.sender], \"Can not transfer\"); _; } // ERC721 function supportsInterface(bytes4 _interfaceId) external view returns(bool) { // ERC165 || ERC721 || ERC165^ERC721 return (_interfaceId == 0x01ffc9a7 || _interfaceId == 0x80ac58cd || _interfaceId == 0x8153916a) && (_interfaceId != 0xffffffff); } function name() public pure returns(string) { return \"Token Tycoon Managers\"; } function symbol() public pure returns(string) { return \"TTM\"; } function tokenURI(uint256 _tokenId) external view returns (string) { if (address(providerContract) == address(0)) { return \"\"; } return providerContract.tokenURI(_tokenId); } /// @dev Search for token quantity address /// @param _owner Address that needs to be searched /// @return Returns token quantity function balanceOf(address _owner) external view returns(uint256) { require(_owner != address(0), \"Owner is 0\"); return ownerToManagerArray[_owner].length; } /// @dev Find the owner of an TTM /// @param _tokenId The tokenId of TTM /// @return Give The address of the owner of this TTM function ownerOf(uint256 _tokenId) external view returns (address owner) { return tokenIdToOwner[_tokenId]; } /// @dev Transfers the ownership of an TTM from one address to another address /// @param _from The current owner of the TTM /// @param _to The new owner /// @param _tokenId The TTM to transfer /// @param data Additional data with no specified format, sent in call to `_to` function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) external whenNotPaused { _safeTransferFrom(_from, _to, _tokenId, data); } /// @dev Transfers the ownership of an TTM from one address to another address /// @param _from The current owner of the TTM /// @param _to The new owner /// @param _tokenId The TTM to transfer function safeTransferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused { _safeTransferFrom(_from, _to, _tokenId, \"\"); } /// @dev Transfer ownership of an TTM, '_to' must be a vaild address, or the TTM will lost /// @param _from The current owner of the TTM /// @param _to The new owner /// @param _tokenId The TTM to transfer function transferFrom(address _from, address _to, uint256 _tokenId) external whenNotPaused isValidToken(_tokenId) canTransfer(_tokenId) { address owner = tokenIdToOwner[_tokenId]; require(owner != address(0), \"Owner is 0\"); require(_to != address(0), \"Transfer target address is 0\"); require(owner == _from, \"Transfer to self\"); _transfer(_from, _to, _tokenId); } /// @dev Set or reaffirm the approved address for an TTM /// @param _approved The new approved TTM controller /// @param _tokenId The TTM to approve function approve(address _approved, uint256 _tokenId) public whenNotPaused { address owner = tokenIdToOwner[_tokenId]; require(owner != address(0)); require(msg.sender == owner || operatorToApprovals[owner][msg.sender]); tokenIdToApprovals[_tokenId] = _approved; emit Approval(owner, _approved, _tokenId); } /// @dev Enable or disable approval for a third party (\"operator\") to manage all your asset. /// @param _operator Address to add to the set of authorized operators. /// @param _approved True if the operators is approved, false to revoke approval function setApprovalForAll(address _operator, bool _approved) external whenNotPaused { operatorToApprovals[msg.sender][_operator] = _approved; emit ApprovalForAll(msg.sender, _operator, _approved); } /// @dev Get the approved address for a single TTM /// @param _tokenId The TTM to find the approved address for /// @return The approved address for this TTM, or the zero address if there is none function getApproved(uint256 _tokenId) external view isValidToken(_tokenId) returns (address) { return tokenIdToApprovals[_tokenId]; } /// @dev Query if an address is an authorized operator for another address /// @param _owner The address that owns the TTMs /// @param _operator The address that acts on behalf of the owner /// @return True if `_operator` is an approved operator for `_owner`, false otherwise function isApprovedForAll(address _owner, address _operator) external view returns (bool) { return operatorToApprovals[_owner][_operator]; } /// @dev Count TTMs tracked by this contract /// @return A count of valid TTMs tracked by this contract, where each one of ///  them has an assigned and queryable owner not equal to the zero address function totalSupply() external view returns (uint256) { return managerArray.length - 1; } /// @dev Enumerate valid TTMs /// @param _index A counter less than totalSupply /// @return The token identifier for the `_index`th TTM, function tokenByIndex(uint256 _index) external view returns (uint256) { require(_index < managerArray.length); return _index; } /// @notice Enumerate TTMs assigned to an owner /// @param _owner Token owner address /// @param _index A counter less than balanceOf(_owner) /// @return The TTM tokenId function tokenOfOwnerByIndex(address _owner, uint256 _index) external view returns (uint256) { require(_owner != address(0)); require(_index < ownerToManagerArray[_owner].length); return ownerToManagerArray[_owner][_index]; } /// @dev Do the real transfer with out any condition checking /// @param _from The old owner of this TTM(If created: 0x0) /// @param _to The new owner of this TTM /// @param _tokenId The tokenId of the TTM function _transfer(address _from, address _to, uint256 _tokenId) internal { if (_from != address(0)) { uint256 indexFrom = tokenIdToOwnerIndex[_tokenId]; uint256[] storage ttmArray = ownerToManagerArray[_from]; require(ttmArray[indexFrom] == _tokenId); if (indexFrom != ttmArray.length - 1) { uint256 lastTokenId = ttmArray[ttmArray.length - 1]; ttmArray[indexFrom] = lastTokenId; tokenIdToOwnerIndex[lastTokenId] = indexFrom; } ttmArray.length -= 1; if (tokenIdToApprovals[_tokenId] != address(0)) { delete tokenIdToApprovals[_tokenId]; } } tokenIdToOwner[_tokenId] = _to; ownerToManagerArray[_to].push(_tokenId); tokenIdToOwnerIndex[_tokenId] = ownerToManagerArray[_to].length - 1; emit Transfer(_from != address(0) ? _from : this, _to, _tokenId); } /// @dev Actually perform the safeTransferFrom function _safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes data) internal isValidToken(_tokenId) canTransfer(_tokenId) { address owner = tokenIdToOwner[_tokenId]; require(owner != address(0)); require(_to != address(0)); require(owner == _from); _transfer(_from, _to, _tokenId); // Do the callback after everything is done to avoid reentrancy attack uint256 codeSize; assembly { codeSize := extcodesize(_to) } if (codeSize == 0) { return; } bytes4 retval = ERC721TokenReceiver(_to).onERC721Received(_from, _tokenId, data); // bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\")) = 0xf0b9e5ba; require(retval == 0xf0b9e5ba); } function setSafeContract(address _actionAddr, bool _useful) external onlyAdmin { safeContracts[_actionAddr] = _useful; } function getSafeContract(address _actionAddr) external view onlyAdmin returns(bool) { return safeContracts[_actionAddr]; } function setMetadataProvider(address _provider) external onlyAdmin { providerContract = ERC721MetadataProvider(_provider); } function getOwnTokens(address _owner) external view returns(uint256[]) { require(_owner != address(0)); return ownerToManagerArray[_owner]; } function safeGiveByContract(uint256 _tokenId, address _to) external whenNotPaused { require(safeContracts[msg.sender]); // Only the token's owner is this can use this function require(tokenIdToOwner[_tokenId] == address(this)); require(_to != address(0)); _transfer(address(this), _to, _tokenId); } /// @dev Safe transfer by trust contracts function safeTransferByContract(uint256 _tokenId, address _to) external whenNotPaused { require(safeContracts[msg.sender]); require(_tokenId >= 1 && _tokenId <= managerArray.length); address owner = tokenIdToOwner[_tokenId]; require(owner != address(0)); require(_to != address(0)); require(owner != _to); _transfer(owner, _to, _tokenId); } function initManager(uint256 _gene, uint256 _count) external { require(safeContracts[msg.sender] || msg.sender == addrAdmin); require(_gene > 0 && _count <= 128); address owner = address(this); uint256[] storage ttmArray = ownerToManagerArray[owner]; uint256 newTokenId; for (uint256 i = 0; i < _count; ++i) { newTokenId = managerArray.length; managerArray.push(_gene); tokenIdToOwner[newTokenId] = owner; tokenIdToOwnerIndex[newTokenId] = ttmArray.length; ttmArray.push(newTokenId); emit Transfer(address(0), owner, newTokenId); } } function approveAndCall(address _spender, uint256 _tokenId, bytes _extraData) external whenNotPaused returns (bool success) { TokenRecipient spender = TokenRecipient(_spender); approve(_spender, _tokenId); spender.receiveApproval(msg.sender, _tokenId, this, _extraData); return true; } function getProtoIdByTokenId(uint256 _tokenId) external view returns(uint256 protoId) { if (_tokenId > 0 && _tokenId < managerArray.length) { return managerArray[_tokenId]; } } function getOwnerTokens(address _owner) external view returns(uint256[] tokenIdArray, uint256[] protoIdArray) { uint256[] storage ownTokens = ownerToManagerArray[_owner]; uint256 count = ownTokens.length; tokenIdArray = new uint256[](count); protoIdArray = new uint256[](count); for (uint256 i = 0; i < count; ++i) { tokenIdArray[i] = ownTokens[i]; protoIdArray[i] = managerArray[tokenIdArray[i]]; } } } "}
{"sol name": "507.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'GoCryptoCoin' token contract // // Deployed to : 0x4e46c85734c04ae0a7f24a1ca21368a58793c03e // Symbol      : GCC // Name        : GO Crypto Coin // Total supply: 1000000000 // Decimals    : 2 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract GoCryptoCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function GoCryptoCoin() public { symbol = \"GCC\"; name = \"GO Crypto Coin\"; decimals = 2; _totalSupply = 10000000000; balances[0x4e46c85734c04ae0a7f24a1ca21368a58793c03e] = _totalSupply; Transfer(address(0), 0x4e46c85734c04ae0a7f24a1ca21368a58793c03e, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "947.sol", "label": 0, "sol content": "pragma solidity 0.4.22; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event FrozenFunds(address target, uint tokens); event Buy(address indexed sender, uint eth, uint token); } // Owned contract contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } //Transfer owner rights, can use only owner (the best practice of secure for the contracts) function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } //Accept tranfer owner rights function acceptOwnership() public onlyOwner { emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // Pausable Contract contract Pausable is Owned { event Pause(); event Unpause(); bool public paused = false; //Modifier to make a function callable only when the contract is not paused. modifier whenNotPaused() { require(!paused); _; } //Modifier to make a function callable only when the contract is paused. modifier whenPaused() { require(paused); _; } //called by the owner to pause, triggers stopped state function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } //called by the owner to unpause, returns to normal state function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract GB is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) public balances; mapping(address => uint) public lockInfo; mapping(address => mapping(address => uint)) internal allowed; mapping (address => bool) public admins; modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; } function setAdmin(address _admin, bool isAdmin) public onlyOwner { admins[_admin] = isAdmin; } constructor() public{ symbol = 'GB'; name = 'Galaxy Block '; decimals = 18; _totalSupply = 1000000000*10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public view returns (uint) { return _totalSupply; } function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0);                                    // Prevent transfer to 0x0 address. Use burn() instead require(_value != 0);                                   // Prevent transfer 0 require(balances[_from] >= _value);                     // Check if the sender has enough require(balances[_from] - _value >= lockInfo[_from]);   // Check after transaction, balance is still more than locked value balances[_from] = balances[_from].sub(_value);          // Substract value from sender balances[_to] = balances[_to].add(_value);              // Add value to recipient emit Transfer(_from, _to, _value); } function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { _transfer(msg.sender, to, tokens); return true; } function approve(address _spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = tokens; emit Approval(msg.sender, _spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { require(allowed[from][msg.sender] >= tokens); _transfer(from, to, tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); return true; } function allowance(address tokenOwner, address spender) public whenNotPaused view returns (uint remaining) { return allowed[tokenOwner][spender]; } //Admin Tool function lockOf(address tokenOwner) public view returns (uint lockedToken) { return lockInfo[tokenOwner]; } //lock tokens or lock 0 to release all function lock(address target, uint lockedToken) public whenNotPaused onlyAdmin { lockInfo[target] = lockedToken; emit FrozenFunds(target, lockedToken); } //Batch lock amount with array function batchLockArray(address[] accounts, uint[] lockedToken) public whenNotPaused onlyAdmin { for (uint i = 0; i < accounts.length; i++) { lock(accounts[i], lockedToken[i]); } } function batchVipWtihLock(address[] receivers, uint[] tokens, bool freeze) public whenNotPaused onlyAdmin { for (uint i = 0; i < receivers.length; i++) { sendTokensWithLock(receivers[i], tokens[i], freeze); } } //Send token with lock function sendTokensWithLock (address receiver, uint tokens, bool freeze) public whenNotPaused onlyAdmin { _transfer(msg.sender, receiver, tokens); if(freeze) { uint lockedAmount = lockInfo[receiver] + tokens; lock(receiver, lockedAmount); } } //Send initial tokens function sendInitialTokens (address user) public onlyOwner { _transfer(msg.sender, user, balanceOf(owner)); } } "}
{"sol name": "884.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } library Math { function max64(uint64 _a, uint64 _b) internal pure returns (uint64) { return _a >= _b ? _a : _b; } function min64(uint64 _a, uint64 _b) internal pure returns (uint64) { return _a < _b ? _a : _b; } function max256(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a >= _b ? _a : _b; } function min256(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a < _b ? _a : _b; } } library SafeERC20 { function safeTransfer(ERC20Basic _token, address _to, uint256 _value) internal { require(_token.transfer(_to, _value)); } function safeTransferFrom( ERC20 _token, address _from, address _to, uint256 _value ) internal { require(_token.transferFrom(_from, _to, _value)); } function safeApprove(ERC20 _token, address _spender, uint256 _value) internal { require(_token.approve(_spender, _value)); } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); string public name = \"B2BCoin Classic\"; string public symbol = \"BBCC\"; uint256 public decimals = 18; bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } constructor () public { mint(msg.sender,1000000000000000000000000000); } function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } "}
{"sol name": "751.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'REEL' 'REEL Token' token contract // // Symbol      : REEL // Name        : Reel Token // Total supply: 120000000.0000000000 // Decimals    : 10 // // Enjoy. // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial REEL supply // ---------------------------------------------------------------------------- contract REELToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function REELToken() public { symbol = \"REEL\"; name = \"Reel Token\"; decimals = 10; _totalSupply = 120000000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "792.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title ERC20 * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } pragma solidity ^0.4.18; /** * @title TopPlayer token */ contract TopPlayerToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; string public name = \"Mu Chen Top Players\"; string public symbol = \"MCTP\"; uint256 public decimals = 18; function TopPlayerToken() public { totalSupply = 2000000000 * (10 ** decimals); balances[msg.sender] = totalSupply; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } "}
{"sol name": "904.sol", "label": 0, "sol content": "pragma solidity 0.4.21; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20 { function totalSupply()public view returns (uint total_Supply); function balanceOf(address _owner)public view returns (uint256 balance); function allowance(address _owner, address _spender)public view returns (uint remaining); function transferFrom(address _from, address _to, uint _amount)public returns (bool ok); function approve(address _spender, uint _amount)public returns (bool ok); function transfer(address _to, uint _amount)public returns (bool ok); event Transfer(address indexed _from, address indexed _to, uint _amount); event Approval(address indexed _owner, address indexed _spender, uint _amount); } contract REGO is ERC20 {using SafeMath for uint256; string public constant symbol = \"REGO\"; string public constant name = \"REGO\"; uint public constant decimals = 5; uint256 _totalSupply = 55000000 * 10 ** 5; // 55 Million Total Supply including 5 decimal // Owner of this contract address public owner; bool public burnTokenStatus; // Balances for each account mapping(address => uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address => mapping (address => uint256)) allowed; // Functions with this modifier can only be executed by the owner modifier onlyOwner() { require (msg.sender == owner); _; } // Constructor function REGO () public { owner = msg.sender; balances[owner] = _totalSupply; emit Transfer(0, owner, _totalSupply); } //Burning tokens function burntokens(uint256 tokens) external onlyOwner { require(!burnTokenStatus); require( tokens <= balances[owner]); burnTokenStatus = true; _totalSupply = (_totalSupply).sub(tokens); balances[owner] = balances[owner].sub(tokens); emit Transfer(owner, 0, tokens); } // what is the total supply of the ech tokens function totalSupply() public view returns (uint256 total_Supply) { total_Supply = _totalSupply; } // What is the balance of a particular account? function balanceOf(address _owner)public view returns (uint256 balance) { return balances[_owner]; } // Transfer the balance from owner's account to another account function transfer(address _to, uint256 _amount)public returns (bool ok) { require( _to != 0x0); require(balances[msg.sender] >= _amount && _amount >= 0); balances[msg.sender] = (balances[msg.sender]).sub(_amount); balances[_to] = (balances[_to]).add(_amount); emit Transfer(msg.sender, _to, _amount); return true; } // Send _value amount of tokens from address _from to address _to // The transferFrom method is used for a withdraw workflow, allowing contracts to send // tokens on your behalf, for example to \"deposit\" to a contract address and/or to charge // fees in sub-currencies; the command should fail unless the _from account has // deliberately authorized the sender of the message via some mechanism; we propose // these standardized APIs for approval: function transferFrom( address _from, address _to, uint256 _amount )public returns (bool ok) { require( _to != 0x0); require(balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount >= 0); balances[_from] = (balances[_from]).sub(_amount); allowed[_from][msg.sender] = (allowed[_from][msg.sender]).sub(_amount); balances[_to] = (balances[_to]).add(_amount); emit Transfer(_from, _to, _amount); return true; } // Allow _spender to withdraw from your account, multiple times, up to the _value amount. // If this function is called again it overwrites the current allowance with _value. function approve(address _spender, uint256 _amount)public returns (bool ok) { require( _spender != 0x0); allowed[msg.sender][_spender] = _amount; emit Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender)public view returns (uint256 remaining) { require( _owner != 0x0 && _spender !=0x0); return allowed[_owner][_spender]; } //In case the ownership needs to be transferred function transferOwnership(address newOwner) external onlyOwner { require( newOwner != 0x0); balances[newOwner] = (balances[newOwner]).add(balances[owner]); balances[owner] = 0; owner = newOwner; emit Transfer(msg.sender, newOwner, balances[newOwner]); } } "}
{"sol name": "231.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20 { function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner,address indexed spender,uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } contract ColorCoin is ERC20 { using SafeMath for uint256; mapping (address => mapping (address => uint256)) private allowed; mapping(address => uint256) private balances; mapping(address => bool) private lockedAddresses; address private admin; address private founder; bool public isTransferable = false; string public name; string public symbol; uint256 public totalSupply; uint8 public decimals; constructor(address _founder, address _admin) public { name = \"Color Coin\"; symbol = \"COL\"; totalSupply = 400000000000000000000000000; decimals = 18; admin = _admin; founder = _founder; balances[founder] = totalSupply; emit Transfer(0x0, founder, totalSupply); } modifier onlyAdmin { require(admin == msg.sender); _; } modifier onlyFounder { require(founder == msg.sender); _; } modifier transferable { require(isTransferable); _; } modifier notLocked { require(!lockedAddresses[msg.sender]); _; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function transfer(address _to, uint256 _value) transferable notLocked public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) transferable public returns (bool) { require(!lockedAddresses[_from]); require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) transferable notLocked public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function distribute(address _to, uint256 _value) onlyFounder public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function claimToken(address tokenContract, address _to, uint256 _value) onlyAdmin public returns (bool) { require(tokenContract != address(0)); require(_to != address(0)); require(_value > 0); ERC20 token = ERC20(tokenContract); return token.transfer(_to, _value); } function lock(address who) onlyAdmin public { lockedAddresses[who] = true; } function unlock(address who) onlyAdmin public { lockedAddresses[who] = false; } function isLocked(address who) public view returns(bool) { return lockedAddresses[who]; } function enableTransfer() onlyAdmin public { isTransferable = true; } function disableTransfer() onlyAdmin public { isTransferable = false; } } "}
{"sol name": "808.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Crypto Commonwealth token contract // // Deployed to : 0x445419a4644985a12346Bbd31C41f5017f3527E8 // Symbol      : COMM // Name        : Crypto Commonwealth // Total supply: 1000000000 // Decimals    : 18 // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard Interface // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract COMM is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"COMM\"; name = \"Crypto Commonwealth\"; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x445419a4644985a12346Bbd31C41f5017f3527E8] = _totalSupply; emit Transfer(address(0), 0x445419a4644985a12346Bbd31C41f5017f3527E8, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "781.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract QYQ is SafeMath{ string public name; string public symbol; uint8 public decimals = 8; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function QYQ( uint256 initialSupply, string tokenName, string tokenSymbol, address holder)  public{ totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply balanceOf[holder] = totalSupply;                       // Give the creator all initial tokens name = tokenName;                                      // Set the name for display purposes symbol = tokenSymbol;                                  // Set the symbol for display purposes owner = holder; } /* Send coins */ function transfer(address _to, uint256 _value) public{ require(_to != 0x0);  // Prevent transfer to 0x0 address. Use burn() instead require(_value > 0); require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) public returns (bool success) { require(_value > 0); allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != 0x0);                                // Prevent transfer to 0x0 address. Use burn() instead require(_value > 0); require(balanceOf[_from] >= _value);                 // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]);  // Check for overflows require(_value <= allowance[_from][msg.sender]);     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } function freeze(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) public returns (bool success) { require(freezeOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } } "}
{"sol name": "903.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"FSC\"; decimals = 4; totalSupply = 10000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]);   // ?????? balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); // ??????? emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract is owned { string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } // constructor function SelfDesctructionContract() { owner = msg.sender; } // a simple setter function function setSomeValue(string value){ someValue = value; } // you can call it anything you want function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "280.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract Ripple is BurnableToken, Ownable { string public constant name = \"Ripplecash coin\"; string public constant symbol = \"RCC\"; uint public constant decimals = 8; uint256 public constant initialSupply = 200000000 * (10 ** uint256(decimals)); // Constructor function Ripple() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; // Send all tokens to owner } } "}
{"sol name": "819.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender;  } modifier onlyOwner() { address sender =  msg.sender; address _owner = owner; require(msg.sender == _owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(0x0, _to, _amount); return true; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mintFinalize(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(0x0, _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title BrickToken * @dev Brick ERC20 Token that can be minted. * It is meant to be used in Brick crowdsale contract. */ contract BrickToken is MintableToken { string public constant name = \"Brick\"; string public constant symbol = \"BRK\"; uint8 public constant decimals = 18; function getTotalSupply() view public returns (uint256) { return totalSupply; } function transfer(address _to, uint256 _value) public returns (bool) { super.transfer(_to, _value); } } contract KycContractInterface { function isAddressVerified(address _address) public view returns (bool); } contract KycContract is Ownable { mapping (address => bool) verifiedAddresses; function isAddressVerified(address _address) public view returns (bool) { return verifiedAddresses[_address]; } function addAddress(address _newAddress) public onlyOwner { require(!verifiedAddresses[_newAddress]); verifiedAddresses[_newAddress] = true; } function removeAddress(address _oldAddress) public onlyOwner { require(verifiedAddresses[_oldAddress]); verifiedAddresses[_oldAddress] = false; } function batchAddAddresses(address[] _addresses) public onlyOwner { for (uint cnt = 0; cnt < _addresses.length; cnt++) { assert(!verifiedAddresses[_addresses[cnt]]); verifiedAddresses[_addresses[cnt]] = true; } } } /** * @title Brick Crowdsale * @dev This is Brick's crowdsale contract. */ contract BrickCrowdsale is Ownable { using SafeMath for uint256; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // amount of raised money in wei uint256 public weiRaised; uint256 public limitDateSale; // end date in units bool public isSoftCapHit = false; bool public isStarted = false; bool public isFinalized = false; // Token rates as per rounds uint256 icoPvtRate  = 40; uint256 icoPreRate  = 50; uint256 ico1Rate    = 65; uint256 ico2Rate    = 75; uint256 ico3Rate    = 90; // Tokens in each round // todo change values below uint256 public pvtTokens        = (40000) * (10**18); uint256 public preSaleTokens    = (6000000) * (10**18); uint256 public ico1Tokens       = (8000000) * (10**18); uint256 public ico2Tokens       = (8000000) * (10**18); uint256 public ico3Tokens       = (8000000) * (10**18); uint256 public totalTokens      = (40000000)* (10**18); // 40 million // todo change it to 4m // address where funds are collected // todo correct these address public advisoryEthWallet        = 0x15D44D6C86908605eFe349E5CBF0E8cd9878b7D2; address public infraEthWallet           = 0x3577333BE98FbC1698CfEEE72E19BF48278B51ec; address public techDevelopmentEthWallet = 0x4d0B70d8E612b5dca3597C64643a8d1efd5965e1; address public operationsEthWallet      = 0xb010a59C909667d1Ca00B43c0515959D6a98Bd28; // address where token will go address public wallet = 0x44d44CA0f75bdd3AE8806D02515E8268459c554A; // wallet where remaining tokens will go struct ContributorData { uint256 contributionAmountViewOnly; uint256 tokensIssuedViewOnly; uint256 contributionAmount; uint256 tokensIssued; } address[] public tokenSendFailures; mapping(address => ContributorData) public contributorList; mapping(uint => address) contributorIndexes; uint nextContributorIndex; constructor() public {} function init( uint256 _tokensForCrowdsale, uint256 _etherInUSD, address _tokenAddress, uint256 _softCapInEthers, uint256 _hardCapInEthers, uint _saleDurationInDays, address _kycAddress, uint bonus) onlyOwner public { // setTotalTokens(_totalTokens); setTokensForCrowdSale(_tokensForCrowdsale); setRate(_etherInUSD); setTokenAddress(_tokenAddress); setSoftCap(_softCapInEthers); setHardCap(_hardCapInEthers); setSaleDuration(_saleDurationInDays); setKycAddress(_kycAddress); setSaleBonus(bonus); kyc = KycContract(_kycAddress); start(); // starting the crowdsale } /** * @dev Must be called to start the crowdsale */ function start() onlyOwner public { require(!isStarted); require(!hasStarted()); require(tokenAddress != address(0)); require(kycAddress != address(0)); require(saleDuration != 0); require(totalTokens != 0); require(tokensForCrowdSale != 0); require(softCap != 0); require(hardCap != 0); starting(); emit BrickStarted(); isStarted = true; // endPvtSale(); } function splitTokens() internal { token.mint(techDevelopmentEthWallet,((totalTokens * 3).div(100))); //wallet for tech development tokensIssuedTillNow = tokensIssuedTillNow + ((totalTokens * 3).div(100)); token.mint(operationsEthWallet,((totalTokens * 7).div(100))); //wallet for operations wallet tokensIssuedTillNow = tokensIssuedTillNow + ((totalTokens * 7).div(100)); } uint256 public tokensForCrowdSale = 0; function setTokensForCrowdSale(uint256 _tokensForCrowdsale) onlyOwner public { tokensForCrowdSale = _tokensForCrowdsale * (10 ** 18); } uint256 public rate=0; uint256 public etherInUSD; function setRate(uint256 _etherInUSD) internal { etherInUSD = _etherInUSD; rate = (getCurrentRateInCents() * (10**18) / 100) / _etherInUSD; } function setRate(uint256 rateInCents, uint256 _etherInUSD) public onlyOwner { etherInUSD = _etherInUSD; rate = (rateInCents * (10**18) / 100) / _etherInUSD; } function updateRateInWei() internal { // this method requires that you must have called etherInUSD earliar, must not be called except when round is ending. require(etherInUSD != 0); rate = (getCurrentRateInCents() * (10**18) / 100) / etherInUSD; } function getCurrentRateInCents() public view returns (uint256) { if(currentRound == 1) { return icoPvtRate; } else if(currentRound == 2) { return icoPreRate; } else if(currentRound == 3) { return ico1Rate; } else if(currentRound == 4) { return  ico2Rate; } else if(currentRound == 5) { return ico3Rate; } else { return ico3Rate; } } // The token being sold BrickToken public token; address tokenAddress = 0x0; function setTokenAddress(address _tokenAddress) public onlyOwner { tokenAddress = _tokenAddress; // to check if token address is provided at start token = BrickToken(_tokenAddress); } function setPvtTokens (uint256 _pvtTokens)onlyOwner public { require(!icoPvtEnded); pvtTokens = (_pvtTokens) * (10 ** 18); } function setPreSaleTokens (uint256 _preSaleTokens)onlyOwner public { require(!icoPreEnded); preSaleTokens = (_preSaleTokens) * (10 ** 18); } function setIco1Tokens (uint256 _ico1Tokens)onlyOwner public { require(!ico1Ended); ico1Tokens = (_ico1Tokens) * (10 ** 18); } function setIco2Tokens (uint256 _ico2Tokens)onlyOwner public { require(!ico2Ended); ico2Tokens = (_ico2Tokens) * (10 ** 18); } function setIco3Tokens (uint256 _ico3Tokens)onlyOwner public { require(!ico3Ended); ico3Tokens = (_ico3Tokens) * (10 ** 18); } uint256 public softCap = 0; function setSoftCap(uint256 _softCap) onlyOwner public { softCap = _softCap * (10 ** 18); } uint256 public hardCap = 0; function setHardCap(uint256 _hardCap) onlyOwner public { hardCap = _hardCap * (10 ** 18); } // sale period (includes holidays) uint public saleDuration = 0; // in days ex: 60. function setSaleDuration(uint _saleDurationInDays) onlyOwner public { saleDuration = _saleDurationInDays; limitDateSale = startTime + (saleDuration * 1 days); endTime = limitDateSale; } address kycAddress = 0x0; function setKycAddress(address _kycAddress) onlyOwner public { kycAddress = _kycAddress; } uint public saleBonus = 0; // ex. 10 function setSaleBonus(uint bonus) public onlyOwner{ saleBonus = bonus; } bool public isKYCRequiredToReceiveFunds = false; // whether Kyc is required to receive funds. function setKYCRequiredToReceiveFunds(bool IS_KYCRequiredToReceiveFunds) public onlyOwner{ isKYCRequiredToReceiveFunds = IS_KYCRequiredToReceiveFunds; } bool public isKYCRequiredToSendTokens = false; // whether Kyc is required to send tokens. function setKYCRequiredToSendTokens(bool IS_KYCRequiredToSendTokens) public onlyOwner{ isKYCRequiredToSendTokens = IS_KYCRequiredToSendTokens; } // fallback function can be used to buy tokens function () public payable { buyPhaseTokens(msg.sender); } KycContract public kyc; function transferKycOwnerShip(address _address) onlyOwner public { kyc.transferOwnership(_address); } function transferTokenOwnership(address _address) onlyOwner public { token.transferOwnership(_address); } /** * release Tokens */ function releaseAllTokens() onlyOwner public { for(uint i=0; i < nextContributorIndex; i++) { address addressToSendTo = contributorIndexes[i]; // address of user releaseTokens(addressToSendTo); } } /** * release Tokens of an individual address */ function releaseTokens(address _contributerAddress) onlyOwner public { if(isKYCRequiredToSendTokens){ if(KycContractInterface(kycAddress).isAddressVerified(_contributerAddress)){ // if kyc needs to be checked at release time release(_contributerAddress); } } else { release(_contributerAddress); } } function release(address _contributerAddress) internal { if(contributorList[_contributerAddress].tokensIssued > 0) { if(token.mint(_contributerAddress, contributorList[_contributerAddress].tokensIssued)) { // tokens sent successfully contributorList[_contributerAddress].tokensIssued = 0; contributorList[_contributerAddress].contributionAmount = 0; } else { // token sending failed, has to be processed manually tokenSendFailures.push(_contributerAddress); } } } function tokenSendFailuresCount() public view returns (uint) { return tokenSendFailures.length; } function currentTokenSupply() public view returns(uint256){ return token.getTotalSupply(); } function buyPhaseTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); if(isKYCRequiredToReceiveFunds){ require(KycContractInterface(kycAddress).isAddressVerified(msg.sender)); } uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = computeTokens(weiAmount); //converts the wei to token amount require(isWithinTokenAllocLimit(tokens)); if(int(pvtTokens - tokensIssuedTillNow) > 0) { //phase1 80 require(int (tokens) < (int(pvtTokens -  tokensIssuedTillNow))); buyTokens(tokens,weiAmount,beneficiary); } else if (int (preSaleTokens + pvtTokens - tokensIssuedTillNow) > 0) {  //phase 2  80 require(int(tokens) < (int(preSaleTokens + pvtTokens - tokensIssuedTillNow))); buyTokens(tokens,weiAmount,beneficiary); } else if(int(ico1Tokens + preSaleTokens + pvtTokens - tokensIssuedTillNow) > 0) {  //phase3 require(int(tokens) < (int(ico1Tokens + preSaleTokens + pvtTokens -tokensIssuedTillNow))); buyTokens(tokens,weiAmount,beneficiary); } else if(int(ico2Tokens + ico1Tokens + preSaleTokens + pvtTokens - (tokensIssuedTillNow)) > 0) {  //phase4 require(int(tokens) < (int(ico2Tokens + ico1Tokens + preSaleTokens + pvtTokens - (tokensIssuedTillNow)))); buyTokens(tokens,weiAmount,beneficiary); }  else if(!ico3Ended && (int(tokensForCrowdSale - (tokensIssuedTillNow)) > 0)) { // 500 -400 require(int(tokens) < (int(tokensForCrowdSale - (tokensIssuedTillNow)))); buyTokens(tokens,weiAmount,beneficiary); } } uint256 public tokensIssuedTillNow=0; function buyTokens(uint256 tokens,uint256 weiAmount ,address beneficiary) internal { // update state - Add to eth raised weiRaised = weiRaised.add(weiAmount); if (contributorList[beneficiary].contributionAmount == 0) { // if its a new contributor, add him and increase index contributorIndexes[nextContributorIndex] = beneficiary; nextContributorIndex += 1; } contributorList[beneficiary].contributionAmount += weiAmount; contributorList[beneficiary].contributionAmountViewOnly += weiAmount; contributorList[beneficiary].tokensIssued += tokens; contributorList[beneficiary].tokensIssuedViewOnly += tokens; tokensIssuedTillNow = tokensIssuedTillNow + tokens; emit BrickTokenPurchase(msg.sender, beneficiary, weiAmount, tokens); } /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event BrickTokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); function investorCount() constant public returns(uint) { return nextContributorIndex; } function hasStarted() public constant returns (bool) { return (startTime != 0 && now > startTime); } // send ether to the fund collection wallet // function forwardFunds() internal { //     wallet.transfer(msg.value); // } // send ether to the fund collection wallet function forwardAllRaisedFunds() internal { require(advisoryEthWallet != address(0)); require(infraEthWallet != address(0)); require(techDevelopmentEthWallet != address(0)); require(operationsEthWallet != address(0)); operationsEthWallet.transfer((weiRaised * 60) / 100); advisoryEthWallet.transfer((weiRaised *5) / 100); infraEthWallet.transfer((weiRaised * 10) / 100); techDevelopmentEthWallet.transfer((weiRaised * 25) / 100); } function isWithinSaleTimeLimit() internal view returns (bool) { return now <= limitDateSale; } function isWithinSaleLimit(uint256 _tokens) internal view returns (bool) { return token.getTotalSupply().add(_tokens) <= tokensForCrowdSale; } function computeTokens(uint256 weiAmount) view internal returns (uint256) { return (weiAmount.div(rate)) * (10 ** 18); } function isWithinTokenAllocLimit(uint256 _tokens) view internal returns (bool) { return (isWithinSaleTimeLimit() && isWithinSaleLimit(_tokens)); } function didSoftCapReached() internal returns (bool) { if(weiRaised >= softCap){ isSoftCapHit = true; // setting the flag that soft cap is hit and all funds should be sent directly to wallet from now on. } else { isSoftCapHit = false; } return isSoftCapHit; } // overriding BrckBaseCrowdsale#validPurchase to add extra cap logic // @return true if investors can buy at the moment function validPurchase() internal constant returns (bool) { bool withinCap = weiRaised.add(msg.value) <= hardCap; bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return (withinPeriod && nonZeroPurchase) && withinCap && isWithinSaleTimeLimit(); } // overriding Crowdsale#hasEnded to add cap logic // @return true if crowdsale event has ended function hasEnded() public constant returns (bool) { bool capReached = weiRaised >= hardCap; return (endTime != 0 && now > endTime) || capReached; } event BrickStarted(); event BrickFinalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); // require(hasEnded()); finalization(); emit BrickFinalized(); isFinalized = true; } function starting() internal { startTime = now; limitDateSale = startTime + (saleDuration * 1 days); endTime = limitDateSale; } function finalization() internal { splitTokens(); token.mintFinalize(wallet, totalTokens.sub(tokensIssuedTillNow)); forwardAllRaisedFunds(); } //functions to manually end round sales uint256 public currentRound = 1; bool public icoPvtEnded = false; bool public icoPreEnded = false; bool public ico1Ended = false; bool public ico2Ended = false; bool public ico3Ended = false; function endPvtSale() onlyOwner public       //ending private sale { require(!icoPvtEnded); pvtTokens = tokensIssuedTillNow; currentRound = 2; updateRateInWei(); icoPvtEnded = true; } function endPreSale() onlyOwner public      //ending pre-sale { require(!icoPreEnded && icoPvtEnded); preSaleTokens = tokensIssuedTillNow - pvtTokens; currentRound = 3; updateRateInWei(); icoPreEnded = true; } function endIcoSaleRound1() onlyOwner public   //ending IcoSaleRound1 { require(!ico1Ended && icoPreEnded); ico1Tokens = tokensIssuedTillNow - preSaleTokens - pvtTokens; currentRound = 4; updateRateInWei(); ico1Ended = true; } function endIcoSaleRound2() onlyOwner public { require(!ico2Ended && ico1Ended); ico2Tokens = tokensIssuedTillNow - ico1Tokens - preSaleTokens - pvtTokens; currentRound = 5; updateRateInWei(); ico2Ended=true; } function endIcoSaleRound3() onlyOwner public  //ending IcoSaleRound3 { require(!ico3Ended && ico2Ended); ico3Tokens = tokensIssuedTillNow - ico2Tokens - ico1Tokens - preSaleTokens - pvtTokens; updateRateInWei(); ico3Ended = true; } modifier afterDeadline() { if (hasEnded() || isFinalized) _; } // a modifier to tell token sale ended /** * auto refund Tokens */ function refundAllMoney() onlyOwner public { for(uint i=0; i < nextContributorIndex; i++) { address addressToSendTo = contributorIndexes[i]; refundMoney(addressToSendTo); } } /** * refund Tokens of a single address */ function refundMoney(address _address) onlyOwner public { uint amount = contributorList[_address].contributionAmount; if (amount > 0 && _address.send(amount)) { // user got money back contributorList[_address].contributionAmount =  0; contributorList[_address].tokensIssued =  0; contributorList[_address].contributionAmountViewOnly =  0; contributorList[_address].tokensIssuedViewOnly =  0; } } } "}
{"sol name": "999.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * HeapX.io Smart Contract * / /** @title SafeMath */ library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; } uint256 c = _a * _b; assert(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a / _b; return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); uint256 c = _a - _b; return c;} function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; assert(c >= _a); return c;} } /** @title ERC20 interface */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); } /** @title Owner */ contract OwnerHeapX { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _;} function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } /** @title HeapX */ contract HeapX is OwnerHeapX, ERC20 { string  public name; string  public symbol; uint8   public decimals; uint256 public totalSupply_; address public owner; constructor() public { name = \"HeapX\"; symbol = \"HEAP\"; decimals = 9; totalSupply_ = 500000000000000000; owner = msg.sender; balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } using SafeMath for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; mapping (address => bool) public frozenAccount; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner,address indexed spender,uint256 value); event Burn(address indexed from, uint256 value); event FrozenFunds(address target, bool frozen); function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256){ return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); require(!frozenAccount[_to]); require(!frozenAccount[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom( address _from, address _to, uint256 _value) public returns (bool){ require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); require(!frozenAccount[_to]); require(!frozenAccount[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function increaseApproval(address _spender, uint256 _addedValue) public returns (bool){ allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subtractedValue) public returns (bool){ uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function burn(uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; totalSupply_ -= _value; emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "910.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } } contract HiBTCToken is PausableToken { string public name = \"HiBTCToken\"; string public symbol = \"HIBT\"; string public version = '1.0.0'; uint8 public decimals = 18; function HiBTCToken() { totalSupply = 10000000000 * (10**(uint256(decimals))); balances[msg.sender] = totalSupply; } function () { revert(); } } "}
{"sol name": "820.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: bancor-contracts/solidity/contracts/utility/interfaces/IOwned.sol /* Owned contract interface */ contract IOwned { // this function isn't abstract since the compiler emits automatically generated getter functions as external function owner() public view returns (address) {} function transferOwnership(address _newOwner) public; function acceptOwnership() public; } // File: bancor-contracts/solidity/contracts/utility/Owned.sol /* Provides support and utilities for contract ownership */ contract Owned is IOwned { address public owner; address public newOwner; event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner); /** @dev constructor */ constructor() public { owner = msg.sender; } // allows execution by the owner only modifier ownerOnly { assert(msg.sender == owner); _; } /** @dev allows transferring the contract ownership the new owner still needs to accept the transfer can only be called by the contract owner @param _newOwner    new contract owner */ function transferOwnership(address _newOwner) public ownerOnly { require(_newOwner != owner); newOwner = _newOwner; } /** @dev used by a new owner to accept an ownership transfer */ function acceptOwnership() public { require(msg.sender == newOwner); emit OwnerUpdate(owner, newOwner); owner = newOwner; newOwner = address(0); } } // File: bancor-contracts/solidity/contracts/token/interfaces/IERC20Token.sol /* ERC20 Standard Token interface */ contract IERC20Token { // these functions aren't abstract since the compiler emits automatically generated getter functions as external function name() public view returns (string) {} function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); } // File: bancor-contracts/solidity/contracts/utility/Utils.sol /* Utilities & Common Modifiers */ contract Utils { /** constructor */ constructor() public { } // verifies that an amount is greater than zero modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } // validates an address - currently only checks that it isn't null modifier validAddress(address _address) { require(_address != address(0)); _; } // verifies that the address is different than this contract address modifier notThis(address _address) { require(_address != address(this)); _; } // Overflow protected math functions /** @dev returns the sum of _x and _y, asserts if the calculation overflows @param _x   value 1 @param _y   value 2 @return sum */ function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; } /** @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number @param _x   minuend @param _y   subtrahend @return difference */ function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) { assert(_x >= _y); return _x - _y; } /** @dev returns the product of multiplying _x by _y, asserts if the calculation overflows @param _x   factor 1 @param _y   factor 2 @return product */ function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x * _y; assert(_x == 0 || z / _x == _y); return z; } } // File: bancor-contracts/solidity/contracts/utility/interfaces/ITokenHolder.sol /* Token Holder interface */ contract ITokenHolder is IOwned { function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public; } // File: bancor-contracts/solidity/contracts/utility/TokenHolder.sol /* We consider every contract to be a 'token holder' since it's currently not possible for a contract to deny receiving tokens. The TokenHolder's contract sole purpose is to provide a safety mechanism that allows the owner to send tokens that were sent to the contract by mistake back to their sender. */ contract TokenHolder is ITokenHolder, Owned, Utils { /** @dev constructor */ constructor() public { } /** @dev withdraws tokens held by the contract and sends them to an account can only be called by the owner @param _token   ERC20 token contract address @param _to      account to receive the new amount @param _amount  amount to withdraw */ function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); } } // File: bancor-contracts/solidity/contracts/token/ERC20Token.sol /** ERC20 Standard Token implementation */ contract ERC20Token is IERC20Token, Utils { string public standard = 'Token 0.1'; string public name = ''; string public symbol = ''; uint8 public decimals = 0; uint256 public totalSupply = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** @dev constructor @param _name        token name @param _symbol      token symbol @param _decimals    decimal points, for display purposes */ constructor(string _name, string _symbol, uint8 _decimals) public { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input name = _name; symbol = _symbol; decimals = _decimals; } /** @dev send coins throws on any error rather then return a false flag to minimize user errors @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors @param _from    source address @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool success) { allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value); balanceOf[_from] = safeSub(balanceOf[_from], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); emit Transfer(_from, _to, _value); return true; } /** @dev allow another account/contract to spend some tokens on your behalf throws on any error rather then return a false flag to minimize user errors also, to minimize the risk of the approve/transferFrom attack vector (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value @param _spender approved address @param _value   allowance amount @return true if the approval was successful, false if it wasn't */ function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) { // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } } // File: bancor-contracts/solidity/contracts/token/interfaces/ISmartToken.sol /* Smart Token interface */ contract ISmartToken is IOwned, IERC20Token { function disableTransfers(bool _disable) public; function issue(address _to, uint256 _amount) public; function destroy(address _from, uint256 _amount) public; } // File: bancor-contracts/solidity/contracts/token/SmartToken.sol /* Smart Token v0.3 'Owned' is specified here for readability reasons */ contract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder { string public version = '0.3'; bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory event NewSmartToken(address _token); // triggered when the total supply is increased event Issuance(uint256 _amount); // triggered when the total supply is decreased event Destruction(uint256 _amount); /** @dev constructor @param _name       token name @param _symbol     token short symbol, minimum 1 character @param _decimals   for display purposes only */ constructor(string _name, string _symbol, uint8 _decimals) public ERC20Token(_name, _symbol, _decimals) { emit NewSmartToken(address(this)); } // allows execution only when transfers aren't disabled modifier transfersAllowed { assert(transfersEnabled); _; } /** @dev disables/enables transfers can only be called by the contract owner @param _disable    true to disable transfers, false to enable them */ function disableTransfers(bool _disable) public ownerOnly { transfersEnabled = !_disable; } /** @dev increases the token supply and sends the new tokens to an account can only be called by the contract owner @param _to         account to receive the new amount @param _amount     amount to increase the supply by */ function issue(address _to, uint256 _amount) public ownerOnly validAddress(_to) notThis(_to) { totalSupply = safeAdd(totalSupply, _amount); balanceOf[_to] = safeAdd(balanceOf[_to], _amount); emit Issuance(_amount); emit Transfer(this, _to, _amount); } /** @dev removes tokens from an account and decreases the token supply can be called by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his/her own account @param _from       account to remove the amount from @param _amount     amount to decrease the supply by */ function destroy(address _from, uint256 _amount) public { require(msg.sender == _from || msg.sender == owner); // validate input balanceOf[_from] = safeSub(balanceOf[_from], _amount); totalSupply = safeSub(totalSupply, _amount); emit Transfer(_from, this, _amount); emit Destruction(_amount); } // ERC20 standard method overrides with some extra functionality /** @dev send coins throws on any error rather then return a false flag to minimize user errors in addition to the standard checks, the function throws if transfers are disabled @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transfer(_to, _value)); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors in addition to the standard checks, the function throws if transfers are disabled @param _from    source address @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transferFrom(_from, _to, _value)); return true; } } // File: contracts/BAYToken.sol /** * @title DAICO Bay Token * @dev DAICO Bay Token is a Smart Token based on Bancor Protocol */ contract BAYToken is SmartToken ( \"DAICO Bay Token\", \"BAY\", 18){ constructor() { issue(msg.sender, 10**10 * 10**18); } } "}
{"sol name": "7.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'weR' 'weR' // // Symbol      : weR // Name        : weR // Total supply: 500,000 // Decimals    : 18 // // // (c) BokkyPooBah / Bok Consulting Pty Ltd 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract weR is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function weR() public { symbol = \"weR\"; name = \"weR\"; decimals = 18; _totalSupply = 500000 * 10**uint(decimals); balances[owner] = _totalSupply; Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1988.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: openzeppelin-solidity/contracts/token/ERC20/CappedToken.sol /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } // File: contracts/HITToken.sol contract HITToken is CappedToken { string public name = \"HIT TOKEN\"; string public symbol = \"HIT\"; uint256 public decimals = 18; uint256 public cap = 1250000000  ether; constructor() CappedToken(cap) public {} } "}
{"sol name": "1969.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; //Slightly modified SafeMath library - includes a min function library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } function min(uint a, uint b) internal pure returns (uint256) { return a < b ? a : b; } } /** *This contract allows users to sign up for the DDA Cooperative Membership. *To complete membership DDA will provide instructions to complete KYC/AML verification *through a system external to this contract. */ contract Membership { using SafeMath for uint256; /*Variables*/ address public owner; //Memebership fees uint public memberFee; /*Structs*/ /** *@dev Keeps member information */ struct Member { uint memberId; uint membershipType; } /*Mappings*/ //Members information mapping(address => Member) public members; address[] public membersAccts; mapping (address => uint) public membersAcctsIndex; /*Events*/ event UpdateMemberAddress(address _from, address _to); event NewMember(address _address, uint _memberId, uint _membershipType); event Refund(address _address, uint _amount); /*Modifiers*/ modifier onlyOwner() { require(msg.sender == owner); _; } /*Functions*/ /** *@dev Constructor - Sets owner */ constructor() public { owner = msg.sender; } /* *@dev Updates the fee amount *@param _memberFee fee amount for member */ function setFee(uint _memberFee) public onlyOwner() { //define fee structure for the three membership types memberFee = _memberFee; } /** *@notice Allows a user to become DDA members if they pay the fee. However, they still have to complete *complete KYC/AML verification off line *@dev This creates and transfers the token to the msg.sender */ function requestMembership() public payable { Member storage sender = members[msg.sender]; require(msg.value >= memberFee && sender.membershipType == 0 ); membersAccts.push(msg.sender); sender.memberId = membersAccts.length; sender.membershipType = 1; emit NewMember(msg.sender, sender.memberId, sender.membershipType); } /** *@dev This updates/transfers the member address *@param _from is the current member address *@param _to is the address the member would like to update their current address with */ function updateMemberAddress(address _from, address _to) public onlyOwner { require(_to != address(0)); Member storage currentAddress = members[_from]; Member storage newAddress = members[_to]; require(newAddress.memberId == 0); newAddress.memberId = currentAddress.memberId; newAddress.membershipType = currentAddress.membershipType; membersAccts[currentAddress.memberId - 1] = _to; currentAddress.memberId = 0; currentAddress.membershipType = 0; emit UpdateMemberAddress(_from, _to); } /** *@dev Use this function to set membershipType for the member *@param _memberAddress address of member that we need to update membershipType *@param _membershipType type of membership to assign to member */ function setMembershipType(address _memberAddress,  uint _membershipType) public onlyOwner{ Member storage memberAddress = members[_memberAddress]; memberAddress.membershipType = _membershipType; } /** *@dev Use this function to set memberId for the member *@param _memberAddress address of member that we need to update membershipType *@param _memberId is the manually assigned memberId */ function setMemberId(address _memberAddress,  uint _memberId) public onlyOwner{ Member storage memberAddress = members[_memberAddress]; memberAddress.memberId = _memberId; } /** *@dev Use this function to remove member acct from array memberAcct *@param _memberAddress address of member to remove */ function removeMemberAcct(address _memberAddress) public onlyOwner{ require(_memberAddress != address(0)); uint256 indexToDelete; uint256 lastAcctIndex; address lastAdd; Member storage memberAddress = members[_memberAddress]; memberAddress.memberId = 0; memberAddress.membershipType = 0; indexToDelete = membersAcctsIndex[_memberAddress]; lastAcctIndex = membersAccts.length.sub(1); lastAdd = membersAccts[lastAcctIndex]; membersAccts[indexToDelete]=lastAdd; membersAcctsIndex[lastAdd] = indexToDelete; membersAccts.length--; membersAcctsIndex[_memberAddress]=0; } /** *@dev Use this function to member acct from array memberAcct *@param _memberAddress address of member to add */ function addMemberAcct(address _memberAddress) public onlyOwner{ require(_memberAddress != address(0)); Member storage memberAddress = members[_memberAddress]; membersAcctsIndex[_memberAddress] = membersAccts.length; membersAccts.push(_memberAddress); memberAddress.memberId = membersAccts.length; memberAddress.membershipType = 1; emit NewMember(_memberAddress, memberAddress.memberId, memberAddress.membershipType); } /** *@dev getter function to get all membersAccts */ function getMembers() view public returns (address[]){ return membersAccts; } /** *@dev Get member information *@param _memberAddress address to pull the memberId, membershipType and membership */ function getMember(address _memberAddress) view public returns(uint, uint) { return(members[_memberAddress].memberId, members[_memberAddress].membershipType); } /** *@dev Gets length of array containing all member accounts or total supply */ function countMembers() view public returns(uint) { return membersAccts.length; } /** *@dev Gets membership type *@param _memberAddress address to view the membershipType */ function getMembershipType(address _memberAddress) public constant returns(uint){ return members[_memberAddress].membershipType; } /** *@dev Allows the owner to set a new owner address *@param _new_owner the new owner address */ function setOwner(address _new_owner) public onlyOwner() { owner = _new_owner; } /** *@dev Refund money if KYC/AML fails *@param _to address to send refund *@param _amount to refund. If no amount  is specified the current memberFee is refunded */ function refund(address _to, uint _amount) public onlyOwner { require (_to != address(0)); if (_amount == 0) {_amount = memberFee;} removeMemberAcct(_to); _to.transfer(_amount); emit Refund(_to, _amount); } /** *@dev Allow owner to withdraw funds *@param _to address to send funds *@param _amount to send */ function withdraw(address _to, uint _amount) public onlyOwner { _to.transfer(_amount); } } "}
{"sol name": "1630.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * Powered by Daonomic (https://daonomic.io) */ contract Whitelist { function isInWhitelist(address addr) public view returns (bool); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract WhitelistImpl is Ownable, Whitelist { mapping(address => bool) whitelist; event WhitelistChange(address indexed addr, bool allow); function isInWhitelist(address addr) constant public returns (bool) { return whitelist[addr]; } function addToWhitelist(address[] _addresses) public onlyOwner { for (uint i = 0; i < _addresses.length; i++) { setWhitelistInternal(_addresses[i], true); } } function removeFromWhitelist(address[] _addresses) public onlyOwner { for (uint i = 0; i < _addresses.length; i++) { setWhitelistInternal(_addresses[i], false); } } function setWhitelist(address addr, bool allow) public onlyOwner { setWhitelistInternal(addr, allow); } function setWhitelistInternal(address addr, bool allow) internal { whitelist[addr] = allow; emit WhitelistChange(addr, allow); } } "}
{"sol name": "250.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } contract MNC is StandardToken, Ownable { string public constant name = \"Moneynet Coin\"; string public constant symbol = \"MNC\"; uint32 public constant decimals = 18; // Tokens amount uint256 public saleTokens = uint256(6e9).mul(1 ether); uint256 public ecosystemTokens = uint256(204e8).mul(1 ether); uint256 public teamTokens = uint256(4e9).mul(1 ether); uint256 public investorsTokens = uint256(24e8).mul(1 ether); uint256 public advisorsTokens = uint256(2e9).mul(1 ether); uint256 public bonusTokens = uint256(16e8).mul(1 ether); uint256 public reserveTokens = uint256(36e8).mul(1 ether); // sale contract address address public saleContract; // locked tokens data mapping(address => uint256) public lockedTokens_3; mapping(address => uint256) public lockedTokens_6; mapping(address => uint256) public lockedTokens_12; uint256 lockTime = now; constructor(address _newOwner) public { require(_newOwner != address(0)); uint256 tokens = ecosystemTokens; owner = _newOwner; balances[owner] = balances[owner].add(tokens); totalSupply_ = totalSupply_.add(tokens); emit Transfer(address(0), owner, tokens); } /** * @dev Sending tokens for sale to the sale contract address. * @param _contract Sale contract address. */ function activateSaleContract(address _contract) public onlyOwner returns (bool) { require(_contract != address(0)); require(saleTokens > 0); uint256 tokens = saleTokens; saleTokens = 0; saleContract = _contract; totalSupply_ = totalSupply_.add(tokens); balances[_contract] = balances[_contract].add(tokens); emit Transfer(address(0), _contract, tokens); return true; } /** * @dev Sending reserve tokens to the sale contract address. */ function sendReserveTokens() public onlyOwner returns (bool) { require(saleContract != address(0)); require(reserveTokens > 0); uint256 tokens = reserveTokens; reserveTokens = 0; totalSupply_ = totalSupply_.add(tokens); balances[saleContract] = balances[saleContract].add(tokens); emit Transfer(address(0), saleContract, tokens); return true; } /** * @dev  Team tokens accrual. * @param _address Recepient address. * @param _amount Accrued amount. */ function accrueTeamTokens(address _address, uint256 _amount) public onlyOwner returns (bool) { require(_amount > 0); require(_amount <= teamTokens); require(_address != address(0)); teamTokens = teamTokens.sub(_amount); lockedTokens_12[_address] = lockedTokens_12[_address].add(_amount); return true; } /** * @dev  Investors tokens accrual. * @param _address Recepient address. * @param _amount Accrued amount. */ function accrueInvestorsTokens(address _address, uint256 _amount) public onlyOwner returns (bool) { require(_amount > 0); require(_amount <= investorsTokens); require(_address != address(0)); investorsTokens = investorsTokens.sub(_amount); lockedTokens_6[_address] = lockedTokens_6[_address].add(_amount); return true; } /** * @dev  Advisors tokens accrual. * @param _address Recepient address. * @param _amount Accrued amount. */ function accrueAdvisorsTokens(address _address, uint256 _amount) public onlyOwner returns (bool) { require(_amount > 0); require(_amount <= advisorsTokens); require(_address != address(0)); advisorsTokens = advisorsTokens.sub(_amount); lockedTokens_6[_address] = lockedTokens_6[_address].add(_amount); return true; } /** * @dev  Bonus tokens accrual. * @param _address Recepient address. * @param _amount Accrued amount. */ function accrueBonusTokens(address _address, uint256 _amount) public onlyOwner returns (bool) { require(_amount > 0); require(_amount <= bonusTokens); require(_address != address(0)); bonusTokens = bonusTokens.sub(_amount); lockedTokens_3[_address] = lockedTokens_3[_address].add(_amount); return true; } function releaseTokens() public returns (bool) { uint256 tokens = 0; if (lockedTokens_3[msg.sender] > 0 && now.sub(lockTime) > 91 days) { tokens = tokens.add(lockedTokens_3[msg.sender]); lockedTokens_3[msg.sender] = 0; } if (lockedTokens_6[msg.sender] > 0 && now.sub(lockTime) > 182 days) { tokens = tokens.add(lockedTokens_6[msg.sender]); lockedTokens_6[msg.sender] = 0; } if (lockedTokens_12[msg.sender] > 0 && now.sub(lockTime) > 365 days) { tokens = tokens.add(lockedTokens_12[msg.sender]); lockedTokens_12[msg.sender] = 0; } require (tokens > 0); totalSupply_ = totalSupply_.add(tokens); balances[msg.sender] = balances[msg.sender].add(tokens); emit Transfer(address(0), msg.sender, tokens); } } "}
{"sol name": "644.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'AGRI' - AgriChain Utility Token Contract // // Symbol           : AGRI // Name             : AgriChain Utility Token // Max Total supply : 1,000,000,000.000000000000000000 (1 billion) // Decimals         : 18 // // Company          : AgriChain Pty Ltd (trading as BlockGrain) //                  : https://agrichain.com // Version          : 2.1 // Author           : Martin Halford <[email\u00a0protected]> // Published        : 15 Aug 2018 // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe Maths // ---------------------------------------------------------------------------- library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b, \"Muliply overflow error.\"); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0, \"Divide by zero error.\"); uint256 c = _a / _b; return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a, \"Subtraction overflow error.\"); uint256 c = _a - _b; return c; } function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a, \"Addition overflow error.\"); return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0, \"Mod overflow error\"); return a % b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner, \"Not contract owner.\"); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner, \"Not new contract owner.\"); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // Agri Token // ---------------------------------------------------------------------------- contract AgriChainToken is ERC20Interface, Owned { using SafeMath for uint; uint256 constant public MAX_SUPPLY = 1000000000000000000000000000; // 1 billion Agri string public symbol; string public  name; uint8 public decimals; uint256 _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // Flag to allow or disallow transfers bool public isAllowingTransfers; // List of admins who can mint, burn and allow transfers of tokens mapping (address => bool) public administrators; // modifier to check if transfers being allowed modifier allowingTransfers() { require(isAllowingTransfers, \"Contract currently not allowing transfers.\"); _; } // modifier to check admin status modifier onlyAdmin() { require(administrators[msg.sender], \"Not contract administrator.\"); _; } // This notifies clients about the amount burnt, only admins can burn tokens event Burn(address indexed burner, uint256 value); // This notifies clients about the transfers being allowed or disallowed event AllowTransfers (); event DisallowTransfers (); // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor(uint initialTokenSupply) public { symbol = \"AGRI\"; name = \"AgriChain Utility Token\"; decimals = 18; _totalSupply = initialTokenSupply * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public allowingTransfers returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public allowingTransfers returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(\"Contract does not accept ETH.\"); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyAdmin returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } // ------------------------------------------------------------------------ // Administrator can mint additional tokens // Do ** NOT ** let totalSupply exceed MAX_SUPPLY // ------------------------------------------------------------------------ function mintTokens(uint256 _value) public onlyAdmin { require(_totalSupply.add(_value) <= MAX_SUPPLY, \"Cannot mint greater than maximum supply.\"); balances[msg.sender] = balances[msg.sender].add(_value); _totalSupply = _totalSupply.add(_value); emit Transfer(0, msg.sender, _value); } // ------------------------------------------------------------------------ // Administrator can burn tokens // ------------------------------------------------------------------------ function burn(uint256 _value) public onlyAdmin { require(_value <= balances[msg.sender], \"Burn value exceeds balance.\"); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); _totalSupply = _totalSupply.sub(_value); emit Burn(burner, _value); } // ------------------------------------------------------------------------ // Administrator can allow transfer of tokens // ------------------------------------------------------------------------ function allowTransfers() public onlyAdmin { isAllowingTransfers = true; emit AllowTransfers(); } // ------------------------------------------------------------------------ // Administrator can disallow transfer of tokens // ------------------------------------------------------------------------ function disallowTransfers() public onlyAdmin { isAllowingTransfers = false; emit DisallowTransfers(); } // ------------------------------------------------------------------------ // Owner can add administrators of tokens // ------------------------------------------------------------------------ function addAdministrator(address _admin) public onlyOwner { administrators[_admin] = true; } // ------------------------------------------------------------------------ // Owner can remove administrators of tokens // ------------------------------------------------------------------------ function removeAdministrator(address _admin) public onlyOwner { administrators[_admin] = false; } } "}
{"sol name": "468.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); Transfer(burner, address(0), _value); } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Cloudbric is StandardToken, BurnableToken, Ownable { using SafeMath for uint256; string public constant symbol = \"CLB\"; string public constant name = \"Cloudbric\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000 * (10 ** uint256(decimals)); uint256 public constant TOKEN_SALE_ALLOWANCE = 540000000 * (10 ** uint256(decimals)); uint256 public constant ADMIN_ALLOWANCE = INITIAL_SUPPLY - TOKEN_SALE_ALLOWANCE; // Address of token administrator address public adminAddr; // Address of token sale contract address public tokenSaleAddr; // Enable transfer after token sale is completed bool public transferEnabled = false; // Accounts to be locked for certain period mapping(address => uint256) private lockedAccounts; /* * * Permissions when transferEnabled is false : *              ContractOwner    Admin    SaleContract    Others * transfer            x           v            v           x * transferFrom        x           v            v           x * * Permissions when transferEnabled is true : *              ContractOwner    Admin    SaleContract    Others * transfer            v           v            v           v * transferFrom        v           v            v           v * */ /* * Check if token transfer is allowed * Permission table above is result of this modifier */ modifier onlyWhenTransferAllowed() { require(transferEnabled == true || msg.sender == adminAddr || msg.sender == tokenSaleAddr); _; } /* * Check if token sale address is not set */ modifier onlyWhenTokenSaleAddrNotSet() { require(tokenSaleAddr == address(0x0)); _; } /* * Check if token transfer destination is valid */ modifier onlyValidDestination(address to) { require(to != address(0x0) && to != address(this) && to != owner && to != adminAddr && to != tokenSaleAddr); _; } modifier onlyAllowedAmount(address from, uint256 amount) { require(balances[from].sub(amount) >= lockedAccounts[from]); _; } /* * The constructor of Cloudbric contract * * @param _adminAddr: Address of token administrator */ function Cloudbric(address _adminAddr) public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = totalSupply_; Transfer(address(0x0), msg.sender, totalSupply_); adminAddr = _adminAddr; approve(adminAddr, ADMIN_ALLOWANCE); } /* * Set amount of token sale to approve allowance for sale contract * * @param _tokenSaleAddr: Address of sale contract * @param _amountForSale: Amount of token for sale */ function setTokenSaleAmount(address _tokenSaleAddr, uint256 amountForSale) external onlyOwner onlyWhenTokenSaleAddrNotSet { require(!transferEnabled); uint256 amount = (amountForSale == 0) ? TOKEN_SALE_ALLOWANCE : amountForSale; require(amount <= TOKEN_SALE_ALLOWANCE); approve(_tokenSaleAddr, amount); tokenSaleAddr = _tokenSaleAddr; } /* * Set transferEnabled variable to true */ function enableTransfer() external onlyOwner { transferEnabled = true; approve(tokenSaleAddr, 0); } /* * Set transferEnabled variable to false */ function disableTransfer() external onlyOwner { transferEnabled = false; } /* * Transfer token from message sender to another * * @param to: Destination address * @param value: Amount of AMO token to transfer */ function transfer(address to, uint256 value) public onlyWhenTransferAllowed onlyValidDestination(to) onlyAllowedAmount(msg.sender, value) returns (bool) { return super.transfer(to, value); } /* * Transfer token from 'from' address to 'to' addreess * * @param from: Origin address * @param to: Destination address * @param value: Amount of tokens to transfer */ function transferFrom(address from, address to, uint256 value) public onlyWhenTransferAllowed onlyValidDestination(to) onlyAllowedAmount(from, value) returns (bool) { return super.transferFrom(from, to, value); } /* * Burn token, only owner is allowed * * @param value: Amount of tokens to burn */ function burn(uint256 value) public onlyOwner { require(transferEnabled); super.burn(value); } /* * Disable transfering tokens more than allowed amount from certain account * * @param addr: Account to set allowed amount * @param amount: Amount of tokens to allow */ function lockAccount(address addr, uint256 amount) external onlyOwner onlyValidDestination(addr) { require(amount > 0); lockedAccounts[addr] = amount; } /* * Enable transfering tokens of locked account * * @param addr: Account to unlock */ function unlockAccount(address addr) external onlyOwner onlyValidDestination(addr) { lockedAccounts[addr] = 0; } } "}
{"sol name": "337.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 0; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract GoodfieldNewRetail is owned, TokenERC20 { uint256 public sellPrice; uint256 public buyPrice; mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ function GoodfieldNewRetail( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); } /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens /// @param target Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } /// @notice Allow users to buy tokens for `newBuyPrice` eth and sell tokens for `newSellPrice` eth /// @param newSellPrice Price the users can sell to the contract /// @param newBuyPrice Price users can buy from the contract function setPrices(uint256 newSellPrice, uint256 newBuyPrice) onlyOwner public { sellPrice = newSellPrice; buyPrice = newBuyPrice; } function buy() payable public returns (uint amount){ amount = msg.value / buyPrice;                    // calculates the amount require(balanceOf[this] >= amount);               // checks if it has enough to sell balanceOf[msg.sender] += amount;                  // adds the amount to buyer's balance balanceOf[this] -= amount;                        // subtracts amount from seller's balance emit Transfer(this, msg.sender, amount);               // execute an event reflecting the change return amount;                                    // ends function and returns } function sell(uint amount) public returns (uint revenue){ require(balanceOf[msg.sender] >= amount);         // checks if the sender has enough to sell balanceOf[this] += amount;                        // adds the amount to owner's balance balanceOf[msg.sender] -= amount;                  // subtracts the amount from seller's balance revenue = amount * sellPrice; msg.sender.transfer(revenue);                     // sends ether to the seller: it's important to do this last to prevent recursion attacks emit Transfer(msg.sender, this, amount);               // executes an event reflecting on the change return revenue;                                   // ends function and returns } } "}
{"sol name": "12.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20,Pausable { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) whenNotPaused public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { require(_value == 0 || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) whenNotPaused public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Internal function that mints an amount of the token and assigns it to * an account. This encapsulates the modification of balances such that the * proper events are emitted. * @param _account The account that will receive the created tokens. * @param _amount The amount that will be created. */ function _mint(address _account, uint256 _amount) internal { require(_account != 0); totalSupply_ = totalSupply_.add(_amount); balances[_account] = balances[_account].add(_amount); emit Transfer(address(0), _account, _amount); } /** * @dev Internal function that burns an amount of the token of a given * account. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burn(address _account, uint256 _amount) internal { require(_account != 0); require(_amount <= balances[_account]); totalSupply_ = totalSupply_.sub(_amount); balances[_account] = balances[_account].sub(_amount); emit Transfer(_account, address(0), _amount); } /** * @dev Internal function that burns an amount of the token of a given * account, deducting from the sender's allowance for said account. Uses the * internal _burn function. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burnFrom(address _account, uint256 _amount) internal { require(_amount <= allowed[_account][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount); _burn(_account, _amount); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { _burnFrom(_from, _value); } /** * @dev Overrides StandardToken._burn in order for burn and burnFrom to emit * an additional Burn event. */ function _burn(address _who, uint256 _value) internal { super._burn(_who, _value); emit Burn(_who, _value); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is BurnableToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { _mint(_to, _amount); emit Mint(_to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } /** * @dev Function to start minting new tokens. * @return True if the operation was successful. */ function startMinting() public onlyOwner returns (bool) { mintingFinished = false; return true; } } contract GUCN is MintableToken { // If ether is sent to this address, send it back. function () public { revert(); } string public constant name = \"Ancient coins\u2019 chain\"; string public constant symbol = \"GUCN\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 10000000000; /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } } "}
{"sol name": "992.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) public balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); } } contract AvailComToken is BurnableToken, Ownable { string public constant name = \"AvailCom Token\"; string public constant symbol = \"AVL\"; uint32 public constant decimals = 4; constructor () public { // 0000 is added to the totalSupply because decimal 4 totalSupply_ = 22000000000000; balances[msg.sender] = totalSupply_; } } "}
{"sol name": "866.sol", "label": 0, "sol content": "pragma solidity ^0.4.10; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } interface ERC20 { function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } interface ERC223 { function transfer(address to, uint value, bytes data) public; event Transfer(address indexed from, address indexed to, uint value, bytes indexed data); } contract ERC223ReceivingContract { function tokenFallback(address _from, uint _value, bytes _data) public; } contract WFC is ERC20, ERC223 { using SafeMath for uint; string internal _name; string internal _symbol; uint8 internal _decimals; uint256 internal _totalSupply; mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; function WFC(string name, string symbol, uint8 decimals, uint256 totalSupply) public { _symbol = symbol; _name = name; _decimals = decimals; _totalSupply = totalSupply; balances[msg.sender] = totalSupply; } function name() public view returns (string) { return _name; } function symbol() public view returns (string) { return _symbol; } function decimals() public view returns (uint8) { return _decimals; } function totalSupply() public view returns (uint256) { return _totalSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); balances[_to] = SafeMath.add(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = SafeMath.sub(balances[_from], _value); balances[_to] = SafeMath.add(balances[_to], _value); allowed[_from][msg.sender] = SafeMath.sub(allowed[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = SafeMath.add(allowed[msg.sender][_spender], _addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = SafeMath.sub(oldValue, _subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function transfer(address _to, uint _value, bytes _data) public { require(_value > 0 ); if(isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); } balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value, _data); } function isContract(address _addr) private returns (bool is_contract) { uint length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } } "}
{"sol name": "1799.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** __    __  __      __  ________  ________  ________  __    __  _______ |  \\  |  \\|  \\    /  \\|        \\|        \\|        \\|  \\  |  \\|       \\ | $$  | $$ \\$$\\  /  $$ \\$$$$$$$$| $$$$$$$$ \\$$$$$$$$| $$  | $$| $$$$$$$\\ \\$$\\/  $$  \\$$\\/  $$     /  $$ | $$__       | $$   | $$__| $$| $$__| $$ >$$  $$    \\$$  $$     /  $$  | $$  \\      | $$   | $$    $$| $$    $$ /  $$$$\\     \\$$$$     /  $$   | $$$$$      | $$   | $$$$$$$$| $$$$$$$\\ |  $$ \\$$\\    | $$     /  $$___ | $$_____    | $$   | $$  | $$| $$  | $$ | $$  | $$    | $$    |  $$    \\| $$     \\   | $$   | $$  | $$| $$  | $$ \\$$   \\$$     \\$$     \\$$$$$$$$ \\$$$$$$$$    \\$$    \\$$   \\$$ \\$$   \\$$ .------..------..------..------.     .------..------..------..------..------..------..------. |M.--. ||O.--. ||R.--. ||E.--. |.-.  |L.--. ||E.--. ||T.--. ||T.--. ||E.--. ||R.--. ||S.--. | | (\\/) || :/\\: || :(): || (\\/) ((5)) | :/\\: || (\\/) || :/\\: || :/\\: || (\\/) || :(): || :/\\: | | :\\/: || :\\/: || ()() || :\\/: |'-.-.| (__) || :\\/: || (__) || (__) || :\\/: || ()() || :\\/: | | '--'M|| '--'O|| '--'R|| '--'E| ((1)) '--'L|| '--'E|| '--'T|| '--'T|| '--'E|| '--'R|| '--'S| `------'`------'`------'`------'  '-'`------'`------'`------'`------'`------'`------'`------' An interactive, variable-dividend rate contract with an ICO-capped price floor and collectibles. This contract describes those collectibles. Don't get left with a hot potato! **/ // Required ERC721 interface. contract ERC721 { function approve(address _to, uint _tokenId) public; function balanceOf(address _owner) public view returns (uint balance); function implementsERC721() public pure returns (bool); function ownerOf(uint _tokenId) public view returns (address addr); function takeOwnership(uint _tokenId) public; function totalSupply() public view returns (uint total); function transferFrom(address _from, address _to, uint _tokenId) public; function transfer(address _to, uint _tokenId) public; event Transfer(address indexed from, address indexed to, uint tokenId); event Approval(address indexed owner, address indexed approved, uint tokenId); } contract XYZethrDividendCards is ERC721 { using SafeMath for uint; /*** EVENTS ***/ /// @dev The Birth event is fired whenever a new dividend card comes into existence. event Birth(uint tokenId, string name, address owner); /// @dev The TokenSold event is fired whenever a token (dividend card, in this case) is sold. event TokenSold(uint tokenId, uint oldPrice, uint newPrice, address prevOwner, address winner, string name); /// @dev Transfer event as defined in current draft of ERC721. ///  Ownership is assigned, including births. event Transfer(address from, address to, uint tokenId); /*** CONSTANTS ***/ /// @notice Name and symbol of the non fungible token, as defined in ERC721. string public constant NAME           = \"XYZethrDividendCard\"; string public constant SYMBOL         = \"XYZDC\"; address public         BANKROLL; /*** STORAGE ***/ /// @dev A mapping from dividend card indices to the address that owns them. ///  All dividend cards have a valid owner address. mapping (uint => address) public      divCardIndexToOwner; // A mapping from a dividend rate to the card index. mapping (uint => uint) public         divCardRateToIndex; // @dev A mapping from owner address to the number of dividend cards that address owns. //  Used internally inside balanceOf() to resolve ownership count. mapping (address => uint) private     ownershipDivCardCount; /// @dev A mapping from dividend card indices to an address that has been approved to call ///  transferFrom(). Each dividend card can only have one approved address for transfer ///  at any time. A zero value means no approval is outstanding. mapping (uint => address) public      divCardIndexToApproved; // @dev A mapping from dividend card indices to the price of the dividend card. mapping (uint => uint) private        divCardIndexToPrice; mapping (address => bool) internal    administrators; address public                        creator; bool    public                        onSale; /*** DATATYPES ***/ struct Card { string name; uint percentIncrease; } Card[] private divCards; modifier onlyCreator() { require(msg.sender == creator); _; } constructor (address _bankroll) public { creator = msg.sender; BANKROLL = _bankroll; createDivCard(\"2%\", 1 ether, 2); divCardRateToIndex[2] = 0; createDivCard(\"5%\", 1 ether, 5); divCardRateToIndex[5] = 1; createDivCard(\"10%\", 1 ether, 10); divCardRateToIndex[10] = 2; createDivCard(\"15%\", 1 ether, 15); divCardRateToIndex[15] = 3; createDivCard(\"20%\", 1 ether, 20); divCardRateToIndex[20] = 4; createDivCard(\"25%\", 1 ether, 25); divCardRateToIndex[25] = 5; createDivCard(\"33%\", 1 ether, 33); divCardRateToIndex[33] = 6; createDivCard(\"MASTER\", 5 ether, 10); divCardRateToIndex[999] = 7; onSale = false; administrators[msg.sender] = true; } /*** MODIFIERS ***/ // Modifier to prevent contracts from interacting with the flip cards modifier isNotContract() { require (msg.sender == tx.origin); _; } // Modifier to prevent purchases before we open them up to everyone modifier hasStarted() { require (onSale == true); _; } modifier isAdmin() { require(administrators[msg.sender]); _; } /*** PUBLIC FUNCTIONS ***/ // Administrative update of the bankroll contract address function setBankroll(address where) isAdmin { BANKROLL = where; } /// @notice Grant another address the right to transfer token via takeOwnership() and transferFrom(). /// @param _to The address to be granted transfer approval. Pass address(0) to ///  clear all approvals. /// @param _tokenId The ID of the Token that can be transferred if this call succeeds. /// @dev Required for ERC-721 compliance. function approve(address _to, uint _tokenId) public isNotContract { // Caller must own token. require(_owns(msg.sender, _tokenId)); divCardIndexToApproved[_tokenId] = _to; emit Approval(msg.sender, _to, _tokenId); } /// For querying balance of a particular account /// @param _owner The address for balance query /// @dev Required for ERC-721 compliance. function balanceOf(address _owner) public view returns (uint balance) { return ownershipDivCardCount[_owner]; } // Creates a div card with bankroll as the owner function createDivCard(string _name, uint _price, uint _percentIncrease) public onlyCreator { _createDivCard(_name, BANKROLL, _price, _percentIncrease); } // Opens the dividend cards up for sale. function startCardSale() public onlyCreator { onSale = true; } /// @notice Returns all the relevant information about a specific div card /// @param _divCardId The tokenId of the div card of interest. function getDivCard(uint _divCardId) public view returns (string divCardName, uint sellingPrice, address owner) { Card storage divCard = divCards[_divCardId]; divCardName = divCard.name; sellingPrice = divCardIndexToPrice[_divCardId]; owner = divCardIndexToOwner[_divCardId]; } function implementsERC721() public pure returns (bool) { return true; } /// @dev Required for ERC-721 compliance. function name() public pure returns (string) { return NAME; } /// For querying owner of token /// @param _divCardId The tokenID for owner inquiry /// @dev Required for ERC-721 compliance. function ownerOf(uint _divCardId) public view returns (address owner) { owner = divCardIndexToOwner[_divCardId]; require(owner != address(0)); return owner; } // Allows someone to send Ether and obtain a card function purchase(uint _divCardId) public payable hasStarted isNotContract { address oldOwner  = divCardIndexToOwner[_divCardId]; address newOwner  = msg.sender; // Get the current price of the card uint currentPrice = divCardIndexToPrice[_divCardId]; // Making sure token owner is not sending to self require(oldOwner != newOwner); // Safety check to prevent against an unexpected 0x0 default. require(_addressNotNull(newOwner)); // Making sure sent amount is greater than or equal to the sellingPrice require(msg.value >= currentPrice); // To find the total profit, we need to know the previous price // currentPrice      = previousPrice * (100 + percentIncrease); // previousPrice     = currentPrice / (100 + percentIncrease); uint percentIncrease = divCards[_divCardId].percentIncrease; uint previousPrice   = SafeMath.mul(currentPrice, 100).div(100 + percentIncrease); // Calculate total profit and allocate 50% to old owner, 50% to bankroll uint totalProfit     = SafeMath.sub(currentPrice, previousPrice); uint oldOwnerProfit  = SafeMath.div(totalProfit, 2); uint bankrollProfit  = SafeMath.sub(totalProfit, oldOwnerProfit); oldOwnerProfit       = SafeMath.add(oldOwnerProfit, previousPrice); // Refund the sender the excess he sent uint purchaseExcess  = SafeMath.sub(msg.value, currentPrice); // Raise the price by the percentage specified by the card divCardIndexToPrice[_divCardId] = SafeMath.div(SafeMath.mul(currentPrice, (100 + percentIncrease)), 100); // Transfer ownership _transfer(oldOwner, newOwner, _divCardId); // Using send rather than transfer to prevent contract exploitability. BANKROLL.send(bankrollProfit); oldOwner.send(oldOwnerProfit); msg.sender.transfer(purchaseExcess); } function priceOf(uint _divCardId) public view returns (uint price) { return divCardIndexToPrice[_divCardId]; } function setCreator(address _creator) public onlyCreator { require(_creator != address(0)); creator = _creator; } /// @dev Required for ERC-721 compliance. function symbol() public pure returns (string) { return SYMBOL; } /// @notice Allow pre-approved user to take ownership of a dividend card. /// @param _divCardId The ID of the card that can be transferred if this call succeeds. /// @dev Required for ERC-721 compliance. function takeOwnership(uint _divCardId) public isNotContract { address newOwner = msg.sender; address oldOwner = divCardIndexToOwner[_divCardId]; // Safety check to prevent against an unexpected 0x0 default. require(_addressNotNull(newOwner)); // Making sure transfer is approved require(_approved(newOwner, _divCardId)); _transfer(oldOwner, newOwner, _divCardId); } /// For querying totalSupply of token /// @dev Required for ERC-721 compliance. function totalSupply() public view returns (uint total) { return divCards.length; } /// Owner initates the transfer of the card to another account /// @param _to The address for the card to be transferred to. /// @param _divCardId The ID of the card that can be transferred if this call succeeds. /// @dev Required for ERC-721 compliance. function transfer(address _to, uint _divCardId) public isNotContract { require(_owns(msg.sender, _divCardId)); require(_addressNotNull(_to)); _transfer(msg.sender, _to, _divCardId); } /// Third-party initiates transfer of a card from address _from to address _to /// @param _from The address for the card to be transferred from. /// @param _to The address for the card to be transferred to. /// @param _divCardId The ID of the card that can be transferred if this call succeeds. /// @dev Required for ERC-721 compliance. function transferFrom(address _from, address _to, uint _divCardId) public isNotContract { require(_owns(_from, _divCardId)); require(_approved(_to, _divCardId)); require(_addressNotNull(_to)); _transfer(_from, _to, _divCardId); } function receiveDividends(uint _divCardRate) public payable { uint _divCardId = divCardRateToIndex[_divCardRate]; address _regularAddress = divCardIndexToOwner[_divCardId]; address _masterAddress = divCardIndexToOwner[7]; uint toMaster = msg.value.div(2); uint toRegular = msg.value.sub(toMaster); _masterAddress.send(toMaster); _regularAddress.send(toRegular); } /*** PRIVATE FUNCTIONS ***/ /// Safety check on _to address to prevent against an unexpected 0x0 default. function _addressNotNull(address _to) private pure returns (bool) { return _to != address(0); } /// For checking approval of transfer for address _to function _approved(address _to, uint _divCardId) private view returns (bool) { return divCardIndexToApproved[_divCardId] == _to; } /// For creating a dividend card function _createDivCard(string _name, address _owner, uint _price, uint _percentIncrease) private { Card memory _divcard = Card({ name: _name, percentIncrease: _percentIncrease }); uint newCardId = divCards.push(_divcard) - 1; // It's probably never going to happen, 4 billion tokens are A LOT, but // let's just be 100% sure we never let this happen. require(newCardId == uint(uint32(newCardId))); emit Birth(newCardId, _name, _owner); divCardIndexToPrice[newCardId] = _price; // This will assign ownership, and also emit the Transfer event as per ERC721 draft _transfer(BANKROLL, _owner, newCardId); } /// Check for token ownership function _owns(address claimant, uint _divCardId) private view returns (bool) { return claimant == divCardIndexToOwner[_divCardId]; } /// @dev Assigns ownership of a specific Card to an address. function _transfer(address _from, address _to, uint _divCardId) private { // Since the number of cards is capped to 2^32 we can't overflow this ownershipDivCardCount[_to]++; //transfer ownership divCardIndexToOwner[_divCardId] = _to; // When creating new div cards _from is 0x0, but we can't account that address. if (_from != address(0)) { ownershipDivCardCount[_from]--; // clear any previously approved ownership exchange delete divCardIndexToApproved[_divCardId]; } // Emit the transfer event. emit Transfer(_from, _to, _divCardId); } } // SafeMath library library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint a, uint b) internal pure returns (uint) { if (a == 0) { return 0; } uint c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint a, uint b) internal pure returns (uint) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } } /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, *  as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly return size > 0; } } "}
{"sol name": "358.sol", "label": 0, "sol content": "/** * Copyright (C) 2017-2018 Hashfuture Inc. All rights reserved. */ pragma solidity ^0.4.22; library strings { struct slice { uint _len; uint _ptr; } function memcpy(uint dest, uint src, uint len) private pure { // Copy word-length chunks while possible for(; len >= 32; len -= 32) { assembly { mstore(dest, mload(src)) } dest += 32; src += 32; } // Copy remaining bytes uint mask = 256 ** (32 - len) - 1; assembly { let srcpart := and(mload(src), not(mask)) let destpart := and(mload(dest), mask) mstore(dest, or(destpart, srcpart)) } } /* * @dev Copies a slice to a new string. * @param self The slice to copy. * @return A newly allocated string containing the slice's text. */ function toString(slice memory self) internal pure returns (string memory) { string memory ret = new string(self._len); uint retptr; assembly { retptr := add(ret, 32) } memcpy(retptr, self._ptr, self._len); return ret; } /* * @dev Returns a slice containing the entire string. * @param self The string to make a slice from. * @return A newly allocated slice containing the entire string. */ function toSlice(string memory self) internal pure returns (slice memory) { uint ptr; assembly { ptr := add(self, 0x20) } return slice(bytes(self).length, ptr); } /* * @dev Returns true if the slice is empty (has a length of 0). * @param self The slice to operate on. * @return True if the slice is empty, False otherwise. */ function empty(slice memory self) internal pure returns (bool) { return self._len == 0; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and `token` to everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and `token` is set to the entirety of `self`. * @param self The slice to split. * @param needle The text to search for in `self`. * @param token An output parameter to which the first token is written. * @return `token`. */ function split(slice memory self, slice memory needle, slice memory token) internal pure returns (slice memory) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr); token._ptr = self._ptr; token._len = ptr - self._ptr; if (ptr == self._ptr + self._len) { // Not found self._len = 0; } else { self._len -= token._len + needle._len; self._ptr = ptr + needle._len; } return token; } /* * @dev Splits the slice, setting `self` to everything after the first *      occurrence of `needle`, and returning everything before it. If *      `needle` does not occur in `self`, `self` is set to the empty slice, *      and the entirety of `self` is returned. * @param self The slice to split. * @param needle The text to search for in `self`. * @return The part of `self` up to the first occurrence of `delim`. */ function split(slice memory self, slice memory needle) internal pure returns (slice memory token) { split(self, needle, token); } // Returns the memory address of the first byte of the first occurrence of // `needle` in `self`, or the first byte after `self` if not found. function findPtr(uint selflen, uint selfptr, uint needlelen, uint needleptr) private pure returns (uint) { uint ptr = selfptr; uint idx; if (needlelen <= selflen) { if (needlelen <= 32) { bytes32 mask = bytes32(~(2 ** (8 * (32 - needlelen)) - 1)); bytes32 needledata; assembly { needledata := and(mload(needleptr), mask) } uint end = selfptr + selflen - needlelen; bytes32 ptrdata; assembly { ptrdata := and(mload(ptr), mask) } while (ptrdata != needledata) { if (ptr >= end) return selfptr + selflen; ptr++; assembly { ptrdata := and(mload(ptr), mask) } } return ptr; } else { // For long needles, use hashing bytes32 hash; assembly { hash := keccak256(needleptr, needlelen) } for (idx = 0; idx <= selflen - needlelen; idx++) { bytes32 testHash; assembly { testHash := keccak256(ptr, needlelen) } if (hash == testHash) return ptr; ptr += 1; } } } return selfptr + selflen; } /* * @dev Counts the number of nonoverlapping occurrences of `needle` in `self`. * @param self The slice to search. * @param needle The text to search for in `self`. * @return The number of occurrences of `needle` found in `self`. */ function count(slice memory self, slice memory needle) internal pure returns (uint cnt) { uint ptr = findPtr(self._len, self._ptr, needle._len, needle._ptr) + needle._len; while (ptr <= self._ptr + self._len) { cnt++; ptr = findPtr(self._len - (ptr - self._ptr), ptr, needle._len, needle._ptr) + needle._len; } } } contract owned { address public holder; constructor() public { holder = msg.sender; } modifier onlyHolder { require(msg.sender == holder, \"This func only can be calle by holder\"); _; } } contract asset is owned { using strings for *; /*Asset Struct*/ struct data { //link URL of the original information for storing data //     null means undisclosed string link; //The encryption method of the original data, such as SHA-256 string encryptionType; //Hash value string hashValue; } data[] dataArray; uint dataNum; //The validity of the contract bool public isValid; //The init status bool public isInit; //The tradeable status of asset bool public isTradeable; uint public price; //Some notes string public remark1; //Other notes, holder can be written //Reservations for validation functions string public remark2; /** constructor */ constructor() public { isValid = true; isInit = false; isTradeable = false; price = 0; dataNum = 0; } /** * Initialize a new asset * @param dataNumber The number of data array * @param linkSet The set of URL of the original information for storing data, if null means undisclosed *          needle is \" \" * @param encryptionTypeSet The set of encryption method of the original data, such as SHA-256 *          needle is \" \" * @param hashValueSet The set of hashvalue *          needle is \" \" */ function initAsset( uint dataNumber, string linkSet, string encryptionTypeSet, string hashValueSet) public onlyHolder { // split string to array var links = linkSet.toSlice(); var encryptionTypes = encryptionTypeSet.toSlice(); var hashValues = hashValueSet.toSlice(); var delim = \" \".toSlice(); dataNum = dataNumber; // after init, the initAsset function cannot be called require(isInit == false, \"The contract has been initialized\"); //check data require(dataNumber >= 1, \"The dataNumber should bigger than 1\"); require(dataNumber - 1 == links.count(delim), \"The uumber of linkSet error\"); require(dataNumber - 1 == encryptionTypes.count(delim), \"The uumber of encryptionTypeSet error\"); require(dataNumber - 1 == hashValues.count(delim), \"The uumber of hashValues error\"); isInit = true; var empty = \"\".toSlice(); for (uint i = 0; i < dataNumber; i++) { var link = links.split(delim); var encryptionType = encryptionTypes.split(delim); var hashValue = hashValues.split(delim); //require data not null // link can be empty require(!encryptionType.empty(), \"The encryptionTypeSet data error\"); require(!hashValue.empty(), \"The hashValues data error\"); dataArray.push( data(link.toString(), encryptionType.toString(), hashValue.toString()) ); } } /** * Get base asset info */ function getAssetBaseInfo() public view returns (uint _price, bool _isTradeable, uint _dataNum, string _remark1, string _remark2) { require(isValid == true, \"contract is invaild\"); _price = price; _isTradeable = isTradeable; _dataNum = dataNum; _remark1 = remark1; _remark2 = remark2; } /** * Get data info by index * @param index index of dataArray */ function getDataByIndex(uint index) public view returns (string link, string encryptionType, string hashValue) { require(isValid == true, \"contract is invaild\"); require(index >= 0, \"The idx smaller than 0\"); require(index < dataNum, \"The idx bigger than dataNum\"); link = dataArray[index].link; encryptionType = dataArray[index].encryptionType; hashValue = dataArray[index].hashValue; } /** * set the price of asset * @param newPrice price of asset * Only can be called by holder */ function setPrice(uint newPrice) public onlyHolder { require(isValid == true, \"contract is invaild\"); price = newPrice; } /** * set the tradeable status of asset * @param status status of isTradeable * Only can be called by holder */ function setTradeable(bool status) public onlyHolder { require(isValid == true, \"contract is invaild\"); isTradeable = status; } /** * set the remark1 * @param content new content of remark1 * Only can be called by holder */ function setRemark1(string content) public onlyHolder { require(isValid == true, \"contract is invaild\"); remark1 = content; } /** * set the remark2 * @param content new content of remark2 * Only can be called by holder */ function setRemark2(string content) public onlyHolder { require(isValid == true, \"contract is invaild\"); remark2 = content; } /** * Modify the link of the indexth data to be url * @param index index of assetInfo * @param url new link * Only can be called by holder */ function setDataLink(uint index, string url) public onlyHolder { require(isValid == true, \"contract is invaild\"); require(index >= 0, \"The index smaller than 0\"); require(index < dataNum, \"The index bigger than dataNum\"); dataArray[index].link = url; } /** * cancel contract * Only can be called by holder */ function cancelContract() public onlyHolder { isValid = false; } /** * Get the number of assetInfo */ function getDataNum() public view returns (uint num) { num = dataNum; } /** * Transfer holder */ function transferOwnership(address newHolder, bool status) public onlyHolder { holder = newHolder; isTradeable = status; } } "}
{"sol name": "420.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract Protecthor { using SafeMath for uint256; string public constant symbol = \"PTX\"; string public constant name = \"Protecthor\"; uint8 public constant decimals = 18; uint256 _totalSupply = 1000000000 * 10 ** uint256(decimals); // Owner of this contract address public owner; // Balances for each account mapping(address => uint256) balances; // Owner of account approves the transfer of an amount to another account mapping(address => mapping (address => uint256)) allowed; // Constructor function Protecthor() public { owner = msg.sender; balances[owner] = _totalSupply; } // ERC20 function totalSupply() public constant returns (uint256) { return _totalSupply; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) public returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0) { balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _amount) public returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0) { balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) public returns (bool success) { if(balances[msg.sender]>=_amount && _amount>0) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } else { return false; } } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); // custom function getMyBalance() public view returns (uint) { return balances[msg.sender]; } } library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "919.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor() public { totalSupply = 210000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"SuperConduct\";                                   // Set the name for display purposes symbol = \"SCT\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } } "}
{"sol name": "1887.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract OMEC{ // Public variables of the token string public name='\u4e07\u80fd\u94fe'; string public symbol='OMEC'; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply=158000000000000000000000000; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function omec( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1963.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * Smart Token Contract * Copyright \u00a9 2018 by Smartportfolio.io */ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } /** * @title SPTToken * @dev SPTToken with 1b Tokens max supply * **/ contract SPTToken is PausableToken, BurnableToken { string public constant version = \"1.0\"; string public constant name = \"Smart Portfolio Token\"; string public constant symbol = \"SPT\"; uint8 public constant decimals = 18; /** * @dev Constructor that gives msg.sender all of existing tokens. */ function SPTToken() { totalSupply_ = 1000000000 * 10**uint256(decimals); //make sure decimals is typecast to uint256 balances[msg.sender] = totalSupply_; } } "}
{"sol name": "1814.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Bazhanov' token contract // // Deployed to : 0x2678dFDa101D138888e96e6241Fa9e951ae916c1 // Symbol      : BAZ // Name        : NB token // Total supply: 10 // Decimals    : 0 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Bazhanov is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function FucksToken() public { symbol = \"BAZ\"; name = \"NB token\"; decimals = 0; _totalSupply = 10; balances[0x2678dFDa101D138888e96e6241Fa9e951ae916c1] = _totalSupply; Transfer(address(0), 0x2678dFDa101D138888e96e6241Fa9e951ae916c1, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "581.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } function MintableToken() { mint (msg.sender, 500000000 * (10 ** 18)); finishMinting(); } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract MCE is MintableToken { string public name=\"MultiChainExchange token\"; string public symbol=\"MCE\"; uint256 public decimals = 18; uint256 public constant initialSupply = 500000000 * (10 ** 18); } "}
{"sol name": "537.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Token { string public symbol = \"\"; string public name = \"\"; uint8 public constant decimals = 18; string public constant ICOFactoryVersion = \"1.0\"; uint256 _totalSupply = 0; uint256 _oneEtherEqualsInWei = 0; uint256 _maxICOpublicSupply = 0; uint256 _ownerICOsupply = 0; uint256 _currentICOpublicSupply = 0; uint256 _blockICOdatetime = 0; address _ICOfundsReceiverAddress = 0; address _remainingTokensReceiverAddress = 0; address owner = 0; bool setupDone = false; bool isICOrunning = false; bool ICOstarted = false; uint256 ICOoverTimestamp = 0; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _owner, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function Token(address adr) public { owner = adr; } function() public payable { if ((isICOrunning && _blockICOdatetime == 0) || (isICOrunning && _blockICOdatetime > 0 && now <= _blockICOdatetime)) { uint256 _amount = ((msg.value * _oneEtherEqualsInWei) / 1000000000000000000); if (((_currentICOpublicSupply + _amount) > _maxICOpublicSupply) && _maxICOpublicSupply > 0) revert(); if(!_ICOfundsReceiverAddress.send(msg.value)) revert(); _currentICOpublicSupply += _amount; balances[msg.sender] += _amount; _totalSupply += _amount; Transfer(this, msg.sender, _amount); } else { revert(); } } function SetupToken(string tokenName, string tokenSymbol, uint256 oneEtherEqualsInWei, uint256 maxICOpublicSupply, uint256 ownerICOsupply, address remainingTokensReceiverAddress, address ICOfundsReceiverAddress, uint256 blockICOdatetime) public { if (msg.sender == owner && !setupDone) { symbol = tokenSymbol; name = tokenName; _oneEtherEqualsInWei = oneEtherEqualsInWei; _maxICOpublicSupply = maxICOpublicSupply * 1000000000000000000; if (ownerICOsupply > 0) { _ownerICOsupply = ownerICOsupply * 1000000000000000000; _totalSupply = _ownerICOsupply; balances[owner] = _totalSupply; Transfer(this, owner, _totalSupply); } _ICOfundsReceiverAddress = ICOfundsReceiverAddress; if (_ICOfundsReceiverAddress == 0) _ICOfundsReceiverAddress = owner; _remainingTokensReceiverAddress = remainingTokensReceiverAddress; _blockICOdatetime = blockICOdatetime; setupDone = true; } } function StartICO() public returns (bool success) { if (msg.sender == owner && !ICOstarted && setupDone) { ICOstarted = true; isICOrunning = true; } else { revert(); } return true; } function StopICO() public returns (bool success) { if (msg.sender == owner && isICOrunning) { if (_remainingTokensReceiverAddress != 0 && _maxICOpublicSupply > 0) { uint256 _remainingAmount = _maxICOpublicSupply - _currentICOpublicSupply; if (_remainingAmount > 0) { balances[_remainingTokensReceiverAddress] += _remainingAmount; _totalSupply += _remainingAmount; Transfer(this, _remainingTokensReceiverAddress, _remainingAmount); } } isICOrunning = false; ICOoverTimestamp = now; } else { revert(); } return true; } function BurnTokens(uint256 amountInWei) public returns (bool success) { if (balances[msg.sender] >= amountInWei) { balances[msg.sender] -= amountInWei; _totalSupply -= amountInWei; Burn(msg.sender, amountInWei); Transfer(msg.sender, 0, amountInWei); } else { revert(); } return true; } function totalSupply() public constant returns (uint256 totalSupplyValue) { return _totalSupply; } function OneEtherEqualsInWei() public constant returns (uint256 oneEtherEqualsInWei) { return _oneEtherEqualsInWei; } function MaxICOpublicSupply() public constant returns (uint256 maxICOpublicSupply) { return _maxICOpublicSupply; } function OwnerICOsupply() public constant returns (uint256 ownerICOsupply) { return _ownerICOsupply; } function CurrentICOpublicSupply() public constant returns (uint256 currentICOpublicSupply) { return _currentICOpublicSupply; } function RemainingTokensReceiverAddress() public constant returns (address remainingTokensReceiverAddress) { return _remainingTokensReceiverAddress; } function ICOfundsReceiverAddress() public constant returns (address ICOfundsReceiver) { return _ICOfundsReceiverAddress; } function Owner() public constant returns (address ownerAddress) { return owner; } function SetupDone() public constant returns (bool setupDoneFlag) { return setupDone; } function IsICOrunning() public constant returns (bool isICOrunningFalg) { return isICOrunning; } function IsICOstarted() public constant returns (bool isICOstartedFlag) { return ICOstarted; } function ICOoverTimeStamp() public constant returns (uint256 ICOoverTimestampCheck) { return ICOoverTimestamp; } function BlockICOdatetime() public constant returns (uint256 blockStopICOdate) { return _blockICOdatetime; } function TimeNow() public constant returns (uint256 timenow) { return now; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) public returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) public returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) public returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "493.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /****************************************************************** * AXNET Decentralized Exchange Smart Contract * * ***************************************************************/ contract SafeMath { function safeMul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function safeSub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract Token { function totalSupply() public constant returns (uint); function balanceOf(address _owner) public constant returns (uint); function allowance(address _owner, address _spender) public constant returns (uint); function transfer(address _to, uint _value) public returns (bool success); function approve(address _spender, uint _value) public returns (bool success); function transferFrom(address _from, address _to, uint _value) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); string public name; string public symbol; uint8 public decimals;  // 18 is the most common number of decimal places } contract AXNETDEX is SafeMath, Owned { address public feeAccount; //the account that will receive fees mapping (address => mapping (address => uint)) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether) mapping (address => bool) public admins;  //admins who is responsible for trading //mapping of order hash to mapping of uints (amount of order that has been filled) mapping (bytes32 => uint256) public orderFills; //to make sure withdraw and trade will be done only once mapping (bytes32 => bool) public withdrawn; mapping (bytes32 => bool) public traded; event Cancel(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, address user, uint8 v, bytes32 r, bytes32 s); event Trade(address tokenGet, uint amountGet, address tokenGive, uint amountGive, address get, address give); event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); constructor() public { feeAccount = msg.sender; } function() public { revert(); } function setAdmin(address admin, bool isAdmin) public onlyOwner { admins[admin] = isAdmin; } modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; } function changeFeeAccount(address feeAccount_) public onlyOwner { feeAccount = feeAccount_; } function deposit() payable public { tokens[0][msg.sender] = safeAdd(tokens[0][msg.sender], msg.value); emit Deposit(0, msg.sender, msg.value, tokens[0][msg.sender]); } function depositToken(address token, uint amount) public { //remember to call Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf. require(token!=0); assert(Token(token).transferFrom(msg.sender, this, amount)); tokens[token][msg.sender] = safeAdd(tokens[token][msg.sender], amount); emit Deposit(token, msg.sender, amount, tokens[token][msg.sender]); } function adminWithdraw(address token, uint amount, address user, uint nonce, uint8 v, bytes32 r, bytes32 s, uint feeWithdrawal) public onlyAdmin { bytes32 hash = sha256(this, token, amount, user, nonce); require(!withdrawn[hash]); withdrawn[hash] = true; require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash), v, r, s) == user); if (feeWithdrawal > 50 finney) feeWithdrawal = 50 finney; require(tokens[token][user] >= amount); tokens[token][user] = safeSub(tokens[token][user], amount); tokens[token][feeAccount] = safeAdd(tokens[token][feeAccount], safeMul(feeWithdrawal, amount) / 1 ether); amount = safeMul((1 ether - feeWithdrawal), amount) / 1 ether; if (token == address(0)) { assert(user.send(amount)); } else { assert(Token(token).transfer(user, amount)); } emit Withdraw(token, user, amount, tokens[token][user]); } function balanceOf(address token, address user)  public view returns (uint) { return tokens[token][user]; } /* uint values 0:amountGet, 1:amountGive, 2:expires, 3:nonce, 4:amount, 5:tradeNonce, 6:feeMake, 7:feeTake addressses 0:tokenGet, 1:tokenGive, 2:maker, 3:taker signature binary v[0] rs[0] rs[1] : signature for order v[1] rs[2] rs[3] : signature for trade */ function trade(uint[8] tradeValues, address[4] tradeAddresses, uint8[2] v, bytes32[4] rs) public onlyAdmin { bytes32 orderHash = sha256(this, tradeAddresses[0], tradeValues[0], tradeAddresses[1], tradeValues[1], tradeValues[2], tradeValues[3], tradeAddresses[2]); require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", orderHash), v[0], rs[0], rs[1]) == tradeAddresses[2]); bytes32 tradeHash = sha256(orderHash, tradeValues[4], tradeAddresses[3], tradeValues[5]); require(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", tradeHash), v[1], rs[2], rs[3]) == tradeAddresses[3]); require(!traded[tradeHash]); traded[tradeHash] = true; require(safeAdd(orderFills[orderHash], tradeValues[4]) <= tradeValues[0]); require(tokens[tradeAddresses[0]][tradeAddresses[3]] >= tradeValues[4]); require(tokens[tradeAddresses[1]][tradeAddresses[2]] >= (safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0])); tokens[tradeAddresses[0]][tradeAddresses[3]] = safeSub(tokens[tradeAddresses[0]][tradeAddresses[3]], tradeValues[4]); tokens[tradeAddresses[0]][tradeAddresses[2]] = safeAdd(tokens[tradeAddresses[0]][tradeAddresses[2]], safeMul(tradeValues[4], ((1 ether) - tradeValues[6])) / (1 ether)); tokens[tradeAddresses[0]][feeAccount] = safeAdd(tokens[tradeAddresses[0]][feeAccount], safeMul(tradeValues[4], tradeValues[6]) / (1 ether)); tokens[tradeAddresses[1]][tradeAddresses[2]] = safeSub(tokens[tradeAddresses[1]][tradeAddresses[2]], safeMul(tradeValues[1], tradeValues[4]) / tradeValues[0]); tokens[tradeAddresses[1]][tradeAddresses[3]] = safeAdd(tokens[tradeAddresses[1]][tradeAddresses[3]], safeMul(safeMul(((1 ether) - tradeValues[7]), tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)); tokens[tradeAddresses[1]][feeAccount] = safeAdd(tokens[tradeAddresses[1]][feeAccount], safeMul(safeMul(tradeValues[7], tradeValues[1]), tradeValues[4]) / tradeValues[0] / (1 ether)); orderFills[orderHash] = safeAdd(orderFills[orderHash], tradeValues[4]); } function cancelOrder(address tokenGet, uint amountGet, address tokenGive, uint amountGive, uint expires, uint nonce, uint8 v, bytes32 r, bytes32 s, address user) public onlyAdmin { bytes32 hash = sha256(this, tokenGet, amountGet, tokenGive, amountGive, expires, nonce, msg.sender, user); assert(ecrecover(keccak256(\"\\x19Ethereum Signed Message:\\n32\", hash),v,r,s) == user); orderFills[hash] = amountGet; emit Cancel(tokenGet, amountGet, tokenGive, amountGive, expires, nonce, user, v, r, s); } } "}
{"sol name": "1696.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "276.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol /** * @title DetailedERC20 token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } // File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: contracts/BSPCP.sol contract BSPCP is StandardToken, DetailedERC20, BurnableToken, MintableToken { constructor(string _name, string _symbol, uint8 _decimals) DetailedERC20(_name, _symbol, _decimals) public { } } "}
{"sol name": "1920.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TimoNetwork { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TimoNetwork( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "1895.sol", "label": 0, "sol content": "pragma solidity 0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20 { using SafeMath for uint256; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_from != address(0)); require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract EIForceCoin is StandardToken, Ownable { string public name = \" EIForceCoin \"; string public symbol = \"EFT\"; uint public decimals = 18; // The token allocation uint public constant TOTAL_SUPPLY       = 1000000000e18; uint public constant ALLOC_FOUNDER    =  1000000000e18; // 100% // wallets address public constant WALLET_FOUNDER    = 0x4aDE23e2dc751527b16289c18c7E26fE4dF7a4B7; // 2 groups of lockup mapping(address => uint256) public jishis_locked; mapping(address => uint256) public simus_locked; mapping(address => uint256) public jiedians_locked; mapping(address => uint256) public dakehus_locked; // 2 types of releasing mapping(address => uint256) public jishis_jishiDate; mapping(address => uint256) public simus_simuDate; mapping(address => uint256) public jiedians_jiedianDate; mapping(address => uint256) public dakehus_dakehuDate; // MODIFIER // checks if the address can transfer certain amount of tokens modifier canTransfer(address _sender, uint256 _value) { require(_sender != address(0)); uint256 remaining = balances[_sender].sub(_value); uint256 totalLockAmt = 0; if (jishis_locked[_sender] > 0) { totalLockAmt = totalLockAmt.add(getLockedAmount_jishis(_sender)); } if (simus_locked[_sender] > 0) { totalLockAmt = totalLockAmt.add(getLockedAmount_simus(_sender)); } if (simus_locked[_sender] > 0) { totalLockAmt = totalLockAmt.add(getLockedAmount_jiedians(_sender)); } if (simus_locked[_sender] > 0) { totalLockAmt = totalLockAmt.add(getLockedAmount_dakehus(_sender)); } require(remaining >= totalLockAmt); _; } // EVENTS event UpdatedLockingState(string whom, address indexed to, uint256 value, uint256 date); // FUNCTIONS function EIForceCoin () public { balances[msg.sender] = TOTAL_SUPPLY; totalSupply = TOTAL_SUPPLY; // do the distribution of the token, in token transfer transfer(WALLET_FOUNDER, ALLOC_FOUNDER); } // get jishis' locked amount of token function getLockedAmount_jishis(address _jishi) public constant returns (uint256) { uint256 jishiDate = jishis_jishiDate[_jishi]; uint256 lockedAmt = jishis_locked[_jishi]; if (now <= jishiDate + (30 * 1 days)) {return lockedAmt;} if (now <= jishiDate + (30 * 2 days)) {return lockedAmt.mul(4).div(5);} if (now <= jishiDate + (30 * 3 days)) {return lockedAmt.mul(3).div(5);} if (now <= jishiDate + (30 * 4 days)) {return lockedAmt.mul(2).div(5);} if (now <= jishiDate + (30 * 5 days)) {return lockedAmt.mul(1).div(5);} return 0; } // get simus' locked amount of token function getLockedAmount_simus(address _simu) public constant returns (uint256) { uint256 simuDate = simus_simuDate[_simu]; uint256 lockedAmt = simus_locked[_simu]; if (now <= simuDate + (30 * 1 days)) {return lockedAmt;} if (now <= simuDate + (30 * 2 days)) {return lockedAmt.mul(9).div(10);} if (now <= simuDate + (30 * 3 days)) {return lockedAmt.mul(8).div(10);} if (now <= simuDate + (30 * 4 days)) {return lockedAmt.mul(7).div(10);} if (now <= simuDate + (30 * 5 days)) {return lockedAmt.mul(6).div(10);} if (now <= simuDate + (30 * 6 days)) {return lockedAmt.mul(5).div(10);} if (now <= simuDate + (30 * 7 days)) {return lockedAmt.mul(4).div(10);} if (now <= simuDate + (30 * 8 days)) {return lockedAmt.mul(3).div(10);} if (now <= simuDate + (30 * 9 days)) {return lockedAmt.mul(2).div(10);} if (now <= simuDate + (30 * 10 days)) {return lockedAmt.mul(1).div(10);} return 0; } function getLockedAmount_jiedians(address _jiedian) public constant returns (uint256) { uint256 jiedianDate = jiedians_jiedianDate[_jiedian]; uint256 lockedAmt = jiedians_locked[_jiedian]; if (now <= jiedianDate + (30 * 1 days)) {return lockedAmt;} if (now <= jiedianDate + (30 * 2 days)){return lockedAmt.mul(11).div(12);} if (now <= jiedianDate + (30 * 3 days)) {return lockedAmt.mul(10).div(12);} if (now <= jiedianDate + (30 * 4 days)) {return lockedAmt.mul(9).div(12);} if (now <= jiedianDate + (30 * 5 days)) {return lockedAmt.mul(8).div(12);} if (now <= jiedianDate + (30 * 6 days)) {return lockedAmt.mul(7).div(12);} if (now <= jiedianDate + (30 * 7 days)) {return lockedAmt.mul(6).div(12);} if (now <= jiedianDate + (30 * 8 days)) {return lockedAmt.mul(5).div(12);} if (now <= jiedianDate + (30 * 9 days)) {return lockedAmt.mul(4).div(12);} if (now <= jiedianDate + (30 * 10 days)) {return lockedAmt.mul(3).div(12);} if (now <= jiedianDate + (30 * 11 days)) {return lockedAmt.mul(2).div(12);} if (now <= jiedianDate + (30 * 12 days)) {return lockedAmt.mul(1).div(12);} return 0; } function getLockedAmount_dakehus(address _dakehu) public constant returns (uint256) { uint256 dakehuDate = dakehus_dakehuDate[_dakehu]; uint256 lockedAmt = dakehus_locked[_dakehu]; if (now <= dakehuDate + (30 * 1 days)) {return lockedAmt;} if (now <= dakehuDate + (30 * 2 days)) {return lockedAmt.mul(23).div(24);} if (now <= dakehuDate + (30 * 3 days)) {return lockedAmt.mul(22).div(24);} if (now <= dakehuDate + (30 * 4 days)) {return lockedAmt.mul(21).div(24);} if (now <= dakehuDate + (30 * 5 days)) {return lockedAmt.mul(20).div(24);} if (now <= dakehuDate + (30 * 6 days)) {return lockedAmt.mul(19).div(24);} if (now <= dakehuDate + (30 * 7 days)) {return lockedAmt.mul(18).div(24);} if (now <= dakehuDate + (30 * 8 days)) {return lockedAmt.mul(17).div(24);} if (now <= dakehuDate + (30 * 9 days)) {return lockedAmt.mul(16).div(24);} if (now <= dakehuDate + (30 * 10 days)) {return lockedAmt.mul(15).div(24);} if (now <= dakehuDate + (30 * 11 days)) {return lockedAmt.mul(14).div(24);} if (now <= dakehuDate + (30 * 12 days)) {return lockedAmt.mul(13).div(24);} if (now <= dakehuDate + (30 * 13 days)) {return lockedAmt.mul(12).div(24);} if (now <= dakehuDate + (30 * 14 days)) {return lockedAmt.mul(11).div(24);} if (now <= dakehuDate + (30 * 15 days)) {return lockedAmt.mul(10).div(24);} if (now <= dakehuDate + (30 * 16 days)) {return lockedAmt.mul(9).div(24);} if (now <= dakehuDate + (30 * 17 days)) {return lockedAmt.mul(8).div(24);} if (now <= dakehuDate + (30 * 18 days)) {return lockedAmt.mul(7).div(24);} if (now <= dakehuDate + (30 * 19 days)) {return lockedAmt.mul(6).div(24);} if (now <= dakehuDate + (30 * 20 days)) {return lockedAmt.mul(5).div(24);} if (now <= dakehuDate + (30 * 21 days)) {return lockedAmt.mul(4).div(24);} if (now <= dakehuDate + (30 * 22 days)) {return lockedAmt.mul(3).div(24);} if (now <= dakehuDate + (30 * 23 days)) {return lockedAmt.mul(2).div(24);} if (now <= dakehuDate + (30 * 24 days)) {return lockedAmt.mul(1).div(24);} return 0; } // set lockup for jishis function setLockup_jishis(address _jishi, uint256 _value, uint256 _jishiDate) public onlyOwner { require(_jishi != address(0)); jishis_locked[_jishi] = _value; jishis_jishiDate[_jishi] = _jishiDate; UpdatedLockingState(\"jishi\", _jishi, _value, _jishiDate); } // set lockup for strategic simu function setLockup_simus(address _simu, uint256 _value, uint256 _simuDate) public onlyOwner { require(_simu != address(0)); simus_locked[_simu] = _value; simus_simuDate[_simu] = _simuDate; UpdatedLockingState(\"simu\", _simu, _value, _simuDate); } function setLockup_jiedians(address _jiedian, uint256 _value, uint256 _jiedianDate) public onlyOwner { require(_jiedian != address(0)); jiedians_locked[_jiedian] = _value; jiedians_jiedianDate[_jiedian] = _jiedianDate; UpdatedLockingState(\"jiedian\", _jiedian, _value, _jiedianDate); } function setLockup_dakehus(address _dakehu, uint256 _value, uint256 _dakehuDate) public onlyOwner { require(_dakehu != address(0)); dakehus_locked[_dakehu] = _value; dakehus_dakehuDate[_dakehu] = _dakehuDate; UpdatedLockingState(\"dakehu\", _dakehu, _value, _dakehuDate); } // Transfer amount of tokens from sender account to recipient. function transfer(address _to, uint _value) public canTransfer(msg.sender, _value) returns (bool success) { return super.transfer(_to, _value); } // Transfer amount of tokens from a specified address to a recipient. function transferFrom(address _from, address _to, uint _value) public canTransfer(_from, _value) returns (bool success) { return super.transferFrom(_from, _to, _value); } } "}
{"sol name": "14.sol", "label": 0, "sol content": "contract Token{ uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract TokenDemo is Token { string public name;                   //\u540d\u79f0\uff0c\u4f8b\u5982\"My test token\" uint8 public decimals;               //\u8fd4\u56detoken\u4f7f\u7528\u7684\u5c0f\u6570\u70b9\u540e\u51e0\u4f4d\u3002\u6bd4\u5982\u5982\u679c\u8bbe\u7f6e\u4e3a3\uff0c\u5c31\u662f\u652f\u63010.001\u8868\u793a. string public symbol;               //token\u7b80\u79f0,like MTT function TokenDemo(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);         // \u8bbe\u7f6e\u521d\u59cb\u603b\u91cf balances[msg.sender] = totalSupply; // \u521d\u59cbtoken\u6570\u91cf\u7ed9\u4e88\u6d88\u606f\u53d1\u9001\u8005\uff0c\u56e0\u4e3a\u662f\u6784\u9020\u51fd\u6570\uff0c\u6240\u4ee5\u8fd9\u91cc\u4e5f\u662f\u5408\u7ea6\u7684\u521b\u5efa\u8005 name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { //\u9ed8\u8ba4totalSupply \u4e0d\u4f1a\u8d85\u8fc7\u6700\u5927\u503c (2^256 - 1). //\u5982\u679c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u5c06\u4f1a\u6709\u65b0\u7684token\u751f\u6210\uff0c\u5219\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u53e5\u907f\u514d\u6ea2\u51fa\u7684\u5f02\u5e38 require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(_to != 0x0); balances[msg.sender] -= _value;//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[_to] += _value;//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value Transfer(msg.sender, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value;//\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value balances[_from] -= _value; //\u652f\u51fa\u8d26\u6237_from\u51cf\u53bbtoken\u6570\u91cf_value allowed[_from][msg.sender] -= _value;//\u6d88\u606f\u53d1\u9001\u8005\u53ef\u4ee5\u4ece\u8d26\u6237_from\u4e2d\u8f6c\u51fa\u7684\u6570\u91cf\u51cf\u5c11_value Transfer(_from, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender];//\u5141\u8bb8_spender\u4ece_owner\u4e2d\u8f6c\u51fa\u7684token\u6570 } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } "}
{"sol name": "1765.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/token/ERC20Basic.sol /** * @title ERC20Basic */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/Exafire.sol /** * @title Exafire * @dev DistributableToken contract is based on a simple initial supply token, with an API for the owner to perform bulk distributions. *      transactions to the distributeTokens function should be paginated to avoid gas limits or computational time restrictions. */ contract Exafire is StandardToken, Ownable { string public constant name = \"Exafire\"; string public constant symbol = \"EXA\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 833494437 * (10 ** uint256(decimals)); //prevent duplicate distributions mapping (address => bool) distributionLocks; /** * @dev Constructor that gives msg.sender all of existing tokens. */ function Exafire() { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } /** * @dev Distribute tokens to multiple addresses in a single transaction * * @param addresses A list of addresses to distribute to * @param values A corresponding list of amounts to distribute to each address */ function anailNathrachOrthaBhaisIsBeathaDoChealDeanaimh(address[] addresses, uint256[] values) onlyOwner public returns (bool success) { require(addresses.length == values.length); for (uint i = 0; i < addresses.length; i++) { require(!distributionLocks[addresses[i]]); transfer(addresses[i], values[i]); distributionLocks[addresses[i]] = true; } return true; } } "}
{"sol name": "730.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } // by [email\u00a0protected]  for the consensys course /* function call order : constructor() function addBank(address _addressBank, uint256 _tokens) IsOwner public function addTokensToBank(address _bank, uint256 _tokens) IsOwner public function GetBankBalance() isBank public view returns (uint256) function removeBankToken(uint256 _value) isBank public function ChangeInterest(uint256 _installment, uint256 _value, uint256 _category, bool _enable) isBank public function findOutInterestByBank(uint256 _category, uint256 _amount, uint256 _installment) isBank public view returns(uint256 _value, bool _enable) function addClient (address _addressUser, uint256 _category) IsOwner  public function ChangeClientCategory (address _client, uint256 _category) IsOwner public function GetClientCategory()  isClient public view returns(uint256) function GetClientCategory(address _client) isBank public view returns(uint256) function findOutInterestByClientCategory(address _bankAddress, uint256 _amount, uint256 _installment) isClient public view returns(uint256 _value, bool _enable) function askForALoan(address _bankAddress, uint256 _amount, uint256 _installment) isClient public function GetLoansLenght(bool _pending) public isBank view returns (uint256) { function GetLoanInfo(uint256 _indexLoan, bool _pending)  public view returns(uint256 _debt, address _client, uint256 _installment, uint256 _category , uint256 _amount, address _owner, uint256 _forSale){ function aproveLoan(uint256 _loanIndex) public isBank function getLoanIDbyClient(uint256 _indexLoan) isClient public view returns (uint256){ function getLoansLengthByClient() isClient public view returns(uint256){ function SellLoan(uint256 _indexLoan, uint256 _value) isLoanOwner(_indexLoan)  public function BuyLoan(address _owner, uint256 _loanId, uint256 _value)  isBank public function payOffClientDebt(uint256 _loanId, uint256 _value)  isLoanOwner(_loanId) public function GetClientBalance() isClient public view returns (uint256 _value) function removeClientToken(uint256 _value) isClient public // Portfolios function createPortfolio(uint256 _idLoan) isBank public  returns (uint256 _index) function countPortfolios(address _bankAddress) isBank public view returns (uint256 _result function addLoanToPortfolio(uint256 _indexPortfolio, uint256 _idLoan) isOwnerPortfolio (_indexPortfolio) public returns (bool _result) function GetLoanIdFromPortfolio(uint256 _indexPortfolio, uint256 _indexLoan)  isBank public view returns(uint256 _ID){ function getPortfolioInfo (address _bankAddress, uint256 _indexPortfolio) isBank  public view returns (uint256 _LoansLength, uint256 _forSale, address _owner){ function removeLoanFromPortfolio(uint256 _indexPortfolio, uint256 _idLoan) isOwnerPortfolio (_indexPortfolio) public returns (bool _result) function deletePortfolio(uint256 _indexPortfolio) isOwnerPortfolio(_indexPortfolio) public function sellPorftolio(uint256 _indexPortfolio, uint256 _value) isOwnerPortfolio (_indexPortfolio) public function buyPortfolio(address _owner, uint256 _indexPortfolio, uint256 _value) isBank public */ contract Base { using SafeMath for uint256; address public owner; struct Client { uint256 Tokens; address Owner; uint256 Category; uint256[] LoansID; } struct Bank { uint256 Tokens; address Owner; mapping (uint256=>strCateg) Category; uint256[] LoansID; Loan[] LoanPending; Portfolio[] Portfolios; } struct strCateg{ mapping(uint256=>strAmount) Amount; } struct strAmount{ mapping(uint256=>strInsta) Installment; } struct strInsta{ uint256 value; bool enable; } struct Loan{ uint256 Debt; uint256 Installment; uint256 Id; uint256 ForSale; address Client; address Owner; uint256 Category; uint256 Amount; uint256 StartTime; uint256 EndTime; } struct Portfolio{ uint256[] idLoans; address Owner; uint256 forSale; } mapping(address => Client) clients; mapping(address => Bank) banks; Loan[] loans; function () public payable{ require(false, \"Should not go through this point\"); } } contract ClientFunctions is Base{ modifier isClient(){ require(clients[msg.sender].Owner == msg.sender, \"not a client\"); _; } function askForALoan(address _bankAddress, uint256 _amount, uint256 _installment) isClient public  { require(banks[_bankAddress].Owner==_bankAddress, \"not a valid bank\"); require(banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].enable, \"you not apply for that loan\"); Loan memory _loan; _loan.Debt = _amount; _loan.Debt  = _loan.Debt.add(banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].value); _loan.Client = msg.sender; _loan.Owner = _bankAddress; _loan.Installment = _installment; _loan.Category = clients[msg.sender].Category; _loan.Amount = _amount; banks[_bankAddress].LoanPending.push(_loan); } function findOutInterestByClientCategory(address _bankAddress, uint256 _amount, uint256 _installment) isClient public view returns(uint256 _value, bool _enable){ _value = banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].value; _enable = banks[_bankAddress].Category[clients[msg.sender].Category].Amount[_amount].Installment[_installment].enable; } function removeClientToken(uint256 _value) isClient public{ require(clients[msg.sender].Tokens >= _value, \"You don't have that many tokens\"); clients[msg.sender].Tokens = clients[msg.sender].Tokens.sub(_value); } function getClientBalance() isClient public view returns (uint256 _value){ _value = clients[msg.sender].Tokens; } function getLoansLengthByClient() isClient public view returns(uint256){ return clients[msg.sender].LoansID.length; } function getLoanIDbyClient(uint256 _indexLoan) isClient public view returns (uint256){ return clients[msg.sender].LoansID[_indexLoan]; } function getClientCategory() isClient public view returns(uint256){ return clients[msg.sender].Category; } } contract BankFunctions is ClientFunctions{ modifier isBank(){ require(banks[msg.sender].Owner==msg.sender, \"you are not a bank\"); _; } modifier isLoanOwner(uint256 _id) { require(banks[msg.sender].Owner==msg.sender, \"you are not a bank\"); require(loans[_id].Owner == msg.sender, \"not owner of loan\"); _; } function GetClientCategory(address _client) isBank public view returns(uint256){ return clients[_client].Category; } function removeBankToken(uint256 _value) isBank public{ require(banks[msg.sender].Tokens >= _value, \"You don't have that many tokens\"); banks[msg.sender].Tokens = banks[msg.sender].Tokens.sub(_value); } function payOffClientDebt(uint256 _loanId, uint256 _value)  isLoanOwner(_loanId) public{ require(loans[_loanId].Debt > 0); require(_value > 0); require(loans[_loanId].Debt>= _value); loans[loans.length-1].EndTime = now; loans[_loanId].Debt = loans[_loanId].Debt.sub(_value); } function ChangeInterest(uint256 _category, uint256 _amount, uint256 _installment, uint256 _value, bool _enable) isBank public{ banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].value = _value; banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].enable = _enable; } function GetBankBalance() isBank public view returns (uint256 ){ return banks[msg.sender].Tokens; } function findOutInterestByBank(uint256 _category, uint256 _amount, uint256 _installment) isBank public view returns(uint256 _value, bool _enable){ _value = banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].value; _enable = banks[msg.sender].Category[_category].Amount[_amount].Installment[_installment].enable; } } contract LoansFunctions is BankFunctions{ function SellLoan(uint256 _loanId, uint256 _value) isLoanOwner(_loanId)  public { loans[_loanId].ForSale = _value; } function BuyLoan(address _owner, uint256 _loanId, uint256 _value)  isBank public{ require(loans[_loanId].ForSale > 0, \"not for sale\"); require(banks[msg.sender].Tokens>= _value, \"you don't have money\"); SwitchLoanOwner( _owner,  _loanId); banks[msg.sender].Tokens = banks[msg.sender].Tokens.sub(_value); banks[_owner].Tokens = banks[_owner].Tokens.add(_value); } function SwitchLoanOwner(address _owner, uint256 _loanId) internal{ //requisitos require(loans[_loanId].Debt> 0, \"at least one of the loans is already paid\"); require(loans[_loanId].Owner == _owner); uint256 _indexLoan; for (uint256 i; i<banks[_owner].LoansID.length; i++){ if (banks[_owner].LoansID[i] == _loanId){ _indexLoan = i; i =  banks[_owner].LoansID.length.add(1); } } // asignar Loan banks[msg.sender].LoansID.push(_loanId); if (_indexLoan !=banks[_owner].LoansID.length - 1){ banks[_owner].LoansID[_indexLoan] = banks[_owner].LoansID[banks[_owner].LoansID.length - 1]; } delete banks[_owner].LoansID[banks[_owner].LoansID.length -1]; banks[_owner].LoansID.length --; loans[_loanId].ForSale = 0; loans[_loanId].Owner = msg.sender; } function aproveLoan(uint256 _loanIndex) public { require(banks[msg.sender].LoanPending[_loanIndex].Owner == msg.sender, \"you are not the owner\"); require(banks[msg.sender].Tokens>=banks[msg.sender].LoanPending[_loanIndex].Amount, \"the bank does not have that amount of tokens\"); banks[msg.sender].LoanPending[_loanIndex].Id =loans.length; loans.push(banks[msg.sender].LoanPending[_loanIndex]); loans[loans.length-1].StartTime = now; address _client = banks[msg.sender].LoanPending[_loanIndex].Client; uint256 _amount  = banks[msg.sender].LoanPending[_loanIndex].Amount; banks[msg.sender].LoansID.push(loans.length - 1); clients[_client].LoansID.push(loans.length - 1); clients[_client].Tokens =  clients[_client].Tokens.add(_amount); banks[msg.sender].Tokens =  banks[msg.sender].Tokens.sub(_amount); if(banks[msg.sender].LoanPending.length !=1){ banks[msg.sender].LoanPending[_loanIndex] = banks[msg.sender].LoanPending [banks[msg.sender].LoanPending.length - 1]; } delete banks[msg.sender].LoanPending [banks[msg.sender].LoanPending.length - 1]; banks[msg.sender].LoanPending.length--; } // in case of _pending = true,  the function will check the LoansPending function GetLoansLenght(bool _pending) public isBank view returns (uint256) { if (_pending){ return banks[msg.sender].LoanPending.length; }else{ return banks[msg.sender].LoansID.length; } } function GetLoanInfo(uint256 _indexLoan, bool _pending)  public view returns(uint256 _debt, address _client, uint256 _installment, uint256 _category , uint256 _amount, address _owner, uint256 _forSale, uint256 _StartTime, uint256 _EndTime){ Loan memory _loan; if (_pending){ require (_indexLoan < banks[msg.sender].LoanPending.length, \"null value\"); _loan = banks[msg.sender].LoanPending[_indexLoan]; }else{ _loan = loans[_indexLoan]; } _debt = _loan.Debt; _client =  _loan.Client; _installment =  _loan.Installment; _category = _loan.Category; _amount = _loan.Amount ; _owner = _loan.Owner ; _forSale = _loan.ForSale; _StartTime = _loan.StartTime; _EndTime = _loan.EndTime; } } contract PortfolioFunctions is LoansFunctions{ modifier isOwnerPortfolio(uint256 _indexPortfolio)  { require(banks[msg.sender].Portfolios[_indexPortfolio].Owner== msg.sender, \"not the owner of portfolio\"); _; } function createPortfolio(uint256 _idLoan) isBank public  returns (uint256 )  { require(msg.sender== loans[_idLoan].Owner); Portfolio  memory  _portfolio; banks[msg.sender].Portfolios.push(_portfolio); banks[msg.sender].Portfolios[banks[msg.sender].Portfolios.length-1].idLoans.push(_idLoan); banks[msg.sender].Portfolios[banks[msg.sender].Portfolios.length-1].Owner= msg.sender; return banks[msg.sender].Portfolios.length-1; } function deletePortfolio(uint256 _indexPortfolio) isOwnerPortfolio(_indexPortfolio) public{ uint256 _PortfolioLength = banks[msg.sender].Portfolios.length; banks[msg.sender].Portfolios[_indexPortfolio] = banks[msg.sender].Portfolios[_PortfolioLength -1]; delete banks[msg.sender].Portfolios[_PortfolioLength -1]; banks[msg.sender].Portfolios.length --; } function addLoanToPortfolio(uint256 _indexPortfolio, uint256 _idLoan) isOwnerPortfolio (_indexPortfolio) public { for(uint256 i; i<banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length;i++){ if (banks[msg.sender].Portfolios[_indexPortfolio].idLoans[i]==_idLoan){ require(false, \"that loan already exists on the portfolio\"); } } banks[msg.sender].Portfolios[_indexPortfolio].idLoans.push(_idLoan); } function removeLoanFromPortfolio(uint256 _indexPortfolio, uint256 _idLoan) isOwnerPortfolio (_indexPortfolio) public returns (bool _result){ uint256 Loanslength = banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length; uint256 _loanIndex = Loanslength; for(uint256 i; i<Loanslength; i++){ if(_idLoan ==banks[msg.sender].Portfolios[_indexPortfolio].idLoans[i]){ _loanIndex = i; i= Loanslength; } } require(_loanIndex<Loanslength, \"the loan is not in the portfolio\"); if (_loanIndex !=banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length-1){ banks[msg.sender].Portfolios[_indexPortfolio].idLoans[_loanIndex] = banks[msg.sender].Portfolios[_indexPortfolio].idLoans[Loanslength-1]; } delete banks[msg.sender].Portfolios[_indexPortfolio].idLoans[Loanslength -1]; banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length --; if (banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length == 0){ deletePortfolio(_indexPortfolio); } _result = true; } function getPortfolioInfo (address _bankAddress, uint256 _indexPortfolio) isBank  public view returns (uint256 _LoansLength, uint256 _forSale, address _owner){ require(banks[_bankAddress].Portfolios[_indexPortfolio].Owner == _bankAddress, \"not the owner of that portfolio\"); _LoansLength =    banks[_bankAddress].Portfolios[_indexPortfolio].idLoans.length; _forSale =    banks[_bankAddress].Portfolios[_indexPortfolio].forSale; _owner =    banks[_bankAddress].Portfolios[_indexPortfolio].Owner; } function sellPorftolio(uint256 _indexPortfolio, uint256 _value) isOwnerPortfolio (_indexPortfolio) public { require(banks[msg.sender].Portfolios[_indexPortfolio].idLoans.length>0); banks[msg.sender].Portfolios[_indexPortfolio].forSale = _value; } function buyPortfolio(address _owner, uint256 _indexPortfolio, uint256 _value) isBank public { require(banks[msg.sender].Tokens>=_value); require(banks[_owner].Portfolios[_indexPortfolio].idLoans.length > 0); require(banks[_owner].Portfolios[_indexPortfolio].forSale > 0); require(banks[_owner].Portfolios[_indexPortfolio].forSale == _value ); banks[msg.sender].Tokens = banks[msg.sender].Tokens.sub(_value); banks[_owner].Tokens = banks[_owner].Tokens.add(_value); for(uint256 a;a< banks[_owner].Portfolios[_indexPortfolio].idLoans.length ;a++){ SwitchLoanOwner(_owner,  banks[_owner].Portfolios[_indexPortfolio].idLoans[a]); } if (_indexPortfolio !=banks[_owner].Portfolios.length-1){ banks[_owner].Portfolios[_indexPortfolio] = banks[_owner].Portfolios[banks[_owner].Portfolios.length-1]; } delete banks[_owner].Portfolios[banks[_owner].Portfolios.length -1]; banks[_owner].Portfolios.length--; } function countPortfolios(address _bankAddress) isBank public view returns (uint256 _result){ _result = banks[_bankAddress].Portfolios.length; } function GetLoanIdFromPortfolio(uint256 _indexPortfolio, uint256 _indexLoan)  isBank public view returns(uint256 _ID){ return banks[msg.sender].Portfolios[_indexPortfolio].idLoans[_indexLoan]; } } contract GobernanceFunctions is PortfolioFunctions{ modifier IsOwner{ require(owner == msg.sender, \"not the owner\"); _; } function addBank(address _addressBank, uint256 _tokens) IsOwner public{ require(banks[_addressBank].Owner==0); require(clients[_addressBank].Owner == 0); banks[_addressBank].Owner=_addressBank; banks[_addressBank].Tokens =  _tokens; } function addClient (address _addressClient, uint256 _category) IsOwner  public{ require(banks[_addressClient].Owner!=_addressClient, \"that addreess is a bank\"); require(clients[_addressClient].Owner!=_addressClient, \"that client already exists\"); require (_category > 0); clients[_addressClient].Owner = _addressClient; clients[_addressClient].Category =  _category; clients[_addressClient].Tokens =  0; } function addTokensToBank(address _bank, uint256 _tokens) IsOwner public{ require(banks[_bank].Owner==_bank, \"not a Bank\"); banks[_bank].Tokens = banks[_bank].Tokens.add(_tokens); } function changeClientCategory (address _client, uint256 _category) IsOwner public{ require (clients[_client].Owner==_client, \"not a client\"); clients[_client].Category = _category; } } contract LoansAndPortfolios is GobernanceFunctions{ constructor() public { owner = msg.sender; } } "}
{"sol name": "442.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; modifier onlyPayloadSize(uint256 numwords) { assert(msg.data.length >= numwords * 32 + 4); _; } /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) onlyPayloadSize(2) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * @dev Implementation of the basic standard token. */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) onlyPayloadSize(3) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) onlyPayloadSize(2) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) onlyPayloadSize(2) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) onlyPayloadSize(2) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title Claimable * @dev Extension for the Ownable contract, where the ownership needs to be claimed. * This allows the new owner to accept the transfer. */ contract Claimable is Ownable { address public pendingOwner; /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation */ contract MintableToken is PausableToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } address public saleAgent = address(0); address public saleAgent2 = address(0); function setSaleAgent(address newSaleAgent) onlyOwner public { saleAgent = newSaleAgent; } function setSaleAgent2(address newSaleAgent) onlyOwner public { saleAgent2 = newSaleAgent; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) canMint public returns (bool) { require(msg.sender == saleAgent || msg.sender == saleAgent2 || msg.sender == owner); totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(this), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract LEAD is MintableToken, Claimable { string public constant name = \"LEADEX\"; string public constant symbol = \"LEAD\"; uint public constant decimals = 8; } contract TokenSale is Ownable { using SafeMath for uint; uint256 public startTime; uint256 public endTime; uint256 constant dec = 10 ** 8; uint256 public tokensToSale = 500000000 * 10 ** 8; // address where funds are collected address public wallet; // one token per one rate uint256 public rate = 800; LEAD public token; // Amount of raised money in wei uint256 public weiRaised; uint256 public minTokensToSale = 200 * dec; uint256 timeBonus1 = 30; uint256 timeBonus2 = 20; uint256 timeBonus3 = 10; uint256 timeStaticBonus = 0; // Round 1 bonuses uint256 bonus1_1 = 15; uint256 bonus1_2 = 25; uint256 bonus1_3 = 35; uint256 bonus1_4 = 45; // Round 2 bonuses uint256 bonus2_1 = 10; uint256 bonus2_2 = 20; uint256 bonus2_3 = 30; uint256 bonus2_4 = 40; // Round 3 bonuses uint256 bonus3_1 = 10; uint256 bonus3_2 = 15; uint256 bonus3_3 = 25; uint256 bonus3_4 = 35; // Round 4 bonuses uint256 bonus4_1 = 5; uint256 bonus4_2 = 10; uint256 bonus4_3 = 20; uint256 bonus4_4 = 30; // Amount bonuses uint256 amount1 = 0; uint256 amount2 = 2 * dec; uint256 amount3 = 3 * dec; uint256 amount4 = 5 * dec; constructor( address _token, uint256 _startTime, uint256 _endTime, address _wallet) public { require(_token != address(0)); require(_endTime > _startTime); require(_wallet != address(0)); token = LEAD(_token); startTime = _startTime; endTime = _endTime; wallet = _wallet; } modifier saleIsOn() { uint tokenSupply = token.totalSupply(); require(now > startTime && now < endTime); require(tokenSupply <= tokensToSale); _; } function setMinTokensToSale( uint256 _newMinTokensToSale) onlyOwner public { minTokensToSale = _newMinTokensToSale; } function setAmount( uint256 _newAmount1, uint256 _newAmount2, uint256 _newAmount3, uint256 _newAmount4) onlyOwner public { amount1 = _newAmount1; amount2 = _newAmount2; amount3 = _newAmount3; amount4 = _newAmount4; } function getBonus(uint256 _value) internal view returns (uint256) { if(_value >= amount1 && _value < amount2) { return bonus1_1; } else if(_value >= amount2 && _value < amount3) { return bonus1_2; } else if(_value >= amount3 && _value < amount4) { return bonus1_3; } else if(_value >= amount4) { return bonus1_4; } } function getBonus2(uint256 _value) internal view returns (uint256) { if(_value >= amount1 && _value < amount2) { return bonus2_1; } else if(_value >= amount2 && _value < amount3) { return bonus2_2; } else if(_value >= amount3 && _value < amount4) { return bonus2_3; } else if(_value >= amount4) { return bonus2_4; } } function getBonus3(uint256 _value) internal view returns (uint256) { if(_value >= amount1 && _value < amount2) { return bonus3_1; } else if(_value >= amount2 && _value < amount3) { return bonus3_2; } else if(_value >= amount3 && _value < amount4) { return bonus3_3; } else if(_value >= amount4) { return bonus3_4; } } function getBonus4(uint256 _value) internal view returns (uint256) { if(_value >= amount1 && _value < amount2) { return bonus4_1; } else if(_value >= amount2 && _value < amount3) { return bonus4_2; } else if(_value >= amount3 && _value < amount4) { return bonus4_3; } else if(_value >= amount4) { return bonus4_4; } } function getTimeBonus(uint256 _value) public view returns (uint256) { if(now < startTime + 61 days) { // Round 1 return getBonus(_value); } else if(now >= startTime + 61 days && now < startTime + 120 days) { // Round 2 return getBonus2(_value); } else if(now >= startTime + 120 days && now < startTime + 181 days) { // Round 3 return getBonus3(_value); } else if(now >= startTime + 181 days && now < endTime) { // Round 4 return getBonus4(_value); } } function setEndTime(uint256 _newEndTime) onlyOwner public { require(now < _newEndTime); endTime = _newEndTime; } function setRate(uint256 _newRate) public onlyOwner { rate = _newRate; } function setTeamAddress(address _newWallet) onlyOwner public { require(_newWallet != address(0)); wallet = _newWallet; } /** * events for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenPartners(address indexed purchaser, address indexed beneficiary, uint256 amount); function buyTokens(address beneficiary) saleIsOn public payable { require(beneficiary != address(0)); uint256 weiAmount = (msg.value).div(10 ** 10); uint256 all = 100; uint256 timeBonusNow = getTimeBonus(weiAmount); // calculate token amount to be created uint256 tokens = weiAmount.mul(rate); require(tokens >= minTokensToSale); uint256 tokensSumBonus = tokens.add(tokens.mul(timeBonusNow).div(all)); require(tokensToSale > tokensSumBonus.add(token.totalSupply())); weiRaised = weiRaised.add(msg.value); token.mint(beneficiary, tokensSumBonus); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokensSumBonus); wallet.transfer(msg.value); } // fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender); } // @return true if tokensale event has ended function hasEnded() public view returns (bool) { return now > endTime; } function kill() onlyOwner public { selfdestruct(owner); } } "}
{"sol name": "807.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: bancor-contracts/solidity/contracts/utility/interfaces/IOwned.sol /* Owned contract interface */ contract IOwned { // this function isn't abstract since the compiler emits automatically generated getter functions as external function owner() public view returns (address) {} function transferOwnership(address _newOwner) public; function acceptOwnership() public; } // File: bancor-contracts/solidity/contracts/utility/Owned.sol /* Provides support and utilities for contract ownership */ contract Owned is IOwned { address public owner; address public newOwner; event OwnerUpdate(address indexed _prevOwner, address indexed _newOwner); /** @dev constructor */ constructor() public { owner = msg.sender; } // allows execution by the owner only modifier ownerOnly { assert(msg.sender == owner); _; } /** @dev allows transferring the contract ownership the new owner still needs to accept the transfer can only be called by the contract owner @param _newOwner    new contract owner */ function transferOwnership(address _newOwner) public ownerOnly { require(_newOwner != owner); newOwner = _newOwner; } /** @dev used by a new owner to accept an ownership transfer */ function acceptOwnership() public { require(msg.sender == newOwner); emit OwnerUpdate(owner, newOwner); owner = newOwner; newOwner = address(0); } } // File: bancor-contracts/solidity/contracts/token/interfaces/IERC20Token.sol /* ERC20 Standard Token interface */ contract IERC20Token { // these functions aren't abstract since the compiler emits automatically generated getter functions as external function name() public view returns (string) {} function symbol() public view returns (string) {} function decimals() public view returns (uint8) {} function totalSupply() public view returns (uint256) {} function balanceOf(address _owner) public view returns (uint256) { _owner; } function allowance(address _owner, address _spender) public view returns (uint256) { _owner; _spender; } function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); } // File: bancor-contracts/solidity/contracts/utility/Utils.sol /* Utilities & Common Modifiers */ contract Utils { /** constructor */ constructor() public { } // verifies that an amount is greater than zero modifier greaterThanZero(uint256 _amount) { require(_amount > 0); _; } // validates an address - currently only checks that it isn't null modifier validAddress(address _address) { require(_address != address(0)); _; } // verifies that the address is different than this contract address modifier notThis(address _address) { require(_address != address(this)); _; } // Overflow protected math functions /** @dev returns the sum of _x and _y, asserts if the calculation overflows @param _x   value 1 @param _y   value 2 @return sum */ function safeAdd(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x + _y; assert(z >= _x); return z; } /** @dev returns the difference of _x minus _y, asserts if the subtraction results in a negative number @param _x   minuend @param _y   subtrahend @return difference */ function safeSub(uint256 _x, uint256 _y) internal pure returns (uint256) { assert(_x >= _y); return _x - _y; } /** @dev returns the product of multiplying _x by _y, asserts if the calculation overflows @param _x   factor 1 @param _y   factor 2 @return product */ function safeMul(uint256 _x, uint256 _y) internal pure returns (uint256) { uint256 z = _x * _y; assert(_x == 0 || z / _x == _y); return z; } } // File: bancor-contracts/solidity/contracts/utility/interfaces/ITokenHolder.sol /* Token Holder interface */ contract ITokenHolder is IOwned { function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public; } // File: bancor-contracts/solidity/contracts/utility/TokenHolder.sol /* We consider every contract to be a 'token holder' since it's currently not possible for a contract to deny receiving tokens. The TokenHolder's contract sole purpose is to provide a safety mechanism that allows the owner to send tokens that were sent to the contract by mistake back to their sender. */ contract TokenHolder is ITokenHolder, Owned, Utils { /** @dev constructor */ constructor() public { } /** @dev withdraws tokens held by the contract and sends them to an account can only be called by the owner @param _token   ERC20 token contract address @param _to      account to receive the new amount @param _amount  amount to withdraw */ function withdrawTokens(IERC20Token _token, address _to, uint256 _amount) public ownerOnly validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); } } // File: bancor-contracts/solidity/contracts/token/ERC20Token.sol /** ERC20 Standard Token implementation */ contract ERC20Token is IERC20Token, Utils { string public standard = 'Token 0.1'; string public name = ''; string public symbol = ''; uint8 public decimals = 0; uint256 public totalSupply = 0; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /** @dev constructor @param _name        token name @param _symbol      token symbol @param _decimals    decimal points, for display purposes */ constructor(string _name, string _symbol, uint8 _decimals) public { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); // validate input name = _name; symbol = _symbol; decimals = _decimals; } /** @dev send coins throws on any error rather then return a false flag to minimize user errors @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { balanceOf[msg.sender] = safeSub(balanceOf[msg.sender], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors @param _from    source address @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool success) { allowance[_from][msg.sender] = safeSub(allowance[_from][msg.sender], _value); balanceOf[_from] = safeSub(balanceOf[_from], _value); balanceOf[_to] = safeAdd(balanceOf[_to], _value); emit Transfer(_from, _to, _value); return true; } /** @dev allow another account/contract to spend some tokens on your behalf throws on any error rather then return a false flag to minimize user errors also, to minimize the risk of the approve/transferFrom attack vector (see https://docs.google.com/document/d/1YLPtQxZu1UAvO9cZ1O2RPXBbT0mooh4DYKjA_jp-RLM/), approve has to be called twice in 2 separate transactions - once to change the allowance to 0 and secondly to change it to the new allowance value @param _spender approved address @param _value   allowance amount @return true if the approval was successful, false if it wasn't */ function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) { // if the allowance isn't 0, it can only be updated to 0 to prevent an allowance change immediately after withdrawal require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } } // File: bancor-contracts/solidity/contracts/token/interfaces/ISmartToken.sol /* Smart Token interface */ contract ISmartToken is IOwned, IERC20Token { function disableTransfers(bool _disable) public; function issue(address _to, uint256 _amount) public; function destroy(address _from, uint256 _amount) public; } // File: bancor-contracts/solidity/contracts/token/SmartToken.sol /* Smart Token v0.3 'Owned' is specified here for readability reasons */ contract SmartToken is ISmartToken, Owned, ERC20Token, TokenHolder { string public version = '0.3'; bool public transfersEnabled = true;    // true if transfer/transferFrom are enabled, false if not // triggered when a smart token is deployed - the _token address is defined for forward compatibility, in case we want to trigger the event from a factory event NewSmartToken(address _token); // triggered when the total supply is increased event Issuance(uint256 _amount); // triggered when the total supply is decreased event Destruction(uint256 _amount); /** @dev constructor @param _name       token name @param _symbol     token short symbol, minimum 1 character @param _decimals   for display purposes only */ constructor(string _name, string _symbol, uint8 _decimals) public ERC20Token(_name, _symbol, _decimals) { emit NewSmartToken(address(this)); } // allows execution only when transfers aren't disabled modifier transfersAllowed { assert(transfersEnabled); _; } /** @dev disables/enables transfers can only be called by the contract owner @param _disable    true to disable transfers, false to enable them */ function disableTransfers(bool _disable) public ownerOnly { transfersEnabled = !_disable; } /** @dev increases the token supply and sends the new tokens to an account can only be called by the contract owner @param _to         account to receive the new amount @param _amount     amount to increase the supply by */ function issue(address _to, uint256 _amount) public ownerOnly validAddress(_to) notThis(_to) { totalSupply = safeAdd(totalSupply, _amount); balanceOf[_to] = safeAdd(balanceOf[_to], _amount); emit Issuance(_amount); emit Transfer(this, _to, _amount); } /** @dev removes tokens from an account and decreases the token supply can be called by the contract owner to destroy tokens from any account or by any holder to destroy tokens from his/her own account @param _from       account to remove the amount from @param _amount     amount to decrease the supply by */ function destroy(address _from, uint256 _amount) public { require(msg.sender == _from || msg.sender == owner); // validate input balanceOf[_from] = safeSub(balanceOf[_from], _amount); totalSupply = safeSub(totalSupply, _amount); emit Transfer(_from, this, _amount); emit Destruction(_amount); } // ERC20 standard method overrides with some extra functionality /** @dev send coins throws on any error rather then return a false flag to minimize user errors in addition to the standard checks, the function throws if transfers are disabled @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transfer(address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transfer(_to, _value)); return true; } /** @dev an account/contract attempts to get the coins throws on any error rather then return a false flag to minimize user errors in addition to the standard checks, the function throws if transfers are disabled @param _from    source address @param _to      target address @param _value   transfer amount @return true if the transfer was successful, false if it wasn't */ function transferFrom(address _from, address _to, uint256 _value) public transfersAllowed returns (bool success) { assert(super.transferFrom(_from, _to, _value)); return true; } } // File: contracts/BAYToken.sol /** * @title daicobay token * @dev daicobay token is a Smart Token based on Bancor Protocol */ contract BAYToken is SmartToken ( \"daicobay token\", \"BAY\", 18){ constructor() { issue(msg.sender, 10**10 * 10**18); } } "}
{"sol name": "596.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); } } /** * Detailed */ contract MyCoin is StandardToken,BurnableToken { string public name = \"DoraCoin\"; string public symbol = \"DOR\"; uint256 public decimals = 18; uint256 public INITIAL_SUPPLY = 51000000 * (10 ** uint256(decimals)); function MyCoin() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "120.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ZEXCoin' token contract // // Deployed to : 0x62020f645e51dac4d6971ff9ed0ce6b07e608243 // Symbol      : Zex // Name        : ZEXCoin // Total supply: 10000000000 // Decimals    : 2 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ZEXCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ZEXCoin() public { symbol = \"ZEX\"; name = \"ZEXCoin\"; decimals = 2; _totalSupply = 10000000000; balances[0x62020f645e51dac4d6971ff9ed0ce6b07e608243] = _totalSupply; Transfer(address(0), 0x62020f645e51dac4d6971ff9ed0ce6b07e608243, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "77.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; contract BlocktekUniversity { string public symbol = \"\"; string public name = \"\"; uint8 public constant decimals = 18; uint256 _totalSupply = 0; address owner = 0; address certificateAuthoirty = 0xC3334De449a1dD1B0FEc7304339371646be8a0c9; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) allowed; function BlocktekUniversity(address adr) { owner = adr; symbol = \"BKU\"; name = \"Blocktek University Credits\"; _totalSupply = 150000000 * 10**18; balances[owner] = _totalSupply; } function totalSupply() constant returns (uint256 totalSupply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) returns (bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) returns (bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) returns (bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "304.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "1935.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract DomonXToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; constructor() public { symbol = \"LZC\"; name = \"\u7eff\u6d32\u94fe\"; decimals = 18; _totalSupply = 20000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "555.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract PeraToken is PausableToken { string public constant name = \"PERA\"; string public constant symbol = \"PERA\"; uint8 public constant decimals = 8; uint256 public constant INITIAL_SUPPLY = 92853735500000000; mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer( address indexed _from, address indexed _to, uint256 _value ); event Approval( address indexed _owner, address indexed _spender, uint256 _value ); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } //implemented the functionality, which checks whether a transfer goes to a contract function transfer(address _to, uint256 _value) public returns (bool) { require(!isContract(_to)); require(!frozenAccount[msg.sender]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen return super.transfer(_to, _value); } //this function specifies the possibility of a complete data set transfer //the web3_batch_function explains how you use this function function batchTransfer(address[] _tos, uint256[] _amount) onlyOwner public whenNotPaused returns (bool success) { require(_tos.length == _amount.length); uint256 i; uint256 sum = 0; for(i = 0; i < _amount.length; i++){ sum = sum.add(_amount[i]); require(_tos[i] != address(0)); } require(balances[msg.sender] >= sum); for(i = 0; i < _tos.length; i++){ transfer(_tos[i], _amount[i]); } return true; } //false and true as arguments for freeze function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } //as mentioned in the erc223 standard you need a function that checks whether an receiving wallet address is a contract function isContract(address _addr) internal view returns(bool is_contract){ uint length; assembly { //retrieve the code length/size on target address length := extcodesize(_addr) } return (length>0); } } "}
{"sol name": "617.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Creedex' token contract // // Deployed to : 0x16385DfCC9139FfB357746780b64a605B4CB46f0 // Symbol      : CDEX // Name        : Creedex // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Creedex is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Creedex() public { symbol = \"CDEX\"; name = \"Creedex\"; decimals = 18; _totalSupply = 10000000000000000000000000; balances[0x16385DfCC9139FfB357746780b64a605B4CB46f0] = _totalSupply; Transfer(address(0), 0x16385DfCC9139FfB357746780b64a605B4CB46f0, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "889.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract TCPC is StandardToken { string public constant name = \"Test Coin PrimeCore\"; // solium-disable-line uppercase string public constant symbol = \"TCPC\"; // solium-disable-line uppercase uint8 public constant decimals = 8; // solium-disable-line uppercase address public constant tokenOwner = 0x3c9da12eda40d69713ef7c6129e5ebd75983ac3d; uint256 public constant INITIAL_SUPPLY = 6750000000 * (10 ** uint256(decimals)); function TCPC() public { totalSupply_ = INITIAL_SUPPLY; balances[tokenOwner] = INITIAL_SUPPLY; emit Transfer(0x0, tokenOwner, INITIAL_SUPPLY); } } "}
{"sol name": "857.sol", "label": 0, "sol content": "pragma solidity 0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } /** * @title TT\u4ee3\u5e01\u5408\u7ea6 */ contract TrustTokenERC20 { /* \u516c\u5171\u53d8\u91cf */ string public name; //\u4ee3\u5e01\u540d\u79f0 string public symbol; //\u4ee3\u5e01\u7b26\u53f7\u6bd4\u5982'$' uint8 public decimals = 18;  //\u4ee3\u5e01\u5355\u4f4d\uff0c\u5c55\u793a\u7684\u5c0f\u6570\u70b9\u540e\u9762\u591a\u5c11\u4e2a0,\u548c\u4ee5\u592a\u5e01\u4e00\u6837\u540e\u9762\u662f\u662f18\u4e2a0 uint256 public totalSupply; //\u4ee3\u5e01\u603b\u91cf /*\u8bb0\u5f55\u6240\u6709\u4f59\u989d\u7684\u6620\u5c04*/ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; /* \u5728\u533a\u5757\u94fe\u4e0a\u521b\u5efa\u4e00\u4e2a\u4e8b\u4ef6\uff0c\u7528\u4ee5\u901a\u77e5\u5ba2\u6237\u7aef*/ event Transfer(address indexed from, address indexed to, uint256 value);  //\u8f6c\u5e10\u901a\u77e5\u4e8b\u4ef6 event Burn(address indexed from, uint256 value);  //\u51cf\u53bb\u7528\u6237\u4f59\u989d\u4e8b\u4ef6 /* \u521d\u59cb\u5316\u5408\u7ea6\uff0c\u5e76\u4e14\u628a\u521d\u59cb\u7684\u6240\u6709\u4ee3\u5e01\u90fd\u7ed9\u8fd9\u5408\u7ea6\u7684\u521b\u5efa\u8005 * @param initialSupply \u4ee3\u5e01\u7684\u603b\u6570 * @param tokenName \u4ee3\u5e01\u540d\u79f0 * @param tokenSymbol \u4ee3\u5e01\u7b26\u53f7 */ function TrustTokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { //\u521d\u59cb\u5316\u603b\u91cf totalSupply = initialSupply * 10 ** uint256(decimals);    //\u4ee5\u592a\u5e01\u662f10^18\uff0c\u540e\u976218\u4e2a0\uff0c\u6240\u4ee5\u9ed8\u8ba4decimals\u662f18 //\u7ed9\u6307\u5b9a\u5e10\u6237\u521d\u59cb\u5316\u4ee3\u5e01\u603b\u91cf\uff0c\u521d\u59cb\u5316\u7528\u4e8e\u5956\u52b1\u5408\u7ea6\u521b\u5efa\u8005 balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } /** * \u79c1\u6709\u65b9\u6cd5\u4ece\u4e00\u4e2a\u5e10\u6237\u53d1\u9001\u7ed9\u53e6\u4e00\u4e2a\u5e10\u6237\u4ee3\u5e01 * @param  _from address \u53d1\u9001\u4ee3\u5e01\u7684\u5730\u5740 * @param  _to address \u63a5\u53d7\u4ee3\u5e01\u7684\u5730\u5740 * @param  _value uint256 \u63a5\u53d7\u4ee3\u5e01\u7684\u6570\u91cf */ function _transfer(address _from, address _to, uint256 _value) internal { //\u907f\u514d\u8f6c\u5e10\u7684\u5730\u5740\u662f0x0 require(_to != 0x0); //\u68c0\u67e5\u53d1\u9001\u8005\u662f\u5426\u62e5\u6709\u8db3\u591f\u4f59\u989d require(balanceOf[_from] >= _value); //\u68c0\u67e5\u662f\u5426\u6ea2\u51fa require(balanceOf[_to] + _value > balanceOf[_to]); //\u4fdd\u5b58\u6570\u636e\u7528\u4e8e\u540e\u9762\u7684\u5224\u65ad uint previousBalances = balanceOf[_from] + balanceOf[_to]; //\u4ece\u53d1\u9001\u8005\u51cf\u6389\u53d1\u9001\u989d balanceOf[_from] -= _value; //\u7ed9\u63a5\u6536\u8005\u52a0\u4e0a\u76f8\u540c\u7684\u91cf balanceOf[_to] += _value; //\u901a\u77e5\u4efb\u4f55\u76d1\u542c\u8be5\u4ea4\u6613\u7684\u5ba2\u6237\u7aef Transfer(_from, _to, _value); //\u5224\u65ad\u4e70\u3001\u5356\u53cc\u65b9\u7684\u6570\u636e\u662f\u5426\u548c\u8f6c\u6362\u524d\u4e00\u81f4 assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * \u4ece\u4e3b\u5e10\u6237\u5408\u7ea6\u8c03\u7528\u8005\u53d1\u9001\u7ed9\u522b\u4eba\u4ee3\u5e01 * @param  _to address \u63a5\u53d7\u4ee3\u5e01\u7684\u5730\u5740 * @param  _value uint256 \u63a5\u53d7\u4ee3\u5e01\u7684\u6570\u91cf */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * \u4ece\u67d0\u4e2a\u6307\u5b9a\u7684\u5e10\u6237\u4e2d\uff0c\u5411\u53e6\u4e00\u4e2a\u5e10\u6237\u53d1\u9001\u4ee3\u5e01 * * \u8c03\u7528\u8fc7\u7a0b\uff0c\u4f1a\u68c0\u67e5\u8bbe\u7f6e\u7684\u5141\u8bb8\u6700\u5927\u4ea4\u6613\u989d * * @param  _from address \u53d1\u9001\u8005\u5730\u5740 * @param  _to address \u63a5\u53d7\u8005\u5730\u5740 * @param  _value uint256 \u8981\u8f6c\u79fb\u7684\u4ee3\u5e01\u6570\u91cf * @return success        \u662f\u5426\u4ea4\u6613\u6210\u529f */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success){ //\u68c0\u67e5\u53d1\u9001\u8005\u662f\u5426\u62e5\u6709\u8db3\u591f\u4f59\u989d require(_value <= allowance[_from][msg.sender]);   // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * \u8bbe\u7f6e\u5e10\u6237\u5141\u8bb8\u652f\u4ed8\u7684\u6700\u5927\u91d1\u989d * * \u4e00\u822c\u5728\u667a\u80fd\u5408\u7ea6\u7684\u65f6\u5019\uff0c\u907f\u514d\u652f\u4ed8\u8fc7\u591a\uff0c\u9020\u6210\u98ce\u9669 * * @param _spender \u5e10\u6237\u5730\u5740 * @param _value \u91d1\u989d */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * \u8bbe\u7f6e\u5e10\u6237\u5141\u8bb8\u652f\u4ed8\u7684\u6700\u5927\u91d1\u989d * * \u4e00\u822c\u5728\u667a\u80fd\u5408\u7ea6\u7684\u65f6\u5019\uff0c\u907f\u514d\u652f\u4ed8\u8fc7\u591a\uff0c\u9020\u6210\u98ce\u9669\uff0c\u52a0\u5165\u65f6\u95f4\u53c2\u6570\uff0c\u53ef\u4ee5\u5728 tokenRecipient \u4e2d\u505a\u5176\u4ed6\u64cd\u4f5c * * @param _spender \u5e10\u6237\u5730\u5740 * @param _value \u91d1\u989d * @param _extraData \u64cd\u4f5c\u7684\u65f6\u95f4 */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * \u51cf\u5c11\u4ee3\u5e01\u8c03\u7528\u8005\u7684\u4f59\u989d * * \u64cd\u4f5c\u4ee5\u540e\u662f\u4e0d\u53ef\u9006\u7684 * * @param _value \u8981\u5220\u9664\u7684\u6570\u91cf */ function burn(uint256 _value) public returns (bool success) { //\u68c0\u67e5\u5e10\u6237\u4f59\u989d\u662f\u5426\u5927\u4e8e\u8981\u51cf\u53bb\u7684\u503c require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough //\u7ed9\u6307\u5b9a\u5e10\u6237\u51cf\u53bb\u4f59\u989d balanceOf[msg.sender] -= _value; //\u4ee3\u5e01\u95ee\u9898\u505a\u76f8\u5e94\u6263\u9664 totalSupply -= _value; Burn(msg.sender, _value); return true; } /** * \u5220\u9664\u5e10\u6237\u7684\u4f59\u989d\uff08\u542b\u5176\u4ed6\u5e10\u6237\uff09 * * \u5220\u9664\u4ee5\u540e\u662f\u4e0d\u53ef\u9006\u7684 * * @param _from \u8981\u64cd\u4f5c\u7684\u5e10\u6237\u5730\u5740 * @param _value \u8981\u51cf\u53bb\u7684\u6570\u91cf */ function burnFrom(address _from, uint256 _value) public returns (bool success) { //\u68c0\u67e5\u5e10\u6237\u4f59\u989d\u662f\u5426\u5927\u4e8e\u8981\u51cf\u53bb\u7684\u503c require(balanceOf[_from] >= _value); //\u68c0\u67e5 \u5176\u4ed6\u5e10\u6237 \u7684\u4f59\u989d\u662f\u5426\u591f\u4f7f\u7528 require(_value <= allowance[_from][msg.sender]); //\u51cf\u6389\u4ee3\u5e01 balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; //\u66f4\u65b0\u603b\u91cf totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "635.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract INCRYPT is owned, TokenERC20 { mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ function INCRYPT( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); } /// @notice Create `mintedAmount` tokens and send it to `target` /// @param target Address to receive the tokens /// @param mintedAmount the amount of tokens it will receive function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens /// @param target Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } } "}
{"sol name": "657.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: contracts/robonomics/XRT.sol contract XRT is MintableToken, BurnableToken { string public constant name     = \"Robonomics Beta\"; string public constant symbol   = \"XRT\"; uint   public constant decimals = 9; uint256 public constant INITIAL_SUPPLY = 1000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "794.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // ---------------------------------------------------------------------------- contract TokenERC20 { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals // Receives ETH and generates tokens // ---------------------------------------------------------------------------- contract AFDTToken is TokenERC20, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * @dev Fix for the ERC20 short address attack. */ modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"AFDTT\"; name = \"AFDChain\"; decimals = 8; _totalSupply = 2100000000 * 10**uint(decimals); owner = 0x1ac6bc75a9e1d32a91e025257eaefc0e8965a16f; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return safeSub(_totalSupply , balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) onlyPayloadSize(safeMul(2,32)) public  returns (bool success) { _transfer(msg.sender, to, tokens);              // makes the transfers return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens)  onlyPayloadSize(safeMul(3,32)) public returns (bool success) { require (to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balances[from] >= tokens);               // Check if the sender has enough require (safeAdd(balances[to] , tokens) >= balances[to]); // Check for overflows require(!frozenAccount[from]);                     // Check if sender is frozen require(!frozenAccount[to]);                       // Check if recipient is frozen balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } /// @notice `freeze? Prevent | Allow` `from` from sending & receiving tokens /// @param from Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address from, bool freeze) onlyOwner public { frozenAccount[from] = freeze; emit FrozenFunds(from, freeze); } /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balances[_from] >= _value);               // Check if the sender has enough require (safeAdd(balances[_to] , _value) >= balances[_to]); // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen balances[_from] = safeSub(balances[_from], _value); balances[_to] = safeAdd(balances[_to], _value); emit Transfer(_from, _to, _value); } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value);   // Check if the sender has enough balances[msg.sender] = safeSub(balances[msg.sender], _value); // Subtract from the sender _totalSupply = safeSub(_totalSupply, _value); // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balances[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowed[_from][msg.sender]);    // Check allowance balances[_from] = safeSub(balances[_from], _value); // Subtract from the targeted balance allowed[_from][msg.sender] = safeSub(allowed[_from][msg.sender], _value); // Subtract from the sender's allowance _totalSupply = safeSub(_totalSupply, _value);  // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "589.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } /** * @title Standard Burnable Token * @dev Adds burnFrom method to ERC20 implementations */ contract StandardBurnableToken is BurnableToken, StandardToken { /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } } /** * @title Issuable token */ contract IssuableToken is StandardToken, Ownable, Pausable { event Mint(address indexed to, uint256 amount); event IssuerAdded(address indexed newIssuer); event IssuerRemoved(address indexed removedIssuer); mapping (address => bool) public issuers; modifier onlyIssuer() { require(issuers[msg.sender]); _; } /** * @dev Authorize an issuer */ function addIssuer(address newIssuer) onlyOwner public { issuers[newIssuer] = true; emit IssuerAdded(newIssuer); } /** * @dev Deauthorize an issuer */ function removeIssuer(address removedIssuer) public onlyOwner { issuers[removedIssuer] = false; emit IssuerRemoved(removedIssuer); } /** * @dev Function to issue tokens to an address * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function issueTo(address _to, uint256 _amount) public onlyIssuer whenNotPaused returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to issue tokens to the caller */ function issue(uint256 _amount) public onlyIssuer whenNotPaused returns (bool) { issueTo(msg.sender, _amount); return true; } } contract StablyFiatToken is StandardBurnableToken, IssuableToken, PausableToken { string public name; string public symbol; uint public decimals; constructor ( uint256 initialSupply, string tokenName, string tokenSymbol, uint tokenDecimals ) { balances[msg.sender] = initialSupply; totalSupply_ = initialSupply; name = tokenName; symbol = tokenSymbol; decimals = tokenDecimals; emit Transfer(address(0), msg.sender, initialSupply); emit Mint(msg.sender, initialSupply); } } "}
{"sol name": "1872.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() public onlyOwner whenNotPaused returns (bool) { paused = true; emit Pause(); return true; } function unpause() public onlyOwner whenPaused returns (bool) { paused = false; emit Unpause(); return true; } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract GSToken is PausableToken { string  public name = \"GrEARN's Token\"; string  public symbol = \"GST\"; uint    public decimals = 18; mapping (address => bool) public frozenAccount; mapping (address => uint256) public frozenAccountTokens; event FrozenFunds(address target, bool frozen); event Burn(address indexed burner, uint256 value); event Freeze(address indexed from, uint256 value); event Unfreeze(address indexed from, uint256 value); constructor() public { totalSupply_ = 60 * 10 ** (uint256(decimals) + 8); balances[msg.sender] = totalSupply_; } function burn(uint256 _value) public onlyOwner returns (bool success) { require(balances[msg.sender] >= _value); require(_value > 0); balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); totalSupply_ = SafeMath.sub(totalSupply_,_value); emit Burn(msg.sender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(!frozenAccount[_from]); require(SafeMath.add(frozenAccountTokens[_from], _value) <= balances[_from]); return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool) { require(!frozenAccount[msg.sender]); require(SafeMath.add(frozenAccountTokens[msg.sender], _value) <= balances[msg.sender]); return super.transfer(_to, _value); } function transferAndFreezeTokens(address _to, uint256 _value) public onlyOwner returns (bool) { transfer(_to, _value); freezeAccountWithToken(_to, _value); return true; } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function freezeAccountWithToken(address wallet, uint256 _value) public onlyOwner returns (bool success) { require(balances[wallet] >= _value); require(_value > 0); frozenAccountTokens[wallet] = SafeMath.add(frozenAccountTokens[wallet], _value); emit Freeze(wallet, _value); return true; } function unfreezeAccountWithToken(address wallet, uint256 _value) public onlyOwner returns (bool success) { require(balances[wallet] >= _value); require(_value > 0); frozenAccountTokens[wallet] = SafeMath.sub(frozenAccountTokens[wallet], _value); emit Unfreeze(wallet, _value); return true; } function multisend(address[] dests, uint256[] values) public onlyOwner returns (uint256) { uint256 i = 0; while (i < dests.length) { transferAndFreezeTokens(dests[i], values[i] * 10 ** 18); i += 1; } return(i); } } "}
{"sol name": "311.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract LineageCode is StandardToken { string public name = 'LinageCode'; string public symbol = 'LIN'; uint public decimals = 10; uint public INITIAL_SUPPLY = 80 * 100000000 * (10 ** decimals); address owner; bool public released = false; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; owner = msg.sender; } function release() public { require(owner == msg.sender); require(!released); released = true; } function lock() public { require(owner == msg.sender); require(released); released = false; } function get_Release() view public returns (bool) { return released; } modifier onlyReleased() { if (owner != msg.sender) require(released); _; } function transfer(address to, uint256 value) public onlyReleased returns (bool) { super.transfer(to, value); } function allowance(address _owner, address _spender) public onlyReleased view returns (uint256) { super.allowance(_owner, _spender); } function transferFrom(address from, address to, uint256 value) public onlyReleased returns (bool) { super.transferFrom(from, to, value); } function approve(address spender, uint256 value) public onlyReleased returns (bool) { super.approve(spender, value); } } "}
{"sol name": "778.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title introduce * @dev erc20: balance, transfer, approve, transferFrom, allowrance * @dev plus functions: ownable, pausable */ /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant public returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant public returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { uint8 public constant decimals = 18; uint256 public constant ONE_TOKEN = (10 ** uint256(decimals)); mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } /** * @title Slash Token * @dev ERC20 Slash Token (ST) */ contract SlashToken is StandardToken, Pausable { string public constant name = 'Slash Token';                       // Set the token name for display string public constant symbol = 'ST';                                       // Set the token symbol for display uint256 constant Thousand_Token = 1000 * ONE_TOKEN; uint256 constant Million_Token = 1000 * Thousand_Token; uint256 constant Billion_Token = 1000 * Million_Token; uint256 public constant TOTAL_TOKENS = 10 * Billion_Token; /** * @dev Slash Token Constructor * Runs only on initial contract creation. */ constructor() public { totalSupply = TOTAL_TOKENS;                               // Set the total supply balances[msg.sender] = TOTAL_TOKENS;                      // Creator address is assigned all } /** * @dev Transfer token for a specified address when not paused * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) { require(_to != address(0)); return super.transfer(_to, _value); } /** * @dev Transfer tokens from one address to another when not paused * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) { require(_to != address(0)); return super.transferFrom(_from, _to, _value); } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender when not paused. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { return super.approve(_spender, _value); } } "}
{"sol name": "189.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20,Pausable { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) whenNotPaused public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) whenNotPaused public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Internal function that mints an amount of the token and assigns it to * an account. This encapsulates the modification of balances such that the * proper events are emitted. * @param _account The account that will receive the created tokens. * @param _amount The amount that will be created. */ function _mint(address _account, uint256 _amount) internal { require(_account != 0); totalSupply_ = totalSupply_.add(_amount); balances[_account] = balances[_account].add(_amount); emit Transfer(address(0), _account, _amount); } /** * @dev Internal function that burns an amount of the token of a given * account. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burn(address _account, uint256 _amount) internal { require(_account != 0); require(_amount <= balances[_account]); totalSupply_ = totalSupply_.sub(_amount); balances[_account] = balances[_account].sub(_amount); emit Transfer(_account, address(0), _amount); } /** * @dev Internal function that burns an amount of the token of a given * account, deducting from the sender's allowance for said account. Uses the * internal _burn function. * @param _account The account whose tokens will be burnt. * @param _amount The amount that will be burnt. */ function _burnFrom(address _account, uint256 _amount) internal { require(_amount <= allowed[_account][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount); _burn(_account, _amount); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { _burnFrom(_from, _value); } /** * @dev Overrides StandardToken._burn in order for burn and burnFrom to emit * an additional Burn event. */ function _burn(address _who, uint256 _value) internal { super._burn(_who, _value); emit Burn(_who, _value); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is BurnableToken { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { _mint(_to, _amount); emit Mint(_to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract GUB is MintableToken { // If ether is sent to this address, send it back. function () public { revert(); } string public constant name = \"Ancient coins\u2019 chain\"; string public constant symbol = \"GUB\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 7000000000; /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } } "}
{"sol name": "773.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || allowed[msg.sender][_spender]== 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title SimpleToken * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. */ contract BFMToken is StandardToken { string public constant name = \"Blockchain and Fintech Media Union\"; string public constant symbol = \"BFM\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 500 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "824.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract Blobs { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1785.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;                       //\u975e\u9057\u5171\u4eab\u94fe string public symbol; uint8 public decimals = 18; uint256 public totalSupply;                 //\u975e\u9057\u5171\u4eab\u94fe mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "1973.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient{ function receiveApproval(address _from,uint256 _value,address _token,bytes _extraData) external ; } contract BicasoBSOToken{ address public owner; string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; uint256 public sellPrice; uint256 public buyPrice; bool public sellOpen; bool public buyOpen; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; mapping(address=>bool) public frozenAccount; event Transfer(address indexed from,address indexed to , uint256 value); event Approval(address indexed owner,address indexed spender,uint256 value); event FrozenFunds(address target,bool freeze); event SellToken(address seller,uint256 sellPrice, uint256 amount,uint256 getEth); event BuyToken(address buyer,uint256 buyPrice,uint256 amount,uint256 spendEth); modifier onlyOwner { require(msg.sender == owner); _; } constructor() public { owner = 0x28F1DdeC2218ec95b14076127a7AdE2F2986E4A6; name = \"BICASO\"; symbol = \"BSO\"; decimals = 8; totalSupply = 5000000000 * 10 ** uint256(8); balanceOf[owner] = totalSupply; } function () public payable { if(msg.sender!=owner){ _buy(); } } function transfer(address _to,uint256 _value) public{ require(!frozenAccount[msg.sender]); if(_to == address(this)){ _sell(msg.sender,_value); }else{ _transfer(msg.sender,_to,_value); } } function transferFrom(address _from,address _to,uint256 _value) public returns (bool success){ require(!frozenAccount[_from]&&!frozenAccount[msg.sender]); require(_value<=allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; if(_to == address(this)){ _sell(_from,_value); }else { _transfer(_from,_to,_value); } return true; } function approve(address _spender,uint256 _value) public returns (bool success){ require(!frozenAccount[msg.sender]); allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender,uint256 _value,bytes _extraData) public returns (bool success){ require(!frozenAccount[msg.sender]); tokenRecipient spender = tokenRecipient(_spender); if(approve(_spender,_value)){ spender.receiveApproval(msg.sender,_value,this,_extraData); return true; } } function freezeAccount(address target,bool freeze)  onlyOwner public{ require(target!=owner); frozenAccount[target] = freeze; emit FrozenFunds(target,freeze); } function transferOwnership(address newOwner) onlyOwner public{ _transfer(owner,newOwner,balanceOf[owner]); owner = newOwner; } function setPrices(uint256 newSellPrice,uint256 newBuyPrice) onlyOwner public{ sellPrice = newSellPrice; buyPrice = newBuyPrice; } function setBuyOpen(bool newBuyOpen) onlyOwner public{ require(buyPrice>0); buyOpen = newBuyOpen; } function setSellOpen(bool newSellOpen) onlyOwner public{ require(sellPrice>0); sellOpen = newSellOpen; } function transferEth(uint256 amount) onlyOwner public{ msg.sender.transfer(amount*10**uint256(18)); } function _transfer(address _from,address _to, uint256 _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >balanceOf[_to]); uint256 previousBalances = balanceOf[_from]+balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from,_to,_value); assert(balanceOf[_from]+balanceOf[_to] == previousBalances); } function _buy() internal returns (uint256 amount){ require(buyOpen); require(buyPrice>0); require(msg.value>0); amount = msg.value / buyPrice; _transfer(owner,msg.sender,amount); emit BuyToken(msg.sender,buyPrice,amount,msg.value); return amount; } function _sell(address _from,uint256 amount) internal returns (uint256 revenue){ require(sellOpen); require(!frozenAccount[_from]); require(amount>0); require(sellPrice>0); require(_from!=owner); _transfer(_from,owner,amount); revenue = amount * sellPrice; _from.transfer(revenue); emit SellToken(_from,sellPrice,amount,revenue); return revenue; } } "}
{"sol name": "978.sol", "label": 0, "sol content": "pragma solidity 0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, *  as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(addr) } return size > 0; } } /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */ contract ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 internal constant ERC721_RECEIVED = 0xf0b9e5ba; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient * after a `safetransfer`. This function MAY throw to revert and reject the * transfer. This function MUST use 50,000 gas or less. Return of other * than the magic value MUST result in the transaction being reverted. * Note: the contract address is always the message sender. * @param _from The sending address * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` */ function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4); } /** * @title ERC165 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md */ interface ERC165 { /** * @notice Query if a contract implements an interface * @param _interfaceId The interface identifier, as specified in ERC-165 * @dev Interface identification is specified in ERC-165. This function * uses less than 30,000 gas. */ function supportsInterface(bytes4 _interfaceId) external view returns (bool); } /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic is ERC165 { event Transfer(address indexed _from, address indexed _to, uint256 indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public; } /** * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } /** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Metadata is ERC721Basic { function name() external view returns (string _name); function symbol() external view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } /** * @title ERC-721 Non-Fungible Token Standard, full implementation interface * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } contract ERC721Holder is ERC721Receiver { function onERC721Received(address, uint256, bytes) public returns(bytes4) { return ERC721_RECEIVED; } } /** * @title SupportsInterfaceWithLookup * @author Matt Condon (@shrugs) * @dev Implements ERC165 using a lookup table. */ contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; /** * 0x01ffc9a7 === *   bytes4(keccak256('supportsInterface(bytes4)')) */ /** * @dev a mapping of interface id to whether or not it's supported */ mapping(bytes4 => bool) internal supportedInterfaces; /** * @dev A contract implementing SupportsInterfaceWithLookup * implement ERC165 itself */ constructor() public { _registerInterface(InterfaceId_ERC165); } /** * @dev implement supportsInterface(bytes4) using a lookup table */ function supportsInterface(bytes4 _interfaceId) external view returns (bool) { return supportedInterfaces[_interfaceId]; } /** * @dev private method for registering an interface */ function _registerInterface(bytes4 _interfaceId) internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } } /** * @title ERC721 Non-Fungible Token Standard basic implementation * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721BasicToken is SupportsInterfaceWithLookup, ERC721Basic { bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd; /* * 0x80ac58cd === *   bytes4(keccak256('balanceOf(address)')) ^ *   bytes4(keccak256('ownerOf(uint256)')) ^ *   bytes4(keccak256('approve(address,uint256)')) ^ *   bytes4(keccak256('getApproved(uint256)')) ^ *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^ *   bytes4(keccak256('isApprovedForAll(address,address)')) ^ *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) */ bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79; /* * 0x4f558e79 === *   bytes4(keccak256('exists(uint256)')) */ using SafeMath for uint256; using AddressUtils for address; // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; // Mapping from token ID to owner mapping (uint256 => address) internal tokenOwner; // Mapping from token ID to approved address mapping (uint256 => address) internal tokenApprovals; // Mapping from owner to number of owned token mapping (address => uint256) internal ownedTokensCount; // Mapping from owner to operator approvals mapping (address => mapping (address => bool)) internal operatorApprovals; /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint256 ID of the token to validate */ modifier canTransfer(uint256 _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721); _registerInterface(InterfaceId_ERC721Exists); } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existence of * @return whether the token exists */ function exists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * @dev The zero address indicates there is no approved address. * @dev There can only be one approved address per token at a given time. * @dev Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } /** * @dev Sets or unsets the approval of a given operator * @dev An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } /** * @dev Transfers the ownership of a given token ID to another address * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function safeTransferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom(address _from, address _to, uint256 _tokenId, bytes _data) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint256 _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } /** * @dev Internal function to clear current approval of a given token ID * @dev Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); emit Approval(_owner, address(0), _tokenId); } } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } /** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; address public pendingOwner; address public manager; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Modifier throws if called by any account other than the manager. */ modifier onlyManager() { require(msg.sender == manager); _; } /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } constructor() public { owner = msg.sender; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() public onlyPendingOwner { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } /** * @dev Sets the manager address. * @param _manager The manager address. */ function setManager(address _manager) public onlyOwner { require(_manager != address(0)); manager = _manager; } } /** * @title Full ERC721 Token * This implementation includes all the required and some optional functionality of the ERC721 standard * Moreover, it includes approve all functionality using operator terminology * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract AviationSecurityToken is SupportsInterfaceWithLookup, ERC721, ERC721BasicToken, Ownable { bytes4 private constant InterfaceId_ERC721Enumerable = 0x780e9d63; /** * 0x780e9d63 === *   bytes4(keccak256('totalSupply()')) ^ *   bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^ *   bytes4(keccak256('tokenByIndex(uint256)')) */ bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; /** * 0x5b5e139f === *   bytes4(keccak256('name()')) ^ *   bytes4(keccak256('symbol()')) ^ *   bytes4(keccak256('tokenURI(uint256)')) */ // Token name string public name_ = \"AviationSecurityToken\"; // Token symbol string public symbol_ = \"AVNS\"; // Mapping from owner to list of owned token IDs mapping(address => uint256[]) internal ownedTokens; // Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; // Array with all token ids, used for enumeration uint256[] internal allTokens; // Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex; // Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs; struct Data{ string liscence; string URL; } mapping(uint256 => Data) internal tokenData; /** * @dev Constructor function */ constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); } /** * @dev External function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token */ function mint(address _to, uint256 _id) external onlyManager { _mint(_to, _id); } /** * @dev Gets the token name * @return string representing the token name */ function name() external view returns (string) { return name_; } /** * @dev Gets the token symbol * @return string representing the token symbol */ function symbol() external view returns (string) { return symbol_; } function arrayOfTokensByAddress(address _holder) public view returns(uint256[]) { return ownedTokens[_holder]; } /** * @dev Returns an URI for a given token ID * @dev Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ function tokenURI(uint256 _tokenId) public view returns (string) { require(exists(_tokenId)); return tokenURIs[_tokenId]; } /** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } /** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ function totalSupply() public view returns (uint256) { return allTokens.length; } /** * @dev Gets the token ID at a given index of all the tokens in this contract * @dev Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } /** * @dev Internal function to set the token URI for a given token * @dev Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ function _setTokenURI(uint256 _tokenId, string _uri) internal { require(exists(_tokenId)); tokenURIs[_tokenId] = _uri; } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; ownedTokens[_from][lastTokenIndex] = 0; // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are // going to be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are // first swapping the lastToken to the first position, and then dropping the element placed in the last // position of the list ownedTokens[_from].length--; ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token */ function _mint(address _to, uint256 _id) internal { allTokens.push(_id); allTokensIndex[_id] = _id; super._mint(_to, _id); } function addTokenData(uint _tokenId, string _liscence, string _URL) public { require(ownerOf(_tokenId) == msg.sender); tokenData[_tokenId].liscence = _liscence; tokenData[_tokenId].URL = _URL; } function getTokenData(uint _tokenId) public view returns(string Liscence, string URL){ require(exists(_tokenId)); Liscence = tokenData[_tokenId].liscence; URL = tokenData[_tokenId].URL; } } "}
{"sol name": "522.sol", "label": 0, "sol content": "pragma solidity 0.4.21; contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract ROG is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ROG() public { symbol = \"ROG\"; name = \"NeoWorld Rare Ore G\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "922.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract Owned { address public owner; function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract VixcoreToken2 is Owned { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; uint public totalTokenSold; uint public totalWeiReceived; uint public weiBalance; //EVENTS // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); //ETH Withdrawn event Withdrawal(address receiver, uint amount); //Token is purchased using Selfdrop event Selfdrop(address backer, uint weiAmount, uint token); //Over softcap set for Selfdrop event OverSoftCap(address receiver, uint weiAmount); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function VixcoreToken2( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes owner = msg.sender; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Default function when someone's transferring to this contract * The next 3 functions are the same */ function () payable public { _pay(); } function pay() payable public { _pay(); } function _pay() internal { uint weiValue = msg.value; uint phase1 = 2500000000000000000000000000; uint phase2 = phase1 + 1500000000000000000000000000; uint phase3 = phase2 + 1000000000000000000000000000; //phase 3 should be less than supply if(totalTokenSold <= phase1){ _exchange(weiValue, 5000000); }else if(totalTokenSold <= phase2){ _exchange(weiValue, 4000000); }else if(totalTokenSold <= phase3){ _exchange(weiValue, 3500000); }else{ emit OverSoftCap(msg.sender, weiValue); } } function _exchange(uint weiValue, uint rate) internal { uint tokenEquiv = tokenEquivalent(weiValue, rate); _transfer(owner, msg.sender, tokenEquiv); totalWeiReceived += weiValue; weiBalance += weiValue; totalTokenSold += tokenEquiv; emit Selfdrop(msg.sender, weiValue, tokenEquiv); } function tokenEquivalent(uint weiValue, uint rate) public returns (uint) { return weiValue * rate; } /** * Withdraw the funds * * Send the benefeciary some Wei * This function will emit the Withdrawal event if send it successful * Only owner can call this function */ function withdraw(uint _amount) onlyOwner public { require(_amount > 0); require(_amount <= weiBalance);     // Amount withdraw should be less or equal to balance if (owner.send(_amount)) { weiBalance -= _amount; emit Withdrawal(owner, _amount); }else{ throw; } } } "}
{"sol name": "363.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "422.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface Token { function transferFrom(address _from, address _to, uint256 _value) external; function transfer(address _to, uint256 _value) external; } contract AirdropiRide { Token public tokenReward; address public creator; address public owner = 0x51463cc990900e42f06439C30a6159a1A764Fb6F; uint256 public startDate; modifier isCreator() { require(msg.sender == creator); _; } event FundTransfer(address backer, uint amount, bool isContribution); constructor() public { creator = msg.sender; startDate = 1519862400; tokenReward = Token(0x69D94dC74dcDcCbadEc877454a40341Ecac34A7c); } function setOwner(address _owner) isCreator public { owner = _owner; } function setCreator(address _creator) isCreator public { creator = _creator; } function setStartDate(uint256 _startDate) isCreator public { startDate = _startDate; } function setToken(address _token) isCreator public { tokenReward = Token(_token); } function kill() isCreator public { selfdestruct(owner); } function dropToken(address[] _to) isCreator public{ require(now > startDate); for (uint256 i = 0; i < _to.length; i++) { uint256 amount = 1000 * (10**18); tokenReward.transferFrom(owner, _to[i], amount); emit FundTransfer(msg.sender, amount, true); } } function dropTokenV2(address[] _to) isCreator public{ require(now > startDate); for (uint256 i = 0; i < _to.length; i++) { uint256 amount = 1000 * (10**18); tokenReward.transfer(_to[i], amount); emit FundTransfer(msg.sender, amount, true); } } } "}
{"sol name": "1764.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'BearTrap' token contract // // Deployed to : 0x7D7fc11f3d623E883dC621Fe7B2CA3A9e0fE75B3 // Symbol      : BRTP // Name        : BearTrap // Total supply: 1000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract BearTrap is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function BearTrap() public { symbol = \"BRTP\"; name = \"BearTrap\"; decimals = 18; _totalSupply = 1000000000000000000000000; balances[0x7D7fc11f3d623E883dC621Fe7B2CA3A9e0fE75B3] = _totalSupply; Transfer(address(0), 0x7D7fc11f3d623E883dC621Fe7B2CA3A9e0fE75B3, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "93.sol", "label": 0, "sol content": "pragma solidity 0.4.24; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a && c >= b); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20 { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract Extent { using SafeMath for uint; address public admin; //the admin address mapping(address => bool) private canClaimTokens; mapping(address => uint) public tokens; //mapping of token addresses to mapping of account balances (token=0 means Ether) mapping(address => uint) public claimableAmount; //mapping of token addresses to max amount to claim event Deposit(address token, address user, uint amount, uint balance); event Withdraw(address token, address user, uint amount, uint balance); modifier onlyAdmin() { require(msg.sender == admin); _; } modifier onlyWhitelisted(address address_) { require(canClaimTokens[address_]); _; } constructor(address admin_) public { admin = admin_; } function() public payable { revert(\"Cannot send ETH directly to the Contract\"); } function changeAdmin(address admin_) public onlyAdmin { admin = admin_; } function addToWhitelist(address address_) public onlyAdmin { canClaimTokens[address_] = true; } function addToWhitelistBulk(address[] addresses_) public onlyAdmin { for (uint i = 0; i < addresses_.length; i++) { canClaimTokens[addresses_[i]] = true; } } function setAmountToClaim(address token, uint amount) public onlyAdmin { claimableAmount[token] = amount; } function depositToken(address token, uint amount) public onlyAdmin { //remember to call ERC20Token(address).approve(this, amount) or this contract will not be able to do the transfer on your behalf. if (token == 0) revert(\"Cannot deposit ETH with depositToken method\"); if (!ERC20(token).transferFrom(msg.sender, this, amount)) revert(\"You didn't call approve method on Token contract\"); tokens[token] += amount; emit Deposit(token, msg.sender, amount, tokens[token]); } function claimTokens(address token) public onlyWhitelisted(msg.sender) { if (token == 0) revert(\"Cannot withdraw ETH with withdrawToken method\"); if (tokens[token] < claimableAmount[token]) revert(\"Not enough tokens to claim\"); tokens[token] -= claimableAmount[token]; canClaimTokens[msg.sender] = false; if (!ERC20(token).transfer(msg.sender, claimableAmount[token])) revert(\"Error while transfering tokens\"); emit Withdraw(token, msg.sender, claimableAmount[token], tokens[token]); } } "}
{"sol name": "988.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /* * Creator: CLASSY (CLASSY) */ /* * Abstract Token Smart Contract * */ /* * Safe Math Smart Contract. * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * ERC-20 standard token interface, as defined * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>. */ contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * Abstract Token Smart Contract that could be used as a base contract for * ERC-20 token contracts. */ contract AbstractToken is Token, SafeMath { /** * Create new Abstract Token contract. */ function AbstractToken () { // Do nothing } /** * Get number of tokens currently belonging to given owner. * * @param _owner address to get number of tokens currently belonging to the *        owner of * @return number of tokens currently belonging to the owner of given address */ function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } /** * Transfer given number of tokens from message sender to given recipient. * * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } /** * Allow given spender to transfer given number of tokens from message sender. * @param _spender address to allow the owner of to transfer tokens from message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } /** * Tell how many tokens given spender is currently allowed to transfer from * given owner. * * @param _owner address to get number of tokens allowed to be transferred *        from the owner of * @param _spender address to get number of tokens allowed to be transferred *        by the owner of * @return number of tokens given spender is currently allowed to transfer *         from given owner */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } /** * Mapping from addresses of token holders to the numbers of tokens belonging * to these token holders. */ mapping (address => uint256) accounts; /** * Mapping from addresses of token holders to the mapping of addresses of * spenders to the allowances set by these token holders to these spenders. */ mapping (address => mapping (address => uint256)) private allowances; } /** * CLASSY smart contract. */ contract CLASSYToken is AbstractToken { /** * Maximum allowed number of tokens in circulation. * tokenSupply = tokensIActuallyWant * (10 ^ decimals) */ uint256 constant MAX_TOKEN_COUNT = 100000000 * (10**18); /** * Address of the owner of this smart contract. */ address private owner; /** * Frozen account list holder */ mapping (address => bool) private frozenAccount; /** * Current number of tokens in circulation. */ uint256 tokenCount = 0; /** * True if tokens transfers are currently frozen, false otherwise. */ bool frozen = false; /** * Create new token smart contract and make msg.sender the * owner of this smart contract. */ function CLASSYToken () { owner = msg.sender; } /** * Get total number of tokens in circulation. * * @return total number of tokens in circulation */ function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"CLASSY\"; string constant public symbol = \"CLASSY\"; uint8 constant public decimals = 18; /** * Transfer given number of tokens from message sender to given recipient. * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise */ function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } /** * Change how many tokens given spender is allowed to transfer from message * spender.  In order to prevent double spending of allowance, * To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender address to allow the owner of to transfer tokens from *        message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } /** * Create _value new tokens and give new created tokens to msg.sender. * May only be called by smart contract owner. * * @param _value number of tokens to create * @return true if tokens were created successfully, false otherwise */ function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); // adding transfer event and _from address as null address emit Transfer(0x0, msg.sender, _value); return true; } return false; } /** * Set new owner for the smart contract. * May only be called by smart contract owner. * * @param _newOwner address of new owner of the smart contract */ function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } /** * Freeze ALL token transfers. * May only be called by smart contract owner. */ function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } /** * Unfreeze ALL token transfers. * May only be called by smart contract owner. */ function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } /*A user is able to unintentionally send tokens to a contract * and if the contract is not prepared to refund them they will get stuck in the contract. * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to * prevent unintended Ether transfers. However, there\u2019s no such mechanism for token transfers. * so the below function is created */ function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } /** * Freeze specific account * May only be called by smart contract owner. */ function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } /** * Logged when token transfers were frozen. */ event Freeze (); /** * Logged when token transfers were unfrozen. */ event Unfreeze (); /** * Logged when a particular account is frozen. */ event FrozenFunds(address target, bool frozen); /** * when accidentally send other tokens are refunded */ event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "1943.sol", "label": 0, "sol content": "pragma solidity ^0.4.15; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract CBOPToken is StandardToken, Ownable { string public constant name = \"ChainBank Token\"; string public constant symbol = \"CBOP\"; uint256 public constant decimals = 8; uint256 public totalSupply = 500000000 * (uint256(10) ** decimals); mapping(address => bool) public specialAccounts; function CBOPToken(address wallet) public { balances[wallet] = totalSupply; specialAccounts[wallet]=true; Transfer(0x0, wallet, totalSupply); } function addSpecialAccount(address account) external onlyOwner { specialAccounts[account] = true; } bool public firstSaleComplete; function markFirstSaleComplete() public { if (specialAccounts[msg.sender]) { firstSaleComplete = true; } } function isOpen() public constant returns (bool) { return firstSaleComplete || specialAccounts[msg.sender]; } function transfer(address _to, uint _value) public returns (bool) { return isOpen() && super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) public returns (bool) { return isOpen() && super.transferFrom(_from, _to, _value); } event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value >= 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } "}
{"sol name": "995.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; /** * PIEXGO TEAM */ contract SafeMath { function mul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function sub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract RegularToken is Token, SafeMath { function transfer(address _to, uint256 _value) returns (bool) { require(balances[msg.sender] >= _value); require(balances[_to] + _value >= balances[_to]); balances[msg.sender] = sub(balances[msg.sender], _value); balances[_to] = add(balances[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool) { require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); require(allowed[_from][msg.sender] >= _value); balances[_from] = sub(balances[_from], _value); balances[_to] = add(balances[_to], _value); allowed[_from][msg.sender] = sub(allowed[_from][msg.sender], _value); emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract PXGToken is RegularToken { uint256 public totalSupply = 100*10**(18+8); uint8 constant public decimals = 18; string constant public name = \"PIEXGO\"; string constant public symbol = \"PXG\"; function PXGToken() { balances[msg.sender] = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "1627.sol", "label": 0, "sol content": "contract Token { /* Public variables of the token */ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); function Token() { totalSupply = 10*(10**8)*(10**8); balanceOf[msg.sender] = 10*(10**8)*(10**8);              // Give the creator all initial tokens name = \"DCB(one)\";                                   // Set the name for display purposes symbol = \"DCB(one)\";                               // Set the symbol for display purposes decimals = 8;                            // Amount of decimals for display purposes } function transfer(address _to, uint256 _value) { /* Check if sender has balance and for overflows */ if (balanceOf[msg.sender] < _value || balanceOf[_to] + _value < balanceOf[_to]) revert(); /* Add and subtract new balances */ balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; /* Notifiy anyone listening that this transfer took place */ Transfer(msg.sender, _to, _value); } /* This unnamed function is called whenever someone tries to send ether to it */ function () { revert();     // Prevents accidental sending of ether } } "}
{"sol name": "266.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* Follows the ERC20 token standard */ contract TheEmperorsCoin { string public tokenName; string public tokenSymbol; uint256 public totalSupply; uint8 public decimals = 18; mapping (address => uint256) public balances; mapping (address => mapping(address => uint256)) public allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _from, uint256 _value); constructor() public { /* Final token characteristics */ tokenName = \"The Emperor's Coin\"; tokenSymbol = \"W40K\"; uint256 initSupply = 40000; /*******************************/ totalSupply = initSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; } function _transfer(address _from, address _to, uint256 _value) internal { require(_to != 0x0); require(balances[_from] >= _value); require(balances[_to] + _value >= balances[_to]); uint256 previousBalances = balances[_from] + balances[_to]; balances[_from] -= _value; balances[_to] += _value; emit Transfer(_from, _to, _value); assert(balances[_from] + balances[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); allowed[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { require(_value <= totalSupply); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) public returns(bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns(bool success) { require(balances[_from] >= _value); require(allowed[_from][msg.sender] >= _value); balances[_from] -= _value; allowed[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } function name() public view returns (string text) { return tokenName; } function symbol() public view returns (string text) { return tokenSymbol; } function decimals() public view returns (uint8 value) { return decimals; } function totalSupply() public view returns (uint256 value) { return totalSupply; } function balanceOf(address _owner) public view returns (uint256 value) { return balances[_owner]; } function allowance(address _owner, address _spender) public view returns (uint256 value) { return allowed[_owner][_spender]; } /* Reverts any purposely or inadvertently Ether payment to the contract */ function () public payable { revert(); } } "}
{"sol name": "463.sol", "label": 0, "sol content": "pragma solidity 0.4.24; contract InterbetCore { /* Global constants */ uint constant oddsDecimals = 2; // Max. decimal places of odds uint constant feeRateDecimals = 1; // Max. decimal places of fee rate uint public minMakerBetFund = 100 * 1 finney; // Minimum fund of a maker bet uint public maxAllowedTakerBetsPerMakerBet = 100; // Limit the number of taker-bets in 1 maker-bet uint public minAllowedStakeInPercentage = 1; // 100 \u00f7 maxAllowedTakerBetsPerMakerBet uint public baseVerifierFee = 1 finney; // Ensure verifier has some minimal profit to cover their gas cost at least /* Owner and admins */ address private owner; mapping(address => bool) private admins; modifier onlyOwner() { require(msg.sender == owner); _; } function changeOwner(address newOwner) external onlyOwner { owner = newOwner; } function addAdmin(address addr) external onlyOwner { admins[addr] = true; } function removeAdmin(address addr) external onlyOwner { admins[addr] = false; } modifier onlyAdmin() { require(admins[msg.sender] == true); _; } function changeMinMakerBetFund(uint weis) external onlyAdmin { minMakerBetFund = mul(weis, 1 wei); } function changeAllowedTakerBetsPerMakerBet(uint maxCount, uint minPercentage) external onlyAdmin { maxAllowedTakerBetsPerMakerBet = maxCount; minAllowedStakeInPercentage = minPercentage; } function changeBaseVerifierFee(uint weis) external onlyAdmin { baseVerifierFee = mul(weis, 1 wei); } /* Events */ event LogUpdateVerifier(address indexed addr, uint oldFeeRate, uint newFeeRate); event LogMakeBet(uint indexed makerBetId, address indexed maker); event LogAddFund(uint indexed makerBetId, address indexed maker, uint oldTotalFund, uint newTotalFund); event LogUpdateOdds(uint indexed makerBetId, address indexed maker, uint oldOdds, uint newOdds); event LogPauseBet(uint indexed makerBetId, address indexed maker); event LogReopenBet(uint indexed makerBetId, address indexed maker); event LogCloseBet(uint indexed makerBetId, address indexed maker); event LogTakeBet(uint indexed makerBetId, address indexed maker, uint indexed takerBetId, address taker); event LogSettleBet(uint indexed makerBetId, address indexed maker); event LogWithdraw(uint indexed makerBetId, address indexed maker, address indexed addr); /* Betting Core */ enum BetStatus { Open, Paused, Closed, Settled } enum BetOutcome { NotSettled, MakerWin, TakerWin, Draw, Canceled } struct MakerBet { uint makerBetId; address maker; uint odds; uint totalFund; Verifier trustedVerifier; uint expiry; BetStatus status; uint reservedFund; uint takerBetsCount; uint totalStake; TakerBet[] takerBets; BetOutcome outcome; bool makerFundWithdrawn; bool trustedVerifierFeeSent; } struct TakerBet { uint takerBetId; address taker; uint odds; uint stake; bool settled; } struct Verifier { address addr; uint feeRate; } uint public makerBetsCount; mapping(uint => mapping(address => MakerBet)) private makerBets; mapping(address => Verifier) private verifiers; constructor() public { owner = msg.sender; makerBetsCount = 0; } function () external payable { revert(); } /// Update verifier's data function updateVerifier(uint feeRate) external { require(feeRate >= 0 && feeRate <= ((10 ** feeRateDecimals) * 100)); Verifier storage verifier = verifiers[msg.sender]; uint oldFeeRate = verifier.feeRate; verifier.addr = msg.sender; verifier.feeRate = feeRate; emit LogUpdateVerifier(msg.sender, oldFeeRate, feeRate); } /// Make a bet function makeBet(uint makerBetId, uint odds, address trustedVerifier, uint trustedVerifierFeeRate, uint expiry) external payable { uint fund = sub(msg.value, baseVerifierFee); require(fund >= minMakerBetFund); require(odds > (10 ** oddsDecimals) && odds < ((10 ** 8) * (10 ** oddsDecimals))); require(expiry > now); MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId == 0); Verifier memory verifier = verifiers[trustedVerifier]; require(verifier.addr != address(0x0)); require(trustedVerifierFeeRate == verifier.feeRate); makerBet.makerBetId = makerBetId; makerBet.maker = msg.sender; makerBet.odds = odds; makerBet.totalFund = fund; makerBet.trustedVerifier = Verifier(verifier.addr, verifier.feeRate); makerBet.expiry = expiry; makerBet.status = BetStatus.Open; makerBet.reservedFund = 0; makerBet.takerBetsCount = 0; makerBet.totalStake = 0; makerBetsCount++; emit LogMakeBet(makerBetId, msg.sender); } /// Increase total fund of a bet function addFund(uint makerBetId) external payable { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(now < makerBet.expiry); require(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused); require(msg.sender == makerBet.maker); require(msg.value > 0); uint oldTotalFund = makerBet.totalFund; makerBet.totalFund = add(makerBet.totalFund, msg.value); emit LogAddFund(makerBetId, msg.sender, oldTotalFund, makerBet.totalFund); } /// Update odds of a bet function updateOdds(uint makerBetId, uint odds) external { require(odds > (10 ** oddsDecimals) && odds < ((10 ** 8) * (10 ** oddsDecimals))); MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(now < makerBet.expiry); require(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused); require(msg.sender == makerBet.maker); require(odds != makerBet.odds); uint oldOdds = makerBet.odds; makerBet.odds = odds; emit LogUpdateOdds(makerBetId, msg.sender, oldOdds, makerBet.odds); } /// Pause a bet function pauseBet(uint makerBetId) external { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(makerBet.status == BetStatus.Open); require(msg.sender == makerBet.maker); makerBet.status = BetStatus.Paused; emit LogPauseBet(makerBetId, msg.sender); } /// Reopen a bet function reopenBet(uint makerBetId) external { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(makerBet.status == BetStatus.Paused); require(msg.sender == makerBet.maker); makerBet.status = BetStatus.Open; emit LogReopenBet(makerBetId, msg.sender); } /// Close a bet and withdraw unused fund function closeBet(uint makerBetId) external { MakerBet storage makerBet = makerBets[makerBetId][msg.sender]; require(makerBet.makerBetId != 0); require(makerBet.status == BetStatus.Open || makerBet.status == BetStatus.Paused); require(msg.sender == makerBet.maker); makerBet.status = BetStatus.Closed; // refund unused fund to maker uint unusedFund = sub(makerBet.totalFund, makerBet.reservedFund); if (unusedFund > 0) { makerBet.totalFund = makerBet.reservedFund; uint refundAmount = unusedFund; if (makerBet.totalStake == 0) { refundAmount = add(refundAmount, baseVerifierFee); // Refund base verifier fee too if no taker-bets, because verifier do not need to settle the bet with no takers makerBet.makerFundWithdrawn = true; } if (!makerBet.maker.send(refundAmount)) { makerBet.totalFund = add(makerBet.totalFund, unusedFund); makerBet.status = BetStatus.Paused; makerBet.makerFundWithdrawn = false; } else { emit LogCloseBet(makerBetId, msg.sender); } } else { emit LogCloseBet(makerBetId, msg.sender); } } /// Take a bet function takeBet(uint makerBetId, address maker, uint odds, uint takerBetId) external payable { require(msg.sender != maker); require(msg.value > 0); MakerBet storage makerBet = makerBets[makerBetId][maker]; require(makerBet.makerBetId != 0); require(msg.sender != makerBet.trustedVerifier.addr); require(now < makerBet.expiry); require(makerBet.status == BetStatus.Open); require(makerBet.odds == odds); // Avoid too many taker-bets in one maker-bet require(makerBet.takerBetsCount < maxAllowedTakerBetsPerMakerBet); // Avoid too many tiny bets uint minAllowedStake = mul(mul(makerBet.totalFund, (10 ** oddsDecimals)), minAllowedStakeInPercentage) / sub(odds, (10 ** oddsDecimals)) / 100; uint maxAvailableStake = mul(sub(makerBet.totalFund, makerBet.reservedFund), (10 ** oddsDecimals)) / sub(odds, (10 ** oddsDecimals)); if (maxAvailableStake >= minAllowedStake) { require(msg.value >= minAllowedStake); } else { require(msg.value >= sub(maxAvailableStake, (maxAvailableStake / 10)) && msg.value <= maxAvailableStake); } // If remaining fund is not enough, send the money back. require(msg.value <= maxAvailableStake); makerBet.takerBets.length++; makerBet.takerBets[makerBet.takerBetsCount] = TakerBet(takerBetId, msg.sender, odds, msg.value, false); makerBet.reservedFund = add(makerBet.reservedFund, mul(msg.value, sub(odds, (10 ** oddsDecimals))) / (10 ** oddsDecimals)); makerBet.totalStake = add(makerBet.totalStake, msg.value); makerBet.takerBetsCount++; emit LogTakeBet(makerBetId, maker, takerBetId, msg.sender); } /// Payout to maker function payMaker(MakerBet storage makerBet) private returns (bool fullyWithdrawn) { fullyWithdrawn = false; if (!makerBet.makerFundWithdrawn) { makerBet.makerFundWithdrawn = true; uint payout = 0; if (makerBet.outcome == BetOutcome.MakerWin) { uint trustedVerifierFeeMakerWin = mul(makerBet.totalStake, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100); payout = sub(add(makerBet.totalFund, makerBet.totalStake), trustedVerifierFeeMakerWin); } else if (makerBet.outcome == BetOutcome.TakerWin) { payout = sub(makerBet.totalFund, makerBet.reservedFund); } else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) { payout = makerBet.totalFund; } if (payout > 0) { fullyWithdrawn = true; if (!makerBet.maker.send(payout)) { makerBet.makerFundWithdrawn = false; fullyWithdrawn = false; } } } return fullyWithdrawn; } /// Payout to taker function payTaker(MakerBet storage makerBet, address taker) private returns (bool fullyWithdrawn) { fullyWithdrawn = false; uint payout = 0; for (uint betIndex = 0; betIndex < makerBet.takerBetsCount; betIndex++) { if (makerBet.takerBets[betIndex].taker == taker) { if (!makerBet.takerBets[betIndex].settled) { makerBet.takerBets[betIndex].settled = true; if (makerBet.outcome == BetOutcome.MakerWin) { continue; } else if (makerBet.outcome == BetOutcome.TakerWin) { uint netProfit = mul(mul(makerBet.takerBets[betIndex].stake, sub(makerBet.takerBets[betIndex].odds, (10 ** oddsDecimals))), sub(((10 ** feeRateDecimals) * 100), makerBet.trustedVerifier.feeRate)) / (10 ** oddsDecimals) / ((10 ** feeRateDecimals) * 100); payout = add(payout, add(makerBet.takerBets[betIndex].stake, netProfit)); } else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) { payout = add(payout, makerBet.takerBets[betIndex].stake); } } } } if (payout > 0) { fullyWithdrawn = true; if (!taker.send(payout)) { fullyWithdrawn = false; for (uint betIndex2 = 0; betIndex2 < makerBet.takerBetsCount; betIndex2++) { if (makerBet.takerBets[betIndex2].taker == taker) { if (makerBet.takerBets[betIndex2].settled) { makerBet.takerBets[betIndex2].settled = false; } } } } } return fullyWithdrawn; } /// Payout to verifier function payVerifier(MakerBet storage makerBet) private returns (bool fullyWithdrawn) { fullyWithdrawn = false; if (!makerBet.trustedVerifierFeeSent) { makerBet.trustedVerifierFeeSent = true; uint payout = 0; if (makerBet.outcome == BetOutcome.MakerWin) { uint trustedVerifierFeeMakerWin = mul(makerBet.totalStake, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100); payout = add(baseVerifierFee, trustedVerifierFeeMakerWin); } else if (makerBet.outcome == BetOutcome.TakerWin) { uint trustedVerifierFeeTakerWin = mul(makerBet.reservedFund, makerBet.trustedVerifier.feeRate) / ((10 ** feeRateDecimals) * 100); payout = add(baseVerifierFee, trustedVerifierFeeTakerWin); } else if (makerBet.outcome == BetOutcome.Draw || makerBet.outcome == BetOutcome.Canceled) { payout = baseVerifierFee; } if (payout > 0) { fullyWithdrawn = true; if (!makerBet.trustedVerifier.addr.send(payout)) { makerBet.trustedVerifierFeeSent = false; fullyWithdrawn = false; } } } return fullyWithdrawn; } /// Settle a bet by trusted verifier function settleBet(uint makerBetId, address maker, uint outcome) external { require(outcome == 1 || outcome == 2 || outcome == 3 || outcome == 4); MakerBet storage makerBet = makerBets[makerBetId][maker]; require(makerBet.makerBetId != 0); require(msg.sender == makerBet.trustedVerifier.addr); require(makerBet.totalStake > 0); require(makerBet.status != BetStatus.Settled); BetOutcome betOutcome = BetOutcome(outcome); makerBet.outcome = betOutcome; makerBet.status = BetStatus.Settled; payMaker(makerBet); payVerifier(makerBet); emit LogSettleBet(makerBetId, maker); } /// Manual withdraw fund from a bet after outcome is set function withdraw(uint makerBetId, address maker) external { MakerBet storage makerBet = makerBets[makerBetId][maker]; require(makerBet.makerBetId != 0); require(makerBet.outcome != BetOutcome.NotSettled); require(makerBet.status == BetStatus.Settled); bool fullyWithdrawn = false; if (msg.sender == maker) { fullyWithdrawn = payMaker(makerBet); } else if (msg.sender == makerBet.trustedVerifier.addr) { fullyWithdrawn = payVerifier(makerBet); } else { fullyWithdrawn = payTaker(makerBet, msg.sender); } if (fullyWithdrawn) { emit LogWithdraw(makerBetId, maker, msg.sender); } } /* External views */ function getOwner() external view returns(address) { return owner; } function isAdmin(address addr) external view returns(bool) { return admins[addr]; } function getVerifier(address addr) external view returns(address, uint) { Verifier memory verifier = verifiers[addr]; return (verifier.addr, verifier.feeRate); } function getMakerBetBasicInfo(uint makerBetId, address maker) external view returns(uint, address, address, uint, uint) { MakerBet memory makerBet = makerBets[makerBetId][maker]; return (makerBet.makerBetId, makerBet.maker, makerBet.trustedVerifier.addr, makerBet.trustedVerifier.feeRate, makerBet.expiry); } function getMakerBetDetails(uint makerBetId, address maker) external view returns(uint, BetStatus, uint, uint, uint, uint, uint, BetOutcome, bool, bool) { MakerBet memory makerBet = makerBets[makerBetId][maker]; return (makerBet.makerBetId, makerBet.status, makerBet.odds, makerBet.totalFund, makerBet.reservedFund, makerBet.takerBetsCount, makerBet.totalStake, makerBet.outcome, makerBet.makerFundWithdrawn, makerBet.trustedVerifierFeeSent); } function getTakerBet(uint makerBetId, address maker, uint takerBetId, address taker) external view returns(uint, address, uint, uint, bool) { MakerBet memory makerBet = makerBets[makerBetId][maker]; for (uint betIndex = 0; betIndex < makerBet.takerBetsCount; betIndex++) { TakerBet memory takerBet = makerBet.takerBets[betIndex]; if (takerBet.takerBetId == takerBetId && takerBet.taker == taker) { return (takerBet.takerBetId, takerBet.taker, takerBet.odds, takerBet.stake, takerBet.settled); } } } /* Math utilities */ function mul(uint256 _a, uint256 _b) private pure returns(uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function sub(uint256 _a, uint256 _b) private pure returns(uint256) { assert(_b <= _a); return _a - _b; } function add(uint256 _a, uint256 _b) private pure returns(uint256 c) { c = _a + _b; assert(c >= _a); return c; } } "}
{"sol name": "291.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"REL\"; decimals = 18; totalSupply = 10000000000000000000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract is owned { string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } function SelfDesctructionContract() { owner = msg.sender; } function setSomeValue(string value){ someValue = value; } function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "475.sol", "label": 0, "sol content": "pragma solidity 0.4.24; interface token { function transfer(address receiver, uint amount) external; function burn(uint amount) external returns(bool success); } contract InterbetCoinCrowdsale { /* Global constants */ uint constant ibcTokenDecimals = 18; // Decimal places of IBC token public tokenReward = token(0xCBbb6861423440170680b538d136FfE17A4b661a); // IBC token contract address public beneficiary = 0x560b989db52368696bDC1db587eA52787Fdc3406; // Interbet team address public admin = 0x8dd4866a5BaB83e1e2433e6e74B8385D12b838A3; // Crowdsale admin /* Events */ event FundTransfer(SaleStage indexed saleStage, address indexed contributor, uint amount, bool isContribution); event CrowdsaleClosed(address recipient, uint totalAmountRaised); event TokenClaimed(address indexed contributor, uint tokenAmount); /* Crowdsale Core */ enum SaleStage { NotStarted, Presale, Break, ICO, Closed } SaleStage public currentSaleStage; uint public minFundInEther = 10 * 1 finney; // Minimum contribution for Presale and ICO uint public presalePrice = 10000; // Base price of Presale: 10,000 IBC = 1 ETH uint public presaleFundingTargetInEther = 3000 * 1 ether; // 3,000 ETH target of Presale uint public breakDurationBetweenPresaleAndICO = 1 weeks; // A short break for preparing ICO uint public icoPhaseTimeInterval = 1 weeks; // Interval of ICO phases uint public icoStart; // ICO starts one week after Presale ended uint public icoTimeBonusPhase1End; // ICO's phase 1 end uint public icoTimeBonusPhase2End; // ICO's phase 2 end uint public icoEnd; // ICO's phase 3 end uint public icoPrice = 5000; // Base price of ICO: 5,000 IBC = 1 ETH uint public totalFundingGoalInIBC = 630000000 * (10 ** ibcTokenDecimals); // Funding goal is 630 Mil IBC: 30 Mil (Presale) + 600 Mil (ICO) uint public fundingRatePredictionBonusPoolInIBC = 70000000 * (10 ** ibcTokenDecimals); // Funding rate prediction bonus pool of minimum 70 Mil IBC uint public icoReferralBonusInPercentage = 5; // 5% bonus for both referrer and contributor uint public icoPhase1TimeBonusInPercentage = 20; // 20% bonus for ICO's phase 1 uint public icoPhase2TimeBonusInPercentage = 10; // 10% bonus for ICO's phase 2 uint public icoPhase3TimeBonusInPercentage = 0; // No bonus for ICO's phase 3 uint public icoFundingRatePredictionBonusInPercentage = 25; // 25% bonus for predicting the correct final funding rate uint public fundingRatePredictionBonusClaimWindow = 4 weeks; // After this window, the remaining pool of prediction bonus tokens will be destroyed uint public etherRaised = 0; // All ether contributed uint public ibcFunded = 0; // Counting only the tokens distributed before ICO ended, without counting funding rate prediction bonus uint public ibcDistributed = 0; // Total tokens distributed uint public contributionCount = 0; // Number of contributions mapping(address => uint256) public balanceOf; // Ether contributed mapping(address => uint256) public ibcVaultBalanceOf; // IBC hold in vault mapping(address => uint256) public baseRewardTokenBalanceOf; // IBC base reward without counting any bonus mapping(address => uint256) public fundingRatePredictionOf; // The funding rate prediction mapping(address => bool) public fundingRatePredictionBingoOf; // Bingo or not constructor() public { currentSaleStage = SaleStage.Presale; } /// Participate by sending ether function () external payable { require(currentSaleStage == SaleStage.Presale || currentSaleStage == SaleStage.Break || currentSaleStage == SaleStage.ICO); if (currentSaleStage == SaleStage.Presale) { participatePresaleNow(); } else if (currentSaleStage == SaleStage.Break || currentSaleStage == SaleStage.ICO) { participateICONow(address(0), 0); } } /// Participate Presale function participatePresale() external payable { participatePresaleNow(); } function participatePresaleNow() private { require(currentSaleStage == SaleStage.Presale); require(etherRaised < presaleFundingTargetInEther); require(msg.value >= minFundInEther); uint amount = msg.value; uint price = presalePrice; uint tokenAmount = mul(amount, price); require(add(ibcFunded, tokenAmount) <= totalFundingGoalInIBC); if (add(etherRaised, amount) >= presaleFundingTargetInEther) { updateSaleStage(SaleStage.Break); } balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); etherRaised = add(etherRaised, amount); contributionCount++; ibcFunded = add(ibcFunded, tokenAmount); ibcVaultBalanceOf[msg.sender] = add(ibcVaultBalanceOf[msg.sender], tokenAmount); emit FundTransfer(SaleStage.Presale, msg.sender, amount, true); } /// Participate ICO function participateICO(address referrer, uint fundingRatePrediction) external payable { participateICONow(referrer, fundingRatePrediction); } function participateICONow(address referrer, uint fundingRatePrediction) private { require(currentSaleStage == SaleStage.Break || currentSaleStage == SaleStage.ICO); if (currentSaleStage == SaleStage.Break) { if (now >= icoStart && now < icoEnd) { updateSaleStage(SaleStage.ICO); } else { revert(); } } else if (currentSaleStage == SaleStage.ICO) { require(now >= icoStart && now < icoEnd); } require(referrer != msg.sender); require(fundingRatePrediction >= 1 && fundingRatePrediction <= 100); uint amount = msg.value; uint price = icoPrice; uint baseRewardTokenAmount = mul(amount, price); uint tokenAmount = add(baseRewardTokenAmount, calculateInstantBonusAmount(baseRewardTokenAmount, referrer)); uint referrerReferralBonus = 0; if (referrer != address(0)) { referrerReferralBonus = mul(baseRewardTokenAmount, icoReferralBonusInPercentage) / 100; } if (add(add(ibcFunded, tokenAmount), referrerReferralBonus) < totalFundingGoalInIBC) { require(msg.value >= minFundInEther); } else { require(add(add(ibcFunded, tokenAmount), referrerReferralBonus) == totalFundingGoalInIBC); } if (add(add(ibcFunded, tokenAmount), referrerReferralBonus) == totalFundingGoalInIBC) { updateSaleStage(SaleStage.Closed); } balanceOf[msg.sender] = add(balanceOf[msg.sender], amount); baseRewardTokenBalanceOf[msg.sender] = add(baseRewardTokenBalanceOf[msg.sender], baseRewardTokenAmount); fundingRatePredictionOf[msg.sender] = fundingRatePrediction; etherRaised = add(etherRaised, amount); contributionCount++; ibcFunded = add(ibcFunded, tokenAmount); ibcVaultBalanceOf[msg.sender] = add(ibcVaultBalanceOf[msg.sender], tokenAmount); if (referrerReferralBonus != 0) { ibcFunded = add(ibcFunded, referrerReferralBonus); ibcVaultBalanceOf[referrer] = add(ibcVaultBalanceOf[referrer], referrerReferralBonus); } emit FundTransfer(SaleStage.ICO, msg.sender, amount, true); } /// Calculate time and referral bonus with base tokens function calculateInstantBonusAmount(uint baseRewardTokenAmount, address referrer) internal view returns(uint) { uint timeBonus = 0; uint timeBonusInPercentage = checkTimeBonusPercentage(); if (timeBonusInPercentage != 0) { timeBonus = mul(baseRewardTokenAmount, timeBonusInPercentage) / 100; } uint referralBonus = 0; if (referrer != address(0)) { referralBonus = mul(baseRewardTokenAmount, icoReferralBonusInPercentage) / 100; } uint instantBonus = add(timeBonus, referralBonus); return instantBonus; } /// Get time bonus percentage function checkTimeBonusPercentage() internal view returns(uint) { uint timeBonusInPercentage = 0; if (now < icoTimeBonusPhase1End) { timeBonusInPercentage = icoPhase1TimeBonusInPercentage; } else if (now < icoTimeBonusPhase2End) { timeBonusInPercentage = icoPhase2TimeBonusInPercentage; } return timeBonusInPercentage; } /// Claim IBC function claimToken() external { require(currentSaleStage == SaleStage.ICO || currentSaleStage == SaleStage.Closed); if (currentSaleStage == SaleStage.ICO) { if (ibcFunded == totalFundingGoalInIBC || now >= icoEnd) { updateSaleStage(SaleStage.Closed); } else { revert(); } } require(ibcVaultBalanceOf[msg.sender] > 0); uint tokenAmount = ibcVaultBalanceOf[msg.sender]; if (now < icoEnd + fundingRatePredictionBonusClaimWindow) { if (fundingRatePredictionBonusPoolInIBC > 0) { uint finalFundingRate = mul(ibcFunded, 100) / totalFundingGoalInIBC; if (finalFundingRate > 100) { finalFundingRate = 100; } if (fundingRatePredictionOf[msg.sender] == finalFundingRate) { if (!fundingRatePredictionBingoOf[msg.sender]) { fundingRatePredictionBingoOf[msg.sender] = true; uint fundingRatePredictionBingoBonus = mul(baseRewardTokenBalanceOf[msg.sender], icoFundingRatePredictionBonusInPercentage) / 100; if (fundingRatePredictionBingoBonus > fundingRatePredictionBonusPoolInIBC) { fundingRatePredictionBingoBonus = fundingRatePredictionBonusPoolInIBC; } fundingRatePredictionBonusPoolInIBC = sub(fundingRatePredictionBonusPoolInIBC, fundingRatePredictionBingoBonus); tokenAmount = add(tokenAmount, fundingRatePredictionBingoBonus); } } } } ibcVaultBalanceOf[msg.sender] = 0; ibcDistributed = add(ibcDistributed, tokenAmount); tokenReward.transfer(msg.sender, tokenAmount); emit TokenClaimed(msg.sender, tokenAmount); } function updateSaleStage(SaleStage saleStage) private { currentSaleStage = saleStage; if (saleStage == SaleStage.Break) { icoStart = now + breakDurationBetweenPresaleAndICO; icoTimeBonusPhase1End = icoStart + icoPhaseTimeInterval; icoTimeBonusPhase2End = icoTimeBonusPhase1End + icoPhaseTimeInterval; icoEnd = icoTimeBonusPhase2End + icoPhaseTimeInterval; } else if (saleStage == SaleStage.Closed) { if (now < icoEnd) { icoEnd = now; } if (ibcFunded < totalFundingGoalInIBC) { fundingRatePredictionBonusPoolInIBC = add(fundingRatePredictionBonusPoolInIBC, sub(totalFundingGoalInIBC, ibcFunded)); } emit CrowdsaleClosed(beneficiary, etherRaised); } } /// Update sale stage manually function updateSaleStageManually(uint saleStage) external { require(msg.sender == admin); require(saleStage >= 1 && saleStage <= 4); require(saleStage > uint(currentSaleStage)); updateSaleStage(SaleStage(saleStage)); } /// Withdraw Ether function withdrawEther(uint amount) external { require(msg.sender == beneficiary); if (beneficiary.send(amount)) { emit FundTransfer(SaleStage.Closed, beneficiary, amount, false); } } /// Burn the remaining pool of prediction bonus tokens function burnAllRemainingIBC() external { require(currentSaleStage == SaleStage.Closed); require(now >= icoEnd + fundingRatePredictionBonusClaimWindow); require(msg.sender == admin); require(fundingRatePredictionBonusPoolInIBC > 0); uint currentFundingRatePredictionBonusPoolInIBC = fundingRatePredictionBonusPoolInIBC; fundingRatePredictionBonusPoolInIBC = 0; if (!tokenReward.burn(currentFundingRatePredictionBonusPoolInIBC)) { fundingRatePredictionBonusPoolInIBC = currentFundingRatePredictionBonusPoolInIBC; } } /* Math utilities */ function mul(uint256 _a, uint256 _b) private pure returns(uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function sub(uint256 _a, uint256 _b) private pure returns(uint256) { assert(_b <= _a); return _a - _b; } function add(uint256 _a, uint256 _b) private pure returns(uint256 c) { c = _a + _b; assert(c >= _a); return c; } } "}
{"sol name": "742.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = 0x6A8F3f9F224FaEe581879c477AC7158AEf730f5d; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: contracts/Upcoin.sol contract Upcoin is MintableToken { string public name = \"Upcoin\"; string public symbol = \"UPCN\"; uint8 public decimals = 18; constructor(uint256 _initial) public { balances[0x6A8F3f9F224FaEe581879c477AC7158AEf730f5d] = _initial; totalSupply_ = _initial; } function isUpcoin() public pure returns (bool) { return true; } function transferOrigin(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[tx.origin]); balances[tx.origin] = balances[tx.origin].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(tx.origin, _to, _value); return true; } } "}
{"sol name": "729.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Beggar' CROWDSALE token contract // // Deployed to : 0x22d6aede0c22a00b5ba34c3cab1c7029af443501 // Symbol      : BGC // Name        : Beggar Token // Total supply: Gazillion // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto & Daniel Bar with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract BeggarToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function BeggarToken() public { symbol = \"BGC\"; name = \"Beggar Token\"; decimals = 18; bonusEnds = now + 8 weeks; endDate = now + 56 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 1,0000 BGC Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 12000; } else { tokens = msg.value * 10000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "856.sol", "label": 0, "sol content": "pragma solidity 0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Owned { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract BidoohToken is MintableToken { string public constant name = \"Bidooh Token\"; string public constant symbol = \"DOOH\"; uint8 public constant decimals = 18; /// This address is be assigned the Bidooh Team tokens address public teamTokensAddress; /// This address is be assigned the Reserve tokens address public reserveTokensAddress; /// This address is be assigned the Sale tokens address public saleTokensAddress; /// This address will have the sole ability to mint more tokens address public bidoohAdminAddress; /// a safeguard flag to prevent multiple calls of close() bool public saleClosed = false; /// Only allowed to execute before the token sale is closed modifier beforeSaleClosed { require(!saleClosed); _; } constructor(address _teamTokensAddress, address _reserveTokensAddress, address _saleTokensAddress, address _bidoohAdminAddress) public { require(_teamTokensAddress != address(0)); require(_reserveTokensAddress != address(0)); require(_saleTokensAddress != address(0)); require(_bidoohAdminAddress != address(0)); teamTokensAddress = _teamTokensAddress; reserveTokensAddress = _reserveTokensAddress; saleTokensAddress = _saleTokensAddress; bidoohAdminAddress = _bidoohAdminAddress; /// Maximum tokens to be allocated on the sale /// 88.2 billion DOOH uint256 saleTokens = 88200000000 * 10**uint256(decimals); totalSupply_ = saleTokens; balances[saleTokensAddress] = saleTokens; /// Reserve tokens - 18.9 billion DOOH uint256 reserveTokens = 18900000000 * 10**uint256(decimals); totalSupply_ = totalSupply_.add(reserveTokens); balances[reserveTokensAddress] = reserveTokens; /// Team tokens - 18.9 billion DOOH uint256 teamTokens = 18900000000 * 10**uint256(decimals); totalSupply_ = totalSupply_.add(teamTokens); balances[teamTokensAddress] = teamTokens; } /// @dev Close the token sale and transfer ownership function close() public onlyOwner beforeSaleClosed { uint256 unsoldTokens = balances[saleTokensAddress]; balances[reserveTokensAddress] = balances[reserveTokensAddress].add(unsoldTokens); balances[saleTokensAddress] = 0; emit Transfer(saleTokensAddress, reserveTokensAddress, unsoldTokens); owner = bidoohAdminAddress; saleClosed = true; } } "}
{"sol name": "528.sol", "label": 0, "sol content": "pragma solidity 0.4.21; contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract ROC is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ROC() public { symbol = \"ROC\"; name = \"NeoWorld Rare Ore C\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1747.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'BTC' token contract // // Deployed to : 0xa33274b924e439c119e36e0f2186de074634d12c // Symbol      : BTC // Name        : BTC Token // Total supply: 10000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract BitCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function BitCoin() public { symbol = \"BTC\"; name = \"BitCoin\"; decimals = 18; _totalSupply = 20000000000000000000000 ; balances[0x2fD1fd25eE243103179bd046777928b0f4882E1A] = _totalSupply; Transfer(address(0), 0x2fD1fd25eE243103179bd046777928b0f4882E1A, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1746.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, uint8 initialDecimals, string tokenName, string tokenSymbol ) public { decimals = initialDecimals; totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1876.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'WCAP' CROWDSALE token contract // // Deployed to : 0x2935e36f278614e1d3fd36c864fbe9098166ca96 // Symbol      : WCP // Name        : WCAP // Total supply: Gazillion // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto & Daniel Bar with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract wcapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function wcapToken() public { symbol = \"WCP\"; name = \"WCAP\"; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 7 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 1,000 FWD Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 2000; } else { tokens = msg.value * 2000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "403.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract KeralaDonationContract is Ownable { string public name; string public symbol; uint public decimals; uint public totalSupply; uint public amountRaised; bool donationClosed = false; mapping (address => uint256) public balanceOf; /* To track donated amount of a user */ mapping (address => uint256) public balance; event FundTransfer(address backer, uint amount, bool isContribution); event Transfer(address indexed from, address indexed to, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor() public { name = 'Kerala Flood Donation Token'; symbol = 'KFDT'; decimals = 0; totalSupply = 1000000; balanceOf[owner] = totalSupply; amountRaised = 0; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] == 0); require(_value == 1); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public onlyOwner returns(bool success) { _transfer(msg.sender, _to, _value); return true; } /* Stop taking donations */ function disableDonation() public onlyOwner returns(bool success) { donationClosed = true; return true; } /* Start taking donations */ function enableDonation() public onlyOwner returns(bool success) { donationClosed = false; return true; } /* check user's donated amount */ function checkMyDonation() public view returns(uint) { return balance[msg.sender]; } /* check if user is a backer */ function isBacker() public view returns(bool) { if (balanceOf[msg.sender] > 0) { return true; } return false; } /** * Fallback function * * The function without name is the default function that is called whenever anyone sends funds to a contract */ function () payable public { require(!donationClosed); uint amount = msg.value; amountRaised += amount; balance[msg.sender] += amount; transfer(msg.sender, 1); owner.transfer(msg.value); } } "}
{"sol name": "1670.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) {return 0;} uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20{ function balanceOf(address _owner)public view returns (uint256 balance); function transfer(address _to, uint256 _value)public returns (bool success); function transferFrom(address _from, address _to, uint256 _value)public returns (bool success); function approve(address _spender, uint256 _value)public returns (bool success); function allowance(address _owner, address _spender)public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract MaxWellToken is ERC20{ using SafeMath for uint256; string public name   = \"MaxWellToken\"; string public symbol = \"MWT\"; uint8 public decimals=18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; constructor(uint256 initialSupply)public{ totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; } function balanceOf(address _owner)public view returns (uint256 balance){ return balances[_owner]; } function transfer(address _to, uint256 _value)public returns (bool success){ require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value)public returns (bool success){ require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value)public returns (bool success){ allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender)public view returns (uint256 remaining){ return allowed[_owner][_spender]; } } "}
{"sol name": "233.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "1626.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract BlockChainZB { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function BlockChainZB( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "987.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = 0x06363C5478A6127826C79e3cf37e880acaE9f642; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token object // create, view and control // ---------------------------------------------------------------------------- contract BanglaCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { name = \"BanglaCoin\"; symbol = \"BDC\"; decimals = 18; _totalSupply = 2000000000000000000000000; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to 'to' account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } // ------------------------------------------------------------------------ // Return the address of the contract owner // ------------------------------------------------------------------------ function getOwner() public view returns (address) { return owner; } } "}
{"sol name": "1852.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // File: node_modules/zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: node_modules/zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: node_modules/zeppelin-solidity/contracts/token/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: node_modules/zeppelin-solidity/contracts/token/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: node_modules/zeppelin-solidity/contracts/token/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: node_modules/zeppelin-solidity/contracts/token/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply = totalSupply.sub(_value); Burn(_who, _value); Transfer(_who, address(0), _value); } } // File: contracts/WinEToken.sol /** * @title WinEToken * An EIP20 compliant token used as the instrument of ticket purchase and * prize award in games on the WinTokens games platform.  After the crowd sale * and final minting of tokens for the project, the token supply will be * 2x the tokens sold during all tiers of the sale forever. */ contract WinEToken is MintableToken, BurnableToken { string public constant name = \"Win ETH and BTC GAMES\"; string public constant symbol = \"WinE\"; uint8 public constant decimals = 18; function WinEToken() public { totalSupply = 1000000000 ether; balances[msg.sender] = totalSupply; } } "}
{"sol name": "1933.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract BCTVToken { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function BCTVToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1660.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract MJOYToken is ERC20Interface, Owned { string  public  symbol; string  public  name; uint8 public decimals; uint  _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; using SafeMath for uint; function MJOYToken() public { symbol = \"JOY\"; name = \"MJOY TOKEN\"; decimals = 18; _totalSupply = 1 * (10 ** 9) * (10 ** uint(decimals)); balances[owner] = 6 * (10 ** 8) * (10 ** uint(decimals)); emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function() public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "224.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } interface AccountRegistryInterface { function accountIdForAddress(address _address) public view returns (uint256); function addressBelongsToAccount(address _address) public view returns (bool); function createNewAccount(address _newUser) external; function addAddressToAccount( address _newAddress, address _sender ) external; function removeAddressFromAccount(address _addressToRemove) external; } /** * @title Bloom account registry * @notice Account Registry implements the Bloom ID data structures * and the low-level account administration functions. * The account administration functions are not publicly accessible. * Account Registry Logic implements the public functions which access the functions in Account Registry. */ contract AccountRegistry is Ownable, AccountRegistryInterface{ address public accountRegistryLogic; /** * @notice The AccountRegistry constructor configures the account registry logic implementation *  and creates an account for the user who deployed the contract. * @dev The owner is also set as the original registryAdmin, who has the privilege to *  create accounts outside of the normal invitation flow. * @param _accountRegistryLogic Address of deployed Account Registry Logic implementation */ constructor( address _accountRegistryLogic ) public { accountRegistryLogic = _accountRegistryLogic; } event AccountRegistryLogicChanged(address oldRegistryLogic, address newRegistryLogic); /** * @dev Zero address not allowed */ modifier nonZero(address _address) { require(_address != 0); _; } modifier onlyAccountRegistryLogic() { require(msg.sender == accountRegistryLogic); _; } // Counter to generate unique account Ids uint256 numAccounts; mapping(address => uint256) public accountByAddress; /** * @notice Change the address of the registry logic which has exclusive write control over this contract * @dev Restricted to AccountRegistry owner and new admin address cannot be 0x0 * @param _newRegistryLogic Address of new registry logic implementation */ function setRegistryLogic(address _newRegistryLogic) public onlyOwner nonZero(_newRegistryLogic) { address _oldRegistryLogic = accountRegistryLogic; accountRegistryLogic = _newRegistryLogic; emit AccountRegistryLogicChanged(_oldRegistryLogic, accountRegistryLogic); } /** * @notice Retreive account ID associated with a user's address * @param _address Address to look up * @return account id as uint256 if exists, otherwise reverts */ function accountIdForAddress(address _address) public view returns (uint256) { require(addressBelongsToAccount(_address)); return accountByAddress[_address]; } /** * @notice Check if an address is associated with any user account * @dev Check if address is associated with any user by cross validating *  the accountByAddress with addressByAccount * @param _address Address to check * @return true if address has been assigned to user. otherwise reverts */ function addressBelongsToAccount(address _address) public view returns (bool) { return accountByAddress[_address] > 0; } /** * @notice Create an account for a user and emit an event * @param _newUser Address of the new user */ function createNewAccount(address _newUser) external onlyAccountRegistryLogic nonZero(_newUser) { require(!addressBelongsToAccount(_newUser)); numAccounts++; accountByAddress[_newUser] = numAccounts; } /** * @notice Add an address to an existing id * @param _newAddress Address to add to account * @param _sender User requesting this action */ function addAddressToAccount( address _newAddress, address _sender ) external onlyAccountRegistryLogic nonZero(_newAddress) { // check if address belongs to someone else require(!addressBelongsToAccount(_newAddress)); accountByAddress[_newAddress] = accountIdForAddress(_sender); } /** * @notice Remove an address from an id * @param _addressToRemove Address to remove from account */ function removeAddressFromAccount( address _addressToRemove ) external onlyAccountRegistryLogic { delete accountByAddress[_addressToRemove]; } } "}
{"sol name": "272.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'BCP' CROWDSALE token contract // // Deployed to : 0xbcc48a07d2c3bb879857f0ed6e9ff80252202e77 // Symbol      : BCP // Name        : BitCash Platform // Total supply: 2100000000 // Decimals    : 18 // // Enjoy. // // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract BitCashPlatform is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function BitCashPlatform() public { symbol = \"BCP\"; name = \"BitCash Platform\"; decimals = 18; bonusEnds = now + 7 weeks; endDate = now + 15 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 2100000 BitCashPlatform per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 2100000; } else { tokens = msg.value * 950000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1894.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(msg.sender != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_from != address(0)); uint256 _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. * https://github.com/OpenZeppelin * openzeppelin-solidity/contracts/ownership/Ownable.sol */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract HiGold is StandardToken, Ownable { /*** SAFEMATH ***/ using SafeMath for uint256; /*** EVENTS ***/ event Deposit(address indexed manager, address indexed user, uint value); event Withdrawl(address indexed manager, address indexed user, uint value); /*** CONSTANTS ***/ // ERC20 string public name = \"HiGold Community Token\"; string public symbol = \"HIG\"; uint256 public decimals = 18; /*** STORAGE ***/ // HiGold Standard uint256 public inVaults; address public miner; mapping (address => mapping (address => uint256)) inVault; /*** MODIFIERS  ***/ modifier onlyMiner() { require(msg.sender == miner); _; } /*** FUNCTIONS ***/ // Constructor function constructor(address _cold) public { totalSupply = 105 * (10 ** 26); balances[_cold] = totalSupply; } // Public functions function totalInVaults() public constant returns (uint256 amount) { return inVaults; } function balanceOfOwnerInVault ( address _vault, address _owner ) public constant returns (uint256 balance) { return inVault[_vault][_owner]; } function deposit ( address _vault, uint256 _value ) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); inVaults = inVaults.add(_value); inVault[_vault][msg.sender] = inVault[_vault][msg.sender].add(_value); emit Deposit(_vault, msg.sender, _value); return true; } function withdraw ( address _vault, uint256 _value ) public returns (bool) { inVault[_vault][msg.sender] = inVault[_vault][msg.sender].sub(_value); inVaults = inVaults.sub(_value); balances[msg.sender] = balances[msg.sender].add(_value); emit Withdrawl(_vault, msg.sender, _value); return true; } function accounting ( address _credit, // - address _debit, // + uint256 _value ) public returns (bool) { inVault[msg.sender][_credit] = inVault[msg.sender][_credit].sub(_value); inVault[msg.sender][_debit] = inVault[msg.sender][_debit].add(_value); return true; } /// For Mining function startMining(address _minerContract) public  onlyOwner { require(miner == address(0)); miner = _minerContract; inVault[miner][miner] = 105 * (10 ** 26); } //// Update contract overview infomations when new token mined. function update(uint _value) public onlyMiner returns(bool) { totalSupply = totalSupply.add(_value); inVaults = inVaults.add(_value); return true; } } "}
{"sol name": "178.sol", "label": 0, "sol content": "pragma solidity 0.4.20; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnboundedRegularToken is RegularToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract LICToken is UnboundedRegularToken { uint public totalSupply = 10*10**27; uint8 constant public decimals = 18; string constant public name = \"LifeCoinToken\"; string constant public symbol = \"LIC\"; function LICToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "818.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'RDW' token contract // // Deployed to :  0xfF26adAb91bD1D7419dbd5b95B61e922850bf818 // Symbol      : RDW // Name        : Real Direct Coin // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract RDWToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function RDWToken() public { symbol = \"RDW\"; name = \"Real Direct Coin\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0xfF26adAb91bD1D7419dbd5b95B61e922850bf818] = _totalSupply; Transfer(address(0), 0xfF26adAb91bD1D7419dbd5b95B61e922850bf818, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "19.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract RSUNToken is ERC20Interface{ using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function RSUNToken() public { symbol = \"RSUN\"; name = \"RUISUN NEW ENERGY\"; decimals = 18; _totalSupply = 500000000 * 10**uint(decimals); balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // send ERC20 Token to multi address // ------------------------------------------------------------------------ function multiTransfer(address[] _addresses, uint256[] amounts) public returns (bool success){ for (uint256 i = 0; i < _addresses.length; i++) { transfer(_addresses[i], amounts[i]); } return true; } // ------------------------------------------------------------------------ // send ERC20 Token to multi address with decimals // ------------------------------------------------------------------------ function multiTransferDecimals(address[] _addresses, uint256[] amounts) public returns (bool success){ for (uint256 i = 0; i < _addresses.length; i++) { transfer(_addresses[i], amounts[i] * 10**uint(decimals)); } return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } } "}
{"sol name": "1653.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract owned { constructor() public { owner = msg.sender; } address owner; modifier onlyOwner { require(msg.sender == owner); _; } } contract ERC20 { function balanceOf(address tokenOwner) public constant returns (uint256 balance); function transfer(address to, uint256 tokens) public returns (bool success); } contract Tank is owned { function () payable public {} function withdrawEther(address toAddress, uint256 amount) public onlyOwner { toAddress.transfer(amount); } function withdrawToken(address token, address toAddress, uint256 amount) public onlyOwner { ERC20(token).transfer(toAddress, amount); } function withdrawInBatch(address[] tokenList, address[] toAddressList, uint256[] amountList) public onlyOwner { require(tokenList.length == toAddressList.length); require(toAddressList.length == amountList.length); for (uint i = 0; i < toAddressList.length; i++) { if (tokenList[i] == 0) { this.withdrawEther(toAddressList[i], amountList[i]); } else { this.withdrawToken(tokenList[i], toAddressList[i], amountList[i]); } } } function withdrawEtherInBatch(address[] toAddressList, uint256[] amountList) public onlyOwner { require(toAddressList.length == amountList.length); for (uint i = 0; i < toAddressList.length; i++) { this.withdrawEther(toAddressList[i], amountList[i]); } } } "}
{"sol name": "61.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred (owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract Aeroneum is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint _totalSupply; uint8 mintx; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; uint256 public rate; // How many token units a buyer gets per wei uint256 public weiRaised;  // Amount of wei raised address wallet; uint _tokenToSale; uint _ownersTokens; event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Aeroneum(address _owner,address _wallet) public{ symbol = \"ARM\"; name = \"Aeroneum\"; decimals = 18; rate = 5000000; //per wei mintx = 16; wallet = _wallet; // to send funds to owner = _owner; //owner of the contract _totalSupply = totalSupply(); _tokenToSale = (_totalSupply.mul(95)).div(100); // 95% kept for sales _ownersTokens = _totalSupply - _tokenToSale; // 5% send to owner balances[this] = _tokenToSale; balances[owner] = _ownersTokens; emit Transfer(address(0),this,_tokenToSale); emit Transfer(address(0),owner,_ownersTokens); } function totalSupply() public constant returns (uint){ return 11000000000 * 10**uint(decimals); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { // prevent transfer to 0x0, use burn instead require(to != 0x0); require(balances[msg.sender] >= tokens ); require(balances[to] + tokens >= balances[to]); balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender,to,tokens); return true; } function _transfer(address _to, uint _tokens) internal returns (bool success){ // prevent transfer to 0x0, use burn instead require(_to != 0x0); require(balances[this] >= _tokens); require(balances[_to] + _tokens >= balances[_to]); balances[this] = balances[this].sub(_tokens); balances[_to] = balances[_to].add(_tokens); emit Transfer(this,_to,_tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success){ allowed[msg.sender][spender] = tokens; emit Approval(msg.sender,spender,tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success){ require(tokens <= allowed[from][msg.sender]); //check allowance require(balances[from] >= tokens); balances[from] = balances[from].sub(tokens); balances[to] = balances[to].add(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); emit Transfer(from,to,tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function () external payable { buyTokens(msg.sender); } function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); TokenPurchase(this, _beneficiary, weiAmount, tokens); _forwardFunds(); } function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0x0)); // require(_weiAmount != 0); } function _getTokenAmount(uint256 _weiAmount) internal returns (uint256) { if(_weiAmount < 1 * 10**uint(mintx)){return 50 * 10**uint(decimals);} else{return _weiAmount.mul(rate);} } function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { _transfer(_beneficiary,_tokenAmount); } function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } function _forwardFunds() internal { wallet.transfer(msg.value); } } "}
{"sol name": "876.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract TokenERC20 is Ownable { using SafeMath for uint256; string public constant name       = \"PWCC\"; string public constant symbol     = \"PWCC\"; uint32 public constant decimals   = 18; uint256 public totalSupply; uint256 public currentTotalSupply = 0; uint256 public startBalance       = 2 ether; mapping(address => bool) touched; mapping(address => uint256) balances; mapping(address => mapping (address => uint256)) internal allowed; mapping(address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); event Burn(address indexed burner, uint256 value); function TokenERC20( uint256 initialSupply ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balances[msg.sender] = totalSupply;                // Give the creator all initial tokens } function totalSupply() public view returns (uint256) { return totalSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); if( !touched[msg.sender] && currentTotalSupply < totalSupply  ){ balances[msg.sender] = balances[msg.sender].add( startBalance ); touched[msg.sender] = true; currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); if( !touched[_from] && currentTotalSupply < totalSupply ){ touched[_from] = true; balances[_from] = balances[_from].add( startBalance ); currentTotalSupply = currentTotalSupply.add( startBalance ); } balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function getBalance(address _a) internal constant returns(uint256) { if( currentTotalSupply < totalSupply ){ if( touched[_a] ) return balances[_a]; else return balances[_a].add( startBalance ); } else { return balances[_a]; } } function balanceOf(address _owner) public view returns (uint256 balance) { return getBalance( _owner ); } function () payable public { } function getEth(uint num) payable public onlyOwner { owner.transfer(num); } function modifyairdrop(uint256 _startBalance ) public onlyOwner { startBalance = _startBalance; } } "}
{"sol name": "574.sol", "label": 0, "sol content": "pragma solidity 0.4.21; contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract ROA is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ROA() public { symbol = \"ROA\"; name = \"NeoWorld Rare Ore A\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "793.sol", "label": 0, "sol content": "/** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ pragma solidity ^0.4.18; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * Standard EIP-20 token with an interface marker. * * @notice Interface marker is used by crowdsale contracts to validate that addresses point a good token contract. * */ contract StandardTokenExt is StandardToken { /* Interface declaration */ function isToken() public pure returns (bool weAre) { return true; } } contract BurnableToken is StandardTokenExt { // @notice An address for the transfer event where the burned tokens are transferred in a faux Transfer event address public constant BURN_ADDRESS = 0; /** How many tokens we burned */ event Burned(address burner, uint burnedAmount); /** * Burn extra tokens from a balance. * */ function burn(uint burnAmount) public { address burner = msg.sender; balances[burner] = balances[burner].sub(burnAmount); totalSupply_ = totalSupply_.sub(burnAmount); Burned(burner, burnAmount); // Inform the blockchain explores that track the // balances only by a transfer event that the balance in this // address has decreased Transfer(burner, BURN_ADDRESS, burnAmount); } } /** * Upgrade agent interface inspired by Lunyr. * * Upgrade agent transfers tokens to a new contract. * Upgrade agent itself can be the token contract, or just a middle man contract doing the heavy lifting. */ contract UpgradeAgent { uint public originalSupply; /** Interface marker */ function isUpgradeAgent() public pure returns (bool) { return true; } function upgradeFrom(address _from, uint256 _value) public; } /** * A token upgrade mechanism where users can opt-in amount of tokens to the next smart contract revision. * * First envisioned by Golem and Lunyr projects. */ contract UpgradeableToken is StandardTokenExt { /** Contract / person who can set the upgrade path. This can be the same as team multisig wallet, as what it is with its default value. */ address public upgradeMaster; /** The next contract where the tokens will be migrated. */ UpgradeAgent public upgradeAgent; /** How many tokens we have upgraded by now. */ uint256 public totalUpgraded; /** * Upgrade states. * * - NotAllowed: The child contract has not reached a condition where the upgrade can bgun * - WaitingForAgent: Token allows upgrade, but we don't have a new agent yet * - ReadyToUpgrade: The agent is set, but not a single token has been upgraded yet * - Upgrading: Upgrade agent is set and the balance holders can upgrade their tokens * */ enum UpgradeState {Unknown, NotAllowed, WaitingForAgent, ReadyToUpgrade, Upgrading} /** * Somebody has upgraded some of his tokens. */ event Upgrade(address indexed _from, address indexed _to, uint256 _value); /** * New upgrade agent available. */ event UpgradeAgentSet(address agent); /** * Do not allow construction without upgrade master set. */ function UpgradeableToken(address _upgradeMaster) public { upgradeMaster = _upgradeMaster; } /** * Allow the token holder to upgrade some of their tokens to a new contract. */ function upgrade(uint256 value) public { UpgradeState state = getUpgradeState(); if(!(state == UpgradeState.ReadyToUpgrade || state == UpgradeState.Upgrading)) { // Called in a bad state revert(); } // Validate input value. if (value == 0) revert(); balances[msg.sender] = balances[msg.sender].sub(value); // Take tokens out from circulation totalSupply_ = totalSupply_.sub(value); totalUpgraded = totalUpgraded.add(value); // Upgrade agent reissues the tokens upgradeAgent.upgradeFrom(msg.sender, value); Upgrade(msg.sender, upgradeAgent, value); } /** * Set an upgrade agent that handles */ function setUpgradeAgent(address agent) external { if(!canUpgrade()) { // The token is not yet in a state that we could think upgrading revert(); } if (agent == 0x0) revert(); // Only a master can designate the next agent if (msg.sender != upgradeMaster) revert(); // Upgrade has already begun for an agent if (getUpgradeState() == UpgradeState.Upgrading) revert(); upgradeAgent = UpgradeAgent(agent); // Bad interface if(!upgradeAgent.isUpgradeAgent()) revert(); // Make sure that token supplies match in source and target if (upgradeAgent.originalSupply() != totalSupply_) revert(); UpgradeAgentSet(upgradeAgent); } /** * Get the state of the token upgrade. */ function getUpgradeState() public constant returns(UpgradeState) { if(!canUpgrade()) return UpgradeState.NotAllowed; else if(address(upgradeAgent) == 0x00) return UpgradeState.WaitingForAgent; else if(totalUpgraded == 0) return UpgradeState.ReadyToUpgrade; else return UpgradeState.Upgrading; } /** * Change the upgrade master. * * This allows us to set a new owner for the upgrade mechanism. */ function setUpgradeMaster(address master) public { if (master == 0x0) revert(); if (msg.sender != upgradeMaster) revert(); upgradeMaster = master; } /** * Child contract can enable to provide the condition when the upgrade can begun. */ function canUpgrade() public view returns(bool); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); owner = newOwner; } } /** * Define interface for releasing the token transfer after a successful crowdsale. */ contract ReleasableToken is ERC20, Ownable { /* The finalizer contract that allows unlift the transfer limits on this token */ address public releaseAgent; /** A crowdsale contract can release us to the wild if ICO success. If false we are are in transfer lock up period.*/ bool public released = false; /** Map of agents that are allowed to transfer tokens regardless of the lock down period. These are crowdsale contracts and possible the team multisig itself. */ mapping (address => bool) public transferAgents; /** Map of addresses that are locked to transfer tokens  */ mapping (address => bool) public lockAddresses; /** * Limit token transfer until the crowdsale is over. * */ modifier canTransfer(address _sender) { if(lockAddresses[_sender]) { revert(); } if(!released) { if(!transferAgents[_sender]) { revert(); } } _; } /** * Set the contract that can call release and make the token transferable. * * Design choice. Allow reset the release agent to fix fat finger mistakes. */ function setReleaseAgent(address addr) onlyOwner inReleaseState(false) public { // We don't do interface check here as we might want to a normal wallet address to act as a release agent releaseAgent = addr; } /** * Owner can allow a particular address (a crowdsale contract) to transfer tokens despite the lock up period. */ function setTransferAgent(address addr, bool state) onlyOwner inReleaseState(false) public { transferAgents[addr] = state; } /** * Owner can lock a particular address (a crowdsale contract) */ function setLockAddress(address addr, bool state) onlyOwner inReleaseState(false) public { lockAddresses[addr] = state; } /** * One way function to release the tokens to the wild. * * Can be called only from the release agent that is the final ICO contract. It is only called if the crowdsale has been success (first milestone reached). */ function releaseTokenTransfer() public onlyReleaseAgent { released = true; } /** The function can be called only before or after the tokens have been releasesd */ modifier inReleaseState(bool releaseState) { if(releaseState != released) { revert(); } _; } /** The function can be called only by a whitelisted release agent. */ modifier onlyReleaseAgent() { if(msg.sender != releaseAgent) { revert(); } _; } function transfer(address _to, uint _value) public canTransfer(msg.sender) returns (bool success) { // Call StandardToken.transfer() return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) public canTransfer(_from) returns (bool success) { // Call StandardToken.transferForm() return super.transferFrom(_from, _to, _value); } } /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLib { function times(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function minus(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b)  internal pure returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * A token that can increase its supply by another contract. * * This allows uncapped crowdsale by dynamically increasing the supply when money pours in. * Only mint agents, contracts whitelisted by owner, can mint new tokens. * */ contract MintableToken is StandardTokenExt, Ownable { using SafeMathLib for uint; bool public mintingFinished = false; /** List of agents that are allowed to create new tokens */ mapping (address => bool) public mintAgents; event MintingAgentChanged(address addr, bool state); event Minted(address receiver, uint amount); /** * Create new tokens and allocate them to an address.. * * Only callably by a crowdsale contract (mint agent). */ function mint(address receiver, uint amount) onlyMintAgent canMint public { totalSupply_ = totalSupply_.plus(amount); balances[receiver] = balances[receiver].plus(amount); // This will make the mint transaction apper in EtherScan.io // We can remove this after there is a standardized minting event Transfer(0, receiver, amount); } /** * Owner can allow a crowdsale contract to mint new tokens. */ function setMintAgent(address addr, bool state) onlyOwner canMint public { mintAgents[addr] = state; MintingAgentChanged(addr, state); } modifier onlyMintAgent() { // Only crowdsale contracts are allowed to mint new tokens if(!mintAgents[msg.sender]) { revert(); } _; } /** Make sure we are not done yet. */ modifier canMint() { if(mintingFinished) revert(); _; } } /** * A crowdsaled token. * * An ERC-20 token designed specifically for crowdsales with investor protection and further development path. * * - The token transfer() is disabled until the crowdsale is over * - The token contract gives an opt-in upgrade path to a new contract * - The same token can be part of several crowdsales through approve() mechanism * - The token can be capped (supply set in the constructor) or uncapped (crowdsale contract can mint new tokens) * */ contract CrowdsaleToken is ReleasableToken, MintableToken, UpgradeableToken { /** Name and symbol were updated. */ event UpdatedTokenInformation(string newName, string newSymbol); string public name; string public symbol; uint public decimals; /** * Construct the token. * * This token must be created through a team multisig wallet, so that it is owned by that wallet. * * @param _name Token name * @param _symbol Token symbol - should be all caps * @param _initialSupply How many tokens we start with * @param _decimals Number of decimal places * @param _mintable Are new tokens created over the crowdsale or do we distribute only the initial supply? Note that when the token becomes transferable the minting always ends. */ function CrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) public UpgradeableToken(msg.sender) { // Create any address, can be transferred // to team multisig via changeOwner(), // also remember to call setUpgradeMaster() owner = msg.sender; name = _name; symbol = _symbol; totalSupply_ = _initialSupply; decimals = _decimals; // Create initially all balance on the team multisig balances[owner] = totalSupply_; if(totalSupply_ > 0) { Minted(owner, totalSupply_); } // No more new supply allowed after the token creation if(!_mintable) { mintingFinished = true; if(totalSupply_ == 0) { revert(); // Cannot create a token without supply and no minting } } } /** * When token is released to be transferable, enforce no new tokens can be created. */ function releaseTokenTransfer() public onlyReleaseAgent { mintingFinished = true; super.releaseTokenTransfer(); } /** * Allow upgrade agent functionality kick in only if the crowdsale was success. */ function canUpgrade() public constant returns(bool) { return released; } /** * Owner can update token information here. * * It is often useful to conceal the actual token association, until * the token operations, like central issuance or reissuance have been completed. * * This function allows the token owner to rename the token after the operations * have been completed and then point the audience to use the token contract. */ function setTokenInformation(string _name, string _symbol) public onlyOwner { name = _name; symbol = _symbol; UpdatedTokenInformation(name, symbol); } } /** * A crowdsaled token that you can also burn. * */ contract BurnableCrowdsaleToken is BurnableToken, CrowdsaleToken { function BurnableCrowdsaleToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) public CrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) { } } /** * The AML Token * * This subset of BurnableCrowdsaleToken gives the Owner a possibility to * reclaim tokens from a participant before the token is released * after a participant has failed a prolonged AML process. * * It is assumed that the anti-money laundering process depends on blockchain data. * The data is not available before the transaction and not for the smart contract. * Thus, we need to implement logic to handle AML failure cases post payment. * We give a time window before the token release for the token sale owners to * complete the AML and claw back all token transactions that were * caused by rejected purchases. */ contract AMLToken is BurnableCrowdsaleToken { // An event when the owner has reclaimed non-released tokens event OwnerReclaim(address fromWhom, uint amount); function AMLToken(string _name, string _symbol, uint _initialSupply, uint _decimals, bool _mintable) public BurnableCrowdsaleToken(_name, _symbol, _initialSupply, _decimals, _mintable) { } /// @dev Here the owner can reclaim the tokens from a participant if ///      the token is not released yet. Refund will be handled offband. /// @param fromWhom address of the participant whose tokens we want to claim function transferToOwner(address fromWhom) public onlyOwner { if (released) revert(); uint amount = balanceOf(fromWhom); balances[fromWhom] = balances[fromWhom].sub(amount); balances[owner] = balances[owner].add(amount); Transfer(fromWhom, owner, amount); OwnerReclaim(fromWhom, amount); } } "}
{"sol name": "1923.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'APEc' 'ApeCash Coin' token contract // // Symbol      : APEc // Name        : ApeCash Coin // Total supply: 250,000,000.000000000000000000 // Decimals    : 18 // // Save Primates. // // (c) The ApeCash Project. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract apeCashCoin is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public name; uint8 public decimals; uint public _totalSupply = 250000000000000000000000000; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public payable { symbol = \"APEc\"; name = \"ApeCash Coin\"; decimals = 18; _totalSupply = 250000000000000000000000000; balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1767.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Welcome To Solid Token // // send at least 0.01 ETH to Smart Contract 0xe806751624417E7D8090CF40C7C03533a7939173 // NOTE: do not forget to set the gas price 100,000 for the transaction to run smoothly // Symbol      : SOLID // Name        : SOLID TOKEN // Total supply: 440,000,000 SOLID // Decimals    : 18 //In a bug prediction market, actors can bet on whether a vulnerability will be discovered //in a smart contract by a certain date. The basis for such a market is a smart contract //that has been audited and secured by an individual or a group of auditors using the Solidified platform. //These actors are held accountable for securing the code by having staked income and reputation in form of the Solid token. //Author receives bug reports and fixes them. //Our primary goal is building our community, we\u2019re targeting //auditors and Ethereum developers for priority on the whitelist. //YOUR SUPPORT: //we appreciate your support, we are very excited and excited for all your support, // //supportive wallet: //-myetherwallet (online) //-metamask (extension) //-imtoken (Android) //-coinomi (Android) // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract SOLID is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function SOLID() public { symbol = \"SOLID\"; name = \"SOLID TOKEN\"; decimals = 18; bonusEnds = now + 5500 weeks; endDate = now + 7500 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 1,000 FWD Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 903021; } else { tokens = msg.value * 14000000000000000000000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "132.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'KHUU' token contract // // Deployed to : 0x7446acC8E63E13b6FAE345130784966864814365 // Symbol      : KHUU // Name        : KHUU Koin // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract KhuuKoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function KhuuKoin() public { symbol = \"KHUU\"; name = \"Khuu Koin\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x7446acC8E63E13b6FAE345130784966864814365] = _totalSupply; Transfer(address(0), 0x7446acC8E63E13b6FAE345130784966864814365, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1732.sol", "label": 0, "sol content": "pragma solidity ^0.4.6; contract LOL { string public name = \"LOL Token\"; string public symbol = \"LOL\"; uint public decimals = 18; uint public INITIAL_SUPPLY = 2000000000000000000000000; mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint256 public _totalSupply; address public _creator; bool bIsFreezeAll = false; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function totalSupply() public constant returns (uint256 total) { total = _totalSupply; } function transfer(address _to, uint _value) public returns (bool success) { require(bIsFreezeAll == false); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { require(bIsFreezeAll == false); var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) public returns (bool success) { require(bIsFreezeAll == false); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint remaining) { return allowed[_owner][_spender]; } function freezeAll() public { require(msg.sender == _creator); bIsFreezeAll = !bIsFreezeAll; } function LOL() public { _totalSupply = INITIAL_SUPPLY; _creator = 0xCEadFdCCd0E8E370D985c49Ed3117b2572243A4a; balances[_creator] = INITIAL_SUPPLY; bIsFreezeAll = false; } function destroy() public  { require(msg.sender == _creator); selfdestruct(_creator); } } "}
{"sol name": "627.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title DetailedERC20 token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract ACCOToken is MintableToken, DetailedERC20 { constructor(string _name, string _symbol, uint8 _decimals) DetailedERC20(_name, _symbol, _decimals) public {} } "}
{"sol name": "823.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; pragma experimental \"v0.5.0\"; /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract DetailedStandardToken is StandardToken { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } contract NovovivoToken is DetailedStandardToken, Ownable { constructor() DetailedStandardToken(\"Novovivo Token Test\", \"NVT\", 18) public { totalSupply_ = 8 * 10**9 * 10**uint256(decimals); balances[address(this)] = totalSupply_; } function send(address _to, uint256 _value) onlyOwner public returns (bool) { uint256 value = _value.mul(10 ** uint256(decimals)); ERC20 token; token = ERC20(address(this)); return token.transfer(_to, value); } function stopTest() onlyOwner public { selfdestruct(owner); } function () external { revert(); } } "}
{"sol name": "1744.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract KYRIOSToken { using SafeMath for uint256; string public name = \"KYRIOS Token\"; string public symbol = \"KRS\"; uint8 public decimals = 18; uint256 public totalSupply = 2000000000 ether; uint256 public totalAirDrop = totalSupply * 10 / 100; uint256 public eachAirDropAmount = 25000 ether; bool public airdropFinished = false; mapping (address => bool) public airDropBlacklist; mapping (address => bool) public transferBlacklist; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function KYRIOSToken() public { balanceOf[msg.sender] = totalSupply - totalAirDrop; } modifier canAirDrop() { require(!airdropFinished); _; } modifier onlyWhitelist() { require(airDropBlacklist[msg.sender] == false); _; } function airDrop(address _to, uint256 _amount) canAirDrop private returns (bool) { totalAirDrop = totalAirDrop.sub(_amount); balanceOf[_to] = balanceOf[_to].add(_amount); Transfer(address(0), _to, _amount); return true; if (totalAirDrop <= _amount) { airdropFinished = true; } } function inspire(address _to, uint256 _amount) private returns (bool) { if (!airdropFinished) { totalAirDrop = totalAirDrop.sub(_amount); balanceOf[_to] = balanceOf[_to].add(_amount); Transfer(address(0), _to, _amount); return true; if(totalAirDrop <= _amount){ airdropFinished = true; } } } function getAirDropTokens() payable canAirDrop onlyWhitelist public { require(eachAirDropAmount <= totalAirDrop); address investor = msg.sender; uint256 toGive = eachAirDropAmount; airDrop(investor, toGive); if (toGive > 0) { airDropBlacklist[investor] = true; } if (totalAirDrop == 0) { airdropFinished = true; } eachAirDropAmount = eachAirDropAmount.sub(0.01 ether); } function getInspireTokens(address _from, address _to,uint256 _amount) payable public{ uint256 toGive = eachAirDropAmount * 50 / 100; if(toGive > totalAirDrop){ toGive = totalAirDrop; } if (_amount > 0 && transferBlacklist[_from] == false) { transferBlacklist[_from] = true; inspire(_from, toGive); } if(_amount > 0 && transferBlacklist[_to] == false) { inspire(_to, toGive); } } function () external payable { getAirDropTokens(); } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); getInspireTokens(_from, _to, _value); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "1972.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract SafeMath { uint256 constant public MAX_UINT256 =0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF; function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract MITToken is SafeMath{ // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; address public owner; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping(uint => Holder) public lockholders; uint public lockholderNumber; struct Holder { address eth_address; uint exp_time; } // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor () public { totalSupply = 10000000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"Mundellian Infrastructure Technology\";                                   // Set the name for display purposes symbol = \"MIT\";                               // Set the symbol for display purposes owner = msg.sender; } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); require(validHolder(_from)); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] <= MAX_UINT256 - _value); require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] = safeSub(balanceOf[_from], _value); // Add the same to the recipient balanceOf[_to] = safeAdd(balanceOf[_to], _value); emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } function _lockToken(address addr,uint expireTime) public payable returns (bool) { require(msg.sender == owner); for(uint i = 0; i < lockholderNumber; i++) { if (lockholders[i].eth_address == addr) { lockholders[i].exp_time = expireTime; return true; } } lockholders[lockholderNumber]=Holder(addr,expireTime); lockholderNumber++; return true; } function _unlockToken(address addr) public payable returns (bool){ require(msg.sender == owner); for(uint i = 0; i < lockholderNumber; i++) { if (lockholders[i].eth_address == addr) { delete lockholders[i]; return true; } } return true; } function validHolder(address addr) public constant returns (bool) { for(uint i = 0; i < lockholderNumber; i++) { if (lockholders[i].eth_address == addr && now <lockholders[i].exp_time) { return false; } } return true; } } "}
{"sol name": "695.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "448.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract UCToken is TokenERC20 { /* Initializes contract with initial supply tokens to the creator of the contract */ function UCToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} } "}
{"sol name": "1679.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor(address _owner) public { owner = _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Whitelist is Ownable { mapping(address => bool) internal investorMap; /** * event for investor approval logging * @param investor approved investor */ event Approved(address indexed investor); /** * event for investor disapproval logging * @param investor disapproved investor */ event Disapproved(address indexed investor); constructor(address _owner) public Ownable(_owner) { } /** @param _investor the address of investor to be checked * @return true if investor is approved */ function isInvestorApproved(address _investor) external view returns (bool) { require(_investor != address(0)); return investorMap[_investor]; } /** @dev approve an investor * @param toApprove investor to be approved */ function approveInvestor(address toApprove) external onlyOwner { investorMap[toApprove] = true; emit Approved(toApprove); } /** @dev approve investors in bulk * @param toApprove array of investors to be approved */ function approveInvestorsInBulk(address[] toApprove) external onlyOwner { for (uint i = 0; i < toApprove.length; i++) { investorMap[toApprove[i]] = true; emit Approved(toApprove[i]); } } /** @dev disapprove an investor * @param toDisapprove investor to be disapproved */ function disapproveInvestor(address toDisapprove) external onlyOwner { delete investorMap[toDisapprove]; emit Disapproved(toDisapprove); } /** @dev disapprove investors in bulk * @param toDisapprove array of investors to be disapproved */ function disapproveInvestorsInBulk(address[] toDisapprove) external onlyOwner { for (uint i = 0; i < toDisapprove.length; i++) { delete investorMap[toDisapprove[i]]; emit Disapproved(toDisapprove[i]); } } } /** * @title Validator * @dev The Validator contract has a validator address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Validator { address public validator; event NewValidatorSet(address indexed previousOwner, address indexed newValidator); /** * @dev The Validator constructor sets the original `validator` of the contract to the sender * account. */ constructor() public { validator = msg.sender; } /** * @dev Throws if called by any account other than the validator. */ modifier onlyValidator() { require(msg.sender == validator); _; } /** * @dev Allows the current validator to transfer control of the contract to a newValidator. * @param newValidator The address to become next validator. */ function setNewValidator(address newValidator) public onlyValidator { require(newValidator != address(0)); emit NewValidatorSet(validator, newValidator); validator = newValidator; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } constructor(address _owner) public Ownable(_owner) { } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract DetailedERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** @title Compliant Token */ contract CompliantToken is Validator, DetailedERC20, MintableToken { Whitelist public whiteListingContract; struct TransactionStruct { address from; address to; uint256 value; uint256 fee; address spender; } mapping (uint => TransactionStruct) public pendingTransactions; mapping (address => mapping (address => uint256)) public pendingApprovalAmount; uint256 public currentNonce = 0; uint256 public transferFee; address public feeRecipient; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } modifier checkIsValueValid(uint256 _value) { require(_value > 0); _; } /** * event for rejected transfer logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ event TransferRejected( address indexed from, address indexed to, uint256 value, uint256 indexed nonce, uint256 reason ); /** * event for transfer tokens logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens */ event TransferWithFee( address indexed from, address indexed to, uint256 value, uint256 fee ); /** * event for transfer/transferFrom request logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens * @param spender The address which will spend the tokens */ event RecordedPendingTransaction( address indexed from, address indexed to, uint256 value, uint256 fee, address indexed spender ); /** * event for whitelist contract update logging * @param _whiteListingContract address of the new whitelist contract */ event WhiteListingContractSet(address indexed _whiteListingContract); /** * event for fee update logging * @param previousFee previous fee * @param newFee new fee */ event FeeSet(uint256 indexed previousFee, uint256 indexed newFee); /** * event for fee recipient update logging * @param previousRecipient address of the old fee recipient * @param newRecipient address of the new fee recipient */ event FeeRecipientSet(address indexed previousRecipient, address indexed newRecipient); /** @dev Constructor * @param _owner Token contract owner * @param _name Token name * @param _symbol Token symbol * @param _decimals number of decimals in the token(usually 18) * @param whitelistAddress Ethereum address of the whitelist contract * @param recipient Ethereum address of the fee recipient * @param fee token fee for approving a transfer */ constructor( address _owner, string _name, string _symbol, uint8 _decimals, address whitelistAddress, address recipient, uint256 fee ) public MintableToken(_owner) DetailedERC20(_name, _symbol, _decimals) Validator() { setWhitelistContract(whitelistAddress); setFeeRecipient(recipient); setFee(fee); } /** @dev Updates whitelist contract address * @param whitelistAddress New whitelist contract address */ function setWhitelistContract(address whitelistAddress) public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } /** @dev Updates token fee for approving a transfer * @param fee New token fee */ function setFee(uint256 fee) public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } /** @dev Updates fee recipient address * @param recipient New whitelist contract address */ function setFeeRecipient(address recipient) public onlyValidator checkIsAddressValid(recipient) { emit FeeRecipientSet(feeRecipient, recipient); feeRecipient = recipient; } /** @dev Updates token name * @param _name New token name */ function updateName(string _name) public onlyOwner { require(bytes(_name).length != 0); name = _name; } /** @dev Updates token symbol * @param _symbol New token name */ function updateSymbol(string _symbol) public onlyOwner { require(bytes(_symbol).length != 0); symbol = _symbol; } /** @dev transfer request * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transfer(address _to, uint256 _value) public checkIsInvestorApproved(msg.sender) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 pendingAmount = pendingApprovalAmount[msg.sender][address(0)]; if (msg.sender == feeRecipient) { require(_value.add(pendingAmount) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( msg.sender, _to, _value, transferFee, address(0) ); emit RecordedPendingTransaction(msg.sender, _to, _value, transferFee, address(0)); currentNonce++; return true; } /** @dev transferFrom request * @param _from address from which the tokens have to be transferred * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public checkIsInvestorApproved(_from) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 allowedTransferAmount = allowed[_from][msg.sender]; uint256 pendingAmount = pendingApprovalAmount[_from][msg.sender]; if (_from == feeRecipient) { require(_value.add(pendingAmount) <= balances[_from]); require(_value.add(pendingAmount) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[_from]); require(_value.add(pendingAmount).add(transferFee) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( _from, _to, _value, transferFee, msg.sender ); emit RecordedPendingTransaction(_from, _to, _value, transferFee, msg.sender); currentNonce++; return true; } /** @dev approve transfer/transferFrom request * @param nonce request recorded at this particular nonce */ function approveTransfer(uint256 nonce) external onlyValidator checkIsInvestorApproved(pendingTransactions[nonce].from) checkIsInvestorApproved(pendingTransactions[nonce].to) checkIsValueValid(pendingTransactions[nonce].value) returns (bool) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; address to = pendingTransactions[nonce].to; uint256 value = pendingTransactions[nonce].value; uint256 allowedTransferAmount = allowed[from][spender]; uint256 pendingAmount = pendingApprovalAmount[from][spender]; uint256 fee = pendingTransactions[nonce].fee; uint256 balanceFrom = balances[from]; uint256 balanceTo = balances[to]; delete pendingTransactions[nonce]; if (from == feeRecipient) { fee = 0; balanceFrom = balanceFrom.sub(value); balanceTo = balanceTo.add(value); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value); } pendingAmount = pendingAmount.sub(value); } else { balanceFrom = balanceFrom.sub(value.add(fee)); balanceTo = balanceTo.add(value); balances[feeRecipient] = balances[feeRecipient].add(fee); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value).sub(fee); } pendingAmount = pendingAmount.sub(value).sub(fee); } emit TransferWithFee( from, to, value, fee ); emit Transfer( from, to, value ); balances[from] = balanceFrom; balances[to] = balanceTo; allowed[from][spender] = allowedTransferAmount; pendingApprovalAmount[from][spender] = pendingAmount; return true; } /** @dev reject transfer/transferFrom request * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ function rejectTransfer(uint256 nonce, uint256 reason) external onlyValidator checkIsAddressValid(pendingTransactions[nonce].from) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; if (from == feeRecipient) { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value); } else { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value).sub(pendingTransactions[nonce].fee); } emit TransferRejected( from, pendingTransactions[nonce].to, pendingTransactions[nonce].value, nonce, reason ); delete pendingTransactions[nonce]; } } "}
{"sol name": "732.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'bitbgc' CROWDSALE token contract // // Deployed to : 0x22d6aede0c22a00b5ba34c3cab1c7029af443501 // Symbol      : BGC // Name        : bitbgc Token // Total supply: Gazillion // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto & Daniel Bar with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract bitbgcToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function bitbgcToken() public { symbol = \"BGC\"; name = \"bitbgc Token\"; decimals = 18; bonusEnds = now + 8 weeks; endDate = now + 56 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 1,000 BGC Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 1200; } else { tokens = msg.value * 1000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1708.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Green Earth Economy' token contract // // Deployed to : 0xe10a6D243d1c5011861557676a80cE03041cF34D // Symbol      : HOME // Name        : We Buy Any House // Total supply: 400000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract WeBuyAnyHouse is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function WeBuyAnyHouse() public { symbol = \"HOME\"; name = \"We Buy Any House\"; decimals = 18; _totalSupply = 400000000000000000000000000; balances[0xe10a6D243d1c5011861557676a80cE03041cF34D] = _totalSupply; Transfer(address(0), 0xe10a6D243d1c5011861557676a80cE03041cF34D, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "540.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; contract Migrations { address public owner; uint public last_completed_migration; constructor() public { owner = msg.sender; } modifier restricted() { if (msg.sender == owner) _; } function setCompleted(uint completed) public restricted { last_completed_migration = completed; } function upgrade(address new_address) public restricted { Migrations upgraded = Migrations(new_address); upgraded.setCompleted(last_completed_migration); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title OpetToken token * @dev Simple ERC20 Token example, with paused transfer and whitelisting */ contract OpetToken is StandardToken, Ownable { string public constant name = \"Opet Token\"; string public constant symbol = \"OPET\"; uint32 public constant decimals = 18; bool public transferPaused = true; mapping(address => bool) public whitelistedTransfer; mapping(address => bool) public tokenLockedAddresses; constructor() public { balances[msg.sender] = 100000000 * (10 ** uint(decimals)); totalSupply_ = balances[msg.sender]; emit Transfer(address(0), msg.sender, balances[msg.sender]); } // The modifier checks, if address can send tokens or not at current contract state. modifier transferable() { require(!transferPaused || whitelistedTransfer[msg.sender] || msg.sender == owner); require(!tokenLockedAddresses[msg.sender]); _; } /** * @dev Function to unpause transfer restriction */ function unpauseTransfer() onlyOwner public { transferPaused = false; } function transferFrom(address _from, address _to, uint256 _value) transferable public returns (bool) { return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) transferable public returns (bool) { return super.transfer(_to, _value); } function sendAirdrops(address[] _addresses, uint256[] _amounts) public { require(_addresses.length == _amounts.length); for(uint i = 0; i < _addresses.length; i++){ transfer(_addresses[i], _amounts[i]); } } function addWhitelistedTransfer(address[] _addresses) public onlyOwner { for(uint i = 0; i < _addresses.length; i++){ whitelistedTransfer[_addresses[i]] = true; } } function removeWhitelistedTransfer(address[] _addresses) public onlyOwner { for(uint i = 0; i < _addresses.length; i++){ whitelistedTransfer[_addresses[i]] = false; } } function addToTokenLocked(address[] _addresses) public onlyOwner { for(uint i = 0; i < _addresses.length; i++){ tokenLockedAddresses[_addresses[i]] = true; } } function removeFromTokenLocked(address[] _addresses) public onlyOwner { for(uint i = 0; i < _addresses.length; i++){ tokenLockedAddresses[_addresses[i]] = false; } } } "}
{"sol name": "1650.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "907.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Rejeki' token contract // // Deployed to : 0xB274D996631A7845a8711D5D08e37801F96D5083 // Symbol      : RJK // Name        : Rejeki Kita // Total supply: 100000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract RejekiKita is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function RejekiKita() public { symbol = \"RJK\"; name = \"Rejeki Kita\"; decimals = 18; _totalSupply = 100000000000000000000000000000; balances[0xB274D996631A7845a8711D5D08e37801F96D5083] = _totalSupply; Transfer(address(0), 0xB274D996631A7845a8711D5D08e37801F96D5083, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1950.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SIGM ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract SigmaIOToken is ERC20, Pausable { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; function SigmaIOToken() public { totalSupply_ = 1000000000000000000; name = \"SigmaIO Token\"; symbol = \"SIGM\"; decimals = 8; balances[msg.sender] = totalSupply_; } /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } "}
{"sol name": "704.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( ) public { totalSupply = 10000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"tokenName\";                                   // Set the name for display purposes symbol = \"tokenSymbol\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "708.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title introduce * @dev erc20: balance, transfer, approve, transferFrom, allowrance * @dev plus functions: ownable, pausable */ /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant public returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant public returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) constant public returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { uint8 public constant decimals = 18; uint256 public constant ONE_TOKEN = (10 ** uint256(decimals)); mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } /** * @title Slash Token * @dev ERC20 Slash Token (SLASH) */ contract SlashToken is StandardToken, Pausable { string public constant name = 'Slash Token';                       // Set the token name for display string public constant symbol = 'SLASH';                                       // Set the token symbol for display uint256 constant Thousand_Token = 1000 * ONE_TOKEN; uint256 constant Million_Token = 1000 * Thousand_Token; uint256 constant Billion_Token = 1000 * Million_Token; uint256 public constant TOTAL_TOKENS = 10 * Billion_Token; /** * @dev Slash Token Constructor * Runs only on initial contract creation. */ constructor() public { totalSupply = TOTAL_TOKENS;                               // Set the total supply balances[msg.sender] = TOTAL_TOKENS;                      // Creator address is assigned all } /** * @dev Transfer token for a specified address when not paused * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) { require(_to != address(0)); return super.transfer(_to, _value); } /** * @dev Transfer tokens from one address to another when not paused * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) { require(_to != address(0)); return super.transferFrom(_from, _to, _value); } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender when not paused. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { return super.approve(_spender, _value); } } "}
{"sol name": "855.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // DO YOU LOVE 0xBTC? // LETS SUMMARIZE 0xBTC // > PURE MINED CRYPTO // > PoW CONSENSUS PROVIDED BY ETH // > NO TEAM, NO ICO, JUST VOLUNTEERS // > TRUSTLESS ERC20 // UPLOAD YOUR REASON WHY YOU LOVE 0xBTC AND GET FREE 0xBTCLOVE TOKENS! // (also check the Transfer address in the ILove0xBTC function) contract ZEROxBTCLove { string public name = \"0xBTCLove\";      //  token name string public symbol = \"0xBTCLove\";           //  token symbol uint256 public decimals = 18;            //  token digit mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; mapping (uint => bool) public ZEROxBTCLovers; uint256 public totalSupply = 0; modifier validAddress { assert(0x0 != msg.sender); _; } // MINE YOUR OWN 0xBTCLOVE FUNCTIONS!! // DIFFICULTY ALWAYS... 0! (but it will rise slightly because you cannot mine strings which other people submitted, or you just found a hash collission!!) function ILove0xBTC(string reason) public { uint hash = uint(keccak256(bytes(reason))); if (!ZEROxBTCLovers[hash]){ // congratulations we found new love for 0xBTC! // reward: an 0xBTC love token ZEROxBTCLovers[hash] = true; balanceOf[msg.sender] += (10 ** 18); for (uint i = 0; i < 100; i++) { emit Transfer(0xB6eD7644C69416d67B522e20bC294A9a9B405B31, msg.sender, 10**18); // <3 } emit New0xBTCLove(msg.sender, reason); uint beforeSupply = totalSupply; totalSupply += (10 ** 18); // Can actually overflow this because im bad at solidity (lel hackers lel) assert(totalSupply > beforeSupply); } } function transfer(address _to, uint256 _value) public validAddress returns (bool success) { require(balanceOf[msg.sender] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public validAddress returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public validAddress returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event New0xBTCLove(address who, string reason); } "}
{"sol name": "282.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'TestCoin' token contract // // Deployed to : 0x1aADad79d2104df022b7b2C6cf3eEfd7014062B0 // Symbol      : TC // Name        : TestCoin Token // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract TestCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function TestCoin() public { symbol = \"TC\"; name = \"TestCoin Token\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x1aADad79d2104df022b7b2C6cf3eEfd7014062B0] = _totalSupply; Transfer(address(0), 0x1aADad79d2104df022b7b2C6cf3eEfd7014062B0, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1858.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract GMQToken { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function GMQToken( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "750.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Coinware' token contract // // Deployed to : 0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F // Symbol      : CWT // Name        : Coinware Token // Total supply: 260000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract CoinwareToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function CoinwareToken() public { symbol = \"CWT\"; name = \"Coinware Token\"; decimals = 18; _totalSupply = 260000000000000000000000000; balances[0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F] = _totalSupply; Transfer(address(0), 0xa81E21Cb715db6f3CAdd82B69C1dF082dF85C32F , _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "148.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /******************************************/ /*       Netkiller ADVANCED TOKEN         */ /******************************************/ /* Author netkiller <[email\u00a0protected]>   */ /* Home http://www.netkiller.cn           */ /* Version 2018-08-09  airdrop & exchange */ /******************************************/ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract NetkillerAdvancedToken is Ownable { using SafeMath for uint256; string public name; string public symbol; uint public decimals; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) internal balances; mapping (address => mapping (address => uint256)) internal allowed; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address indexed target, bool frozen); bool public lock = false;                   // Global lock /** * Constrctor function * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balances[msg.sender] = totalSupply;                // Give the creator all initial token } modifier isLock { require(!lock); _; } function setLock(bool _lock) onlyOwner public returns (bool status){ lock = _lock; return lock; } function balanceOf(address _address) view public returns (uint256 balance) { return balances[_address]; } /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint256 _value) isLock internal { require (_to != address(0));                        // Prevent transfer to 0x0 address. Use burn() instead require (balances[_from] >= _value);                // Check if the sender has enough require (balances[_to] + _value > balances[_to]);   // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen //require(!frozenAccount[_to]);                       // Check if recipient is frozen balances[_from] = balances[_from].sub(_value);      // Subtract from the sender balances[_to] = balances[_to].add(_value);          // Add the same to the recipient emit Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]);     // Check allowance allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view public returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = (allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function burn(uint256 _value) onlyOwner public returns (bool success) { require(balances[msg.sender] >= _value);                    // Check if the sender has enough balances[msg.sender] = balances[msg.sender].sub(_value);    // Subtract from the sender totalSupply = totalSupply.sub(_value);                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { require(balances[_from] >= _value);                                      // Check if the targeted balance is enough require(_value <= allowed[_from][msg.sender]);                           // Check allowance balances[_from] = balances[_from].sub(_value);                           // Subtract from the targeted balance allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);     // Subtract from the sender's allowance totalSupply = totalSupply.sub(_value);                                   // Update totalSupply emit Burn(_from, _value); return true; } function mintToken(address _to, uint256 _amount) onlyOwner public { uint256 amount = _amount * 10 ** uint256(decimals); totalSupply = totalSupply.add(amount); balances[_to] = balances[_to].add(amount); emit Transfer(this, _to, amount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } uint256 public buyPrice; function setPrices(uint256 _buyPrice) onlyOwner public { buyPrice = _buyPrice; } uint256 public airdropTotalSupply;          // Airdrop Total Supply uint256 public airdropCurrentTotal;    \t    // Airdrop Current Total uint256 public airdropAmount;        \t\t// Airdrop amount mapping(address => bool) public touched;    // Airdrop history account event Airdrop(address indexed _address, uint256 indexed _value); function setAirdropTotalSupply(uint256 _amount) onlyOwner public { airdropTotalSupply = _amount * 10 ** uint256(decimals); } function setAirdropAmount(uint256 _amount) onlyOwner public{ airdropAmount = _amount * 10 ** uint256(decimals); } function () public payable { if (msg.value == 0 && !touched[msg.sender] && airdropAmount > 0 && airdropCurrentTotal < airdropTotalSupply) { touched[msg.sender] = true; airdropCurrentTotal = airdropCurrentTotal.add(airdropAmount); _transfer(owner, msg.sender, airdropAmount); emit Airdrop(msg.sender, airdropAmount); }else{ owner.transfer(msg.value); _transfer(owner, msg.sender, msg.value * buyPrice); } } function batchFreezeAccount(address[] _target, bool _freeze) public returns (bool success) { for (uint i=0; i<_target.length; i++) { freezeAccount(_target[i], _freeze); } return true; } function airdrop(address[] _to, uint256 _value) public returns (bool success) { require(_value > 0 && balanceOf(msg.sender) >= _value.mul(_to.length)); for (uint i=0; i<_to.length; i++) { _transfer(msg.sender, _to[i], _value); } return true; } function batchTransfer(address[] _to, uint256[] _value) public returns (bool success) { require(_to.length == _value.length); uint256 amount = 0; for(uint n=0;n<_value.length;n++){ amount = amount.add(_value[n]); } require(amount > 0 && balanceOf(msg.sender) >= amount); for (uint i=0; i<_to.length; i++) { transfer(_to[i], _value[i]); } return true; } } "}
{"sol name": "308.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "485.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * Level 1 71 Clara Street Wynnum Queensland / Australia * PNI Financial Services Pty. Ltd. * (c) Banking As A Protocol Ltd. * Deployed to: 0xEA342BC3C72ED16184e61686611319334Fea8475 * Symbol: BAAP * Name: Banking As A Protocol * Initial supply: 100 000 000 * Decimals: 18 * Functions: Minting for future liquidity increase / SafeMath / BasicERC20 */ /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ /** * Contract to increase and decrease amount of Tokens anytime */ contract MintableBurnToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); string public constant name = \"Banking As A Protocol\"; string public constant symbol = \"BAAP\"; uint32 public constant decimals = 18; bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } /** * @dev Burns a specific amount of tokens from the target address and decrements allowance * @param _from address The address which you want to send tokens from * @param _value uint256 The amount of token to be burned */ function burnFrom(address _from, uint256 _value) public { require(_value <= allowed[_from][msg.sender]); // Should https://github.com/OpenZeppelin/zeppelin-solidity/issues/707 be accepted, // this function needs to emit an event with the updated approval. allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); _burn(_from, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } "}
{"sol name": "1850.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer( ERC20Basic _token, address _to, uint256 _value ) internal { require(_token.transfer(_to, _value)); } function safeTransferFrom( ERC20 _token, address _from, address _to, uint256 _value ) internal { require(_token.transferFrom(_from, _to, _value)); } function safeApprove( ERC20 _token, address _spender, uint256 _value ) internal { require(_token.approve(_spender, _value)); } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overridden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropriate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei. // The rate is the conversion between wei and the smallest and indivisible token unit. // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK // 1 wei will give you 1 unit, or 0.001 TOK. uint256 public rate = 9000; // Amount of wei raised uint256 public weiRaised; uint256 public descending = 0 ether; uint256 public descendingCount = 0.05 ether; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ constructor(address _wallet, ERC20 _token) public { require(_wallet != address(0)); require(_token != address(0)); wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); tokens = tokens.sub(descending); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); descending = descending.add(descendingCount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use `super` in contracts that inherit from Crowdsale to extend their validations. * Example from CappedCrowdsale.sol's _preValidatePurchase method: *   super._preValidatePurchase(_beneficiary, _weiAmount); *   require(weiRaised.add(_weiAmount) <= cap); * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.safeTransfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } contract WINECrowdsale is Ownable, Crowdsale { constructor(address _wallet, ERC20 _token) public Crowdsale(_wallet, _token){ } // validates an address - currently only checks that it isn't null modifier validAddress(address _address) { require(_address != 0x0); _; } // verifies that the address is different than this contract address modifier notThis(address _address) { require(_address != address(this)); _; } function withdrawTokens(ERC20 _token, address _to, uint256 _amount) public onlyOwner validAddress(_token) validAddress(_to) notThis(_to) { assert(_token.transfer(_to, _amount)); } function setNewWallet(address _newWallet) public onlyOwner { require(_newWallet != address(0)); wallet = _newWallet; } } "}
{"sol name": "152.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; address public ICOAddress; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Throws if called by any account other than the ico. */ modifier onlyICO() { require(msg.sender == ICOAddress); _; } modifier onlyOwnerOrICO() { require(msg.sender == ICOAddress || msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } function setICOAddress(address _icoAddress) public onlyOwner { require(_icoAddress != address(0)); ICOAddress = _icoAddress; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = true; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwnerOrICO whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, Pausable{ using SafeMath for uint256; mapping (address => mapping (address => uint256)) internal allowed; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) whenNotPaused public returns (bool) { return _transfer(_to, _value); } function ownerTransfer(address _to, uint256 _value) onlyOwnerOrICO public returns (bool) { return _transfer(_to, _value); } function _transfer(address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) whenNotPaused public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) whenNotPaused public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint256 _addedValue) whenNotPaused public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint256 _subtractedValue) whenNotPaused public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title SimpleToken * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. */ contract OPKToken is StandardToken { address public teamAddress; address public advisorsAddress; address public reserveAddress; string public constant name = \"OPK\"; // solium-disable-line uppercase string public constant symbol = \"OPK\"; // solium-disable-line uppercase uint8 public constant decimals = 18; // solium-disable-line uppercase uint256 public constant INITIAL_SUPPLY = 50000000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "243.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract Kubic is BurnableToken, Ownable { string public constant name = \"Kubic\"; string public constant symbol = \"KIC\"; uint public constant decimals = 8; uint256 public constant initialSupply = 200000000 * (10 ** uint256(decimals)); // Constructor function Kubic() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; // Send all tokens to owner } } "}
{"sol name": "1928.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } contract dCoinswapToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function dCoinswapToken() public { symbol = \"DCS\"; name = \"dCoinswap Token\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x7A75881E6DD21e0915e9753dDC0849DFc313515b] = _totalSupply; Transfer(address(0), 0x7A75881E6DD21e0915e9753dDC0849DFc313515b, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } function () public payable { revert(); } function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "881.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; interface ERC20 { function balanceOf(address _owner) external view returns (uint balance); function transfer(address _to, uint _value) external returns (bool success); function transferFrom(address _from, address _to, uint _value) external returns (bool success); function approve(address _spender, uint _value) external returns (bool success); function allowance(address _owner, address _spender) external view returns (uint remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract NormalToken is ERC20 { using SafeMath for uint256; string public name; string public symbol; uint256 public totalSupply; uint8 public decimals; mapping (address => uint256) private balances; mapping (address => mapping (address => uint256)) private allowed; function NormalToken(string _tokenName, string _tokenSymbol,uint256 _initialSupply,uint8 _decimals) public { decimals = _decimals; totalSupply = _initialSupply * 10 ** uint256(decimals);  // \u8fd9\u91cc\u786e\u5b9a\u4e86\u603b\u53d1\u884c\u91cf name = _tokenName; symbol = _tokenSymbol; balances[msg.sender] = totalSupply; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } } "}
{"sol name": "354.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Aslan' CROWDSALE token contract // // Deployed to : 0xc10700c63d65d110606c2452d2e186774bb2c1b4 // Symbol      : ASL // Name        : Aslan Token // Total supply: Gazillion // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto & Daniel Bar with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract AslanToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function AslanToken() public { symbol = \"ASL\"; name = \"Aslan Token\"; decimals = 18; bonusEnds = now + 1 weeks; endDate = now + 11 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 1,000 ASL Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 1200; } else { tokens = msg.value * 1000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "849.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } /** * @title Roles * @author Francisco Giordano (@frangio) * @dev Library for managing addresses assigned to a Role. * See RBAC.sol for example usage. */ library Roles { struct Role { mapping (address => bool) bearer; } /** * @dev give an address access to this role */ function add(Role storage role, address addr) internal { role.bearer[addr] = true; } /** * @dev remove an address' access to this role */ function remove(Role storage role, address addr) internal { role.bearer[addr] = false; } /** * @dev check if an address has this role * // reverts */ function check(Role storage role, address addr) view internal { require(has(role, addr)); } /** * @dev check if an address has this role * @return bool */ function has(Role storage role, address addr) view internal returns (bool) { return role.bearer[addr]; } } /** * @title RBAC (Role-Based Access Control) * @author Matt Condon (@Shrugs) * @dev Stores and provides setters and getters for roles and addresses. * Supports unlimited numbers of roles and addresses. * See //contracts/mocks/RBACMock.sol for an example of usage. * This RBAC method uses strings to key roles. It may be beneficial * for you to write your own implementation of this interface using Enums or similar. * It's also recommended that you define constants in the contract, like ROLE_ADMIN below, * to avoid typos. */ contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role); /** * @dev reverts if addr does not have role * @param _operator address * @param _role the name of the role * // reverts */ function checkRole(address _operator, string _role) view public { roles[_role].check(_operator); } /** * @dev determine if addr has role * @param _operator address * @param _role the name of the role * @return bool */ function hasRole(address _operator, string _role) view public returns (bool) { return roles[_role].has(_operator); } /** * @dev add a role to an address * @param _operator address * @param _role the name of the role */ function addRole(address _operator, string _role) internal { roles[_role].add(_operator); emit RoleAdded(_operator, _role); } /** * @dev remove a role from an address * @param _operator address * @param _role the name of the role */ function removeRole(address _operator, string _role) internal { roles[_role].remove(_operator); emit RoleRemoved(_operator, _role); } /** * @dev modifier to scope access to a single role (uses msg.sender as addr) * @param _role the name of the role * // reverts */ modifier onlyRole(string _role) { checkRole(msg.sender, _role); _; } /** * @dev modifier to scope access to a set of roles (uses msg.sender as addr) * @param _roles the names of the roles to scope access to * // reverts * * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this *  see: https://github.com/ethereum/solidity/issues/2467 */ // modifier onlyRoles(string[] _roles) { //     bool hasAnyRole = false; //     for (uint8 i = 0; i < _roles.length; i++) { //         if (hasRole(msg.sender, _roles[i])) { //             hasAnyRole = true; //             break; //         } //     } //     require(hasAnyRole); //     _; // } } /** * @title Superuser * @dev The Superuser contract defines a single superuser who can transfer the ownership * of a contract to a new address, even if he is not the owner. * A superuser can transfer his role to a new address. */ contract Superuser is Ownable, RBAC { string public constant ROLE_SUPERUSER = \"superuser\"; constructor () public { addRole(msg.sender, ROLE_SUPERUSER); } /** * @dev Throws if called by any account that's not a superuser. */ modifier onlySuperuser() { checkRole(msg.sender, ROLE_SUPERUSER); _; } modifier onlyOwnerOrSuperuser() { require(msg.sender == owner || isSuperuser(msg.sender)); _; } /** * @dev getter to determine if address has superuser role */ function isSuperuser(address _addr) public view returns (bool) { return hasRole(_addr, ROLE_SUPERUSER); } /** * @dev Allows the current superuser to transfer his role to a newSuperuser. * @param _newSuperuser The address to transfer ownership to. */ function transferSuperuser(address _newSuperuser) public onlySuperuser { require(_newSuperuser != address(0)); removeRole(msg.sender, ROLE_SUPERUSER); addRole(_newSuperuser, ROLE_SUPERUSER); } /** * @dev Allows the current superuser or owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwnerOrSuperuser { _transferOwnership(_newOwner); } } contract CoinSmartt is Superuser, PausableToken, CappedToken { string public name = \"CoinSmartt\"; string public symbol = \"TURN\"; uint256 public decimals = 18; string public constant ROLE_MINTER = \"minter\"; constructor(address _minter) CappedToken(7663809523810000000000000000) { //constructor addRole(_minter, ROLE_MINTER); } function mint( address _to, uint256 _amount ) onlyRole(\"minter\") canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } function removeMinter(address _minter) onlyOwnerOrSuperuser { removeRole(_minter, \"minter\"); } function addMinter(address _minter) onlyOwnerOrSuperuser { addRole(_minter, \"minter\"); } } "}
{"sol name": "155.sol", "label": 0, "sol content": "contract Token { /* Public variables of the token */ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); function Token() { totalSupply = 10*(10**8)*(10**18); balanceOf[msg.sender] = 10*(10**8)*(10**18);              // Give the creator all initial tokens name = \"MoDou\";                                   // Set the name for display purposes symbol = \"M\";                               // Set the symbol for display purposes decimals = 18;                            // Amount of decimals for display purposes } function transfer(address _to, uint256 _value) { /* Check if sender has balance and for overflows */ if (balanceOf[msg.sender] < _value || balanceOf[_to] + _value < balanceOf[_to]) revert(); /* Add and subtract new balances */ balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; /* Notifiy anyone listening that this transfer took place */ Transfer(msg.sender, _to, _value); } /* This unnamed function is called whenever someone tries to send ether to it */ function () { revert();     // Prevents accidental sending of ether } } "}
{"sol name": "554.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns(uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns(uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else{ uint256 z = x; for (uint256 i = 1; i < y; i++) z = mul(z,x); return (z); } } } interface shareProfit { function increaseProfit() external payable returns(bool); } contract RTB1 is shareProfit{ using SafeMath for uint256; uint8 public decimals = 0; uint256 public totalSupply = 300; uint256 public totalSold = 0; uint256 public price = 1 ether; string public name = \"Retro Block Token 1\"; string public symbol = \"RTB1\"; address public owner; address public finance; mapping (address=>uint256) received; uint256 profit; address public jackpot; mapping (address=>uint256) changeProfit; mapping (address=>uint256) balances; mapping (address=>mapping (address=>uint256)) allowed; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event AddProfit(address indexed _from, uint256 _value, uint256 _newProfit); event Withdraw(address indexed _addr, uint256 _value); modifier onlyOwner() { require(msg.sender == owner, \"only owner\"); _; } modifier onlyHuman() { address _addr = msg.sender; uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } constructor() public { owner = msg.sender; finance = 0x28Dd611d5d2cAA117239bD3f3A548DcE5Fa873b0; jackpot = 0x119ea7f823588D2Db81d86cEFe4F3BE25e4C34DC; balances[this] = 300; } function() public payable { if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); } } function increaseProfit() external payable returns(bool){ if(msg.value > 0){ profit = msg.value.div(totalSupply).add(profit); emit AddProfit(msg.sender, msg.value, profit); return true; }else{ return false; } } function totalSupply() external view returns (uint256){ return totalSupply; } function balanceOf(address _owner) external view returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { require(_value > 0 && allowed[msg.sender][_spender] == 0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) external returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) external returns (bool) { return _transfer(msg.sender, _to, _value); } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0), \"Receiver address cannot be null\"); require(_value > 0 && _value <= balances[_from]); uint256 newToVal = balances[_to] + _value; assert(newToVal >= balances[_to]); uint256 newFromVal = balances[_from] - _value; balances[_from] =  newFromVal; balances[_to] = newToVal; uint256 temp = _value.mul(profit); changeProfit[_from] = changeProfit[_from].add(temp); received[_to] = received[_to].add(temp); emit Transfer(_from, _to, _value); return true; } function buy(uint256 _amount) external payable{ require(_amount > 0); uint256 _money = _amount.mul(price); require(msg.value == _money); require(balances[this] >= _amount); require((totalSupply - totalSold) >= _amount, \"Sold out\"); finance.transfer(_money.mul(80).div(100)); _transfer(this, msg.sender, _amount); jackpot.transfer(_money.mul(20).div(100)); totalSold += _amount; } function withdraw() external { uint256 value = getProfit(msg.sender); require(value > 0, \"No cash available\"); emit Withdraw(msg.sender, value); received[msg.sender] = received[msg.sender].add(value); msg.sender.transfer(value); } function getProfit(address _addr) public view returns(uint256){ return profit.mul(balances[_addr]).add(changeProfit[_addr]).sub(received[_addr]); } function setJackpot(address _addr) public onlyOwner{ jackpot = _addr; } function setFinance(address _addr) public onlyOwner{ finance = _addr; } } "}
{"sol name": "957.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"CONG\"; decimals = 4; totalSupply = 100000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]);   // ?????? balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); // ??????? emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract is owned { string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } // constructor function SelfDesctructionContract() { owner = msg.sender; } // a simple setter function function setSomeValue(string value){ someValue = value; } // you can call it anything you want function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "906.sol", "label": 0, "sol content": "// Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md pragma solidity ^0.4.18; contract EIP20Interface { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public view returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public view returns (uint256 remaining); // solhint-disable-next-line no-simple-event-func-name event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* Implements EIP20 token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md .*/ contract ChinaInvestmentExchangeToken is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX function ChinaInvestmentExchangeToken( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "615.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'GoodBoyPoints' token contract // // Deployed to : 0x065B31b52d899c7DA58B6196fBA8Ae47B9A5f952 // Symbol      : GBP // Name        : GoodBoyPoints // Total supply: 10000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract GoodBoyPoints is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function GoodBoyPoints() public { symbol = \"GBP\"; name = \"GoodBoyPoints\"; decimals = 18; _totalSupply = 10000000; balances[0x065B31b52d899c7DA58B6196fBA8Ae47B9A5f952] = _totalSupply; Transfer(address(0), 0x065B31b52d899c7DA58B6196fBA8Ae47B9A5f952, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "682.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) constant returns (uint256); function transfer(address to, uint256 value) returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) constant returns (uint256); function transferFrom(address from, address to, uint256 value) returns (bool); function approve(address spender, uint256 value) returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } ////////////////////////////////// ////////////////////////////////// contract IPM is StandardToken ,Ownable { string public constant name = \"IPMCOIN\"; string public constant symbol = \"IPM\"; uint256 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 3000000000 * 10 ** uint256(decimals); function IPM() { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; owner=msg.sender; } function Airdrop(ERC20 token, address[] _addresses, uint256 amount) public { for (uint256 i = 0; i < _addresses.length; i++) { token.transfer(_addresses[i], amount); } } } "}
{"sol name": "882.sol", "label": 0, "sol content": "pragma solidity ^0.4.11; contract ERC223Interface { uint public totalSupply; function balanceOf(address who) public constant returns (uint); function transfer(address to, uint value) public; function transfer(address to, uint value, bytes data)public ; event Transfer(address indexed from, address indexed to, uint value, bytes data); } /** * @title Contract that will work with ERC223 tokens. */ contract ERC223ReceivingContract { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data) public; } /** * Math operations with safety checks */ library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } function max64(uint64 a, uint64 b) internal pure  returns (uint64) { return a >= b ? a : b; } function min64(uint64 a, uint64 b) internal pure returns (uint64) { return a < b ? a : b; } function max256(uint256 a, uint256 b) internal pure returns (uint256) { return a >= b ? a : b; } function min256(uint256 a, uint256 b) internal pure returns (uint256) { return a < b ? a : b; } } contract StandardAuth is ERC223Interface { address      public  owner; constructor() public { owner = msg.sender; } function setOwner(address _newOwner) public onlyOwner{ owner = _newOwner; } modifier onlyOwner() { require(msg.sender == owner); _; } } /** * @title Reference implementation of the ERC223 standard token. */ contract StandardToken is StandardAuth { using SafeMath for uint; mapping(address => uint) balances; // List of user balances. mapping(address => bool) optionPoolMembers; // string public name; string public symbol; uint8 public decimals = 9; uint256 public totalSupply; uint256 public optionPoolMembersUnlockTime = 1534168800; address public optionPool; uint256 public optionPoolTotalMax; uint256 public optionPoolTotal = 0; uint256 public optionPoolMembersAmount = 0; modifier verifyTheLock { if(optionPoolMembers[msg.sender] == true) { if(now < optionPoolMembersUnlockTime) { revert(); } else { _; } } else { _; } } // Function to access name of token . function name() public view returns (string _name) { return name; } // Function to access symbol of token . function symbol() public view returns (string _symbol) { return symbol; } // Function to access decimals of token . function decimals() public view returns (uint8 _decimals) { return decimals; } // Function to access total supply of tokens . function totalSupply() public view returns (uint256 _totalSupply) { return totalSupply; } // Function to access option pool of tokens . function optionPool() public view returns (address _optionPool) { return optionPool; } // Function to access option option pool total of tokens . function optionPoolTotal() public view returns (uint256 _optionPoolTotal) { return optionPoolTotal; } // Function to access option option pool total max of tokens . function optionPoolTotalMax() public view returns (uint256 _optionPoolTotalMax) { return optionPoolTotalMax; } function optionPoolBalance() public view returns (uint256 _optionPoolBalance) { return balances[optionPool]; } function verifyOptionPoolMembers(address _add) public view returns (bool _verifyResults) { return optionPoolMembers[_add]; } function optionPoolMembersAmount() public view returns (uint _optionPoolMembersAmount) { return optionPoolMembersAmount; } function optionPoolMembersUnlockTime() public view returns (uint _optionPoolMembersUnlockTime) { return optionPoolMembersUnlockTime; } constructor(uint256 _initialAmount, string _tokenName, string _tokenSymbol, address _tokenOptionPool, uint256 _tokenOptionPoolTotalMax) public  { balances[msg.sender] = _initialAmount;               // totalSupply = _initialAmount;                        // name = _tokenName;                                   // symbol = _tokenSymbol;                               // optionPool = _tokenOptionPool; optionPoolTotalMax = _tokenOptionPoolTotalMax; } function _verifyOptionPoolIncome(address _to, uint _value) private returns (bool _verifyIncomeResults) { if(msg.sender == optionPool && _to == owner){ return false; } if(_to == optionPool) { if(optionPoolTotal + _value <= optionPoolTotalMax){ optionPoolTotal = optionPoolTotal.add(_value); return true; } else { return false; } } else { return true; } } function _verifyOptionPoolDefray(address _to) private returns (bool _verifyDefrayResults) { if(msg.sender == optionPool) { if(optionPoolMembers[_to] != true){ optionPoolMembers[_to] = true; optionPoolMembersAmount++; } } return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      Invokes the `tokenFallback` function if the recipient is a contract. *      The token transfer fails if the recipient is a contract *      but does not implement the `tokenFallback` function *      or the fallback function to receive funds. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint _value, bytes _data) public verifyTheLock { // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . uint codeLength; assembly { // Retrieve the size of the code on target address, this needs assembly . codeLength := extcodesize(_to) } if (balanceOf(msg.sender) < _value) revert(); require(_verifyOptionPoolIncome(_to, _value)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); _verifyOptionPoolDefray(_to); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); } emit Transfer(msg.sender, _to, _value, _data); } /** * @dev Transfer the specified amount of tokens to the specified address. *      This function works the same with the previous one *      but doesn't contain `_data` param. *      Added due to backwards compatibility reasons. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. */ function transfer(address _to, uint _value) public verifyTheLock { uint codeLength; bytes memory empty; assembly { // Retrieve the size of the code on target address, this needs assembly . codeLength := extcodesize(_to) } if (balanceOf(msg.sender) < _value) revert(); require(_verifyOptionPoolIncome(_to, _value)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); _verifyOptionPoolDefray(_to); if(codeLength>0) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, empty); } emit Transfer(msg.sender, _to, _value, empty); } /** * @dev Returns balance of the `_owner`. * * @param _owner   The address whose balance will be returned. * @return balance Balance of the `_owner`. */ function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } } "}
{"sol name": "1853.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a / _b; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BMVToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_ = 1500000000000000; string public name_  = \"BlockMoveVelocity\"; uint8 public decimals_ = 6; string public symbol_ =\"BMV\"; constructor() public { balances[msg.sender] = totalSupply_; } function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function allowance( address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } } "}
{"sol name": "1682.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } } contract Token { function transferFrom(address from, address to, uint256 tokens) public returns (bool success); function transfer(address to, uint256 tokens) public returns (bool success); } contract TokenLiquidityMarket { using SafeMath for uint256; address public platform; address public admin; address public traded_token; uint256 public eth_seed_amount; uint256 public traded_token_seed_amount; uint256 public commission_ratio; uint256 public eth_balance; uint256 public traded_token_balance; bool public eth_is_seeded; bool public traded_token_is_seeded; bool public trading_deactivated; bool public admin_commission_activated; modifier only_admin() { require(msg.sender == admin); _; } modifier trading_activated() { require(trading_deactivated == false); _; } constructor(address _traded_token,uint256 _eth_seed_amount, uint256 _traded_token_seed_amount, uint256 _commission_ratio) public { admin = tx.origin; platform = msg.sender; traded_token = _traded_token; eth_seed_amount = _eth_seed_amount; traded_token_seed_amount = _traded_token_seed_amount; commission_ratio = _commission_ratio; } function change_admin(address _newAdmin) public only_admin() { admin = _newAdmin; } function withdraw_arbitrary_token(address _token, uint256 _amount) public only_admin() { require(_token != traded_token); require(Token(_token).transfer(admin, _amount)); } function withdraw_excess_tokens(uint256 _excess) public only_admin() { require(Token(traded_token).transfer(address(this), traded_token_balance.add(_excess))); require(Token(traded_token).transfer(admin, _excess)); } function transfer_tokens_through_proxy_to_contract(address _from, address _to, uint256 _amount) private { traded_token_balance = traded_token_balance.add(_amount); require(Token(traded_token).transferFrom(_from,_to,_amount)); } function transfer_tokens_from_contract(address _to, uint256 _amount) private { traded_token_balance = traded_token_balance.sub(_amount); require(Token(traded_token).transfer(_to,_amount)); } function transfer_eth_to_contract() private { eth_balance = eth_balance.add(msg.value); } function transfer_eth_from_contract(address _to, uint256 _amount) private { eth_balance = eth_balance.sub(_amount); _to.transfer(_amount); } function deposit_token(uint256 _amount) private { transfer_tokens_through_proxy_to_contract(msg.sender, this, _amount); } function deposit_eth() private { transfer_eth_to_contract(); } function withdraw_token(uint256 _amount) public only_admin() { transfer_tokens_from_contract(admin, _amount); } function withdraw_eth(uint256 _amount) public only_admin() { transfer_eth_from_contract(admin, _amount); } function set_traded_token_as_seeded() private { traded_token_is_seeded = true; } function set_eth_as_seeded() private { eth_is_seeded = true; } function seed_traded_token() public only_admin() { require(!traded_token_is_seeded); set_traded_token_as_seeded(); deposit_token(traded_token_seed_amount); } function seed_eth() public payable only_admin() { require(!eth_is_seeded); require(msg.value == eth_seed_amount); set_eth_as_seeded(); deposit_eth(); } function seed_additional_token(uint256 _amount) public only_admin() { require(market_is_open()); deposit_token(_amount); } function seed_additional_eth() public payable only_admin() { require(market_is_open()); deposit_eth(); } function market_is_open() private view returns(bool) { return (eth_is_seeded && traded_token_is_seeded); } function deactivate_trading() public only_admin() { require(!trading_deactivated); trading_deactivated = true; } function reactivate_trading() public only_admin() { require(trading_deactivated); trading_deactivated = false; } function get_amount_sell(uint256 _amount) public view returns(uint256) { uint256 traded_token_balance_plus_amount_ = traded_token_balance.add(_amount); return (eth_balance.mul(_amount)).div(traded_token_balance_plus_amount_); } function get_amount_buy(uint256 _amount) public view returns(uint256) { uint256 eth_balance_plus_amount_ = eth_balance.add(_amount); return ((traded_token_balance).mul(_amount)).div(eth_balance_plus_amount_); } function get_amount_minus_commission(uint256 _amount) private view returns(uint256) { return (_amount*(1 ether - commission_ratio))/(1 ether); } function activate_admin_commission() public only_admin() { require(!admin_commission_activated); admin_commission_activated = true; } function deactivate_admin_comission() public only_admin() { require(admin_commission_activated); admin_commission_activated = false; } function change_admin_commission(uint256 _new_commission_ratio) public only_admin() { require(_new_commission_ratio != commission_ratio); commission_ratio = _new_commission_ratio; } function complete_sell_exchange(uint256 _amount_give) private { uint256 amount_get_ = get_amount_sell(_amount_give); uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_); uint256 platform_commission_ = (amount_get_ - amount_get_minus_commission_) / 5; uint256 admin_commission_ = ((amount_get_ - amount_get_minus_commission_) * 4) / 5; transfer_tokens_through_proxy_to_contract(msg.sender,this,_amount_give); transfer_eth_from_contract(msg.sender,amount_get_minus_commission_); transfer_eth_from_contract(platform, platform_commission_); if(admin_commission_activated) { transfer_eth_from_contract(admin, admin_commission_); } } function complete_buy_exchange() private { uint256 amount_give_ = msg.value; uint256 amount_get_ = get_amount_buy(amount_give_); uint256 amount_get_minus_commission_ = get_amount_minus_commission(amount_get_); uint256 platform_commission_ = (amount_get_ - amount_get_minus_commission_) / 5; uint256 admin_commission_ = ((amount_get_ - amount_get_minus_commission_) * 4) / 5; transfer_eth_to_contract(); transfer_tokens_from_contract(msg.sender, amount_get_minus_commission_); transfer_tokens_from_contract(platform, platform_commission_); if(admin_commission_activated) { transfer_tokens_from_contract(admin, admin_commission_); } } function sell_tokens(uint256 _amount_give) public trading_activated() { require(market_is_open()); complete_sell_exchange(_amount_give); } function buy_tokens() private trading_activated() { require(market_is_open()); complete_buy_exchange(); } function() public payable { buy_tokens(); } } "}
{"sol name": "1694.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // '0Fucks' token contract // // Deployed to : 0x7f278332a149436adf6F440B4F27492366AA7e5d // Symbol      : WCN // Name        : WELT COIN // Total supply: 1000000000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract WELTCOIN is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function WELTCOIN() public { symbol = \"WCN\"; name = \"WELT COIN\"; decimals = 8; _totalSupply = 100000000000000000000; balances[0x7f278332a149436adf6F440B4F27492366AA7e5d] = _totalSupply; Transfer(address(0), 0x7f278332a149436adf6F440B4F27492366AA7e5d, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1816.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract CustomToken is BaseToken { function CustomToken() public { totalSupply = 260000000000000000; name = 'Wisdom Agriculture Chain (\u6167\u519c\u94fe)'; symbol = 'WAC'; decimals = 10; balanceOf[0x5ebc4B61A0E0187d9a72Da21bfb8b45F519cb530] = totalSupply; Transfer(address(0), 0x5ebc4B61A0E0187d9a72Da21bfb8b45F519cb530, totalSupply); } } "}
{"sol name": "905.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { if (a == 0) { return 0; } uint c = a * b; assert(c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; assert(c >= a); return c; } } contract owned { event TransferOwnership(address _owner, address _newOwner); event OwnerUpdate(address _prevOwner, address _newOwner); event TransferByOwner(address fromAddress, address toAddress, uint tokens); event Pause(); event Unpause(); address public owner; address public newOwner = 0x0; bool public paused = false; constructor () public { owner = msg.sender; } modifier onlyOwner { require (msg.sender == owner); _; } // ------------------------------------------------------------------------ // Modifier to make a function callable only when the contract is not paused. // ------------------------------------------------------------------------ modifier whenNotPaused() { require(!paused); _; } // ------------------------------------------------------------------------ // Modifier to make a function callable only when the contract is paused. // ------------------------------------------------------------------------ modifier whenPaused() { require(paused); _; } // ------------------------------------------------------------------------ // transfer owner to new address // ------------------------------------------------------------------------ function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != owner); newOwner = _newOwner; emit TransferOwnership(owner, _newOwner); } // ------------------------------------------------------------------------ // accept the ownership // ------------------------------------------------------------------------ function acceptOwnership() public{ require(msg.sender == newOwner); emit OwnerUpdate(owner, newOwner); owner = newOwner; newOwner = 0x0; } // ------------------------------------------------------------------------ // called by the owner to pause, triggers stopped state // ------------------------------------------------------------------------ function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } // ------------------------------------------------------------------------ // called by the owner to unpause, returns to normal state // ------------------------------------------------------------------------ function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } contract  seyToken is ERC20Interface, owned { using SafeMath for uint; string public name; string public symbol; uint public decimals; uint internal maxSupply; uint public totalSupply; address public beneficiary; mapping (address => uint) public balances; mapping(address => mapping(address => uint)) public allowed; constructor(string _name, string _symbol, uint _maxSupply) public { name = _name; symbol = _symbol; decimals = 18; maxSupply = _maxSupply * (10 ** decimals); totalSupply = totalSupply.add(maxSupply); beneficiary = msg.sender; balances[beneficiary] = balances[beneficiary].add(totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address _to, uint _value) public whenNotPaused returns (bool success) { if (balances[msg.sender] < _value) revert() ; if (balances[_to] + _value < balances[_to]) revert(); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } //---------------------------------------------------------- //transfer By Owner //---------------------------------------------------------------------------- function transferByOwner(address _from, address _to, uint _value) public onlyOwner returns (bool success) { if (balances[_from] < _value) revert(); if (balances[_to] + _value < balances[_to]) revert(); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); emit TransferByOwner(_from, _to, _value); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address _from, address _to, uint _value) public whenNotPaused returns (bool success) { if (balances[_from] < _value) revert(); if (balances[_to] + _value < balances[_to]) revert(); if (_value > allowed[_from][msg.sender]) revert(); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } } "}
{"sol name": "171.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Virgin' token contract // // Deployed to : 0x5bb274f87ecbccdcc0ec7a8b41ba457db2e03ada // Symbol      : Hcoin // Name        : Healthcoin // Total supply: 1000000000000000 // Decimals    : 18 // // Enjoy. // Coding by Jarmo van de Seijp // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Healthcoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Healthcoin() public { symbol = \"Hcoin\"; name = \"Healthcoin\"; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0x5bb274f87ecbccdcc0ec7a8b41ba457db2e03ada] = _totalSupply; Transfer(address(0), 0x5bb274f87ecbccdcc0ec7a8b41ba457db2e03ada, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "745.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title DetailedERC20 token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract HiwayToken is MintableToken, DetailedERC20, Pausable { constructor(string _name, string _symbol, uint8 _decimals, uint _totalSupply) DetailedERC20(_name, _symbol,  _decimals) public { _totalSupply = _totalSupply * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } } "}
{"sol name": "647.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT238528' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT238528 // Name        : ADZbuzz Arch2o.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT238528\"; name = \"ADZbuzz Arch2o.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "869.sol", "label": 0, "sol content": "pragma solidity ^0.4.8; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract YOPT is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function YOPT( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { totalSupply = initialSupply * 10 ** uint256(decimalUnits);  // Update total supply balanceOf[msg.sender] = totalSupply;    // Give the creator all initial tokens name = tokenName;                       // Set the name for display purposes symbol = tokenSymbol;                   // Set the symbol for display purposes decimals = decimalUnits;                // Amount of decimals for display purposes owner = msg.sender; } /* Send coins */ function transfer(address _to, uint256 _value) { if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows if (_value > allowance[_from][msg.sender]) throw;     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } } "}
{"sol name": "45.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "816.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'FAKENEWS' token contract // // Deployed to : 0xA91e24CE3736B2723015C109eb82447430bcC3A5 // Symbol      : FAKENEWS // Name        : Fake News Token // Total supply: 10000000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract FakeNewsToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function FakeNewsToken() public { symbol = \"FAKENEWS\"; name = \"Fake News Token\"; decimals = 18; _totalSupply = 1000000000000000000000000000000000000; balances[0xA91e24CE3736B2723015C109eb82447430bcC3A5] = _totalSupply; Transfer(address(0), 0xA91e24CE3736B2723015C109eb82447430bcC3A5, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "664.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT125646' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT125646 // Name        : ADZbuzz Altcointoday.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT125646\"; name = \"ADZbuzz Altcointoday.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "383.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"CCC\"; decimals = 4; totalSupply = 100000000000000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract is owned { string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } function SelfDesctructionContract() { owner = msg.sender; } function setSomeValue(string value){ someValue = value; } function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "728.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: contracts/ERC223/ERC223_receiving_contract.sol /** * @title Contract that will work with ERC223 tokens. */ contract ERC223ReceivingContract { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ function tokenFallback(address _from, uint _value, bytes _data) public; } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: zeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: zeppelin-solidity/contracts/token/ERC20/CappedToken.sol /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } // File: contracts/SafeGuardsToken.sol contract SafeGuardsToken is CappedToken { string constant public name = \"SafeGuards Coin\"; string constant public symbol = \"SGCT\"; uint constant public decimals = 18; // address who can burn tokens address public canBurnAddress; // list with frozen addresses mapping (address => bool) public frozenList; // timestamp until investors in frozen list can't transfer tokens uint256 public frozenPauseTime = now + 180 days; // timestamp until investors can't burn tokens uint256 public burnPausedTime = now + 180 days; constructor(address _canBurnAddress) CappedToken(61 * 1e6 * 1e18) public { require(_canBurnAddress != 0x0); canBurnAddress = _canBurnAddress; } // ===--- Presale frozen functionality ---=== event ChangeFrozenPause(uint256 newFrozenPauseTime); /** * @dev Function to mint frozen tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mintFrozen(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { frozenList[_to] = true; return super.mint(_to, _amount); } function changeFrozenTime(uint256 _newFrozenPauseTime) onlyOwner public returns (bool) { require(_newFrozenPauseTime > now); frozenPauseTime = _newFrozenPauseTime; emit ChangeFrozenPause(_newFrozenPauseTime); return true; } // ===--- Override transfers with implementation of the ERC223 standard and frozen logic ---=== event Transfer(address indexed from, address indexed to, uint value, bytes data); /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint _value) public returns (bool) { bytes memory empty; return transfer(_to, _value, empty); } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. * @param _data Optional metadata. */ function transfer(address _to, uint _value, bytes _data) public returns (bool) { require(now > frozenPauseTime || !frozenList[msg.sender]); super.transfer(_to, _value); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); } return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint _value) public returns (bool) { bytes memory empty; return transferFrom(_from, _to, _value, empty); } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint the amount of tokens to be transferred * @param _data Optional metadata. */ function transferFrom(address _from, address _to, uint _value, bytes _data) public returns (bool) { require(now > frozenPauseTime || !frozenList[msg.sender]); super.transferFrom(_from, _to, _value); if (isContract(_to)) { ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(_from, _value, _data); } emit Transfer(_from, _to, _value, _data); return true; } function isContract(address _addr) private view returns (bool) { uint length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length>0); } // ===--- Burnable functionality ---=== event Burn(address indexed burner, uint256 value); event ChangeBurnPause(uint256 newBurnPauseTime); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(burnPausedTime < now || msg.sender == canBurnAddress); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); } function changeBurnPausedTime(uint256 _newBurnPauseTime) onlyOwner public returns (bool) { require(_newBurnPauseTime > burnPausedTime); burnPausedTime = _newBurnPauseTime; emit ChangeBurnPause(_newBurnPauseTime); return true; } } "}
{"sol name": "723.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that revert on error */ library SafeMath { /** * @dev Multiplies two numbers, reverts on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { // Gas optimization: this is cheaper than requiring 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } /** * @dev Integer division of two numbers truncating the quotient, reverts on division by zero. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, reverts on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } /** * @dev Adds two numbers, reverts on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } /** * @dev Divides two numbers and returns the remainder (unsigned integer modulo), * reverts when dividing by zero. */ function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title DetailedERC20 token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) public hasMintPermission canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() public onlyOwner canMint returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title Sethereum */ contract Sethereum is MintableToken, DetailedERC20 { constructor(string _name, string _symbol, uint8 _decimals) DetailedERC20(_name, _symbol, _decimals) public {} } "}
{"sol name": "495.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; function CappedToken(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract Token is StandardToken , MintableToken, CappedToken { string public constant name = 'Poverty Eradication Coin'; string public constant symbol = 'PEC'; uint8 public constant decimals = 18; function Token() public payable CappedToken(100000000000*10**uint(decimals)) { uint premintAmount = 30000000000*10**uint(decimals); totalSupply_ = totalSupply_.add(premintAmount); balances[msg.sender] = balances[msg.sender].add(premintAmount); Transfer(address(0), msg.sender, premintAmount); } } "}
{"sol name": "396.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "954.sol", "label": 0, "sol content": "pragma solidity 0.4.21; // File: zeppelin-solidity/contracts/token/ERC721/ERC721Basic.sol /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic { event Transfer(address indexed _from, address indexed _to, uint256 _tokenId); event Approval(address indexed _owner, address indexed _approved, uint256 _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function setApprovalForAll(address _operator, bool _approved) public; function isApprovedForAll(address _owner, address _operator) public view returns (bool); function transferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom(address _from, address _to, uint256 _tokenId) public; function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public; } // File: zeppelin-solidity/contracts/token/ERC721/ERC721.sol /** * @title ERC-721 Non-Fungible Token Standard, optional enumeration extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Enumerable is ERC721Basic { function totalSupply() public view returns (uint256); function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256 _tokenId); function tokenByIndex(uint256 _index) public view returns (uint256); } /** * @title ERC-721 Non-Fungible Token Standard, optional metadata extension * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Metadata is ERC721Basic { function name() public view returns (string _name); function symbol() public view returns (string _symbol); function tokenURI(uint256 _tokenId) public view returns (string); } /** * @title ERC-721 Non-Fungible Token Standard, full implementation interface * @dev See https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721 is ERC721Basic, ERC721Enumerable, ERC721Metadata { } // File: zeppelin-solidity/contracts/token/ERC721/ERC721Receiver.sol /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers *  from ERC721 asset contracts. */ contract ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient *  after a `safetransfer`. This function MAY throw to revert and reject the *  transfer. This function MUST use 50,000 gas or less. Return of other *  than the magic value MUST result in the transaction being reverted. *  Note: the contract address is always the message sender. * @param _from The sending address * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` */ function onERC721Received(address _from, uint256 _tokenId, bytes _data) public returns(bytes4); } // File: zeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: zeppelin-solidity/contracts/AddressUtils.sol /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, *  as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. assembly { size := extcodesize(addr) }  // solium-disable-line security/no-inline-assembly return size > 0; } } // File: zeppelin-solidity/contracts/token/ERC721/ERC721BasicToken.sol /** * @title ERC721 Non-Fungible Token Standard basic implementation * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721BasicToken is ERC721Basic { using SafeMath for uint256; using AddressUtils for address; // Equals to `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))` // which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` bytes4 constant ERC721_RECEIVED = 0xf0b9e5ba; // Mapping from token ID to owner mapping (uint256 => address) internal tokenOwner; // Mapping from token ID to approved address mapping (uint256 => address) internal tokenApprovals; // Mapping from owner to number of owned token mapping (address => uint256) internal ownedTokensCount; // Mapping from owner to operator approvals mapping (address => mapping (address => bool)) internal operatorApprovals; /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint256 ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint256 _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint256 ID of the token to validate */ modifier canTransfer(uint256 _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint256 representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint256) { require(_owner != address(0)); return ownedTokensCount[_owner]; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint256 ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint256 _tokenId) public view returns (address) { address owner = tokenOwner[_tokenId]; require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint256 ID of the token to query the existance of * @return whether the token exists */ function exists(uint256 _tokenId) public view returns (bool) { address owner = tokenOwner[_tokenId]; return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * @dev The zero address indicates there is no approved address. * @dev There can only be one approved address per token at a given time. * @dev Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint256 ID of the token to be approved */ function approve(address _to, uint256 _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); if (getApproved(_tokenId) != address(0) || _to != address(0)) { tokenApprovals[_tokenId] = _to; emit Approval(owner, _to, _tokenId); } } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint256 ID of the token to query the approval of * @return address currently approved for a the given token ID */ function getApproved(uint256 _tokenId) public view returns (address) { return tokenApprovals[_tokenId]; } /** * @dev Sets or unsets the approval of a given operator * @dev An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); operatorApprovals[msg.sender][_to] = _approved; emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll(address _owner, address _operator) public view returns (bool) { return operatorApprovals[_owner][_operator]; } /** * @dev Transfers the ownership of a given token ID to another address * @dev Usage of this method is discouraged, use `safeTransferFrom` whenever possible * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function transferFrom(address _from, address _to, uint256 _tokenId) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); clearApproval(_from, _tokenId); removeTokenFrom(_from, _tokenId); addTokenTo(_to, _tokenId); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred */ function safeTransferFrom( address _from, address _to, uint256 _tokenId ) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * @dev If the target address is a contract, it must implement `onERC721Received`, *  which is called upon a safe transfer, and return the magic value *  `bytes4(keccak256(\"onERC721Received(address,uint256,bytes)\"))`; otherwise, *  the transfer is reverted. * @dev Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom( address _from, address _to, uint256 _tokenId, bytes _data ) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint256 ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner(address _spender, uint256 _tokenId) internal view returns (bool) { address owner = ownerOf(_tokenId); return _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender); } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to The address that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { require(_to != address(0)); addTokenTo(_to, _tokenId); emit Transfer(address(0), _to, _tokenId); } /** * @dev Internal function to burn a specific token * @dev Reverts if the token does not exist * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { clearApproval(_owner, _tokenId); removeTokenFrom(_owner, _tokenId); emit Transfer(_owner, address(0), _tokenId); } /** * @dev Internal function to clear current approval of a given token ID * @dev Reverts if the given address is not indeed the owner of the token * @param _owner owner of the token * @param _tokenId uint256 ID of the token to be transferred */ function clearApproval(address _owner, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _owner); if (tokenApprovals[_tokenId] != address(0)) { tokenApprovals[_tokenId] = address(0); emit Approval(_owner, address(0), _tokenId); } } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { require(tokenOwner[_tokenId] == address(0)); tokenOwner[_tokenId] = _to; ownedTokensCount[_to] = ownedTokensCount[_to].add(1); } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { require(ownerOf(_tokenId) == _from); ownedTokensCount[_from] = ownedTokensCount[_from].sub(1); tokenOwner[_tokenId] = address(0); } /** * @dev Internal function to invoke `onERC721Received` on a target address * @dev The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint256 ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint256 _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received(_from, _tokenId, _data); return (retval == ERC721_RECEIVED); } } // File: zeppelin-solidity/contracts/token/ERC721/ERC721Token.sol /** * @title Full ERC721 Token * This implementation includes all the required and some optional functionality of the ERC721 standard * Moreover, it includes approve all functionality using operator terminology * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Token is ERC721, ERC721BasicToken { // Token name string internal name_; // Token symbol string internal symbol_; // Mapping from owner to list of owned token IDs mapping (address => uint256[]) internal ownedTokens; // Mapping from token ID to index of the owner tokens list mapping(uint256 => uint256) internal ownedTokensIndex; // Array with all token ids, used for enumeration uint256[] internal allTokens; // Mapping from token id to position in the allTokens array mapping(uint256 => uint256) internal allTokensIndex; // Optional mapping for token URIs mapping(uint256 => string) internal tokenURIs; /** * @dev Constructor function */ function ERC721Token(string _name, string _symbol) public { name_ = _name; symbol_ = _symbol; } /** * @dev Gets the token name * @return string representing the token name */ function name() public view returns (string) { return name_; } /** * @dev Gets the token symbol * @return string representing the token symbol */ function symbol() public view returns (string) { return symbol_; } /** * @dev Returns an URI for a given token ID * @dev Throws if the token ID does not exist. May return an empty string. * @param _tokenId uint256 ID of the token to query */ function tokenURI(uint256 _tokenId) public view returns (string) { require(exists(_tokenId)); return tokenURIs[_tokenId]; } /** * @dev Gets the token ID at a given index of the tokens list of the requested owner * @param _owner address owning the tokens list to be accessed * @param _index uint256 representing the index to be accessed of the requested tokens list * @return uint256 token ID at the given index of the tokens list owned by the requested address */ function tokenOfOwnerByIndex(address _owner, uint256 _index) public view returns (uint256) { require(_index < balanceOf(_owner)); return ownedTokens[_owner][_index]; } /** * @dev Gets the total amount of tokens stored by the contract * @return uint256 representing the total amount of tokens */ function totalSupply() public view returns (uint256) { return allTokens.length; } /** * @dev Gets the token ID at a given index of all the tokens in this contract * @dev Reverts if the index is greater or equal to the total number of tokens * @param _index uint256 representing the index to be accessed of the tokens list * @return uint256 token ID at the given index of the tokens list */ function tokenByIndex(uint256 _index) public view returns (uint256) { require(_index < totalSupply()); return allTokens[_index]; } /** * @dev Internal function to set the token URI for a given token * @dev Reverts if the token ID does not exist * @param _tokenId uint256 ID of the token to set its URI * @param _uri string URI to assign */ function _setTokenURI(uint256 _tokenId, string _uri) internal { require(exists(_tokenId)); tokenURIs[_tokenId] = _uri; } /** * @dev Internal function to add a token ID to the list of a given address * @param _to address representing the new owner of the given token ID * @param _tokenId uint256 ID of the token to be added to the tokens list of the given address */ function addTokenTo(address _to, uint256 _tokenId) internal { super.addTokenTo(_to, _tokenId); uint256 length = ownedTokens[_to].length; ownedTokens[_to].push(_tokenId); ownedTokensIndex[_tokenId] = length; } /** * @dev Internal function to remove a token ID from the list of a given address * @param _from address representing the previous owner of the given token ID * @param _tokenId uint256 ID of the token to be removed from the tokens list of the given address */ function removeTokenFrom(address _from, uint256 _tokenId) internal { super.removeTokenFrom(_from, _tokenId); uint256 tokenIndex = ownedTokensIndex[_tokenId]; uint256 lastTokenIndex = ownedTokens[_from].length.sub(1); uint256 lastToken = ownedTokens[_from][lastTokenIndex]; ownedTokens[_from][tokenIndex] = lastToken; ownedTokens[_from][lastTokenIndex] = 0; // Note that this will handle single-element arrays. In that case, both tokenIndex and lastTokenIndex are going to // be zero. Then we can make sure that we will remove _tokenId from the ownedTokens list since we are first swapping // the lastToken to the first position, and then dropping the element placed in the last position of the list ownedTokens[_from].length--; ownedTokensIndex[_tokenId] = 0; ownedTokensIndex[lastToken] = tokenIndex; } /** * @dev Internal function to mint a new token * @dev Reverts if the given token ID already exists * @param _to address the beneficiary that will own the minted token * @param _tokenId uint256 ID of the token to be minted by the msg.sender */ function _mint(address _to, uint256 _tokenId) internal { super._mint(_to, _tokenId); allTokensIndex[_tokenId] = allTokens.length; allTokens.push(_tokenId); } /** * @dev Internal function to burn a specific token * @dev Reverts if the token does not exist * @param _owner owner of the token to burn * @param _tokenId uint256 ID of the token being burned by the msg.sender */ function _burn(address _owner, uint256 _tokenId) internal { super._burn(_owner, _tokenId); // Clear metadata (if any) if (bytes(tokenURIs[_tokenId]).length != 0) { delete tokenURIs[_tokenId]; } // Reorg all tokens array uint256 tokenIndex = allTokensIndex[_tokenId]; uint256 lastTokenIndex = allTokens.length.sub(1); uint256 lastToken = allTokens[lastTokenIndex]; allTokens[tokenIndex] = lastToken; allTokens[lastTokenIndex] = 0; allTokens.length--; allTokensIndex[_tokenId] = 0; allTokensIndex[lastToken] = tokenIndex; } } // File: zeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: zeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: zeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/IWasFirstServiceToken.sol contract IWasFirstServiceToken is StandardToken, Ownable { string public constant NAME = \"IWasFirstServiceToken\"; // solium-disable-line uppercase string public constant SYMBOL = \"IWF\"; // solium-disable-line uppercase uint8 public constant DECIMALS = 18; // solium-disable-line uppercase uint256 public constant INITIAL_SUPPLY = 10000000 * (10 ** uint256(DECIMALS)); address fungibleTokenAddress; address shareTokenAddress; /** * @dev Constructor that gives msg.sender all of existing tokens. */ function IWasFirstServiceToken() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } function getFungibleTokenAddress() public view returns (address) { return fungibleTokenAddress; } function setFungibleTokenAddress(address _address) onlyOwner() public { require(fungibleTokenAddress == address(0)); fungibleTokenAddress = _address; } function getShareTokenAddress() public view returns (address) { return shareTokenAddress; } function setShareTokenAddress(address _address) onlyOwner() public { require(shareTokenAddress == address(0)); shareTokenAddress = _address; } function transferByRelatedToken(address _from, address _to, uint256 _value) public returns (bool) { require(msg.sender == fungibleTokenAddress || msg.sender == shareTokenAddress); require(_to != address(0)); require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(_from, _to, _value); return true; } } // File: contracts/IWasFirstFungibleToken.sol contract IWasFirstFungibleToken is ERC721Token(\"IWasFirstFungible\", \"IWX\"), Ownable { struct TokenMetaData { uint creationTime; string creatorMetadataJson; } address _serviceTokenAddress; address _shareTokenAddress; mapping (uint256 => string) internal tokenHash; mapping (string => uint256) internal tokenIdOfHash; uint256 internal tokenIdSeq = 1; mapping (uint256 => TokenMetaData[]) internal tokenMetaData; function hashExists(string hash) public view returns (bool) { return tokenIdOfHash[hash] != 0; } function mint(string hash, string creatorMetadataJson) external { require(!hashExists(hash)); uint256 currentTokenId = tokenIdSeq; tokenIdSeq = tokenIdSeq + 1; IWasFirstServiceToken serviceToken = IWasFirstServiceToken(_serviceTokenAddress); serviceToken.transferByRelatedToken(msg.sender, _shareTokenAddress, 10 ** uint256(serviceToken.DECIMALS())); tokenHash[currentTokenId] = hash; tokenIdOfHash[hash] = currentTokenId; tokenMetaData[currentTokenId].push(TokenMetaData(now, creatorMetadataJson)); super._mint(msg.sender, currentTokenId); } function getTokenCreationTime(string hash) public view returns(uint) { require(hashExists(hash)); uint length = tokenMetaData[tokenIdOfHash[hash]].length; return tokenMetaData[tokenIdOfHash[hash]][length-1].creationTime; } function getCreatorMetadata(string hash) public view returns(string) { require(hashExists(hash)); uint length = tokenMetaData[tokenIdOfHash[hash]].length; return tokenMetaData[tokenIdOfHash[hash]][length-1].creatorMetadataJson; } function getMetadataHistoryLength(string hash) public view returns(uint) { if(hashExists(hash)) { return tokenMetaData[tokenIdOfHash[hash]].length; } else { return 0; } } function getCreationDateOfHistoricalMetadata(string hash, uint index) public view returns(uint) { require(hashExists(hash)); return tokenMetaData[tokenIdOfHash[hash]][index].creationTime; } function getCreatorMetadataOfHistoricalMetadata(string hash, uint index) public view returns(string) { require(hashExists(hash)); return tokenMetaData[tokenIdOfHash[hash]][index].creatorMetadataJson; } function updateMetadata(string hash, string creatorMetadataJson) public { require(hashExists(hash)); require(ownerOf(tokenIdOfHash[hash]) == msg.sender); tokenMetaData[tokenIdOfHash[hash]].push(TokenMetaData(now, creatorMetadataJson)); } function getTokenIdByHash(string hash) public view returns(uint256) { require(hashExists(hash)); return tokenIdOfHash[hash]; } function getHashByTokenId(uint256 tokenId) public view returns(string) { require(exists(tokenId)); return tokenHash[tokenId]; } function getNumberOfTokens() public view returns(uint) { return allTokens.length; } function setServiceTokenAddress(address serviceTokenAdress) onlyOwner() public { require(_serviceTokenAddress == address(0)); _serviceTokenAddress = serviceTokenAdress; } function getServiceTokenAddress() public view returns(address) { return _serviceTokenAddress; } function setShareTokenAddress(address shareTokenAdress) onlyOwner() public { require(_shareTokenAddress == address(0)); _shareTokenAddress = shareTokenAdress; } function getShareTokenAddress() public view returns(address) { return _shareTokenAddress; } } "}
{"sol name": "264.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /* suport  tocoin.com * \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510 \u252c \u250c\u2500\u2510    \u250c\u252c\u2510\u250c\u2500\u2510\u250c\u2500\u2510\u250c\u252c\u2510 *  \u2502 \u2502 \u2502\u2502  \u2502 \u2502 \u2502 \u2502 \u2502     \u2502 \u251c\u2524 \u251c\u2500\u2524\u2502\u2502\u2502 *  \u2534 \u2514\u2500\u2518\u2514\u2500\u2518\u2514\u2500\u2518 \u2534 \u2534 \u2534     \u2534 \u2514\u2500\u2518\u2534 \u2534\u2534 \u2534 */ interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } } "}
{"sol name": "975.sol", "label": 0, "sol content": "pragma solidity 0.4.24; contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Follor is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; function Follor() public { symbol = \"OLLO\"; name = \"FOLLOR\"; decimals = 18; _totalSupply = 700000000000000000000000000; balances[0x0E00D8Bc271a6121CbDe6D542AbC7185C0F9D983] = _totalSupply; Transfer(address(0), 0x0E00D8Bc271a6121CbDe6D542AbC7185C0F9D983, _totalSupply); } function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "437.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event PausePublic(bool newState); event PauseOwnerAdmin(bool newState); bool public pausedPublic = true; bool public pausedOwnerAdmin = false; address public admin; /** * @dev Modifier to make a function callable based on pause states. */ modifier whenNotPaused() { if(pausedPublic) { if(!pausedOwnerAdmin) { require(msg.sender == admin || msg.sender == owner); } else { revert(); } } _; } /** * @dev called by the owner to set new pause flags * pausedPublic can't be false while pausedOwnerAdmin is true */ function pause(bool newPausedPublic, bool newPausedOwnerAdmin) onlyOwner public { require(!(newPausedPublic == false && newPausedOwnerAdmin == true)); pausedPublic = newPausedPublic; pausedOwnerAdmin = newPausedOwnerAdmin; PausePublic(newPausedPublic); PauseOwnerAdmin(newPausedOwnerAdmin); } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract Swachhcoin is PausableToken { string  public  constant name = \"Swachhcoin\"; string  public  constant symbol = \"SCX\"; uint8   public  constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 400000000 * 10**18; modifier validDestination( address to ) { require(to != address(0x0)); require(to != address(this)); _; } function Swachhcoin( address _admin ) { // assign the admin account admin = _admin; totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; Transfer(address(0x0), msg.sender, INITIAL_SUPPLY); } function transfer(address _to, uint _value) validDestination(_to) returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint _value) validDestination(_to) returns (bool) { return super.transferFrom(_from, _to, _value); } event Burn(address indexed _burner, uint _value); function burn(uint _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); Burn(msg.sender, _value); Transfer(msg.sender, address(0x0), _value); return true; } // save some gas by making only one contract call function burnFrom(address _from, uint256 _value) returns (bool) { assert( transferFrom( _from, msg.sender, _value ) ); return burn(_value); } function emergencyERC20Drain( ERC20 token, uint amount ) onlyOwner { // owner can drain tokens that are sent here by mistake token.transfer( owner, amount ); } event AdminTransferred(address indexed previousAdmin, address indexed newAdmin); function changeAdmin(address newAdmin) onlyOwner { // owner can re-assign the admin AdminTransferred(admin, newAdmin); admin = newAdmin; } } "}
{"sol name": "389.sol", "label": 0, "sol content": "library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and a // fixed supply // ---------------------------------------------------------------------------- contract HVAToken is ERC20Interface, Owned { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"HVA\"; name = \"HVA SHARE\"; decimals = 0; _totalSupply = 200000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public view returns (uint) { return _totalSupply.sub(balances[address(0)]); } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public view returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "376.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract MB { string public name = \"MicroChain\"; string public symbol = \"MB\"; uint public decimals = 18; uint public INITIAL_SUPPLY = 100000000000000000000000000000; mapping(address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint256 public _totalSupply; address public _creator; bool bIsFreezeAll = false; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); function safeSub(uint a, uint b) internal returns (uint) { assert(b <= a); return a - b; } function safeAdd(uint a, uint b) internal returns (uint) { uint c = a + b; assert(c>=a && c>=b); return c; } function totalSupply() public constant returns (uint256 total) { total = _totalSupply; } function transfer(address _to, uint _value) public returns (bool success) { require(bIsFreezeAll == false); balances[msg.sender] = safeSub(balances[msg.sender], _value); balances[_to] = safeAdd(balances[_to], _value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { require(bIsFreezeAll == false); var _allowance = allowed[_from][msg.sender]; balances[_to] = safeAdd(balances[_to], _value); balances[_from] = safeSub(balances[_from], _value); allowed[_from][msg.sender] = safeSub(_allowance, _value); Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint balance) { return balances[_owner]; } function approve(address _spender, uint _value) public returns (bool success) { require(bIsFreezeAll == false); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint remaining) { return allowed[_owner][_spender]; } function freezeAll() public { require(msg.sender == _creator); bIsFreezeAll = !bIsFreezeAll; } function MB() public { _totalSupply = INITIAL_SUPPLY; _creator = 0xf2F91C1C681816eE275ce9b4366D5a906da6eBf5; balances[_creator] = INITIAL_SUPPLY; bIsFreezeAll = false; } function destroy() public  { require(msg.sender == _creator); selfdestruct(_creator); } } "}
{"sol name": "913.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title ERC20 * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } pragma solidity ^0.4.18; /** * @title TopPlayer token */ contract TopPlayerToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; string public name = \"Top Player Token Test\"; string public symbol = \"TPT-TEST\"; uint256 public decimals = 18; function TopPlayerToken() public { totalSupply = 2000000000 * (10 ** decimals); balances[msg.sender] = totalSupply; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } "}
{"sol name": "438.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract ECF { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals;  // decimals \u53ef\u4ee5\u6709\u7684\u5c0f\u6570\u70b9\u4e2a\u6570\uff0c\u6700\u5c0f\u7684\u4ee3\u5e01\u5355\u4f4d\u300218 \u662f\u5efa\u8bae\u7684\u9ed8\u8ba4\u503c uint256 public totalSupply; address public owner; // \u7528mapping\u4fdd\u5b58\u6bcf\u4e2a\u5730\u5740\u5bf9\u5e94\u7684\u4f59\u989d mapping (address => uint256) public balanceOf; // \u5b58\u50a8\u5bf9\u8d26\u53f7\u7684\u63a7\u5236 mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256) public freezeOf; // \u4e8b\u4ef6\uff0c\u7528\u6765\u901a\u77e5\u5ba2\u6237\u7aef\u4ea4\u6613\u53d1\u751f event Transfer(address indexed from, address indexed to, uint256 value); // \u4e8b\u4ef6\uff0c\u7528\u6765\u901a\u77e5\u5ba2\u6237\u7aef\u4ee3\u5e01\u88ab\u6d88\u8d39 event Burn(address indexed from, uint256 value); //\u8868\u793a\u76f8\u5e94\u7684\u6388\u6743\u7684\u8bf7\u6c42\u88ab\u540c\u610f\uff0c\u53ef\u4ee5\u6b63\u5f0f\u6388\u6743 event Approval(address indexed tokenOwner, address indexed spender, uint tokens); /* \u51bb\u7ed3 */ event Freeze(address indexed from, uint256 value); /* \u89e3\u51bb */ event Unfreeze(address indexed from, uint256 value); /** * \u521d\u59cb\u5316\u6784\u9020 */ constructor(uint256 initialSupply, string tokenName, string tokenSymbol, uint8 uintDecimal) public { decimals = uintDecimal; totalSupply = initialSupply * 10 ** uint256(uintDecimal);  // \u4f9b\u5e94\u7684\u4efd\u989d\uff0c\u4efd\u989d\u8ddf\u6700\u5c0f\u7684\u4ee3\u5e01\u5355\u4f4d\u6709\u5173\uff0c\u4efd\u989d = \u5e01\u6570 * 10 ** decimals\u3002 balanceOf[msg.sender] = totalSupply;                // \u521b\u5efa\u8005\u62e5\u6709\u6240\u6709\u7684\u4ee3\u5e01 name = tokenName;                                   // \u4ee3\u5e01\u540d\u79f0 symbol = tokenSymbol;                               // \u4ee3\u5e01\u7b26\u53f7 owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); owner = newOwner; } /** * \u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb\u7684\u5185\u90e8\u5b9e\u73b0 */ function _transfer(address _from, address _to, uint _value) internal { // \u786e\u4fdd\u76ee\u6807\u5730\u5740\u4e0d\u4e3a0x0\uff0c\u56e0\u4e3a0x0\u5730\u5740\u4ee3\u8868\u9500\u6bc1 require(_to != 0x0); // \u68c0\u67e5\u53d1\u9001\u8005\u4f59\u989d require(balanceOf[_from] >= _value); // \u786e\u4fdd\u8f6c\u79fb\u4e3a\u6b63\u6570\u4e2a require(balanceOf[_to] + _value > balanceOf[_to]); // \u4ee5\u4e0b\u7528\u6765\u68c0\u67e5\u4ea4\u6613\uff0c uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] = balanceOf[_from].sub(_value); // Add the same to the recipient balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(_from, _to, _value); // \u7528assert\u6765\u68c0\u67e5\u4ee3\u7801\u903b\u8f91\u3002 assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** *  \u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb * \u4ece\u521b\u5efa\u4ea4\u6613\u8005\u8d26\u53f7\u53d1\u9001`_value`\u4efd\u989d\u4ee3\u5e01\u5230 `_to`\u8d26\u53f7 * * @param _to \u63a5\u6536\u8005\u5730\u5740 * @param _value \u8f6c\u79fb\u6570\u989d */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * \u8d26\u53f7\u4e4b\u95f4\u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb * @param _from \u53d1\u9001\u8005\u5730\u5740 * @param _to \u63a5\u6536\u8005\u5730\u5740 * @param _value \u8f6c\u79fb\u6570\u989d */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; } /** * \u8bbe\u7f6e\u67d0\u4e2a\u5730\u5740\uff08\u5408\u7ea6\uff09\u53ef\u4ee5\u4ea4\u6613\u8005\u540d\u4e49\u82b1\u8d39\u7684\u4ee3\u5e01\u6570\u3002 * * \u5141\u8bb8\u53d1\u9001\u8005`_spender` \u82b1\u8d39\u4e0d\u591a\u4e8e `_value` \u4efd\u989d\u4ee3\u5e01 * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender,_spender,_value); return true; } /** * \u8bbe\u7f6e\u5141\u8bb8\u4e00\u4e2a\u5730\u5740\uff08\u5408\u7ea6\uff09\u4ee5\u4ea4\u6613\u8005\u540d\u4e49\u53ef\u6700\u591a\u82b1\u8d39\u7684\u4ee3\u5e01\u6570\u3002 * * @param _spender \u88ab\u6388\u6743\u7684\u5730\u5740\uff08\u5408\u7ea6\uff09 * @param _value \u6700\u5927\u53ef\u82b1\u8d39\u4ee3\u5e01\u6570 * @param _extraData \u53d1\u9001\u7ed9\u5408\u7ea6\u7684\u9644\u52a0\u6570\u636e */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * \u9500\u6bc1\u521b\u5efa\u8005\u8d26\u6237\u4e2d\u6307\u5b9a\u4e2a\u4ee3\u5e01 */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value);            // Subtract from the sender totalSupply = totalSupply.sub(_value);                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * \u9500\u6bc1\u7528\u6237\u8d26\u6237\u4e2d\u6307\u5b9a\u4e2a\u4ee3\u5e01 * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] = balanceOf[_from].sub(_value);                         // Subtract from the targeted balance allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value);             // Subtract from the sender's allowance totalSupply = totalSupply.sub(_value);                              // Update totalSupply emit Burn(_from, _value); return true; } //\u589e\u53d1 function mintToken(address target, uint256 mintedAmount) public onlyOwner { balanceOf[target] = balanceOf[target].add(mintedAmount); totalSupply = totalSupply.add(mintedAmount); emit Transfer(0, owner, mintedAmount); emit Transfer(owner, target, mintedAmount); } //\u51bb\u7ed3 function freeze(address target,uint256 _value) onlyOwner public returns (bool success) { if (balanceOf[target] < _value) revert();            // Check if the sender has enough if (_value <= 0) revert(); balanceOf[target] = balanceOf[target].sub(_value);                      // Subtract from the sender freezeOf[target] = freezeOf[target].add(_value);                                // Updates totalSupply emit Freeze(target, _value); return true; } //\u89e3\u51bb function unfreeze(address target,uint256 _value) onlyOwner public returns (bool success) { if (freezeOf[target] < _value) revert();            // Check if the sender has enough if (_value <= 0) revert(); freezeOf[target] = freezeOf[target].sub(_value);                      // Subtract from the sender balanceOf[target] = balanceOf[target].add(_value); emit Unfreeze(target, _value); return true; } // can accept ether function() payable public{ } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } "}
{"sol name": "861.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* * Creator: MARX (Marx) */ /* * Abstract Token Smart Contract * */ /* * Safe Math Smart Contract. * https://github.com/OpenZeppelin/zeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ contract SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * ERC-20 standard token interface, as defined * <a href=\"http://github.com/ethereum/EIPs/issues/20\">here</a>. */ contract Token { function totalSupply() constant returns (uint256 supply); function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /** * Abstract Token Smart Contract that could be used as a base contract for * ERC-20 token contracts. */ contract AbstractToken is Token, SafeMath { /** * Create new Abstract Token contract. */ function AbstractToken () { // Do nothing } /** * Get number of tokens currently belonging to given owner. * * @param _owner address to get number of tokens currently belonging to the *        owner of * @return number of tokens currently belonging to the owner of given address */ function balanceOf(address _owner) constant returns (uint256 balance) { return accounts [_owner]; } /** * Transfer given number of tokens from message sender to given recipient. * * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (accounts [msg.sender] < _value) return false; if (_value > 0 && msg.sender != _to) { accounts [msg.sender] = safeSub (accounts [msg.sender], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer (msg.sender, _to, _value); return true; } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise * accounts [_to] + _value > accounts [_to] for overflow check * which is already in safeMath */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); if (allowances [_from][msg.sender] < _value) return false; if (accounts [_from] < _value) return false; if (_value > 0 && _from != _to) { allowances [_from][msg.sender] = safeSub (allowances [_from][msg.sender], _value); accounts [_from] = safeSub (accounts [_from], _value); accounts [_to] = safeAdd (accounts [_to], _value); } emit Transfer(_from, _to, _value); return true; } /** * Allow given spender to transfer given number of tokens from message sender. * @param _spender address to allow the owner of to transfer tokens from message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { allowances [msg.sender][_spender] = _value; emit Approval (msg.sender, _spender, _value); return true; } /** * Tell how many tokens given spender is currently allowed to transfer from * given owner. * * @param _owner address to get number of tokens allowed to be transferred *        from the owner of * @param _spender address to get number of tokens allowed to be transferred *        by the owner of * @return number of tokens given spender is currently allowed to transfer *         from given owner */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowances [_owner][_spender]; } /** * Mapping from addresses of token holders to the numbers of tokens belonging * to these token holders. */ mapping (address => uint256) accounts; /** * Mapping from addresses of token holders to the mapping of addresses of * spenders to the allowances set by these token holders to these spenders. */ mapping (address => mapping (address => uint256)) private allowances; } /** * Marx smart contract. */ contract MARXToken is AbstractToken { /** * Maximum allowed number of tokens in circulation. * tokenSupply = tokensIActuallyWant * (10 ^ decimals) */ uint256 constant MAX_TOKEN_COUNT = 2000000 * (10**2); /** * Address of the owner of this smart contract. */ address private owner; /** * Frozen account list holder */ mapping (address => bool) private frozenAccount; /** * Current number of tokens in circulation. */ uint256 tokenCount = 0; /** * True if tokens transfers are currently frozen, false otherwise. */ bool frozen = false; /** * Create new token smart contract and make msg.sender the * owner of this smart contract. */ function MARXToken () { owner = msg.sender; } /** * Get total number of tokens in circulation. * * @return total number of tokens in circulation */ function totalSupply() constant returns (uint256 supply) { return tokenCount; } string constant public name = \"Marx\"; string constant public symbol = \"MARX\"; uint8 constant public decimals = 2; /** * Transfer given number of tokens from message sender to given recipient. * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer to the owner of given address * @return true if tokens were transferred successfully, false otherwise */ function transfer(address _to, uint256 _value) returns (bool success) { require(!frozenAccount[msg.sender]); if (frozen) return false; else return AbstractToken.transfer (_to, _value); } /** * Transfer given number of tokens from given owner to given recipient. * * @param _from address to transfer tokens from the owner of * @param _to address to transfer tokens to the owner of * @param _value number of tokens to transfer from given owner to given *        recipient * @return true if tokens were transferred successfully, false otherwise */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(!frozenAccount[_from]); if (frozen) return false; else return AbstractToken.transferFrom (_from, _to, _value); } /** * Change how many tokens given spender is allowed to transfer from message * spender.  In order to prevent double spending of allowance, * To change the approve amount you first have to reduce the addresses` * allowance to zero by calling `approve(_spender, 0)` if it is not * already 0 to mitigate the race condition described here: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender address to allow the owner of to transfer tokens from *        message sender * @param _value number of tokens to allow to transfer * @return true if token transfer was successfully approved, false otherwise */ function approve (address _spender, uint256 _value) returns (bool success) { require(allowance (msg.sender, _spender) == 0 || _value == 0); return AbstractToken.approve (_spender, _value); } /** * Create _value new tokens and give new created tokens to msg.sender. * May only be called by smart contract owner. * * @param _value number of tokens to create * @return true if tokens were created successfully, false otherwise */ function createTokens(uint256 _value) returns (bool success) { require (msg.sender == owner); if (_value > 0) { if (_value > safeSub (MAX_TOKEN_COUNT, tokenCount)) return false; accounts [msg.sender] = safeAdd (accounts [msg.sender], _value); tokenCount = safeAdd (tokenCount, _value); // adding transfer event and _from address as null address emit Transfer(0x0, msg.sender, _value); return true; } return false; } /** * For future use only when we will need more tokens for our main application * Create mintedAmount new tokens and give new created tokens to target. * May only be called by smart contract owner. * @param mintedAmount number of tokens to create * @return true if tokens were created successfully, false otherwise */ function mintToken(address target, uint256 mintedAmount) returns (bool success) { require (msg.sender == owner); if (mintedAmount > 0) { accounts [target] = safeAdd (accounts [target], mintedAmount); tokenCount = safeAdd (tokenCount, mintedAmount); // adding transfer event and _from address as null address emit Transfer(0x0, target, mintedAmount); return true; } return false; } /** * Set new owner for the smart contract. * May only be called by smart contract owner. * * @param _newOwner address of new owner of the smart contract */ function setOwner(address _newOwner) { require (msg.sender == owner); owner = _newOwner; } /** * Freeze ALL token transfers. * May only be called by smart contract owner. */ function freezeTransfers () { require (msg.sender == owner); if (!frozen) { frozen = true; emit Freeze (); } } /** * Unfreeze ALL token transfers. * May only be called by smart contract owner. */ function unfreezeTransfers () { require (msg.sender == owner); if (frozen) { frozen = false; emit Unfreeze (); } } /*A user is able to unintentionally send tokens to a contract * and if the contract is not prepared to refund them they will get stuck in the contract. * The same issue used to happen for Ether too but new Solidity versions added the payable modifier to * prevent unintended Ether transfers. However, there\u2019s no such mechanism for token transfers. * so the below function is created */ function refundTokens(address _token, address _refund, uint256 _value) { require (msg.sender == owner); require(_token != address(this)); AbstractToken token = AbstractToken(_token); token.transfer(_refund, _value); emit RefundTokens(_token, _refund, _value); } /** * Freeze specific account * May only be called by smart contract owner. */ function freezeAccount(address _target, bool freeze) { require (msg.sender == owner); require (msg.sender != _target); frozenAccount[_target] = freeze; emit FrozenFunds(_target, freeze); } /** * Logged when token transfers were frozen. */ event Freeze (); /** * Logged when token transfers were unfrozen. */ event Unfreeze (); /** * Logged when a particular account is frozen. */ event FrozenFunds(address target, bool frozen); /** * when accidentally send other tokens are refunded */ event RefundTokens(address _token, address _refund, uint256 _value); } "}
{"sol name": "502.sol", "label": 0, "sol content": "/* Implements EIP20 token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md .*/ pragma solidity ^0.4.21; // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md pragma solidity ^0.4.21; contract EIP20Interface { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public view returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public view returns (uint256 remaining); // solhint-disable-next-line no-simple-event-func-name event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract B3 is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX function B3( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "340.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256 balance); function allowance(address owner, address spender) public view returns (uint256 remaining); function transfer(address to, uint256 value) public returns (bool success); function approve(address spender, uint256 value) public returns (bool success); function transferFrom(address from, address to, uint256 value) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } library SafeMath { function sub(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a - b; assert(b <= a && c <= a); return c; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a && c>=b); return c; } } library SafeERC20 { function safeTransfer(ERC20 _token, address _to, uint256 _value) internal { require(_token.transfer(_to, _value)); } } contract Owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner,\"O1- Owner only function\"); _; } function setOwner(address newOwner) onlyOwner public { owner = newOwner; } } contract Pausable is Owned { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() public onlyOwner whenNotPaused { paused = true; emit Pause(); } function unpause() public onlyOwner whenPaused { paused = false; emit Unpause(); } } contract VIDToken is Owned, Pausable, ERC20 { using SafeMath for uint256; using SafeERC20 for ERC20; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; mapping (address => bool) public frozenAccount; mapping (address => bool) public verifyPublisher; mapping (address => bool) public verifyWallet; struct fStruct { uint256 index; } mapping(string => fStruct) private fileHashes; string[] private fileIndex; string public constant name = \"V-ID Token\"; uint8 public constant decimals = 18; string public constant symbol = \"VIDT\"; uint256 public constant initialSupply = 100000000; uint256 public validationPrice = 7 * 10 ** uint(decimals); address public validationWallet = address(0); constructor() public { validationWallet = msg.sender; verifyWallet[msg.sender] = true; totalSupply = initialSupply * 10 ** uint(decimals); balances[msg.sender] = totalSupply; emit Transfer(address(0),owner,initialSupply); } function () public payable { revert(); } function transfer(address _to, uint256 _value) public whenNotPaused returns (bool success) { require(_to != msg.sender,\"T1- Recipient can not be the same as sender\"); require(_to != address(0),\"T2- Please check the recipient address\"); require(balances[msg.sender] >= _value,\"T3- The balance of sender is too low\"); require(!frozenAccount[msg.sender],\"T4- The wallet of sender is frozen\"); require(!frozenAccount[_to],\"T5- The wallet of recipient is frozen\"); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool success) { require(_to != address(0),\"TF1- Please check the recipient address\"); require(balances[_from] >= _value,\"TF2- The balance of sender is too low\"); require(allowed[_from][msg.sender] >= _value,\"TF3- The allowance of sender is too low\"); require(!frozenAccount[_from],\"TF4- The wallet of sender is frozen\"); require(!frozenAccount[_to],\"TF5- The wallet of recipient is frozen\"); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool success) { require((_value == 0) || (allowed[msg.sender][_spender] == 0),\"A1- Reset allowance to 0 first\"); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function increaseApproval(address _spender, uint256 _addedValue) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint256 _subtractedValue) public whenNotPaused returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].sub(_subtractedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } struct TKN { address sender; uint256 value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint256 _value, bytes _data) public pure returns (bool) { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); return true; } function transferToken(address tokenAddress, uint256 tokens) public onlyOwner { ERC20(tokenAddress).safeTransfer(owner,tokens); } function burn(uint256 _value) public onlyOwner returns (bool) { require(_value <= balances[msg.sender],\"B1- The balance of burner is too low\"); balances[msg.sender] = balances[msg.sender].sub(_value); totalSupply = totalSupply.sub(_value); emit Burn(msg.sender, _value); emit Transfer(msg.sender, address(0), _value); return true; } function freeze(address _address, bool _state) public onlyOwner returns (bool) { frozenAccount[_address] = _state; emit Freeze(_address, _state); return true; } function validatePublisher(address Address, bool State, string Publisher) public onlyOwner returns (bool) { verifyPublisher[Address] = State; emit ValidatePublisher(Address,State,Publisher); return true; } function validateWallet(address Address, bool State, string Wallet) public onlyOwner returns (bool) { verifyWallet[Address] = State; emit ValidateWallet(Address,State,Wallet); return true; } function validateFile(address To, uint256 Payment, bytes Data, bool cStore, bool eLog) public whenNotPaused returns (bool) { require(Payment>=validationPrice,\"V1- Insufficient payment provided\"); require(verifyPublisher[msg.sender],\"V2- Unverified publisher address\"); require(!frozenAccount[msg.sender],\"V3- The wallet of publisher is frozen\"); require(Data.length == 64,\"V4- Invalid hash provided\"); if (!verifyWallet[To] || frozenAccount[To]) { To = validationWallet; } uint256 index = 0; string memory fileHash = string(Data); if (cStore) { if (fileIndex.length > 0) { require(fileHashes[fileHash].index == 0,\"V5- This hash was previously validated\"); } fileHashes[fileHash].index = fileIndex.push(fileHash)-1; index = fileHashes[fileHash].index; } if (allowed[To][msg.sender] >= Payment) { allowed[To][msg.sender] = allowed[To][msg.sender].sub(Payment); } else { balances[msg.sender] = balances[msg.sender].sub(Payment); balances[To] = balances[To].add(Payment); } emit Transfer(msg.sender, To, Payment); if (eLog) { emit ValidateFile(index,fileHash); } return true; } function verifyFile(string fileHash) public view returns (bool) { if (fileIndex.length == 0) { return false; } bytes memory a = bytes(fileIndex[fileHashes[fileHash].index]); bytes memory b = bytes(fileHash); if (a.length != b.length) { return false; } for (uint256 i = 0; i < a.length; i ++) { if (a[i] != b[i]) { return false; } } return true; } function setPrice(uint256 newPrice) public onlyOwner { validationPrice = newPrice; } function setWallet(address newWallet) public onlyOwner { validationWallet = newWallet; } function listFiles(uint256 startAt, uint256 stopAt) onlyOwner public returns (bool) { if (fileIndex.length == 0) { return false; } require(startAt <= fileIndex.length-1,\"L1- Please select a valid start\"); if (stopAt > 0) { require(stopAt > startAt && stopAt <= fileIndex.length-1,\"L2- Please select a valid stop\"); } else { stopAt = fileIndex.length-1; } for (uint256 i = startAt; i <= stopAt; i++) { emit LogEvent(i,fileIndex[i]); } return true; } event Burn(address indexed burner, uint256 value); event Freeze(address target, bool frozen); event ValidateFile(uint256 index, string data); event ValidatePublisher(address indexed publisherAddress, bool state, string indexed publisherName); event ValidateWallet(address indexed walletAddress, bool state, string indexed walletName); event LogEvent(uint256 index, string data) anonymous; } "}
{"sol name": "862.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract MPCToken is PausableToken { string public name = \"Miner Pass Card\"; string public symbol = \"MPC\"; uint8 public decimals = 18; constructor() public { totalSupply_ = 2000000000 * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } function batchTransfer(address[] _to, uint256[] value) public whenNotPaused returns(bool success){ require(_to.length == value.length); for( uint256 i = 0; i < _to.length; i++ ){ transfer(_to[i],value[i]); } return true; } } "}
{"sol name": "1881.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract SAMS { // Public variables of the token string public name='\u8f6e\u56de\u94fe'; string public symbol='SAMS'; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply=158000000000000000000000000; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function sams( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "842.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; function DetailedERC20(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } /** * @title Lara * @dev LARA Token Smart Contract */ contract Lara is DetailedERC20, StandardToken, BurnableToken, PausableToken { /** * Init token by setting its total supply * * @param totalSupply total token supply */ function Lara( uint256 totalSupply ) DetailedERC20( \"Lara\", \"LARA\", 8 ) { totalSupply_ = totalSupply; balances[msg.sender] = totalSupply; } } "}
{"sol name": "59.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Roto2coin' token contract // // Deployed to : 0xFE221B0f1aCe6f41A4E19A7a8ef6487b6eE3f7ca // Symbol      : RTO2 // Name        : Roto2coin // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Roto2coin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Roto2coin() public { symbol = \"RTO2\"; name = \"Roto2coin\"; decimals = 18; _totalSupply = 288000000000000000000000000000000; balances[0xFE221B0f1aCe6f41A4E19A7a8ef6487b6eE3f7ca] = _totalSupply; Transfer(address(0), 0xFE221B0f1aCe6f41A4E19A7a8ef6487b6eE3f7ca, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "179.sol", "label": 0, "sol content": "pragma solidity 0.4.19; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnboundedRegularToken is RegularToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract CCIToken is UnboundedRegularToken { uint public totalSupply = 1000*10**26; uint8 constant public decimals = 18; string constant public name = \"China Commodity Integrity\"; string constant public symbol = \"CCI\"; function CCIToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "1798.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20 { function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Leader { address owner; mapping (address => bool) public admins; modifier onlyOwner() { require(owner == msg.sender); _; } modifier onlyAdmins() { require(admins[msg.sender]); _; } function setOwner (address _addr) onlyOwner() public { owner = _addr; } function addAdmin (address _addr) onlyOwner() public { admins[_addr] = true; } function removeAdmin (address _addr) onlyOwner() public { delete admins[_addr]; } } contract FCash is ERC20, Leader { string public name = \"FCash\"; string public symbol = \"FCH\"; uint8 public decimals = 8; uint256 public totalSupply = 100e16; using SafeMath for uint256; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; constructor() public { owner = msg.sender; admins[msg.sender] = true; balanceOf[owner] = totalSupply; } function transfer(address _to, uint256 _value) public returns (bool success) { require (_to != 0x0 && _value > 0); if (admins[msg.sender] == true && admins[_to] == true) { balanceOf[_to] = balanceOf[_to].add(_value); totalSupply = totalSupply.add(_value); emit Transfer(msg.sender, _to, _value); return true; } require (balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { require (_value > 0); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require (_to != 0x0 && _value > 0); require (balanceOf[_from] >= _value && _value <= allowance[_from][msg.sender]); balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } "}
{"sol name": "924.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract BCASToken is TokenERC20 { /* Initializes contract with initial supply tokens to the creator of the contract */ function BCASToken( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} } "}
{"sol name": "79.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed from, address indexed to); /** * Constructor assigns ownership to the address used to deploy the contract. * */ function Ownable() public { owner = msg.sender; } /** * Any function with this modifier in its method signature can only be executed by * the owner of the contract. Any attempt made by any other account to invoke the * functions with this modifier will result in a loss of gas and the contract's state * will remain untampered. * */ modifier onlyOwner { require(msg.sender == owner); _; } /** * Allows for the transfer of ownership to another address; * * @param _newOwner The address to be assigned new ownership. * */ function transferOwnership(address _newOwner) public onlyOwner { require( _newOwner != address(0) && _newOwner != owner ); OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * Contract acts as an interface between the DappleAirdrops contract and all ERC20 compliant * tokens. * */ contract ERCInterface { function transferFrom(address _from, address _to, uint256 _value) public; function balanceOf(address who) constant public returns (uint256); function allowance(address owner, address spender) constant public returns (uint256); function transfer(address to, uint256 value) public returns(bool); } contract DappleAirdrops is Ownable { using SafeMath for uint256; mapping (address => uint256) public bonusDropsOf; mapping (address => uint256) public ethBalanceOf; mapping (address => bool) public tokenIsBanned; mapping (address => uint256) public trialDrops; uint256 public rate; uint256 public dropUnitPrice; uint256 public bonus; uint256 public maxDropsPerTx; uint256 public maxTrialDrops; string public constant website = \"www.dappleairdrops.com\"; event BonusCreditGranted(address indexed to, uint256 credit); event BonusCreditRevoked(address indexed from, uint256 credit); event CreditPurchased(address indexed by, uint256 etherValue, uint256 credit); event AirdropInvoked(address indexed by, uint256 creditConsumed); event BonustChanged(uint256 from, uint256 to); event TokenBanned(address indexed tokenAddress); event TokenUnbanned(address indexed tokenAddress); event EthWithdrawn(address indexed by, uint256 totalWei); event RateChanged(uint256 from, uint256 to); event MaxDropsChanged(uint256 from, uint256 to); event RefundIssued(address indexed to, uint256 totalWei); event ERC20TokensWithdrawn(address token, address sentTo, uint256 value); /** * Constructor sets the rate such that 1 ETH = 10,000 credits (i.e., 10,000 airdrop recipients) * which equates to a unit price of 0.00001 ETH per airdrop recipient. The bonus percentage * is set to 20% but is subject to change. Bonus credits will only be issued after once normal * credits have been used (unless credits have been granted to an address by the owner of the * contract). * */ function DappleAirdrops() public { rate = 10000; dropUnitPrice = 1e14; bonus = 20; maxDropsPerTx = 1000000; maxTrialDrops = 1000000; } /** * Checks whether or not an ERC20 token has used its free trial of 100 drops. This is a constant * function which does not alter the state of the contract and therefore does not require any gas * or a signature to be executed. * * @param _addressOfToken The address of the token being queried. * * @return true if the token being queried has not used its 100 first free trial drops, false * otherwise. * */ function tokenHasFreeTrial(address _addressOfToken) public view returns(bool) { return trialDrops[_addressOfToken] < maxTrialDrops; } /** * Checks how many remaining free trial drops a token has. * * @param _addressOfToken the address of the token being queried. * * @return the total remaining free trial drops of a token. * */ function getRemainingTrialDrops(address _addressOfToken) public view returns(uint256) { if(tokenHasFreeTrial(_addressOfToken)) { return maxTrialDrops.sub(trialDrops[_addressOfToken]); } return 0; } /** * Allows for the price of drops to be changed by the owner of the contract. Any attempt made by * any other account to invoke the function will result in a loss of gas and the price will remain * untampered. * * @return true if function executes successfully, false otherwise. * */ function setRate(uint256 _newRate) public onlyOwner returns(bool) { require( _newRate != rate && _newRate > 0 ); RateChanged(rate, _newRate); rate = _newRate; uint256 eth = 1 ether; dropUnitPrice = eth.div(rate); return true; } function getRate() public view returns(uint256) { return rate; } /** * Allows for the maximum number of participants to be queried. This is a constant function * which does not alter the state of the contract and therefore does not require any gas or a * signature to be executed. * * @return the maximum number of recipients per transaction. * */ function getMaxDropsPerTx() public view returns(uint256) { return maxDropsPerTx; } /** * Allows for the maximum number of recipients per transaction to be changed by the owner. * Any attempt made by any other account to invoke the function will result in a loss of gas * and the maximum number of recipients will remain untampered. * * @return true if function executes successfully, false otherwise. * */ function setMaxDrops(uint256 _maxDrops) public onlyOwner returns(bool) { require(_maxDrops >= 1000000); MaxDropsChanged(maxDropsPerTx, _maxDrops); maxDropsPerTx = _maxDrops; return true; } /** * Allows for the bonus to be changed at any point in time by the owner of the contract. Any * attempt made by any other account to invoke the function will result in a loss of gas and * the bonus will remain untampered. * * @param _newBonus The value of the new bonus to be set. * */ function setBonus(uint256 _newBonus) public onlyOwner returns(bool) { require(bonus != _newBonus); BonustChanged(bonus, _newBonus); bonus = _newBonus; } /** * Allows for bonus drops to be granted to a recipient address by the owner of the contract. * Any attempt made by any other account to invoke the function will result in a loss of gas * and the bonus drops of the recipient will remain untampered. * * @param _addr The address which will receive bonus credits. * @param _bonusDrops The amount of bonus drops to be granted. * * @return true if function executes successfully, false otherwise. * */ function grantBonusDrops(address _addr, uint256 _bonusDrops) public onlyOwner returns(bool) { require( _addr != address(0) && _bonusDrops > 0 ); bonusDropsOf[_addr] = bonusDropsOf[_addr].add(_bonusDrops); BonusCreditGranted(_addr, _bonusDrops); return true; } /** * Allows for bonus drops of an address to be revoked by the owner of the contract. Any * attempt made by any other account to invoke the function will result in a loss of gas * and the bonus drops of the recipient will remain untampered. * * @param _addr The address to revoke bonus credits from. * @param _bonusDrops The amount of bonus drops to be revoked. * * @return true if function executes successfully, false otherwise. * */ function revokeBonusCreditOf(address _addr, uint256 _bonusDrops) public onlyOwner returns(bool) { require( _addr != address(0) && bonusDropsOf[_addr] >= _bonusDrops ); bonusDropsOf[_addr] = bonusDropsOf[_addr].sub(_bonusDrops); BonusCreditRevoked(_addr, _bonusDrops); return true; } /** * Allows for the credit of an address to be queried. This is a constant function which * does not alter the state of the contract and therefore does not require any gas or a * signature to be executed. * * @param _addr The address of which to query the credit balance of. * * @return The total amount of credit the address has (minus any bonus credits). * */ function getDropsOf(address _addr) public view returns(uint256) { return (ethBalanceOf[_addr].mul(rate)).div(10 ** 18); } /** * Allows for the bonus credit of an address to be queried. This is a constant function * which does not alter the state of the contract and therefore does not require any gas * or a signature to be executed. * * @param _addr The address of which to query the bonus credits. * * @return The total amount of bonus credit the address has (minus non-bonus credit). * */ function getBonusDropsOf(address _addr) public view returns(uint256) { return bonusDropsOf[_addr]; } /** * Allows for the total credit (bonus + non-bonus) of an address to be queried. This is a * constant function which does not alter the state of the contract and therefore does not * require any gas or a signature to be executed. * * @param _addr The address of which to query the total credits. * * @return The total amount of credit the address has (bonus + non-bonus credit). * */ function getTotalDropsOf(address _addr) public view returns(uint256) { return getDropsOf(_addr).add(getBonusDropsOf(_addr)); } /** * Allows for the total ETH balance of an address to be queried. This is a constant * function which does not alter the state of the contract and therefore does not * require any gas or a signature to be executed. * * @param _addr The address of which to query the total ETH balance. * * @return The total amount of ETH balance the address has. * */ function getEthBalanceOf(address _addr) public view returns(uint256) { return ethBalanceOf[_addr]; } /** * Allows for suspected fraudulent ERC20 tokens to be banned from being airdropped by the * owner of the contract. Any attempt made by any other account to invoke the function will * result in a loss of gas and the token to remain unbanned. * * @param _tokenAddr The contract address of the ERC20 token to be banned from being airdropped. * * @return true if function executes successfully, false otherwise. * */ function banToken(address _tokenAddr) public onlyOwner returns(bool) { require(!tokenIsBanned[_tokenAddr]); tokenIsBanned[_tokenAddr] = true; TokenBanned(_tokenAddr); return true; } /** * Allows for previously suspected fraudulent ERC20 tokens to become unbanned by the owner * of the contract. Any attempt made by any other account to invoke the function will * result in a loss of gas and the token to remain banned. * * @param _tokenAddr The contract address of the ERC20 token to be banned from being airdropped. * * @return true if function executes successfully, false otherwise. **/ function unbanToken(address _tokenAddr) public onlyOwner returns(bool) { require(tokenIsBanned[_tokenAddr]); tokenIsBanned[_tokenAddr] = false; TokenUnbanned(_tokenAddr); return true; } /** * Allows for the allowance of a token from its owner to this contract to be queried. * * As part of the ERC20 standard all tokens which fall under this category have an allowance * function which enables owners of tokens to allow (or give permission) to another address * to spend tokens on behalf of the owner. This contract uses this as part of its protocol. * Users must first give permission to the contract to transfer tokens on their behalf, however, * this does not mean that the tokens will ever be transferrable without the permission of the * owner. This is a security feature which was implemented on this contract. It is not possible * for the owner of this contract or anyone else to transfer the tokens which belong to others. * * @param _addr The address of the token's owner. * @param _addressOfToken The contract address of the ERC20 token. * * @return The ERC20 token allowance from token owner to this contract. * */ function getTokenAllowance(address _addr, address _addressOfToken) public view returns(uint256) { ERCInterface token = ERCInterface(_addressOfToken); return token.allowance(_addr, address(this)); } /** * Allows users to buy and receive credits automatically when sending ETH to the contract address. * */ function() public payable { ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].add(msg.value); CreditPurchased(msg.sender, msg.value, msg.value.mul(rate)); } /** * Allows users to withdraw their ETH for drops which they have bought and not used. This * will result in the credit of the user being set back to 0. However, bonus credits will * remain the same because they are granted when users use their drops. * * @param _eth The amount of ETH to withdraw * * @return true if function executes successfully, false otherwise. * */ function withdrawEth(uint256 _eth) public returns(bool) { require( ethBalanceOf[msg.sender] >= _eth && _eth > 0 ); uint256 toTransfer = _eth; ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].sub(_eth); msg.sender.transfer(toTransfer); EthWithdrawn(msg.sender, toTransfer); } /** * Allows for refunds to be made by the owner of the contract. Any attempt made by any other account * to invoke the function will result in a loss of gas and no refunds will be made. * */ function issueRefunds(address[] _addrs) public onlyOwner returns(bool) { require(_addrs.length <= maxDropsPerTx); for(uint i = 0; i < _addrs.length; i++) { if(_addrs[i] != address(0) && ethBalanceOf[_addrs[i]] > 0) { uint256 toRefund = ethBalanceOf[_addrs[i]]; ethBalanceOf[_addrs[i]] = 0; _addrs[i].transfer(toRefund); RefundIssued(_addrs[i], toRefund); } } } /** * Allows for the distribution of an ERC20 token to be transferred to up to 100 recipients at * a time. This function only facilitates batch transfers of constant values (i.e., all recipients * will receive the same amount of tokens). * * @param _addressOfToken The contract address of an ERC20 token. * @param _recipients The list of addresses which will receive tokens. * @param _value The amount of tokens all addresses will receive. * * @return true if function executes successfully, false otherwise. * */ function singleValueAirdrop(address _addressOfToken,  address[] _recipients, uint256 _value) public returns(bool) { ERCInterface token = ERCInterface(_addressOfToken); require( _recipients.length <= maxDropsPerTx && ( getTotalDropsOf(msg.sender)>= _recipients.length || tokenHasFreeTrial(_addressOfToken) ) && !tokenIsBanned[_addressOfToken] ); for(uint i = 0; i < _recipients.length; i++) { if(_recipients[i] != address(0)) { token.transferFrom(msg.sender, _recipients[i], _value); } } if(tokenHasFreeTrial(_addressOfToken)) { trialDrops[_addressOfToken] = trialDrops[_addressOfToken].add(_recipients.length); } else { updateMsgSenderBonusDrops(_recipients.length); } AirdropInvoked(msg.sender, _recipients.length); return true; } /** * Allows for the distribution of an ERC20 token to be transferred to up to 100 recipients at * a time. This function facilitates batch transfers of differing values (i.e., all recipients * can receive different amounts of tokens). * * @param _addressOfToken The contract address of an ERC20 token. * @param _recipients The list of addresses which will receive tokens. * @param _values The corresponding values of tokens which each address will receive. * * @return true if function executes successfully, false otherwise. * */ function multiValueAirdrop(address _addressOfToken,  address[] _recipients, uint256[] _values) public returns(bool) { ERCInterface token = ERCInterface(_addressOfToken); require( _recipients.length <= maxDropsPerTx && _recipients.length == _values.length && ( getTotalDropsOf(msg.sender) >= _recipients.length || tokenHasFreeTrial(_addressOfToken) ) && !tokenIsBanned[_addressOfToken] ); for(uint i = 0; i < _recipients.length; i++) { if(_recipients[i] != address(0) && _values[i] > 0) { token.transferFrom(msg.sender, _recipients[i], _values[i]); } } if(tokenHasFreeTrial(_addressOfToken)) { trialDrops[_addressOfToken] = trialDrops[_addressOfToken].add(_recipients.length); } else { updateMsgSenderBonusDrops(_recipients.length); } AirdropInvoked(msg.sender, _recipients.length); return true; } /** * Invoked internally by the airdrop functions. The purpose of thie function is to grant bonus * drops to users who spend their ETH airdropping tokens, and to remove bonus drops when users * no longer have ETH in their account but do have some bonus drops when airdropping tokens. * * @param _drops The amount of recipients which received tokens from the airdrop. * */ function updateMsgSenderBonusDrops(uint256 _drops) internal { if(_drops <= getDropsOf(msg.sender)) { bonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].add(_drops.mul(bonus).div(100)); ethBalanceOf[msg.sender] = ethBalanceOf[msg.sender].sub(_drops.mul(dropUnitPrice)); owner.transfer(_drops.mul(dropUnitPrice)); } else { uint256 remainder = _drops.sub(getDropsOf(msg.sender)); if(ethBalanceOf[msg.sender] > 0) { bonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].add(getDropsOf(msg.sender).mul(bonus).div(100)); owner.transfer(ethBalanceOf[msg.sender]); ethBalanceOf[msg.sender] = 0; } bonusDropsOf[msg.sender] = bonusDropsOf[msg.sender].sub(remainder); } } /** * Allows for any ERC20 tokens which have been mistakenly  sent to this contract to be returned * to the original sender by the owner of the contract. Any attempt made by any other account * to invoke the function will result in a loss of gas and no tokens will be transferred out. * * @param _addressOfToken The contract address of an ERC20 token. * @param _recipient The address which will receive tokens. * @param _value The amount of tokens to refund. * * @return true if function executes successfully, false otherwise. * */ function withdrawERC20Tokens(address _addressOfToken,  address _recipient, uint256 _value) public onlyOwner returns(bool){ require( _addressOfToken != address(0) && _recipient != address(0) && _value > 0 ); ERCInterface token = ERCInterface(_addressOfToken); token.transfer(_recipient, _value); ERC20TokensWithdrawn(_addressOfToken, _recipient, _value); return true; } } "}
{"sol name": "225.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { if (_a == 0) { return 0; } uint256 c = _a * _b; require(c / _a == _b); return c; } function div(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b > 0); // Solidity only automatically asserts when dividing by 0 uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { require(_b <= _a); uint256 c = _a - _b; return c; } function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; require(c >= _a); return c; } function mod(uint256 a, uint256 b) internal pure returns (uint256) { require(b != 0); return a % b; } } contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20 { using SafeMath for uint256; mapping (address => uint256) private balances; mapping (address => mapping (address => uint256)) private allowed; uint256 private totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function _mint(address _account, uint256 _amount) internal { require(_account != 0); totalSupply_ = totalSupply_.add(_amount); balances[_account] = balances[_account].add(_amount); emit Transfer(address(0), _account, _amount); } function _burn(address _account, uint256 _amount) internal { require(_account != 0); require(_amount <= balances[_account]); totalSupply_ = totalSupply_.sub(_amount); balances[_account] = balances[_account].sub(_amount); emit Transfer(_account, address(0), _amount); } function _burnFrom(address _account, uint256 _amount) internal { require(_amount <= allowed[_account][msg.sender]); allowed[_account][msg.sender] = allowed[_account][msg.sender].sub(_amount); _burn(_account, _amount); } } "}
{"sol name": "727.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /**************************************************************************** *                   ******MAJz Token Smart Contract******                   * *                   Symbol      :   MAZ                                     * *                   Name        :   MAJz                                    * *                   Total Supply:   560 000 000                             * *                   Decimals    :   18                                      * *                   Almar Blockchain Technology                             * *                   *************************************                   * ****************************************************************************/ /**************************************************************************** *                       Safemath Library                                    * *                       to prevent Over / Underflow                         * ****************************************************************************/ library SafeMath { function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0){return 0;} c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } } /**************************************************************************** *                   Standart ERC20 Token Interface                          * *                   Contains Standart Token Functionalities                 * ****************************************************************************/ contract ERC20Token { function totalSupply() public view returns (uint256); function balanceOf(address _targetAddress) public view returns (uint256); function transfer(address _targetAddress, uint256 _value) public returns (bool); event Transfer(address indexed _originAddress, address indexed _targetAddress, uint256 _value); function allowance(address _originAddress, address _targetAddress) public view returns (uint256); function approve(address _originAddress, uint256 _value) public returns (bool); function transferFrom(address _originAddress, address _targetAddress, uint256 _value) public returns (bool); event Approval(address indexed _originAddress, address indexed _targetAddress, uint256 _value); } /**************************************************************************** *                       Ownership Contract                                  * *                       for authorization Control                           * ****************************************************************************/ contract Ownership { address public owner; modifier onlyOwner() { require(msg.sender == owner); _; } modifier validDestination(address _targetAddress) { require(_targetAddress != address(0x0)); _; } } /**************************************************************************** *                       The Token Contract                                  * *                       with Extended funtionalities                        * ****************************************************************************/ contract MAJz is ERC20Token, Ownership { using SafeMath for uint256; string public symbol; string public name; uint256 public decimals; uint256 public totalSupply; mapping(address => uint256) public balances; mapping(address => mapping(address => uint256)) allowed; //Constructor of the Token constructor() public{ symbol = \"MAZ\"; name = \"MAJz\"; decimals = 18; totalSupply = 560000000000000000000000000; balances[msg.sender] = totalSupply; owner = msg.sender; emit Transfer(address(0), msg.sender, totalSupply); } /**************************************************************************** *                   Basic Token Functions                                   * ****************************************************************************/ //Returns the totalSupply function totalSupply() public view returns (uint256) { return totalSupply; } //Return the balance of an specified account function balanceOf(address _targetAddress) public view returns (uint256) { return balances[_targetAddress]; } //Transfer function. Validates targetAdress not to be 0x0 function transfer(address _targetAddress, uint256 _value) validDestination(_targetAddress) public returns (bool) { balances[msg.sender] = SafeMath.sub(balances[msg.sender], _value); //SafeMath will throw if value > balance balances[_targetAddress] = SafeMath.add(balances[_targetAddress], _value); emit Transfer(msg.sender, _targetAddress, _value); return true; } /**************************************************************************** *                   ERC20 Token Functions                                   * ****************************************************************************/ function allowance(address _originAddress, address _targetAddress) public view returns (uint256){ return allowed[_originAddress][_targetAddress]; } function approve(address _targetAddress, uint256 _value) public returns (bool) { allowed[msg.sender][_targetAddress] = _value; emit Approval(msg.sender, _targetAddress, _value); return true; } function transferFrom(address _originAddress, address _targetAddress, uint256 _value) public returns (bool) { balances[_originAddress] = SafeMath.sub(balances[_originAddress], _value); //SafeMath will throw if _value> balanceOf[_originAddress] allowed[_originAddress][msg.sender] = SafeMath.sub(allowed[_originAddress][msg.sender], _value); //SafeMath will throw if _value > allowance balances[_targetAddress] = SafeMath.add(balances[_targetAddress], _value); emit Transfer(_originAddress, _targetAddress, _value); return true; } function () public payable { revert(); } /**************************************************************************** *                   Extended Functionalites                                 * ****************************************************************************/ //Burn the specified amount (_value) of tokens function burnTokens(uint256 _value) public onlyOwner returns (bool){ balances[owner] = SafeMath.sub(balances[owner], _value); //SafeMath will throw if value > balance totalSupply = SafeMath.sub(totalSupply, _value); emit BurnTokens(_value); return true; } //Emit new tokens function emitTokens(uint256 _value) public onlyOwner returns (bool){ balances[owner] = SafeMath.add(balances[owner], _value); //SafeMath will throw if Overflow totalSupply = SafeMath.add(totalSupply, _value); emit EmitTokens(_value); return true; } //Revert a transfer in case of error. onlyOwner function revertTransfer(address _targetAddress, uint256 _value) public onlyOwner returns (bool) { balances[_targetAddress] = SafeMath.sub(balances[_targetAddress], _value); balances[owner] = SafeMath.add(balances[owner], _value); emit RevertTransfer(_targetAddress, _value); return true; } event RevertTransfer(address _targetAddress, uint256 _value); event BurnTokens(uint256 _value); event EmitTokens(uint256 _value); } "}
{"sol name": "113.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract AppCoins { mapping (address => mapping (address => uint256)) public allowance; function balanceOf (address _owner) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (uint); } contract AppCoinsIABInterface { function division(uint numerator, uint denominator) public view returns (uint); function buy(string _packageName, string _sku, uint256 _amount, address _addr_appc, address _dev, address _appstore, address _oem, bytes2 _countryCode) public view returns (bool); } contract AppCoinsIAB is AppCoinsIABInterface { uint public dev_share = 85; uint public appstore_share = 10; uint public oem_share = 5; mapping (address => bool) allowedAddresses; address owner; modifier onlyAllowedAddress(string _funcName) { if(!allowedAddresses[msg.sender]){ emit Error(_funcName, \"Operation can only be performed by allowed Addresses\"); return; } _; } modifier onlyOwner(string _funcName) { if(owner != msg.sender){ emit Error(_funcName, \"Operation can only be performed by contract owner\"); return; } _; } event Buy(string packageName, string _sku, uint _amount, address _from, address _dev, address _appstore, address _oem, bytes2 countryCode); event Error(string func, string message); event OffChainBuy(address _wallet, bytes32 _rootHash); function AppCoinsIAB() public { owner = msg.sender; } function addAllowedAddress(address _account) public onlyOwner(\"addAllowedAddress\"){ allowedAddresses[_account] = true; } function removeAllowedAddress(address _account) public onlyOwner(\"removeAllowedAddress\") { allowedAddresses[_account] = false; } function informOffChainBuy(address[] _walletList, bytes32[] _rootHashList) public onlyAllowedAddress(\"informOffChainTransaction\") { if(_walletList.length != _rootHashList.length){ emit Error(\"informOffChainTransaction\", \"Wallet list and Roothash list must have the same lengths\"); return; } for(uint i = 0; i < _walletList.length; i++){ emit OffChainBuy(_walletList[i],_rootHashList[i]); } } function division(uint _numerator, uint _denominator) public view returns (uint) { uint quotient = _numerator / _denominator; return quotient; } function buy(string _packageName, string _sku, uint256 _amount, address _addr_appc, address _dev, address _appstore, address _oem, bytes2 _countryCode) public view returns (bool) { require(_addr_appc != 0x0); require(_dev != 0x0); require(_appstore != 0x0); require(_oem != 0x0); AppCoins appc = AppCoins(_addr_appc); uint256 aux = appc.allowance(msg.sender, address(this)); if(aux < _amount){ emit Error(\"buy\",\"Not enough allowance\"); return false; } uint[] memory amounts = new uint[](3); amounts[0] = division(_amount * dev_share, 100); amounts[1] = division(_amount * appstore_share, 100); amounts[2] = division(_amount * oem_share, 100); appc.transferFrom(msg.sender, _dev, amounts[0]); appc.transferFrom(msg.sender, _appstore, amounts[1]); appc.transferFrom(msg.sender, _oem, amounts[2]); emit Buy(_packageName, _sku, _amount, msg.sender, _dev, _appstore, _oem, _countryCode); return true; } } "}
{"sol name": "815.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract CPX is SafeMath{ string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function CPX( uint256 initialSupply, string tokenName, string tokenSymbol, address holder)  public{ totalSupply = initialSupply * 10 ** uint256(decimals); // Update total supply balanceOf[holder] = totalSupply;                       // Give the creator all initial tokens name = tokenName;                                      // Set the name for display purposes symbol = tokenSymbol;                                  // Set the symbol for display purposes owner = holder; } /* Send coins */ function transfer(address _to, uint256 _value) public{ require(_to != 0x0);  // Prevent transfer to 0x0 address. Use burn() instead require(_value > 0); require(balanceOf[msg.sender] >= _value);           // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) public returns (bool success) { require(_value > 0); allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_to != 0x0);                                // Prevent transfer to 0x0 address. Use burn() instead require(_value > 0); require(balanceOf[_from] >= _value);                 // Check if the sender has enough require(balanceOf[_to] + _value >= balanceOf[_to]);  // Check for overflows require(_value <= allowance[_from][msg.sender]);     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(msg.sender, _value); return true; } function freeze(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) public returns (bool success) { require(freezeOf[msg.sender] >= _value);            // Check if the sender has enough require(_value > 0); freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } } "}
{"sol name": "650.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract KAA is ERC20,Ownable{ using SafeMath for uint256; //the base info of the token string public constant name=\"KAA\"; string public constant symbol=\"KAA\"; string public constant version = \"1.0\"; uint256 public constant decimals = 18; //\u5e73\u53f0\u57fa\u91d113395000000 uint256 public constant PLATFORM_FUNDING_SUPPLY=13395000000*10**decimals; //\u521b\u59cb\u56e2\u961f13395000000 uint256 public constant TEAM_KEEPING=13395000000*10**decimals; //\u6218\u7565\u4f19\u4f348037000000 uint256 public constant COOPERATE_REWARD=8037000000*10**decimals; //\u5206\u4eab\u5956\u52b18930000000 uint256 public constant SHARDING_REWARD=8930000000*10**decimals; //\u6316\u77ff\u5956\u52b145543000000 uint256 public constant MINING_REWARD=45543000000*10**decimals; //\u53ef\u666e\u901a\u63d0\u73b0\u989d\u5ea68930000000+45543000000=54473000000 uint256 public constant COMMON_WITHDRAW_SUPPLY=SHARDING_REWARD+MINING_REWARD; //\u603b\u53d1\u884c54473000000+13395000000+13395000000+8037000000=89300000000 uint256 public constant MAX_SUPPLY=COMMON_WITHDRAW_SUPPLY+PLATFORM_FUNDING_SUPPLY+TEAM_KEEPING+COOPERATE_REWARD; //\u57fa\u51c6\u65f6\u95f4 uint256 startTime; //\u89e3\u9501\u6b65\u957f\uff0830\u5929\uff09 uint256 unlockStepLong; //\u5e73\u53f0\u5df2\u63d0\u73b0 uint256 platformFundingSupply; //\u5e73\u53f0\u6bcf\u671f\u53ef\u63d0\u73b0 uint256 platformFundingPerEpoch; //\u56e2\u961f\u5df2\u63d0\u73b0 uint256 teamKeepingSupply; //\u56e2\u961f\u6bcf\u671f\u53ef\u63d0\u73b0 uint256 teamKeepingPerEpoch; //\u6218\u7565\u4f19\u4f34\u5df2\u7ecf\u5206\u53d1\u989d\u5ea6 uint256 public cooperateRewardSupply; //\u5df2\u7ecf\u666e\u901a\u63d0\u73b0\u91cf uint256 public totalCommonWithdrawSupply; //\u6218\u7565\u4f19\u4f34\u9501\u4ed3\u603b\u989d\u5ea6 mapping(address=>uint256) public lockAmount; //ERC20\u7684\u4f59\u989d mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; constructor() public{ totalSupply = 0 ; platformFundingSupply=0; teamKeepingSupply=0; cooperateRewardSupply=0; totalCommonWithdrawSupply=0; platformFundingPerEpoch=372083333; teamKeepingPerEpoch=372083333; //\u521d\u59cb\u65f6\u95f4 20180818 startTime = 1534521600; unlockStepLong=2592000; } event CreateKAA(address indexed _to, uint256 _value); modifier notReachTotalSupply(uint256 _value){ assert(MAX_SUPPLY>=totalSupply.add(_value)); _; } //\u5e73\u53f0\u6700\u5927\u63d0\u73b0\u989d\u5ea6 modifier notReachPlatformFundingSupply(uint256 _value){ assert(PLATFORM_FUNDING_SUPPLY>=platformFundingSupply.add(_value)); _; } modifier notReachTeamKeepingSupply(uint256 _value){ assert(TEAM_KEEPING>=teamKeepingSupply.add(_value)); _; } modifier notReachCooperateRewardSupply(uint256 _value){ assert(COOPERATE_REWARD>=cooperateRewardSupply.add(_value)); _; } modifier notReachCommonWithdrawSupply(uint256 _value){ assert(COMMON_WITHDRAW_SUPPLY>=totalCommonWithdrawSupply.add(_value)); _; } //\u7edf\u4e00\u4ee3\u5e01\u5206\u53d1\u51fd\u6570\uff0c\u5185\u90e8\u4f7f\u7528 function processFunding(address receiver,uint256 _value) internal notReachTotalSupply(_value) { uint256 amount=_value; totalSupply=totalSupply.add(amount); balances[receiver]=balances[receiver].add(amount); emit CreateKAA(receiver,amount); emit Transfer(0x0, receiver, amount); } //\u666e\u901a\u5206\u53d1,\u7ed9\u5206\u4eab\u548c\u6316\u77ff\u4f7f\u7528 function commonWithdraw(uint256 _value) external onlyOwner notReachCommonWithdrawSupply(_value) { processFunding(msg.sender,_value); //\u589e\u52a0\u5df2\u7ecf\u666e\u901a\u63d0\u73b0\u4efd\u989d totalCommonWithdrawSupply=totalCommonWithdrawSupply.add(_value); } //\u5e73\u53f0\u57fa\u91d1\u63d0\u5e01\uff08\u4e0d\u6301\u5e01\u9501\u4ed3\uff0c36\u671f\u91ca\u653e\uff09 function withdrawToPlatformFunding(uint256 _value) external onlyOwner notReachPlatformFundingSupply(_value) { //\u5224\u65ad\u53ef\u63d0\u73b0\u989d\u5ea6\u662f\u5426\u8db3\u591f if (!canPlatformFundingWithdraw(_value)) { revert(); }else{ processFunding(msg.sender,_value); //\u5e73\u53f0\u5df2\u63d0\u73b0\u989d\u5ea6 platformFundingSupply=platformFundingSupply.add(_value); } } //\u56e2\u961f\u63d0\u5e01\uff08\u4e0d\u6301\u5e01\u9501\u4ed3\uff0c36\u671f\u91ca\u653e\uff09 function withdrawToTeam(uint256 _value) external onlyOwner notReachTeamKeepingSupply(_value) { //\u5224\u65ad\u53ef\u63d0\u73b0\u989d\u5ea6\u662f\u5426\u8db3\u591f if (!canTeamKeepingWithdraw(_value)) { revert(); }else{ processFunding(msg.sender,_value); //\u56e2\u961f\u5df2\u63d0\u73b0\u989d\u5ea6 teamKeepingSupply=teamKeepingSupply.add(_value); } } //\u63d0\u5e01\u7ed9\u6218\u7565\u4f19\u4f34\uff08\u6301\u5e01\u9501\u4ed3\uff0c36\u671f\u91ca\u653e\uff09 function withdrawToCooperate(address _to,uint256 _value) external onlyOwner notReachCooperateRewardSupply(_value) { processFunding(_to,_value); cooperateRewardSupply=cooperateRewardSupply.add(_value); //\u8bb0\u5f55\u5206\u53d1\u4efd\u989d lockAmount[_to]=lockAmount[_to].add(_value); } //\u5e73\u53f0\u662f\u5426\u53ef\u63d0\u73b0 function canPlatformFundingWithdraw(uint256 _value)internal view returns (bool) { //\u5f53\u524d\u671f\u6570=\uff08\u73b0\u65f6\u95f4-\u521d\u59cb\u65f6\u95f4)/\u671f\u6570\u6b65\u957f uint256 epoch=now.sub(startTime).div(unlockStepLong); //\u5982\u679c\u8d85\u51fa36\u671f\u65f6\u95f4\uff0c\u90a3\u4e48\u5c31\u8bbe\u7f6e\u4e3a36 if (epoch>36) { epoch=36; } //\u8ba1\u7b97\u5df2\u7ecf\u91ca\u653e\u989d\u5ea6 = \u6bcf\u671f\u53ef\u63d0\u73b0\u989d\u5ea6*\u671f\u6570 uint256 releaseAmount = platformFundingPerEpoch.mul(epoch); //\u8ba1\u7b97\u53ef\u63d0\u73b0\u989d\u5ea6=\u5df2\u7ecf\u91ca\u653e\u989d\u5ea6-\u5df2\u7ecf\u63d0\u73b0\u989d\u5ea6 uint256 canWithdrawAmount=releaseAmount.sub(platformFundingSupply); if(canWithdrawAmount>=_value){ return true; }else{ return false; } } function canTeamKeepingWithdraw(uint256 _value)internal view returns (bool) { //\u5f53\u524d\u671f\u6570=\uff08\u73b0\u65f6\u95f4-\u521d\u59cb\u65f6\u95f4)/\u671f\u6570\u6b65\u957f uint256 epoch=now.sub(startTime).div(unlockStepLong); //\u5982\u679c\u8d85\u51fa36\u671f\u65f6\u95f4\uff0c\u90a3\u4e48\u5c31\u8bbe\u7f6e\u4e3a36 if (epoch>36) { epoch=36; } //\u8ba1\u7b97\u5df2\u7ecf\u91ca\u653e\u989d\u5ea6 = \u6bcf\u671f\u53ef\u63d0\u73b0\u989d\u5ea6*\u671f\u6570 uint256 releaseAmount=teamKeepingPerEpoch.mul(epoch); //\u8ba1\u7b97\u53ef\u63d0\u73b0\u989d\u5ea6=\u5df2\u7ecf\u91ca\u653e\u989d\u5ea6-\u5df2\u7ecf\u63d0\u73b0\u989d\u5ea6 uint256 canWithdrawAmount=releaseAmount.sub(teamKeepingSupply); if(canWithdrawAmount>=_value){ return true; }else{ return false; } } function clacCooperateNeedLockAmount(uint256 totalLockAmount)internal view returns (uint256) { //\u5f53\u524d\u671f\u6570=\uff08\u73b0\u65f6\u95f4-\u521d\u59cb\u65f6\u95f4)/\u671f\u6570\u6b65\u957f uint256 epoch=now.sub(startTime).div(unlockStepLong); //\u5982\u679c\u8d85\u51fa36\u671f\u65f6\u95f4\uff0c\u90a3\u4e48\u5c31\u8bbe\u7f6e\u4e3a36 if (epoch>36) { epoch=36; } //\u5269\u4f59\u671f\u6570 uint256 remainingEpoch=uint256(36).sub(epoch); //\u8ba1\u7b97\u6bcf\u671f\u53ef\u91ca\u653e\u8f6c\u8d26\u989d\u5ea6\uff08\u603b\u5206\u53d1\u989d\u5ea6/36\uff09 uint256 cooperatePerEpoch= totalLockAmount.div(36); //\u8ba1\u7b97\u5269\u4f59\u9501\u4ed3\u989d\u5ea6\uff08\u6bcf\u671f\u53ef\u91ca\u653e\u8f6c\u8d26\u989d\u5ea6*\u5269\u4f59\u671f\u6570\uff09 return cooperatePerEpoch.mul(remainingEpoch); } function () payable external { revert(); } //\u8f6c\u8d26\u524d\uff0c\u5148\u6821\u9a8c\u51cf\u53bb\u8f6c\u51fa\u4efd\u989d\u540e\uff0c\u662f\u5426\u5927\u4e8e\u7b49\u4e8e\u9501\u4ed3\u4efd\u989d function transfer(address _to, uint256 _value) public  returns (bool) { require(_to != address(0)); //\u8ba1\u7b97\u9501\u4ed3\u4efd\u989d uint256 needLockBalance=0; if (lockAmount[msg.sender]>0) { needLockBalance=clacCooperateNeedLockAmount(lockAmount[msg.sender]); } require(balances[msg.sender].sub(_value)>=needLockBalance); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } //\u4ece\u59d4\u6258\u4eba\u8d26\u4e0a\u8f6c\u51fa\u4efd\u989d\u65f6\uff0c\u8fd8\u8981\u5224\u65ad\u59d4\u6258\u4eba\u7684\u4f59\u989d-\u8f6c\u51fa\u4efd\u989d\u662f\u5426\u5927\u4e8e\u7b49\u4e8e\u9501\u4ed3\u4efd\u989d function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); //\u8ba1\u7b97\u9501\u4ed3\u4efd\u989d uint256 needLockBalance=0; if (lockAmount[_from]>0) { needLockBalance=clacCooperateNeedLockAmount(lockAmount[_from]); } require(balances[_from].sub(_value)>=needLockBalance); uint256 _allowance = allowed[_from][msg.sender]; balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "527.sol", "label": 0, "sol content": "pragma solidity 0.4.21; contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract ROD is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ROD() public { symbol = \"ROD\"; name = \"NeoWorld Rare Ore D\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "17.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } contract BlockchainId is Ownable { event NewCompany(bytes32 companyId, bytes32 merkleRoot); event ChangeCompany(bytes32 companyId, bytes32 merkleRoot); event DeleteCompany(bytes32 companyId); mapping (bytes32 => bytes32) companyMap; function _createCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit NewCompany(companyId, merkleRoot); } function _createCompanies(bytes32[] companyIds, bytes32[] merkleRoots) public onlyOwner() { require(companyIds.length == merkleRoots.length); for (uint i = 0; i < companyIds.length; i++) { _createCompany(companyIds[i], merkleRoots[i]); } } function getCompany(bytes32 companyId) public view returns (bytes32) { return companyMap[companyId]; } function _updateCompany(bytes32 companyId, bytes32 merkleRoot) public onlyOwner() { companyMap[companyId] = merkleRoot; emit ChangeCompany(companyId, merkleRoot); } function _updateCompanies(bytes32[] companyIds, bytes32[] merkleRoots) public onlyOwner() { require(companyIds.length == merkleRoots.length); for (uint i = 0; i < companyIds.length; i++) { _updateCompany(companyIds[i], merkleRoots[i]); } } function _deleteCompany(bytes32 companyId) public onlyOwner() { delete companyMap[companyId]; emit DeleteCompany(companyId); } } "}
{"sol name": "952.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) public balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } /** * @title CABoxToken * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. */ contract CABoxToken is BurnableToken, Ownable { string public constant name = \"CABox\"; string public constant symbol = \"CAB\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 500 * 1000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ function CABoxToken() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } /** * @title CABoxCrowdsale * @dev CABoxCrowdsale is a completed contract for managing a token crowdsale. * CABoxCrowdsale have a start and end timestamps, where investors can make * token purchases and the CABoxCrowdsale will assign them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. */ contract CABoxCrowdsale is Ownable{ using SafeMath for uint256; // The token being sold CABoxToken public token; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // address where funds are collected address public wallet; // address where development funds are collected address public devWallet; /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); event TokenContractUpdated(bool state); event WalletAddressUpdated(bool state); function CABoxCrowdsale() public { token = createTokenContract(); startTime = 1535155200; endTime = 1540771200; wallet = 0x9BeAbD0aeB08d18612d41210aFEafD08fb84E9E8; devWallet = 0x13dF1d8F51324a237552E87cebC3f501baE2e972; } // creates the token to be sold. // override this method to have crowdsale of a specific token. function createTokenContract() internal returns (CABoxToken) { return new CABoxToken(); } // fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender); } // low level token purchase function function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 bonusRate = getBonusRate(); uint256 tokens = weiAmount.mul(bonusRate); token.transfer(beneficiary, tokens); TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } function getBonusRate() internal view returns (uint256) { uint64[5] memory tokenRates = [uint64(24000),uint64(20000),uint64(16000),uint64(12000),uint64(8000)]; // apply bonus for time uint64[5] memory timeStartsBoundaries = [uint64(1535155200),uint64(1538352000),uint64(1538956800),uint64(1539561600),uint64(1540166400)]; uint64[5] memory timeEndsBoundaries = [uint64(1538352000),uint64(1538956800),uint64(1539561600),uint64(1540166400),uint64(1540771200)]; uint[5] memory timeRates = [uint(500),uint(250),uint(200),uint(150),uint(100)]; uint256 bonusRate = tokenRates[0]; for (uint i = 0; i < 5; i++) { bool timeInBound = (timeStartsBoundaries[i] <= now) && (now < timeEndsBoundaries[i]); if (timeInBound) { bonusRate = tokenRates[i] + tokenRates[i] * timeRates[i] / 1000; } } return bonusRate; } // send ether to the fund collection wallet // override to create custom fund forwarding mechanisms function forwardFunds() internal { wallet.transfer(msg.value * 750 / 1000); devWallet.transfer(msg.value * 250 / 1000); } // @return true if the transaction can buy tokens function validPurchase() internal view returns (bool) { bool nonZeroPurchase = msg.value != 0; bool withinPeriod = now >= startTime && now <= endTime; return nonZeroPurchase && withinPeriod; } // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { bool timeEnded = now > endTime; return timeEnded; } // update token contract function updateCABoxToken(address _tokenAddress) onlyOwner{ require(_tokenAddress != address(0)); token.transferOwnership(_tokenAddress); TokenContractUpdated(true); } // transfer tokens function transferTokens(address _to, uint256 _amount) onlyOwner { require(_to != address(0)); token.transfer(_to, _amount); } } "}
{"sol name": "801.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract BaseToken { string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; assert(balanceOf[_from] + balanceOf[_to] == previousBalances); Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } } contract CustomToken is BaseToken { function CustomToken() public { totalSupply = 1000000000000000000000000000; name = 'InfluenceConstantCoin'; symbol = 'ICC'; decimals = 18; balanceOf[0x3e5a7109e0a1362baf285bc6e39b2ad0995c00dd] = totalSupply; Transfer(address(0), 0x3e5a7109e0a1362baf285bc6e39b2ad0995c00dd, totalSupply); } } "}
{"sol name": "1620.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title Pausable token * * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } } /** * @title Cmm Token * * @dev Implementation of Cmm Token based on the basic standard token. */ contract CmmToken is PausableToken { /** * Public variables of the token * The following variables are OPTIONAL vanities. One does not have to include them. * They allow one to customise the token contract & in no way influences the core functionality. * Some wallets/interfaces might not even bother to look at this information. */ string public name = \"CustomerMarketingManagement\"; string public symbol = \"CMM\"; string public version = '1.0.0'; uint8 public decimals = 2; /** * @dev Function to check the amount of tokens that an owner allowed to a spender. */ function CmmToken() { totalSupply = 1800000000 * (10**(uint256(decimals))); balances[msg.sender] = totalSupply;    // Give the creator all initial tokens } function () { //if ether is sent to this address, send it back. revert(); } } "}
{"sol name": "444.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; // Generated by TokenGen and the Fabric Token platform. // https://tokengen.io // https://fabrictoken.io // File: contracts/library/SafeMath.sol /** * @title Safe Math * * @dev Library for safe mathematical operations. */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function minus(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function plus(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } // File: contracts/token/ERC20Token.sol /** * @dev The standard ERC20 Token contract base. */ contract ERC20Token { uint256 public totalSupply;  /* shorthand for public function and a property */ function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } // File: contracts/token/StandardToken.sol /** * @title Standard Token * * @dev The standard abstract implementation of the ERC20 interface. */ contract StandardToken is ERC20Token { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; /** * @dev The constructor assigns the token name, symbols and decimals. */ constructor(string _name, string _symbol, uint8 _decimals) internal { name = _name; symbol = _symbol; decimals = _decimals; } /** * @dev Get the balance of an address. * * @param _address The address which's balance will be checked. * * @return The current balance of the address. */ function balanceOf(address _address) public view returns (uint256 balance) { return balances[_address]; } /** * @dev Checks the amount of tokens that an owner allowed to a spender. * * @param _owner The address which owns the funds allowed for spending by a third-party. * @param _spender The third-party address that is allowed to spend the tokens. * * @return The number of tokens available to `_spender` to be spent. */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * @dev Give permission to `_spender` to spend `_value` number of tokens on your behalf. * E.g. You place a buy or sell order on an exchange and in that example, the * `_spender` address is the address of the contract the exchange created to add your token to their * website and you are `msg.sender`. * * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. * * @return Whether the approval process was successful or not. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfers `_value` number of tokens to the `_to` address. * * @param _to The address of the recipient. * @param _value The number of tokens to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { executeTransfer(msg.sender, _to, _value); return true; } /** * @dev Allows another contract to spend tokens on behalf of the `_from` address and send them to the `_to` address. * * @param _from The address which approved you to spend tokens on their behalf. * @param _to The address where you want to send tokens. * @param _value The number of tokens to be sent. * * @return Whether the transfer was successful or not. */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] = allowed[_from][msg.sender].minus(_value); executeTransfer(_from, _to, _value); return true; } /** * @dev Internal function that this reused by the transfer functions */ function executeTransfer(address _from, address _to, uint256 _value) internal { require(_to != address(0)); require(_value != 0 && _value <= balances[_from]); balances[_from] = balances[_from].minus(_value); balances[_to] = balances[_to].plus(_value); emit Transfer(_from, _to, _value); } } // File: contracts/token/MintableToken.sol /** * @title Mintable Token * * @dev Allows the creation of new tokens. */ contract MintableToken is StandardToken { /// @dev The only address allowed to mint coins address public minter; /// @dev Indicates whether the token is still mintable. bool public mintingDisabled = false; /** * @dev Event fired when minting is no longer allowed. */ event MintingDisabled(); /** * @dev Allows a function to be executed only if minting is still allowed. */ modifier canMint() { require(!mintingDisabled); _; } /** * @dev Allows a function to be called only by the minter */ modifier onlyMinter() { require(msg.sender == minter); _; } /** * @dev The constructor assigns the minter which is allowed to mind and disable minting */ constructor(address _minter) internal { minter = _minter; } /** * @dev Creates new `_value` number of tokens and sends them to the `_to` address. * * @param _to The address which will receive the freshly minted tokens. * @param _value The number of tokens that will be created. */ function mint(address _to, uint256 _value) onlyMinter canMint public { totalSupply = totalSupply.plus(_value); balances[_to] = balances[_to].plus(_value); emit Transfer(0x0, _to, _value); } /** * @dev Disable the minting of new tokens. Cannot be reversed. * * @return Whether or not the process was successful. */ function disableMinting() onlyMinter canMint public { mintingDisabled = true; emit MintingDisabled(); } } // File: contracts/token/BurnableToken.sol /** * @title Burnable Token * * @dev Allows tokens to be destroyed. */ contract BurnableToken is StandardToken { /** * @dev Event fired when tokens are burned. * * @param _from The address from which tokens will be removed. * @param _value The number of tokens to be destroyed. */ event Burn(address indexed _from, uint256 _value); /** * @dev Burnes `_value` number of tokens. * * @param _value The number of tokens that will be burned. */ function burn(uint256 _value) public { require(_value != 0); address burner = msg.sender; require(_value <= balances[burner]); balances[burner] = balances[burner].minus(_value); totalSupply = totalSupply.minus(_value); emit Burn(burner, _value); emit Transfer(burner, address(0), _value); } } // File: contracts/trait/HasOwner.sol /** * @title HasOwner * * @dev Allows for exclusive access to certain functionality. */ contract HasOwner { // The current owner. address public owner; // Conditionally the new owner. address public newOwner; /** * @dev The constructor. * * @param _owner The address of the owner. */ constructor(address _owner) public { owner = _owner; } /** * @dev Access control modifier that allows only the current owner to call the function. */ modifier onlyOwner { require(msg.sender == owner); _; } /** * @dev The event is fired when the current owner is changed. * * @param _oldOwner The address of the previous owner. * @param _newOwner The address of the new owner. */ event OwnershipTransfer(address indexed _oldOwner, address indexed _newOwner); /** * @dev Transfering the ownership is a two-step process, as we prepare * for the transfer by setting `newOwner` and requiring `newOwner` to accept * the transfer. This prevents accidental lock-out if something goes wrong * when passing the `newOwner` address. * * @param _newOwner The address of the proposed new owner. */ function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } /** * @dev The `newOwner` finishes the ownership transfer process by accepting the * ownership. */ function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransfer(owner, newOwner); owner = newOwner; } } // File: contracts/token/PausableToken.sol /** * @title Pausable Token * * @dev Allows you to pause/unpause transfers of your token. **/ contract PausableToken is StandardToken, HasOwner { /// Indicates whether the token contract is paused or not. bool public paused = false; /** * @dev Event fired when the token contracts gets paused. */ event Pause(); /** * @dev Event fired when the token contracts gets unpaused. */ event Unpause(); /** * @dev Allows a function to be called only when the token contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Pauses the token contract. */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev Unpauses the token contract. */ function unpause() onlyOwner public { require(paused); paused = false; emit Unpause(); } /// Overrides of the standard token's functions to add the paused/unpaused functionality. function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } } // File: contracts/fundraiser/AbstractFundraiser.sol contract AbstractFundraiser { /// The ERC20 token contract. ERC20Token public token; /** * @dev The event fires every time a new buyer enters the fundraiser. * * @param _address The address of the buyer. * @param _ethers The number of ethers funded. * @param _tokens The number of tokens purchased. */ event FundsReceived(address indexed _address, uint _ethers, uint _tokens); /** * @dev The initialization method for the token * * @param _token The address of the token of the fundraiser */ function initializeFundraiserToken(address _token) internal { token = ERC20Token(_token); } /** * @dev The default function which is executed when someone sends funds to this contract address. */ function() public payable { receiveFunds(msg.sender, msg.value); } /** * @dev this overridable function returns the current conversion rate for the fundraiser */ function getConversionRate() public view returns (uint256); /** * @dev checks whether the fundraiser passed `endTime`. * * @return whether the fundraiser has ended. */ function hasEnded() public view returns (bool); /** * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`. * * @param _address The address of the receiver of tokens. * @param _amount The amount of received funds in ether. */ function receiveFunds(address _address, uint256 _amount) internal; /** * @dev It throws an exception if the transaction does not meet the preconditions. */ function validateTransaction() internal view; /** * @dev this overridable function makes and handles tokens to buyers */ function handleTokens(address _address, uint256 _tokens) internal; /** * @dev this overridable function forwards the funds (if necessary) to a vault or directly to the beneficiary */ function handleFunds(address _address, uint256 _ethers) internal; } // File: contracts/fundraiser/BasicFundraiser.sol /** * @title Basic Fundraiser * * @dev An abstract contract that is a base for fundraisers. * It implements a generic procedure for handling received funds: * 1. Validates the transaciton preconditions * 2. Calculates the amount of tokens based on the conversion rate. * 3. Delegate the handling of the tokens (mint, transfer or conjure) * 4. Delegate the handling of the funds * 5. Emit event for received funds */ contract BasicFundraiser is HasOwner, AbstractFundraiser { using SafeMath for uint256; // The number of decimals for the token. uint8 constant DECIMALS = 18;  // Enforced // Decimal factor for multiplication purposes. uint256 constant DECIMALS_FACTOR = 10 ** uint256(DECIMALS); /// The start time of the fundraiser - Unix timestamp. uint256 public startTime; /// The end time of the fundraiser - Unix timestamp. uint256 public endTime; /// The address where funds collected will be sent. address public beneficiary; /// The conversion rate with decimals difference adjustment, /// When converion rate is lower than 1 (inversed), the function calculateTokens() should use division uint256 public conversionRate; /// The total amount of ether raised. uint256 public totalRaised; /** * @dev The event fires when the number of token conversion rate has changed. * * @param _conversionRate The new number of tokens per 1 ether. */ event ConversionRateChanged(uint _conversionRate); /** * @dev The basic fundraiser initialization method. * * @param _startTime The start time of the fundraiser - Unix timestamp. * @param _endTime The end time of the fundraiser - Unix timestamp. * @param _conversionRate The number of tokens create for 1 ETH funded. * @param _beneficiary The address which will receive the funds gathered by the fundraiser. */ function initializeBasicFundraiser( uint256 _startTime, uint256 _endTime, uint256 _conversionRate, address _beneficiary ) internal { require(_endTime >= _startTime); require(_conversionRate > 0); require(_beneficiary != address(0)); startTime = _startTime; endTime = _endTime; conversionRate = _conversionRate; beneficiary = _beneficiary; } /** * @dev Sets the new conversion rate * * @param _conversionRate New conversion rate */ function setConversionRate(uint256 _conversionRate) public onlyOwner { require(_conversionRate > 0); conversionRate = _conversionRate; emit ConversionRateChanged(_conversionRate); } /** * @dev Sets The beneficiary of the fundraiser. * * @param _beneficiary The address of the beneficiary. */ function setBeneficiary(address _beneficiary) public onlyOwner { require(_beneficiary != address(0)); beneficiary = _beneficiary; } /** * @dev Create and sends tokens to `_address` considering amount funded and `conversionRate`. * * @param _address The address of the receiver of tokens. * @param _amount The amount of received funds in ether. */ function receiveFunds(address _address, uint256 _amount) internal { validateTransaction(); uint256 tokens = calculateTokens(_amount); require(tokens > 0); totalRaised = totalRaised.plus(_amount); handleTokens(_address, tokens); handleFunds(_address, _amount); emit FundsReceived(_address, msg.value, tokens); } /** * @dev this overridable function returns the current conversion rate for the fundraiser */ function getConversionRate() public view returns (uint256) { return conversionRate; } /** * @dev this overridable function that calculates the tokens based on the ether amount */ function calculateTokens(uint256 _amount) internal view returns(uint256 tokens) { tokens = _amount.mul(getConversionRate()); } /** * @dev It throws an exception if the transaction does not meet the preconditions. */ function validateTransaction() internal view { require(msg.value != 0); require(now >= startTime && now < endTime); } /** * @dev checks whether the fundraiser passed `endtime`. * * @return whether the fundraiser is passed its deadline or not. */ function hasEnded() public view returns (bool) { return now >= endTime; } } // File: contracts/token/StandardMintableToken.sol contract StandardMintableToken is MintableToken { constructor(address _minter, string _name, string _symbol, uint8 _decimals) StandardToken(_name, _symbol, _decimals) MintableToken(_minter) public { } } // File: contracts/fundraiser/MintableTokenFundraiser.sol /** * @title Fundraiser With Mintable Token */ contract MintableTokenFundraiser is BasicFundraiser { /** * @dev The initialization method that creates a new mintable token. * * @param _name Token name * @param _symbol Token symbol * @param _decimals Token decimals */ function initializeMintableTokenFundraiser(string _name, string _symbol, uint8 _decimals) internal { token = new StandardMintableToken( address(this), // The fundraiser is the token minter _name, _symbol, _decimals ); } /** * @dev Mint the specific amount tokens */ function handleTokens(address _address, uint256 _tokens) internal { MintableToken(token).mint(_address, _tokens); } } // File: contracts/fundraiser/GasPriceLimitFundraiser.sol /** * @title GasPriceLimitFundraiser * * @dev This fundraiser allows to set gas price limit for the participants in the fundraiser */ contract GasPriceLimitFundraiser is HasOwner, BasicFundraiser { uint256 public gasPriceLimit; event GasPriceLimitChanged(uint256 gasPriceLimit); /** * @dev This function puts the initial gas limit */ function initializeGasPriceLimitFundraiser(uint256 _gasPriceLimit) internal { gasPriceLimit = _gasPriceLimit; } /** * @dev This function allows the owner to change the gas limit any time during the fundraiser */ function changeGasPriceLimit(uint256 _gasPriceLimit) onlyOwner() public { gasPriceLimit = _gasPriceLimit; emit GasPriceLimitChanged(_gasPriceLimit); } /** * @dev The transaction is valid if the gas price limit is lifted-off or the transaction meets the requirement */ function validateTransaction() internal view { require(gasPriceLimit == 0 || tx.gasprice <= gasPriceLimit); return super.validateTransaction(); } } // File: contracts/fundraiser/ForwardFundsFundraiser.sol /** * @title Forward Funds to Beneficiary Fundraiser * * @dev This contract forwards the funds received to the beneficiary. */ contract ForwardFundsFundraiser is BasicFundraiser { /** * @dev Forward funds directly to beneficiary */ function handleFunds(address, uint256 _ethers) internal { // Forward the funds directly to the beneficiary beneficiary.transfer(_ethers); } } // File: contracts/Fundraiser.sol /** * @title RealDirectToken */ contract RealDirectToken is MintableToken, BurnableToken, PausableToken { constructor(address _owner, address _minter) StandardToken( \"Real Direct Token\",   // Token name \"RDT\", // Token symbol 18  // Token decimals ) HasOwner(_owner) MintableToken(_minter) public { } } /** * @title RealDirectTokenFundraiser */ contract RealDirectTokenFundraiser is MintableTokenFundraiser, ForwardFundsFundraiser, GasPriceLimitFundraiser { constructor() HasOwner(msg.sender) public { token = new RealDirectToken( msg.sender,  // Owner address(this)  // The fundraiser is the minter ); initializeBasicFundraiser( 1534291200, // Start date = 15 Aug 2018 00:00 UTC 1544918340,  // End date = 15 Dec 2018 23:59 UTC 20000, // Conversion rate = 20000 RDT per 1 ether 0xEcB3c79EB0A9f539340adE65e8823CE8d248fbad     // Beneficiary ); initializeGasPriceLimitFundraiser( 50000000000 // Gas price limit in wei ); } } "}
{"sol name": "1805.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18;  // decimals \u53ef\u4ee5\u6709\u7684\u5c0f\u6570\u70b9\u4e2a\u6570\uff0c\u6700\u5c0f\u7684\u4ee3\u5e01\u5355\u4f4d\u300218 \u662f\u5efa\u8bae\u7684\u9ed8\u8ba4\u503c uint256 public totalSupply; // \u7528mapping\u4fdd\u5b58\u6bcf\u4e2a\u5730\u5740\u5bf9\u5e94\u7684\u4f59\u989d mapping (address => uint256) public balanceOf; // \u5b58\u50a8\u5bf9\u8d26\u53f7\u7684\u63a7\u5236 mapping (address => mapping (address => uint256)) public allowance; // \u4e8b\u4ef6\uff0c\u7528\u6765\u901a\u77e5\u5ba2\u6237\u7aef\u4ea4\u6613\u53d1\u751f event Transfer(address indexed from, address indexed to, uint256 value); // \u4e8b\u4ef6\uff0c\u7528\u6765\u901a\u77e5\u5ba2\u6237\u7aef\u4ee3\u5e01\u88ab\u6d88\u8d39 event Burn(address indexed from, uint256 value); /** * \u521d\u59cb\u5316\u6784\u9020 */ function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // \u4f9b\u5e94\u7684\u4efd\u989d\uff0c\u4efd\u989d\u8ddf\u6700\u5c0f\u7684\u4ee3\u5e01\u5355\u4f4d\u6709\u5173\uff0c\u4efd\u989d = \u5e01\u6570 * 10 ** decimals\u3002 balanceOf[msg.sender] = totalSupply;                // \u521b\u5efa\u8005\u62e5\u6709\u6240\u6709\u7684\u4ee3\u5e01 name = tokenName;                                   // \u4ee3\u5e01\u540d\u79f0 symbol = tokenSymbol;                               // \u4ee3\u5e01\u7b26\u53f7 } /** * \u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb\u7684\u5185\u90e8\u5b9e\u73b0 */ function _transfer(address _from, address _to, uint _value) internal { // \u786e\u4fdd\u76ee\u6807\u5730\u5740\u4e0d\u4e3a0x0\uff0c\u56e0\u4e3a0x0\u5730\u5740\u4ee3\u8868\u9500\u6bc1 require(_to != 0x0); // \u68c0\u67e5\u53d1\u9001\u8005\u4f59\u989d require(balanceOf[_from] >= _value); // \u786e\u4fdd\u8f6c\u79fb\u4e3a\u6b63\u6570\u4e2a require(balanceOf[_to] + _value > balanceOf[_to]); // \u4ee5\u4e0b\u7528\u6765\u68c0\u67e5\u4ea4\u6613\uff0c uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; Transfer(_from, _to, _value); // \u7528assert\u6765\u68c0\u67e5\u4ee3\u7801\u903b\u8f91\u3002 assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** *  \u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb * \u4ece\u81ea\u5df1\uff08\u521b\u5efa\u4ea4\u6613\u8005\uff09\u8d26\u53f7\u53d1\u9001`_value`\u4e2a\u4ee3\u5e01\u5230 `_to`\u8d26\u53f7 * * @param _to \u63a5\u6536\u8005\u5730\u5740 * @param _value \u8f6c\u79fb\u6570\u989d */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * \u8d26\u53f7\u4e4b\u95f4\u4ee3\u5e01\u4ea4\u6613\u8f6c\u79fb * @param _from \u53d1\u9001\u8005\u5730\u5740 * @param _to \u63a5\u6536\u8005\u5730\u5740 * @param _value \u8f6c\u79fb\u6570\u989d */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * \u8bbe\u7f6e\u67d0\u4e2a\u5730\u5740\uff08\u5408\u7ea6\uff09\u53ef\u4ee5\u521b\u5efa\u4ea4\u6613\u8005\u540d\u4e49\u82b1\u8d39\u7684\u4ee3\u5e01\u6570\u3002 * * \u5141\u8bb8\u53d1\u9001\u8005`_spender` \u82b1\u8d39\u4e0d\u591a\u4e8e `_value` \u4e2a\u4ee3\u5e01 * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * \u8bbe\u7f6e\u5141\u8bb8\u4e00\u4e2a\u5730\u5740\uff08\u5408\u7ea6\uff09\u4ee5\u6211\uff08\u521b\u5efa\u4ea4\u6613\u8005\uff09\u7684\u540d\u4e49\u53ef\u6700\u591a\u82b1\u8d39\u7684\u4ee3\u5e01\u6570\u3002 * * @param _spender \u88ab\u6388\u6743\u7684\u5730\u5740\uff08\u5408\u7ea6\uff09 * @param _value \u6700\u5927\u53ef\u82b1\u8d39\u4ee3\u5e01\u6570 * @param _extraData \u53d1\u9001\u7ed9\u5408\u7ea6\u7684\u9644\u52a0\u6570\u636e */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { // \u901a\u77e5\u5408\u7ea6 spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * \u9500\u6bc1\u6211\uff08\u521b\u5efa\u4ea4\u6613\u8005\uff09\u8d26\u6237\u4e2d\u6307\u5b9a\u4e2a\u4ee3\u5e01 */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply Burn(msg.sender, _value); return true; } /** * \u9500\u6bc1\u7528\u6237\u8d26\u6237\u4e2d\u6307\u5b9a\u4e2a\u4ee3\u5e01 * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply Burn(_from, _value); return true; } } "}
{"sol name": "158.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract Wicflight { /* * Potential statuses for the Insurance struct * 0: ongoing * 1: insurance contract resolved normaly and the flight landed before the limit * 2: insurance contract resolved normaly and the flight landed after the limit * 3: insurance contract resolved because cancelled by the user * 4: insurance contract resolved because flight cancelled by the air company * 5: insurance contract resolved because flight redirected * 6: insurance contract resolved because flight diverted */ struct Insurance {          // all the infos related to a single insurance bytes32 productId;           // ID string of the product linked to this insurance uint limitArrivalTime;    // maximum arrival time after which we trigger compensation (timestamp in sec) uint32 premium;           // amount of the premium uint32 indemnity;         // amount of the indemnity uint8 status;             // status of this insurance contract. See comment above for potential values } event InsuranceCreation(    // event sent when a new insurance contract is added to this smart contract bytes32 flightId,         // <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date> uint32 premium,           // amount of the premium paid by the user uint32 indemnity,         // amount of the potential indemnity bytes32 productId            // ID string of the product linked to this insurance ); /* * Potential statuses for the InsuranceUpdate event * 1: flight landed before the limit * 2: flight landed after the limit * 3: insurance contract cancelled by the user * 4: flight cancelled * 5: flight redirected * 6: flight diverted */ event InsuranceUpdate(      // event sent when the situation of a particular insurance contract is resolved bytes32 productId,           // id string of the user linked to this account bytes32 flightId,         // <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date> uint32 premium,           // amount of the premium paid by the user uint32 indemnity,         // amount of the potential indemnity uint8 status              // new status of the insurance contract. See above comment for potential values ); address creator;            // address of the creator of the contract // All the insurances handled by this smart contract are contained in this mapping // key: a string containing the flight number and the timestamp separated by a dot // value: an array of insurance contracts for this flight mapping (bytes32 => Insurance[]) insuranceList; // ------------------------------------------------------------------------------------------ // // MODIFIERS / CONSTRUCTOR // ------------------------------------------------------------------------------------------ // /** * @dev This modifier checks that only the creator of the contract can call this smart contract */ modifier onlyIfCreator { if (msg.sender == creator) _; } /** * @dev Constructor */ function Wicflight() public { creator = msg.sender; } // ------------------------------------------------------------------------------------------ // // INTERNAL FUNCTIONS // ------------------------------------------------------------------------------------------ // function areStringsEqual (bytes32 a, bytes32 b) private pure returns (bool) { // generate a hash for each string and compare them return keccak256(a) == keccak256(b); } // ------------------------------------------------------------------------------------------ // // FUNCTIONS TRIGGERING TRANSACTIONS // ------------------------------------------------------------------------------------------ // /** * @dev Add a new insurance for the given flight * @param flightId <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date> * @param limitArrivalTime Maximum time after which we trigger the compensation (timestamp in sec) * @param premium Amount of premium paid by the client * @param indemnity Amount (potentialy) perceived by the client * @param productId ID string of product linked to the insurance */ function addNewInsurance( bytes32 flightId, uint limitArrivalTime, uint32 premium, uint32 indemnity, bytes32 productId) public onlyIfCreator { Insurance memory insuranceToAdd; insuranceToAdd.limitArrivalTime = limitArrivalTime; insuranceToAdd.premium = premium; insuranceToAdd.indemnity = indemnity; insuranceToAdd.productId = productId; insuranceToAdd.status = 0; insuranceList[flightId].push(insuranceToAdd); // send an event about the creation of this insurance contract InsuranceCreation(flightId, premium, indemnity, productId); } /** * @dev Update the status of a flight * @param flightId <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date> * @param actualArrivalTime The actual arrival time of the flight (timestamp in sec) */ function updateFlightStatus( bytes32 flightId, uint actualArrivalTime) public onlyIfCreator { uint8 newStatus = 1; // go through the list of all insurances related to the given flight for (uint i = 0; i < insuranceList[flightId].length; i++) { // we check this contract is still ongoing before updating it if (insuranceList[flightId][i].status == 0) { newStatus = 1; // if the actual arrival time is over the limit the user wanted, // we trigger the indemnity, which means status = 2 if (actualArrivalTime > insuranceList[flightId][i].limitArrivalTime) { newStatus = 2; } // update the status of the insurance contract insuranceList[flightId][i].status = newStatus; // send an event about this update for each insurance InsuranceUpdate( insuranceList[flightId][i].productId, flightId, insuranceList[flightId][i].premium, insuranceList[flightId][i].indemnity, newStatus ); } } } /** * @dev Manually resolve an insurance contract * @param flightId <carrier_code><flight_number>.<timestamp_in_sec_of_departure_date> * @param newStatusId ID of the resolution status for this insurance contract * @param productId ID string of the product linked to the insurance */ function manualInsuranceResolution( bytes32 flightId, uint8 newStatusId, bytes32 productId) public onlyIfCreator { // go through the list of all insurances related to the given flight for (uint i = 0; i < insuranceList[flightId].length; i++) { // look for the insurance contract with the correct ID number if (areStringsEqual(insuranceList[flightId][i].productId, productId)) { // we check this contract is still ongoing before updating it if (insuranceList[flightId][i].status == 0) { // change the status of the insurance contract to the specified one insuranceList[flightId][i].status = newStatusId; // send an event about this update InsuranceUpdate( productId, flightId, insuranceList[flightId][i].premium, insuranceList[flightId][i].indemnity, newStatusId ); return; } } } } function getInsurancesCount(bytes32 flightId) public view onlyIfCreator returns (uint) { return insuranceList[flightId].length; } function getInsurance(bytes32 flightId, uint index) public view onlyIfCreator returns (bytes32, uint, uint32, uint32, uint8) { Insurance memory ins = insuranceList[flightId][index]; return (ins.productId, ins.limitArrivalTime, ins.premium, ins.indemnity, ins.status); } } "}
{"sol name": "163.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract CXYToken is StandardToken { address public admin; string public name = \"CXYToken\"; string public symbol = \"CXY\"; uint8 public decimals = 8; uint256 public INITIAL_SUPPLY = 100000000000000000; mapping (address => bool) public frozenAccount; //\u65e0\u9650\u671f\u51bb\u7ed3\u7684\u8d26\u6237 mapping (address => uint256) public frozenTimestamp; // \u6709\u9650\u671f\u51bb\u7ed3\u7684\u8d26\u6237 event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); constructor() public { totalSupply_ = INITIAL_SUPPLY; admin = msg.sender; balances[msg.sender] = INITIAL_SUPPLY; } function() public payable { require(msg.value > 0); } function changeAdmin( address _newAdmin ) public returns (bool)  { require(msg.sender == admin); require(_newAdmin != address(0)); balances[_newAdmin] = balances[_newAdmin].add(balances[admin]); balances[admin] = 0; admin = _newAdmin; return true; } function generateToken( address _target, uint256 _amount ) public returns (bool)  { require(msg.sender == admin); require(_target != address(0)); balances[_target] = balances[_target].add(_amount); totalSupply_ = totalSupply_.add(_amount); INITIAL_SUPPLY = totalSupply_; return true; } function withdraw ( uint256 _amount ) public returns (bool) { require(msg.sender == admin); msg.sender.transfer(_amount); return true; } function freeze( address _target, bool _freeze ) public returns (bool) { require(msg.sender == admin); require(_target != address(0)); frozenAccount[_target] = _freeze; return true; } function freezeWithTimestamp( address _target, uint256 _timestamp ) public returns (bool) { require(msg.sender == admin); require(_target != address(0)); frozenTimestamp[_target] = _timestamp; return true; } function multiFreeze( address[] _targets, bool[] _freezes ) public returns (bool) { require(msg.sender == admin); require(_targets.length == _freezes.length); uint256 len = _targets.length; require(len > 0); for (uint256 i = 0; i < len; i = i.add(1)) { address _target = _targets[i]; require(_target != address(0)); bool _freeze = _freezes[i]; frozenAccount[_target] = _freeze; } return true; } function multiFreezeWithTimestamp( address[] _targets, uint256[] _timestamps ) public returns (bool) { require(msg.sender == admin); require(_targets.length == _timestamps.length); uint256 len = _targets.length; require(len > 0); for (uint256 i = 0; i < len; i = i.add(1)) { address _target = _targets[i]; require(_target != address(0)); uint256 _timestamp = _timestamps[i]; frozenTimestamp[_target] = _timestamp; } return true; } function multiTransfer( address[] _tos, uint256[] _values ) public returns (bool) { require(!frozenAccount[msg.sender]); require(now > frozenTimestamp[msg.sender]); require(_tos.length == _values.length); uint256 len = _tos.length; require(len > 0); uint256 amount = 0; for (uint256 i = 0; i < len; i = i.add(1)) { amount = amount.add(_values[i]); } require(amount <= balances[msg.sender]); for (uint256 j = 0; j < len; j = j.add(1)) { address _to = _tos[j]; require(_to != address(0)); balances[_to] = balances[_to].add(_values[j]); balances[msg.sender] = balances[msg.sender].sub(_values[j]); emit Transfer(msg.sender, _to, _values[j]); } return true; } function transfer( address _to, uint256 _value ) public returns (bool) { require(!frozenAccount[msg.sender]); require(now > frozenTimestamp[msg.sender]); require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(!frozenAccount[_from]); require(now > frozenTimestamp[msg.sender]); require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve( address _spender, uint256 _value ) public returns (bool) { require(_value <= balances[_spender]); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]);   // Check if the sender has enough balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender totalSupply_ = totalSupply_.sub(_value); INITIAL_SUPPLY = totalSupply_; emit Burn(msg.sender, _value); return true; } function getFrozenTimestamp( address _target ) public view returns (uint256) { require(_target != address(0)); return frozenTimestamp[_target]; } function getFrozenAccount( address _target ) public view returns (bool) { require(_target != address(0)); return frozenAccount[_target]; } function getBalance(address _owner) public view returns (uint256) { return balances[_owner]; } function setName ( string _value ) public returns (bool) { require(msg.sender == admin); name = _value; return true; } function setSymbol ( string _value ) public returns (bool) { require(msg.sender == admin); symbol = _value; return true; } function kill() public { require(msg.sender == admin); selfdestruct(admin); } } "}
{"sol name": "1622.sol", "label": 0, "sol content": "pragma solidity 0.4.24; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnboundedRegularToken is RegularToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract MASIKIToken is UnboundedRegularToken { uint public totalSupply = 201000000000000000000000000; uint8 constant public decimals = 18; string constant public name = \"MASIKIToken\"; string constant public symbol = \"MSK\"; function MASIKIToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "895.sol", "label": 0, "sol content": "/* Copyright 2018 Jobs Dealings Anteil Intl. Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. */ pragma solidity 0.4.24; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract StandardToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnlimitedAllowanceToken is StandardToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited allowance. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract JDAnteil is UnlimitedAllowanceToken { uint8 constant public decimals = 8; uint public totalSupply = 10**17; // 1 billion tokens, 8 decimal places string constant public name = \"Jobs Dealings Anteil\"; string constant public symbol = \"JDA\"; function JDAnteil() { balances[msg.sender] = totalSupply; } } "}
{"sol name": "386.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract CAECToken { using SafeMath for uint256; string public name = \"CarEasyChain\"; string public symbol = \"CAEC\"; uint8 public decimals = 18; uint256 public totalSupply = 10000000000 ether; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function CAECToken() public { balanceOf[msg.sender] = totalSupply; } function () external payable { } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "1947.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract SNOVToken { function transfer(address _to, uint256 _value) public returns (bool success); } contract MultiOwnable { mapping(address => bool) ownerMap; address[] public owners; event OwnerAdded(address indexed _newOwner); event OwnerRemoved(address indexed _oldOwner); modifier onlyOwner() { require(isOwner(msg.sender)); _; } constructor() public { // Add default owner address owner = msg.sender; ownerMap[owner] = true; owners.push(owner); } function ownerCount() public constant returns (uint256) { return owners.length; } function isOwner(address owner) public constant returns (bool) { return ownerMap[owner]; } function addOwner(address owner) public onlyOwner returns (bool) { if (!isOwner(owner) && owner != 0) { ownerMap[owner] = true; owners.push(owner); emit OwnerAdded(owner); return true; } else return false; } function removeOwner(address owner) public onlyOwner returns (bool) { if (isOwner(owner)) { ownerMap[owner] = false; for (uint i = 0; i < owners.length - 1; i++) { if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } } owners.length -= 1; emit OwnerRemoved(owner); return true; } else return false; } } contract MultiTransfer is MultiOwnable { function MultiTransaction(address _tokenAddress, address[] _addresses, uint256[] _values) public onlyOwner { SNOVToken token = SNOVToken(_tokenAddress); for (uint256 i = 0; i < _addresses.length; i++) { token.transfer(_addresses[i], _values[i]); } } } "}
{"sol name": "616.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //\u56fd\u9645\u8d85\u5bfc\u80fd\u6e90\u94fe supper conductor energy blockchain string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "1854.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) {return 0;} uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20{ using SafeMath for uint256; function balanceOf(address _owner)public view returns (uint256 balance); function transfer(address _to, uint256 _value)public returns (bool success); function transferFrom(address _from, address _to, uint256 _value)public returns (bool success); function approve(address _spender, uint256 _value)public returns (bool success); function allowance(address _owner, address _spender)public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract VTToken is ERC20{ string public name   = \"Virtual Talk\"; string public symbol = \"VT\"; uint8 public decimals=18; uint256 public totalSupply; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; constructor(uint256 initialSupply)public{ totalSupply = initialSupply * 10 ** uint256(decimals); balances[msg.sender] = totalSupply; } function balanceOf(address _owner)public view returns (uint256 balance){ return balances[_owner]; } function transfer(address _to, uint256 _value)public returns (bool success){ require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value)public returns (bool success){ require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value)public returns (bool success){ allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender)public view returns (uint256 remaining){ return allowed[_owner][_spender]; } } "}
{"sol name": "1913.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract F4Devents { // fired whenever a player registers a name event onNewName ( uint256 indexed playerID, address indexed playerAddress, bytes32 indexed playerName, bool isNewPlayer, uint256 affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 amountPaid, uint256 timeStamp ); // fired at end of buy or reload event onEndTx ( uint256 compressedData, uint256 compressedIDs, bytes32 playerName, address playerAddress, uint256 ethIn, uint256 keysBought, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount, uint256 potAmount ); // fired whenever theres a withdraw event onWithdraw ( uint256 indexed playerID, address playerAddress, bytes32 playerName, uint256 ethOut, uint256 timeStamp ); // fired whenever a withdraw forces end round to be ran event onWithdrawAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethOut, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (FoMo4D long only) fired whenever a player tries a buy after round timer // hit zero, and causes end round to be ran. event onBuyAndDistribute ( address playerAddress, bytes32 playerName, uint256 ethIn, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // (FoMo4D long only) fired whenever a player tries a reload after round timer // hit zero, and causes end round to be ran. event onReLoadAndDistribute ( address playerAddress, bytes32 playerName, uint256 compressedData, uint256 compressedIDs, address winnerAddr, bytes32 winnerName, uint256 amountWon, uint256 newPot, uint256 P3DAmount, uint256 genAmount ); // fired whenever an affiliate is paid event onAffiliatePayout ( uint256 indexed affiliateID, address affiliateAddress, bytes32 affiliateName, uint256 indexed roundID, uint256 indexed buyerID, uint256 amount, uint256 timeStamp ); // received pot swap deposit event onPotSwapDeposit ( uint256 roundID, uint256 amountAddedToPot ); } contract FoMo4DSoon is F4Devents{ using SafeMath for uint256; using NameFilter for string; using F4DKeysCalcFast for uint256; address private owner_; PlayerBookInterface constant private PlayerBook = PlayerBookInterface(0xeB367060583fd067Edec36202339360071e617Db); string constant public name = \"Fomo4D Soon\"; string constant public symbol = \"F4D\"; uint256 private rndGap_ = 60 seconds;                       // length of ICO phase, set to 1 year for EOS. uint256 constant private rndInit_ = 5 minutes;              // round timer starts at this uint256 constant private rndInc_ = 5 minutes;               // every full key purchased adds this much to the timer uint256 constant private rndMax_ = 5 minutes;               // max length a round timer can be uint256 public rID_;    // round id number / total rounds that have happened //**************** // PLAYER DATA //**************** mapping (address => uint256) public pIDxAddr_;          // (addr => pID) returns player id by address mapping (bytes32 => uint256) public pIDxName_;          // (name => pID) returns player id by name mapping (uint256 => F4Ddatasets.Player) public plyr_;   // (pID => data) player data mapping (uint256 => mapping (uint256 => F4Ddatasets.PlayerRounds)) public plyrRnds_;    // (pID => rID => data) player round data by player id & round id mapping (uint256 => mapping (bytes32 => bool)) public plyrNames_; // (pID => name => bool) list of names a player owns.  (used so you can change your display name amongst any name you own) //**************** // ROUND DATA //**************** mapping (uint256 => F4Ddatasets.Round) public round_;   // (rID => data) round data mapping (uint256 => mapping(uint256 => uint256)) public rndTmEth_;      // (rID => tID => data) eth in per team, by round id and team id //**************** // TEAM FEE DATA //**************** mapping (uint256 => F4Ddatasets.TeamFee) public fees_;          // (team => fees) fee distribution by team mapping (uint256 => F4Ddatasets.PotSplit) public potSplit_;     // (team => fees) pot split distribution by team constructor() public { owner_ = msg.sender; // Team allocation structures // 0 = whales // 1 = bears // 2 = sneks // 3 = bulls fees_[0] = F4Ddatasets.TeamFee(24); fees_[1] = F4Ddatasets.TeamFee(38); fees_[2] = F4Ddatasets.TeamFee(50); fees_[3] = F4Ddatasets.TeamFee(42); potSplit_[0] = F4Ddatasets.PotSplit(12); potSplit_[1] = F4Ddatasets.PotSplit(19); potSplit_[2] = F4Ddatasets.PotSplit(26); potSplit_[3] = F4Ddatasets.PotSplit(30); } /** * @dev used to make sure no one can interact with contract until it has * been activated. */ modifier isActivated() { require(activated_ == true, \"its not ready yet.  check ?eta in discord\"); _; } /** * @dev prevents contracts from interacting with FoMo4D */ modifier isHuman() { address _addr = msg.sender; require (_addr == tx.origin); uint256 _codeLength; assembly {_codeLength := extcodesize(_addr)} require(_codeLength == 0, \"sorry humans only\"); _; } /** * @dev sets boundaries for incoming tx */ modifier isWithinLimits(uint256 _eth) { require(_eth >= 1000000000, \"pocket lint: not a valid currency\"); require(_eth <= 100000000000000000000000, \"no vitalik, no\");    /** NOTE THIS NEEDS TO BE CHECKED **/ _; } /** * @dev emergency buy uses last stored affiliate ID and team snek */ function() isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F4Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // buy core buyCore(_pID, plyr_[_pID].laff, 2, _eventData_); } /** * @dev converts all incoming ethereum to keys. * -functionhash- 0x8f38f309 (using ID for affiliate) * -functionhash- 0x98a0871d (using address for affiliate) * -functionhash- 0xa65b37a1 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? */ function buyXid(uint256 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F4Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affCode, _team, _eventData_); } function buyXaddr(address _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F4Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } function buyXname(bytes32 _affCode, uint256 _team) isActivated() isHuman() isWithinLimits(msg.value) public payable { // set up our tx event data and determine if player is new or not F4Ddatasets.EventReturns memory _eventData_ = determinePID(_eventData_); // fetch player id uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // buy core buyCore(_pID, _affID, _team, _eventData_); } /** * @dev essentially the same as buy, but instead of you sending ether * from your wallet, it uses your unwithdrawn earnings. * -functionhash- 0x349cdcac (using ID for affiliate) * -functionhash- 0x82bfc739 (using address for affiliate) * -functionhash- 0x079ce327 (using name for affiliate) * @param _affCode the ID/address/name of the player who gets the affiliate fee * @param _team what team is the player playing for? * @param _eth amount of earnings to use (remainder returned to gen vault) */ function reLoadXid(uint256 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F4Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals // if no affiliate code was given or player tried to use their own, lolz if (_affCode == 0 || _affCode == _pID) { // use last stored affiliate code _affCode = plyr_[_pID].laff; // if affiliate code was given & its not the same as previously stored } else if (_affCode != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affCode; } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affCode, _team, _eth, _eventData_); } function reLoadXaddr(address _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F4Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == address(0) || _affCode == msg.sender) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxAddr_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } function reLoadXname(bytes32 _affCode, uint256 _team, uint256 _eth) isActivated() isHuman() isWithinLimits(_eth) public { // set up our tx event data F4Ddatasets.EventReturns memory _eventData_; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // manage affiliate residuals uint256 _affID; // if no affiliate code was given or player tried to use their own, lolz if (_affCode == '' || _affCode == plyr_[_pID].name) { // use last stored affiliate code _affID = plyr_[_pID].laff; // if affiliate code was given } else { // get affiliate ID from aff Code _affID = pIDxName_[_affCode]; // if affID is not the same as previously stored if (_affID != plyr_[_pID].laff) { // update last affiliate plyr_[_pID].laff = _affID; } } // verify a valid team was selected _team = verifyTeam(_team); // reload core reLoadCore(_pID, _affID, _team, _eth, _eventData_); } /** * @dev withdraws all of your earnings. * -functionhash- 0x3ccfd60b */ function withdraw() isActivated() isHuman() public { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // fetch player ID uint256 _pID = pIDxAddr_[msg.sender]; // setup temp var for player eth uint256 _eth; // check to see if round has ended and no one has run round end yet if (_now > round_[_rID].end && round_[_rID].ended == false) { // set up our tx event data F4Ddatasets.EventReturns memory _eventData_; // end the round (distributes pot) round_[_rID].ended = true; _eventData_ = endRound(_eventData_); // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // build event data _eventData_.compressedData = _eventData_.compressedData + (_now * 1000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID; // fire withdraw and distribute event emit F4Devents.onWithdrawAndDistribute ( msg.sender, plyr_[_pID].name, _eth, _eventData_.compressedData, _eventData_.compressedIDs, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount ); // in any other situation } else { // get their earnings _eth = withdrawEarnings(_pID); // gib moni if (_eth > 0) plyr_[_pID].addr.transfer(_eth); // fire withdraw event emit F4Devents.onWithdraw(_pID, msg.sender, plyr_[_pID].name, _eth, _now); } } /** * @dev use these to register names.  they are just wrappers that will send the * registration requests to the PlayerBook contract.  So registering here is the * same as registering there.  UI will always display the last name you registered. * but you will still own all previously registered names to use as affiliate * links. * - must pay a registration fee. * - name must be unique * - names will be converted to lowercase * - name cannot start or end with a space * - cannot have more than 1 space in a row * - cannot be only numbers * - cannot start with 0x * - name must be at least 1 char * - max length of 32 characters long * - allowed characters: a-z, 0-9, and space * -functionhash- 0x921dec21 (using ID for affiliate) * -functionhash- 0x3ddd4698 (using address for affiliate) * -functionhash- 0x685ffd83 (using name for affiliate) * @param _nameString players desired name * @param _affCode affiliate ID, address, or name of who referred you * @param _all set to true if you want this to push your info to all games * (this might cost a lot of gas) */ function registerNameXID(string _nameString, uint256 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXIDFromDapp.value(_paid)(_addr, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F4Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXaddr(string _nameString, address _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXaddrFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F4Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } function registerNameXname(string _nameString, bytes32 _affCode, bool _all) isHuman() public payable { bytes32 _name = _nameString.nameFilter(); address _addr = msg.sender; uint256 _paid = msg.value; (bool _isNewPlayer, uint256 _affID) = PlayerBook.registerNameXnameFromDapp.value(msg.value)(msg.sender, _name, _affCode, _all); uint256 _pID = pIDxAddr_[_addr]; // fire event emit F4Devents.onNewName(_pID, _addr, _name, _isNewPlayer, _affID, plyr_[_affID].addr, plyr_[_affID].name, _paid, now); } /** * @dev return the price buyer will pay for next 1 individual key. * - during live round.  this is accurate. (well... unless someone buys before * you do and ups the price!  you better HURRY!) * - during ICO phase.  this is the max you would get based on current eth * invested during ICO phase.  if others invest after you, you will receive * less.  (so distract them with meme vids till ICO is over) * -functionhash- 0x018a25e8 * @return price for next key bought (in wei format) */ function getBuyPrice() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // is ICO phase over??  & theres eth in the round? if (_now > round_[_rID].strt + rndGap_ && round_[_rID].eth != 0 && _now <= round_[_rID].end) return ( (round_[_rID].keys.add(1000000000000000000)).ethRec(1000000000000000000) ); else if (_now <= round_[_rID].end) // round hasn't ended (in ICO phase, or ICO phase is over, but round eth is 0) return ( ((round_[_rID].ico.keys()).add(1000000000000000000)).ethRec(1000000000000000000) ); else // rounds over.  need price for new round return ( 100000000000000 ); // init } /** * @dev returns time left.  dont spam this, you'll ddos yourself from your node * provider * -functionhash- 0xc7e284b8 * @return time left in seconds */ function getTimeLeft() public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // are we in ICO phase? if (_now <= round_[_rID].strt + rndGap_) return( ((round_[_rID].end).sub(rndInit_)).sub(_now) ); else if (_now < round_[_rID].end) return( (round_[_rID].end).sub(_now) ); else return(0); } /** * @dev returns player earnings per vaults * -functionhash- 0x63066434 * @return winnings vault * @return general vault * @return affiliate vault */ function getPlayerVaults(uint256 _pID) public view returns(uint256 ,uint256, uint256) { // setup local rID uint256 _rID = rID_; // if round has ended.  but round end has not been run (so contract has not distributed winnings) if (now > round_[_rID].end && round_[_rID].ended == false) { uint256 _roundMask; uint256 _roundEth; uint256 _roundKeys; uint256 _roundPot; if (round_[_rID].eth == 0 && round_[_rID].ico > 0) { // create a temp round eth based on eth sent in during ICO phase _roundEth = round_[_rID].ico; // create a temp round keys based on keys bought during ICO phase _roundKeys = (round_[_rID].ico).keys(); // create a temp round mask based on eth and keys from ICO phase _roundMask = ((round_[_rID].icoGen).mul(1000000000000000000)) / _roundKeys; // create a temp rount pot based on pot, and dust from mask _roundPot = (round_[_rID].pot).add((round_[_rID].icoGen).sub((_roundMask.mul(_roundKeys)) / (1000000000000000000))); } else { _roundEth = round_[_rID].eth; _roundKeys = round_[_rID].keys; _roundMask = round_[_rID].mask; _roundPot = round_[_rID].pot; } uint256 _playerKeys; if (plyrRnds_[_pID][plyr_[_pID].lrnd].ico == 0) _playerKeys = plyrRnds_[_pID][plyr_[_pID].lrnd].keys; else _playerKeys = calcPlayerICOPhaseKeys(_pID, _rID); // if player is winner if (round_[_rID].plyr == _pID) { return ( (plyr_[_pID].win).add( (_roundPot.mul(48)) / 100 ), (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _roundMask, _roundPot, _roundKeys, _playerKeys) ), plyr_[_pID].aff ); // if player is not the winner } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add( getPlayerVaultsHelper(_pID, _roundMask, _roundPot, _roundKeys, _playerKeys) ), plyr_[_pID].aff ); } // if round is still going on, we are in ico phase, or round has ended and round end has been ran } else { return ( plyr_[_pID].win, (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)), plyr_[_pID].aff ); } } /** * solidity hates stack limits.  this lets us avoid that hate */ function getPlayerVaultsHelper(uint256 _pID, uint256 _roundMask, uint256 _roundPot, uint256 _roundKeys, uint256 _playerKeys) private view returns(uint256) { return(  (((_roundMask.add((((_roundPot.mul(potSplit_[round_[rID_].team].gen)) / 100).mul(1000000000000000000)) / _roundKeys)).mul(_playerKeys)) / 1000000000000000000).sub(plyrRnds_[_pID][rID_].mask)  ); } /** * @dev returns all current round info needed for front end * -functionhash- 0x747dff42 * @return eth invested during ICO phase * @return round id * @return total keys for round * @return time round ends * @return time round started * @return current pot * @return current team ID & player ID in lead * @return current player in leads address * @return current player in leads name * @return whales eth in for round * @return bears eth in for round * @return sneks eth in for round * @return bulls eth in for round */ function getCurrentRoundInfo() public view returns(uint256, uint256, uint256, uint256, uint256, uint256, uint256, address, bytes32, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (round_[_rID].eth != 0) { return ( round_[_rID].ico,               //0 _rID,                           //1 round_[_rID].keys,              //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3]              //12 ); } else { return ( round_[_rID].ico,               //0 _rID,                           //1 (round_[_rID].ico).keys(),      //2 round_[_rID].end,               //3 round_[_rID].strt,              //4 round_[_rID].pot,               //5 (round_[_rID].team + (round_[_rID].plyr * 10)),     //6 plyr_[round_[_rID].plyr].addr,  //7 plyr_[round_[_rID].plyr].name,  //8 rndTmEth_[_rID][0],             //9 rndTmEth_[_rID][1],             //10 rndTmEth_[_rID][2],             //11 rndTmEth_[_rID][3]              //12 ); } } /** * @dev returns player info based on address.  if no address is given, it will * use msg.sender * -functionhash- 0xee0b5d8b * @param _addr address of the player you want to lookup * @return player ID * @return player name * @return keys owned (current round) * @return winnings vault * @return general vault * @return affiliate vault * @return player ico eth */ function getPlayerInfoByAddress(address _addr) public view returns(uint256, bytes32, uint256, uint256, uint256, uint256, uint256) { // setup local rID uint256 _rID = rID_; if (_addr == address(0)) { _addr == msg.sender; } uint256 _pID = pIDxAddr_[_addr]; if (plyrRnds_[_pID][_rID].ico == 0) { return ( _pID,                               //0 plyr_[_pID].name,                   //1 plyrRnds_[_pID][_rID].keys,         //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 0\t\t\t\t\t\t            //6 ); } else { return ( _pID,                               //0 plyr_[_pID].name,                   //1 calcPlayerICOPhaseKeys(_pID, _rID), //2 plyr_[_pID].win,                    //3 (plyr_[_pID].gen).add(calcUnMaskedEarnings(_pID, plyr_[_pID].lrnd)),       //4 plyr_[_pID].aff,                    //5 plyrRnds_[_pID][_rID].ico           //6 ); } } /** * @dev logic runs whenever a buy order is executed.  determines how to handle * incoming eth depending on if we are in ICO phase or not */ function buyCore(uint256 _pID, uint256 _affID, uint256 _team, F4Ddatasets.EventReturns memory _eventData_) private { // check to see if round has ended.  and if player is new to round _eventData_ = manageRoundAndPlayer(_pID, _eventData_); // are we in ICO phase? if (now <= round_[rID_].strt + rndGap_) { // let event data know this is a ICO phase buy order _eventData_.compressedData = _eventData_.compressedData + 2000000000000000000000000000000; // ICO phase core icoPhaseCore(_pID, msg.value, _team, _affID, _eventData_); // round is live } else { // let event data know this is a buy order _eventData_.compressedData = _eventData_.compressedData + 1000000000000000000000000000000; // call core core(_pID, msg.value, _affID, _team, _eventData_); } } /** * @dev logic runs whenever a reload order is executed.  determines how to handle * incoming eth depending on if we are in ICO phase or not */ function reLoadCore(uint256 _pID, uint256 _affID, uint256 _team, uint256 _eth, F4Ddatasets.EventReturns memory _eventData_) private { // check to see if round has ended.  and if player is new to round _eventData_ = manageRoundAndPlayer(_pID, _eventData_); // get earnings from all vaults and return unused to gen vault // because we use a custom safemath library.  this will throw if player // tried to spend more eth than they have. plyr_[_pID].gen = withdrawEarnings(_pID).sub(_eth); // are we in ICO phase? if (now <= round_[rID_].strt + rndGap_) { // let event data know this is an ICO phase reload _eventData_.compressedData = _eventData_.compressedData + 3000000000000000000000000000000; // ICO phase core icoPhaseCore(_pID, _eth, _team, _affID, _eventData_); // round is live } else { // call core core(_pID, _eth, _affID, _team, _eventData_); } } /** * @dev during ICO phase all eth sent in by each player.  will be added to an * \"investment pool\".  upon end of ICO phase, all eth will be used to buy keys. * each player receives an amount based on how much they put in, and the * the average price attained. */ function icoPhaseCore(uint256 _pID, uint256 _eth, uint256 _team, uint256 _affID, F4Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // if they bought at least 1 whole key (at time of purchase) if ((round_[_rID].ico).keysRec(_eth) >= 1000000000000000000 || round_[_rID].plyr == 0) { // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // add eth to our players & rounds ICO phase investment. this will be used // to determine total keys and each players share plyrRnds_[_pID][_rID].ico = _eth.add(plyrRnds_[_pID][_rID].ico); round_[_rID].ico = _eth.add(round_[_rID].ico); // add eth in to team eth tracker rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // send eth share to com, p3d, affiliate, and FoMo4D long _eventData_ = distributeExternal(_eth, _eventData_); // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; uint256 _aff = _eth / 10; if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F4Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _gen = _gen.add(_aff); } // add gen share to rounds ICO phase gen tracker (will be distributed // when round starts) round_[_rID].icoGen = _gen.add(round_[_rID].icoGen); uint256 _pot = (_eth.sub(((_eth.mul(14)) / 100))).sub(_gen); // add eth to pot round_[_rID].pot = _pot.add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; // fire event endTx(_rID, _pID, _team, _eth, 0, _eventData_); } /** * @dev this is the core logic for any buy/reload that happens while a round * is live. */ function core(uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, F4Ddatasets.EventReturns memory _eventData_) private { // setup local rID uint256 _rID = rID_; // check to see if its a new round (past ICO phase) && keys were bought in ICO phase if (round_[_rID].eth == 0 && round_[_rID].ico > 0) roundClaimICOKeys(_rID); // if player is new to round and is owed keys from ICO phase if (plyrRnds_[_pID][_rID].keys == 0 && plyrRnds_[_pID][_rID].ico > 0) { // assign player their keys from ICO phase plyrRnds_[_pID][_rID].keys = calcPlayerICOPhaseKeys(_pID, _rID); // zero out ICO phase investment plyrRnds_[_pID][_rID].ico = 0; } // mint the new keys uint256 _keys = (round_[_rID].eth).keysRec(_eth); // if they bought at least 1 whole key if (_keys >= 1000000000000000000) { updateTimer(_keys, _rID); // set new leaders if (round_[_rID].plyr != _pID) round_[_rID].plyr = _pID; if (round_[_rID].team != _team) round_[_rID].team = _team; // set the new leader bool to true _eventData_.compressedData = _eventData_.compressedData + 100; } // update player plyrRnds_[_pID][_rID].keys = _keys.add(plyrRnds_[_pID][_rID].keys); // update round round_[_rID].keys = _keys.add(round_[_rID].keys); round_[_rID].eth = _eth.add(round_[_rID].eth); rndTmEth_[_rID][_team] = _eth.add(rndTmEth_[_rID][_team]); // distribute eth _eventData_ = distributeExternal(_eth, _eventData_); _eventData_ = distributeInternal(_rID, _pID, _eth, _affID, _team, _keys, _eventData_); // call end tx function to fire end tx event. endTx(_rID, _pID, _team, _eth, _keys, _eventData_); } /** * @dev calculates unmasked earnings (just calculates, does not update mask) * @return earnings in wei format */ function calcUnMaskedEarnings(uint256 _pID, uint256 _rIDlast) private view returns(uint256) { // if player does not have unclaimed keys bought in ICO phase // return their earnings based on keys held only. if (plyrRnds_[_pID][_rIDlast].ico == 0) return(  (((round_[_rIDlast].mask).mul(plyrRnds_[_pID][_rIDlast].keys)) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); else if (now > round_[_rIDlast].strt + rndGap_ && round_[_rIDlast].eth == 0) return(  (((((round_[_rIDlast].icoGen).mul(1000000000000000000)) / (round_[_rIDlast].ico).keys()).mul(calcPlayerICOPhaseKeys(_pID, _rIDlast))) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); else return(  (((round_[_rIDlast].mask).mul(calcPlayerICOPhaseKeys(_pID, _rIDlast))) / (1000000000000000000)).sub(plyrRnds_[_pID][_rIDlast].mask)  ); // otherwise return earnings based on keys owed from ICO phase // (this would be a scenario where they only buy during ICO phase, and never // buy/reload during round) } /** * @dev average ico phase key price is total eth put in, during ICO phase, * divided by the number of keys that were bought with that eth. * -functionhash- 0xdcb6af48 * @return average key price */ function calcAverageICOPhaseKeyPrice(uint256 _rID) public view returns(uint256) { return(  (round_[_rID].ico).mul(1000000000000000000) / (round_[_rID].ico).keys()  ); } /** * @dev at end of ICO phase, each player is entitled to X keys based on final * average ICO phase key price, and the amount of eth they put in during ICO. * if a player participates in the round post ICO, these will be \"claimed\" and * added to their rounds total keys.  if not, this will be used to calculate * their gen earnings throughout round and on round end. * -functionhash- 0x75661f4c * @return players keys bought during ICO phase */ function calcPlayerICOPhaseKeys(uint256 _pID, uint256 _rID) public view returns(uint256) { if (round_[_rID].icoAvg != 0 || round_[_rID].ico == 0 ) return(  ((plyrRnds_[_pID][_rID].ico).mul(1000000000000000000)) / round_[_rID].icoAvg  ); else return(  ((plyrRnds_[_pID][_rID].ico).mul(1000000000000000000)) / calcAverageICOPhaseKeyPrice(_rID)  ); } /** * @dev returns the amount of keys you would get given an amount of eth. * - during live round.  this is accurate. (well... unless someone buys before * you do and ups the price!  you better HURRY!) * - during ICO phase.  this is the max you would get based on current eth * invested during ICO phase.  if others invest after you, you will receive * less.  (so distract them with meme vids till ICO is over) * -functionhash- 0xce89c80c * @param _rID round ID you want price for * @param _eth amount of eth sent in * @return keys received */ function calcKeysReceived(uint256 _rID, uint256 _eth) public view returns(uint256) { // grab time uint256 _now = now; // is ICO phase over??  & theres eth in the round? if (_now > round_[_rID].strt + rndGap_ && round_[_rID].eth != 0 && _now <= round_[_rID].end) return ( (round_[_rID].eth).keysRec(_eth) ); else if (_now <= round_[_rID].end) // round hasn't ended (in ICO phase, or ICO phase is over, but round eth is 0) return ( (round_[_rID].ico).keysRec(_eth) ); else // rounds over.  need keys for new round return ( (_eth).keys() ); } /** * @dev returns current eth price for X keys. * - during live round.  this is accurate. (well... unless someone buys before * you do and ups the price!  you better HURRY!) * - during ICO phase.  this is the max you would get based on current eth * invested during ICO phase.  if others invest after you, you will receive * less.  (so distract them with meme vids till ICO is over) * -functionhash- 0xcf808000 * @param _keys number of keys desired (in 18 decimal format) * @return amount of eth needed to send */ function iWantXKeys(uint256 _keys) public view returns(uint256) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // is ICO phase over??  & theres eth in the round? if (_now > round_[_rID].strt + rndGap_ && round_[_rID].eth != 0 && _now <= round_[_rID].end) return ( (round_[_rID].keys.add(_keys)).ethRec(_keys) ); else if (_now <= round_[_rID].end) // round hasn't ended (in ICO phase, or ICO phase is over, but round eth is 0) return ( (((round_[_rID].ico).keys()).add(_keys)).ethRec(_keys) ); else // rounds over.  need price for new round return ( (_keys).eth() ); } /** * @dev receives name/player info from names contract */ function receivePlayerInfo(uint256 _pID, address _addr, bytes32 _name, uint256 _laff) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if (pIDxAddr_[_addr] != _pID) pIDxAddr_[_addr] = _pID; if (pIDxName_[_name] != _pID) pIDxName_[_name] = _pID; if (plyr_[_pID].addr != _addr) plyr_[_pID].addr = _addr; if (plyr_[_pID].name != _name) plyr_[_pID].name = _name; if (plyr_[_pID].laff != _laff) plyr_[_pID].laff = _laff; if (plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev receives entire player name list */ function receivePlayerNameList(uint256 _pID, bytes32 _name) external { require (msg.sender == address(PlayerBook), \"your not playerNames contract... hmmm..\"); if(plyrNames_[_pID][_name] == false) plyrNames_[_pID][_name] = true; } /** * @dev gets existing or registers new pID.  use this when a player may be new * @return pID */ function determinePID(F4Ddatasets.EventReturns memory _eventData_) private returns (F4Ddatasets.EventReturns) { uint256 _pID = pIDxAddr_[msg.sender]; // if player is new to this version of FoMo4D if (_pID == 0) { // grab their player ID, name and last aff ID, from player names contract _pID = PlayerBook.getPlayerID(msg.sender); bytes32 _name = PlayerBook.getPlayerName(_pID); uint256 _laff = PlayerBook.getPlayerLAff(_pID); // set up player account pIDxAddr_[msg.sender] = _pID; plyr_[_pID].addr = msg.sender; if (_name != \"\") { pIDxName_[_name] = _pID; plyr_[_pID].name = _name; plyrNames_[_pID][_name] = true; } if (_laff != 0 && _laff != _pID) plyr_[_pID].laff = _laff; // set the new player bool to true _eventData_.compressedData = _eventData_.compressedData + 1; } return (_eventData_); } /** * @dev checks to make sure user picked a valid team.  if not sets team * to default (sneks) */ function verifyTeam(uint256 _team) private pure returns (uint256) { if (_team < 0 || _team > 3) return(2); else return(_team); } /** * @dev decides if round end needs to be run & new round started.  and if * player unmasked earnings from previously played rounds need to be moved. */ function manageRoundAndPlayer(uint256 _pID, F4Ddatasets.EventReturns memory _eventData_) private returns (F4Ddatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // grab time uint256 _now = now; // check to see if round has ended.  we use > instead of >= so that LAST // second snipe tx can extend the round. if (_now > round_[_rID].end) { // check to see if round end has been run yet.  (distributes pot) if (round_[_rID].ended == false) { _eventData_ = endRound(_eventData_); round_[_rID].ended = true; } // start next round in ICO phase rID_++; _rID++; round_[_rID].strt = _now; round_[_rID].end = _now.add(rndInit_).add(rndGap_); } // is player new to round? if (plyr_[_pID].lrnd != _rID) { // if player has played a previous round, move their unmasked earnings // from that round to gen vault. if (plyr_[_pID].lrnd != 0) updateGenVault(_pID, plyr_[_pID].lrnd); // update player's last round played plyr_[_pID].lrnd = _rID; // set the joined round bool to true _eventData_.compressedData = _eventData_.compressedData + 10; } return(_eventData_); } /** * @dev ends the round. manages paying out winner/splitting up pot */ function endRound(F4Ddatasets.EventReturns memory _eventData_) private returns (F4Ddatasets.EventReturns) { // setup local rID uint256 _rID = rID_; // check to round ended with ONLY ico phase transactions if (round_[_rID].eth == 0 && round_[_rID].ico > 0) roundClaimICOKeys(_rID); // grab our winning player and team id's uint256 _winPID = round_[_rID].plyr; uint256 _winTID = round_[_rID].team; // grab our pot amount uint256 _pot = round_[_rID].pot; // calculate our winner share, community rewards, gen share, // p3d share, and amount reserved for next pot uint256 _win = (_pot.mul(48)) / 100; uint256 _own = (_pot.mul(14) / 100); owner_.transfer(_own); uint256 _gen = (_pot.mul(potSplit_[_winTID].gen)) / 100; uint256 _res = (((_pot.sub(_win)).sub(_own)).sub(_gen)); // calculate ppt for round mask uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = _gen.sub((_ppt.mul(round_[_rID].keys)) / 1000000000000000000); if (_dust > 0) { _gen = _gen.sub(_dust); _res = _res.add(_dust); } // pay our winner plyr_[_winPID].win = _win.add(plyr_[_winPID].win); // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); // fill next round pot with its share round_[_rID + 1].pot += _res; // prepare event data _eventData_.compressedData = _eventData_.compressedData + (round_[_rID].end * 1000000); _eventData_.compressedIDs = _eventData_.compressedIDs + (_winPID * 100000000000000000000000000) + (_winTID * 100000000000000000); _eventData_.winnerAddr = plyr_[_winPID].addr; _eventData_.winnerName = plyr_[_winPID].name; _eventData_.amountWon = _win; _eventData_.genAmount = _gen; _eventData_.newPot = _res; return(_eventData_); } /** * @dev takes keys bought during ICO phase, and adds them to round.  pays * out gen rewards that accumulated during ICO phase */ function roundClaimICOKeys(uint256 _rID) private { // update round eth to account for ICO phase eth investment round_[_rID].eth = round_[_rID].ico; // add keys to round that were bought during ICO phase round_[_rID].keys = (round_[_rID].ico).keys(); // store average ICO key price round_[_rID].icoAvg = calcAverageICOPhaseKeyPrice(_rID); // set round mask from ICO phase uint256 _ppt = ((round_[_rID].icoGen).mul(1000000000000000000)) / (round_[_rID].keys); uint256 _dust = (round_[_rID].icoGen).sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000)); if (_dust > 0) round_[_rID].pot = (_dust).add(round_[_rID].pot);   // <<< your adding to pot and havent updated event data // distribute gen portion to key holders round_[_rID].mask = _ppt.add(round_[_rID].mask); } /** * @dev moves any unmasked earnings to gen vault.  updates earnings mask */ function updateGenVault(uint256 _pID, uint256 _rIDlast) private { uint256 _earnings = calcUnMaskedEarnings(_pID, _rIDlast); if (_earnings > 0) { // put in gen vault plyr_[_pID].gen = _earnings.add(plyr_[_pID].gen); // zero out their earnings by updating mask plyrRnds_[_pID][_rIDlast].mask = _earnings.add(plyrRnds_[_pID][_rIDlast].mask); } } /** * @dev updates round timer based on number of whole keys bought. */ function updateTimer(uint256 _keys, uint256 _rID) private { // calculate time based on number of keys bought uint256 _newTime = (((_keys) / (1000000000000000000)).mul(rndInc_)).add(round_[_rID].end); // grab time uint256 _now = now; // compare to max and set new end time if (_newTime < (rndMax_).add(_now)) round_[_rID].end = _newTime; else round_[_rID].end = rndMax_.add(_now); } /** * @dev distributes eth based on fees to com, aff, and p3d */ function distributeExternal(uint256 _eth, F4Ddatasets.EventReturns memory _eventData_) private returns(F4Ddatasets.EventReturns) { // pay 14% out to owner rewards uint256 _own = _eth.mul(14) / 100; owner_.transfer(_own); return(_eventData_); } function potSwap() external payable { // setup local rID uint256 _rID = rID_ + 1; round_[_rID].pot = round_[_rID].pot.add(msg.value); emit F4Devents.onPotSwapDeposit(_rID, msg.value); } /** * @dev distributes eth based on fees to gen and pot */ function distributeInternal(uint256 _rID, uint256 _pID, uint256 _eth, uint256 _affID, uint256 _team, uint256 _keys, F4Ddatasets.EventReturns memory _eventData_) private returns(F4Ddatasets.EventReturns) { // calculate gen share uint256 _gen = (_eth.mul(fees_[_team].gen)) / 100; // distribute share to affiliate 10% uint256 _aff = _eth / 10; // decide what to do with affiliate share of fees // affiliate must not be self, and must have a name registered if (_affID != _pID && plyr_[_affID].name != '') { plyr_[_affID].aff = _aff.add(plyr_[_affID].aff); emit F4Devents.onAffiliatePayout(_affID, plyr_[_affID].addr, plyr_[_affID].name, _rID, _pID, _aff, now); } else { _gen = _gen.add(_aff); } // update eth balance (eth = eth - (com share + pot swap share + aff share + p3d share)) _eth = _eth.sub(((_eth.mul(14)) / 100)); // calculate pot uint256 _pot = _eth.sub(_gen); // distribute gen share (thats what updateMasks() does) and adjust // balances for dust. uint256 _dust = updateMasks(_rID, _pID, _gen, _keys); if (_dust > 0) _gen = _gen.sub(_dust); // add eth to pot round_[_rID].pot = _pot.add(_dust).add(round_[_rID].pot); // set up event data _eventData_.genAmount = _gen.add(_eventData_.genAmount); _eventData_.potAmount = _pot; return(_eventData_); } /** * @dev updates masks for round and player when keys are bought * @return dust left over */ function updateMasks(uint256 _rID, uint256 _pID, uint256 _gen, uint256 _keys) private returns(uint256) { /* MASKING NOTES earnings masks are a tricky thing for people to wrap their minds around. the basic thing to understand here.  is were going to have a global tracker based on profit per share for each round, that increases in relevant proportion to the increase in share supply. the player will have an additional mask that basically says \"based on the rounds mask, my shares, and how much i've already withdrawn, how much is still owed to me?\" */ // calc profit per key & round mask based on this buy:  (dust goes to pot) uint256 _ppt = (_gen.mul(1000000000000000000)) / (round_[_rID].keys); round_[_rID].mask = _ppt.add(round_[_rID].mask); // calculate player earning from their own buy (only based on the keys // they just bought).  & update player earnings mask uint256 _pearn = (_ppt.mul(_keys)) / (1000000000000000000); plyrRnds_[_pID][_rID].mask = (((round_[_rID].mask.mul(_keys)) / (1000000000000000000)).sub(_pearn)).add(plyrRnds_[_pID][_rID].mask); // calculate & return dust return(_gen.sub((_ppt.mul(round_[_rID].keys)) / (1000000000000000000))); } /** * @dev adds up unmasked earnings, & vault earnings, sets them all to 0 * @return earnings in wei format */ function withdrawEarnings(uint256 _pID) private returns(uint256) { // update gen vault updateGenVault(_pID, plyr_[_pID].lrnd); // from vaults uint256 _earnings = (plyr_[_pID].win).add(plyr_[_pID].gen).add(plyr_[_pID].aff); if (_earnings > 0) { plyr_[_pID].win = 0; plyr_[_pID].gen = 0; plyr_[_pID].aff = 0; } return(_earnings); } /** * @dev prepares compression data and fires event for buy or reload tx's */ function endTx(uint256 _rID, uint256 _pID, uint256 _team, uint256 _eth, uint256 _keys, F4Ddatasets.EventReturns memory _eventData_) private { _eventData_.compressedData = _eventData_.compressedData + (now * 1000000000000000000) + (_team * 100000000000000000000000000000); _eventData_.compressedIDs = _eventData_.compressedIDs + _pID + (_rID * 10000000000000000000000000000000000000000000000000000); emit F4Devents.onEndTx ( _eventData_.compressedData, _eventData_.compressedIDs, plyr_[_pID].name, msg.sender, _eth, _keys, _eventData_.winnerAddr, _eventData_.winnerName, _eventData_.amountWon, _eventData_.newPot, _eventData_.P3DAmount, _eventData_.genAmount, _eventData_.potAmount ); } /** upon contract deploy, it will be deactivated.  this is a one time * use function that will activate the contract.  we do this so devs * have time to set things up on the web end                            **/ bool public activated_ = false; function activate() public { // only team just can activate require( msg.sender == owner_, \"only team just can activate\" ); // can only be ran once require(activated_ == false, \"FoMo4D already activated\"); // activate the contract activated_ = true; // lets start first round in ICO phase rID_ = 1; round_[1].strt = now; round_[1].end = now + rndInit_ + rndGap_; } } library F4Ddatasets { //compressedData key // [76-33][32][31][30][29][28-18][17][16-6][5-3][2][1][0] // 0 - new player (bool) // 1 - joined round (bool) // 2 - new  leader (bool) // 6-16 - round end time // 17 - winnerTeam // 18 - 28 timestamp // 29 - team // 30 - 0 = reinvest (round), 1 = buy (round), 2 = buy (ico), 3 = reinvest (ico) //compressedIDs key // [77-52][51-26][25-0] // 0-25 - pID // 26-51 - winPID // 52-77 - rID struct EventReturns { uint256 compressedData; uint256 compressedIDs; address winnerAddr;         // winner address bytes32 winnerName;         // winner name uint256 amountWon;          // amount won uint256 newPot;             // amount in new pot uint256 P3DAmount;          // amount distributed to p3d uint256 genAmount;          // amount distributed to gen uint256 potAmount;          // amount added to pot } struct Player { address addr;   // player address bytes32 name;   // player name uint256 win;    // winnings vault uint256 gen;    // general vault uint256 aff;    // affiliate vault uint256 lrnd;   // last round played uint256 laff;   // last affiliate id used } struct PlayerRounds { uint256 eth;    // eth player has added to round (used for eth limiter) uint256 keys;   // keys uint256 mask;   // player mask uint256 ico;    // ICO phase investment } struct Round { uint256 plyr;   // pID of player in lead uint256 team;   // tID of team in lead uint256 end;    // time ends/ended bool ended;     // has round end function been ran uint256 strt;   // time round started uint256 keys;   // keys uint256 eth;    // total eth in uint256 pot;    // eth to pot (during round) / final amount paid to winner (after round ends) uint256 mask;   // global mask uint256 ico;    // total eth sent in during ICO phase uint256 icoGen; // total eth for gen during ICO phase uint256 icoAvg; // average key price for ICO phase } struct TeamFee { uint256 gen;    // % of buy in thats paid to key holders of current round } struct PotSplit { uint256 gen;    // % of pot thats paid to key holders of current round } } library F4DKeysCalcFast { using SafeMath for *; /** * @dev calculates number of keys received given X eth * @param _curEth current amount of eth in contract * @param _newEth eth being spent * @return amount of ticket purchased */ function keysRec(uint256 _curEth, uint256 _newEth) internal pure returns (uint256) { return(keys((_curEth).add(_newEth)).sub(keys(_curEth))); } /** * @dev calculates amount of eth received if you sold X keys * @param _curKeys current amount of keys that exist * @param _sellKeys amount of keys you wish to sell * @return amount of eth received */ function ethRec(uint256 _curKeys, uint256 _sellKeys) internal pure returns (uint256) { return((eth(_curKeys)).sub(eth(_curKeys.sub(_sellKeys)))); } /** * @dev calculates how many keys would exist with given an amount of eth * @param _eth eth \"in contract\" * @return number of keys that would exist */ function keys(uint256 _eth) internal pure returns(uint256) { return ((((((_eth).mul(1000000000000000000)).mul(200000000000000000000000000000000)).add(2500000000000000000000000000000000000000000000000000000000000000)).sqrt()).sub(50000000000000000000000000000000)) / (100000000000000); } /** * @dev calculates how much eth would be in contract given a number of keys * @param _keys number of keys \"in contract\" * @return eth that would exists */ function eth(uint256 _keys) internal pure returns(uint256) { return ((50000000000000).mul(_keys.sq()).add(((100000000000000).mul(_keys.mul(1000000000000000000))) / (2))) / ((1000000000000000000).sq()); } } interface PlayerBookInterface { function getPlayerID(address _addr) external returns (uint256); function getPlayerName(uint256 _pID) external view returns (bytes32); function getPlayerLAff(uint256 _pID) external view returns (uint256); function getPlayerAddr(uint256 _pID) external view returns (address); function getNameFee() external view returns (uint256); function registerNameXIDFromDapp(address _addr, bytes32 _name, uint256 _affCode, bool _all) external payable returns(bool, uint256); function registerNameXaddrFromDapp(address _addr, bytes32 _name, address _affCode, bool _all) external payable returns(bool, uint256); function registerNameXnameFromDapp(address _addr, bytes32 _name, bytes32 _affCode, bool _all) external payable returns(bool, uint256); } library NameFilter { /** * @dev filters name strings * -converts uppercase to lower case. * -makes sure it does not start/end with a space * -makes sure it does not contain multiple spaces in a row * -cannot be only numbers * -cannot start with 0x * -restricts characters to A-Z, a-z, 0-9, and space. * @return reprocessed string in bytes32 format */ function nameFilter(string _input) internal pure returns(bytes32) { bytes memory _temp = bytes(_input); uint256 _length = _temp.length; //sorry limited to 32 characters require (_length <= 32 && _length > 0, \"string must be between 1 and 32 characters\"); // make sure it doesnt start with or end with space require(_temp[0] != 0x20 && _temp[_length-1] != 0x20, \"string cannot start or end with space\"); // make sure first two characters are not 0x if (_temp[0] == 0x30) { require(_temp[1] != 0x78, \"string cannot start with 0x\"); require(_temp[1] != 0x58, \"string cannot start with 0X\"); } // create a bool to track if we have a non number character bool _hasNonNumber; // convert & check for (uint256 i = 0; i < _length; i++) { // if its uppercase A-Z if (_temp[i] > 0x40 && _temp[i] < 0x5b) { // convert to lower case a-z _temp[i] = byte(uint(_temp[i]) + 32); // we have a non number if (_hasNonNumber == false) _hasNonNumber = true; } else { require ( // require character is a space _temp[i] == 0x20 || // OR lowercase a-z (_temp[i] > 0x60 && _temp[i] < 0x7b) || // or 0-9 (_temp[i] > 0x2f && _temp[i] < 0x3a), \"string contains invalid characters\" ); // make sure theres not 2x spaces in a row if (_temp[i] == 0x20) require( _temp[i+1] != 0x20, \"string cannot contain consecutive spaces\"); // see if we have a character other than a number if (_hasNonNumber == false && (_temp[i] < 0x30 || _temp[i] > 0x39)) _hasNonNumber = true; } } require(_hasNonNumber == true, \"string cannot be only numbers\"); bytes32 _ret; assembly { _ret := mload(add(_temp, 32)) } return (_ret); } } /** * @title SafeMath v0.1.9 * @dev Math operations with safety checks that throw on error * change notes:  original SafeMath library from OpenZeppelin modified by Inventor * - added sqrt * - added sq * - added pwr * - changed asserts to requires with error log outputs * - removed div, its useless */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; require(c / a == b, \"SafeMath mul failed\"); return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a, \"SafeMath sub failed\"); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; require(c >= a, \"SafeMath add failed\"); return c; } /** * @dev gives square root of given x. */ function sqrt(uint256 x) internal pure returns (uint256 y) { uint256 z = ((add(x,1)) / 2); y = x; while (z < y) { y = z; z = ((add((x / z),z)) / 2); } } /** * @dev gives square. multiplies x by x */ function sq(uint256 x) internal pure returns (uint256) { return (mul(x,x)); } /** * @dev x to the power of y */ function pwr(uint256 x, uint256 y) internal pure returns (uint256) { if (x==0) return (0); else if (y==0) return (1); else { uint256 z = x; for (uint256 i=1; i < y; i++) z = mul(z,x); return (z); } } } "}
{"sol name": "560.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) internal balances; uint256 internal totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address _owner, address _spender) public view returns (uint256); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract CCEToken is StandardToken { string public constant name = \"CCEToken\"; string public constant symbol = \"CT\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY =  10000000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "408.sol", "label": 0, "sol content": "// ---------------------------------------------------------------------------- // 'FC24' token contract // // Deployed to : 0xB264f69f1aF3b486435b938a3935280e25722d4A // Symbol      : FC24 // Name        : Freecoins24 // Total supply: 200000000 // Decimals    : 18 // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Freecoins24 is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Freecoins24() public { symbol = \"FC24\"; name = \"Freecoins24\"; decimals = 18; _totalSupply = 200000000000000000000000000; balances[0xB264f69f1aF3b486435b938a3935280e25722d4A] = _totalSupply; Transfer(address(0), 0xB264f69f1aF3b486435b938a3935280e25722d4A, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1891.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_to != address(this)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor()public{ owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title Pausable token * * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract BitGooseCoin is PausableToken { string public constant name = \"BitGooseCoin\"; string public constant symbol = \"KBB\"; uint8 public constant decimals = 18; uint256 private constant TOKEN_UNIT = 10 ** uint256(decimals); uint256 public constant totalSupply = 2100000000 * TOKEN_UNIT; constructor() public { balances[owner] = totalSupply; emit Transfer(address(0), owner, balances[owner]); } } "}
{"sol name": "701.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract ERC20StandardToken { event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed _owner, address indexed _spender, uint _value); mapping (address => mapping (address => uint256)) internal allowed; mapping (address => uint256) public balanceOf; using SafeMath for uint256; uint256 totalSupply_; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from,address _to,uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balanceOf[_from]); require(_value <= allowed[_from][msg.sender]); balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balanceOf[msg.sender]); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Contract that will work with ERC223 tokens. */ contract addtionalERC223Interface { function transfer(address to, uint256 value, bytes data) public returns (bool); event Transfer(address indexed from, address indexed to, uint value, bytes data); } contract ERC223ReceivingContract { /** * @dev Standard ERC223 function that will handle incoming token transfers. * * @param _from  Token sender address. * @param _value Amount of tokens. * @param _data  Transaction metadata. */ struct TKN { address sender; uint value; bytes data; bytes4 sig; } function tokenFallback(address _from, uint256 _value, bytes _data) public pure { TKN memory tkn; tkn.sender = _from; tkn.value = _value; tkn.data = _data; uint32 u = uint32(_data[3]) + (uint32(_data[2]) << 8) + (uint32(_data[1]) << 16) + (uint32(_data[0]) << 24); tkn.sig = bytes4(u); } } /** * @title Reference implementation of the ERC223 standard token. */ contract ERC223Token is addtionalERC223Interface , ERC20StandardToken { function _transfer(address _to, uint256 _value ) private returns (bool) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); return true; } function _transferFallback(address _to, uint256 _value, bytes _data) private returns (bool) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] = balanceOf[msg.sender].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); ERC223ReceivingContract receiver = ERC223ReceivingContract(_to); receiver.tokenFallback(msg.sender, _value, _data); emit Transfer(msg.sender, _to, _value, _data); return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      Invokes the `tokenFallback` function if the recipient is a contract. *      The token transfer fails if the recipient is a contract *      but does not implement the `tokenFallback` function *      or the fallback function to receive funds. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. * @param _data  Transaction metadata. */ function transfer(address _to, uint256 _value, bytes _data) public returns (bool OK) { // Standard function transfer similar to ERC20 transfer with no _data . // Added due to backwards compatibility reasons . if(isContract(_to)) { return _transferFallback(_to,_value,_data); }else{ _transfer(_to,_value); emit Transfer(msg.sender, _to, _value, _data); } return true; } /** * @dev Transfer the specified amount of tokens to the specified address. *      This function works the same with the previous one *      but doesn't contain `_data` param. *      Added due to backwards compatibility reasons. * * @param _to    Receiver address. * @param _value Amount of tokens that will be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { bytes memory empty; if(isContract(_to)) { return _transferFallback(_to,_value,empty); }else{ _transfer(_to,_value); emit Transfer(msg.sender, _to, _value); } } // assemble the given address bytecode. If bytecode exists then the _addr is a contract. function isContract(address _addr) private view returns (bool) { uint length; assembly { //retrieve the size of the code on target address, this needs assembly length := extcodesize(_addr) } return (length > 0); } } contract TowaCoin is ERC223Token { string public name = \"TOWACOIN\"; string public symbol = \"TOWA\"; uint8 public decimals = 18; constructor() public{ address founder = 0x9F7d681707AA64fFdfBA162084932058bD34aBF4; address developer = 0xE66EBB7Bd6E44413Ac1dE57ECe202c8F0CA1Efd9; uint256  dec = decimals; totalSupply_ = 200 * 1e8 * (10**dec); balanceOf[founder] = totalSupply_.mul(97).div(100); balanceOf[developer] = totalSupply_.mul(3).div(100); } } "}
{"sol name": "1862.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns(uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns(uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns(uint256); function transfer(address to, uint256 value) public returns(bool); function allowance(address owner, address spender) public view returns(uint256); function transferFrom(address from, address to, uint256 value) public returns(bool); function approve(address spender, uint256 value) public returns(bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns(uint256 balance) { return balances[_owner]; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns(bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns(bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns(bool) { require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns(uint256 remaining) { return allowed[_owner][_spender]; } } contract ICWToken is StandardToken { string public constant name = \"Intelligent Car Washing Token\"; string public constant symbol = \"ICWT\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 20000000000 * (10 ** uint256(decimals)); // contributors address address public contributorsAddress = 0x42cd691a49e8FF418528Fe906553B002846dE3cf; // company address address public companyAddress = 0xf9C722e5c7c3313BBcD80e9A78e055391f75C732; // market Address address public marketAddress = 0xbd2F5D1975ccE83dfbf2B5743B1F8409CF211f90; // ICO Address address public icoAddress = 0xe26E3a77cA40b3e04C64E29f6c076Eec25a66E76; // the share of contributors uint8 public constant CONTRIBUTORS_SHARE = 30; // the share of company uint8 public constant COMPANY_SHARE = 20; // the share of market uint8 public constant MARKET_SHARE = 30; // the share of ICO uint8 public constant ICO_SHARE = 20; /** * Constructor that gives four address all existing tokens. */ constructor() public { totalSupply = INITIAL_SUPPLY; uint256 valueContributorsAddress = INITIAL_SUPPLY.mul(CONTRIBUTORS_SHARE).div(100); balances[contributorsAddress] = valueContributorsAddress; emit Transfer(address(0), contributorsAddress, valueContributorsAddress); uint256 valueCompanyAddress = INITIAL_SUPPLY.mul(COMPANY_SHARE).div(100); balances[companyAddress] = valueCompanyAddress; emit Transfer(address(0), companyAddress, valueCompanyAddress); uint256 valueMarketAddress = INITIAL_SUPPLY.mul(MARKET_SHARE).div(100); balances[marketAddress] = valueMarketAddress; emit Transfer(address(0), marketAddress, valueMarketAddress); uint256 valueIcoAddress = INITIAL_SUPPLY.mul(ICO_SHARE).div(100); balances[icoAddress] = valueIcoAddress; emit Transfer(address(0), icoAddress, valueIcoAddress); } } "}
{"sol name": "1635.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { return _a / _b; } /** * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** *  Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } contract ERC20 { uint256 totalSupply; function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); // This generates a public event on the blockchain that will notify clients function transfer(address _to, uint256 _value) public returns (bool); // This generates a public event on the blockchain that will notify clients function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to,  uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); } contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; /** * Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** *  Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256){ return allowed[_owner][_spender]; } /** * Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** *  Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public  returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** *  Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value);   // Check if the sender has enough balances[msg.sender] = balances[msg.sender].sub(_value);            // Subtract from the sender totalSupply = totalSupply.sub(_value);                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balances[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowed[_from][msg.sender]);    // Check allowance balances[_from] = balances[_from].sub(_value);                         // Subtract from the targeted balance allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value);             // Subtract from the sender's allowance totalSupply = totalSupply.sub(_value);                              // Update totalSupply emit Burn(_from, _value); return true; } } contract POBTokenERC20 is StandardToken { // Public variables of the token string public name = \"Proof Of Brain\"; string public symbol = \"PoB\"; uint8 constant public decimals = 18; uint256 constant public initialSupply = 2100*100000000; constructor() public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balances[msg.sender] = totalSupply;                // Give the creator all initial tokens emit Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "938.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //DY INTL BUSINESS INSTITUTE string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "532.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * Math operations with safety checks */ contract SafeMath { function safeMul(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function assert(bool assertion) internal { if (!assertion) { throw; } } } contract BackdoorBurner is SafeMath{ string public name; string public symbol; uint8 public decimals; uint256 public totalSupply; address public owner; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => uint256) public freezeOf; mapping (address => mapping (address => uint256)) public allowance; /* This generates a public event on the blockchain that will notify clients */ event Transfer(address indexed from, address indexed to, uint256 value); /* This notifies clients about the amount burnt */ event Burn(address indexed from, uint256 value); /* This notifies clients about the amount frozen */ event Freeze(address indexed from, uint256 value); /* This notifies clients about the amount unfrozen */ event Unfreeze(address indexed from, uint256 value); /* Initializes contract with initial supply tokens to the creator of the contract */ function BackdoorBurner( uint256 initialSupply, string tokenName, uint8 decimalUnits, string tokenSymbol ) { balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens totalSupply = initialSupply;                        // Update total supply name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes decimals = decimalUnits;                            // Amount of decimals for display purposes owner = msg.sender; } /* Send coins */ function transfer(address _to, uint256 _value) { if (_to == 0x0) throw;                               // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                     // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                            // Add the same to the recipient Transfer(msg.sender, _to, _value);                   // Notify anyone listening that this transfer took place } /* Allow another contract to spend some tokens in your behalf */ function approve(address _spender, uint256 _value) returns (bool success) { if (_value <= 0) throw; allowance[msg.sender][_spender] = _value; return true; } /* A contract attempts to get the coins */ function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (_to == 0x0) throw;                                // Prevent transfer to 0x0 address. Use burn() instead if (_value <= 0) throw; if (balanceOf[_from] < _value) throw;                 // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw;  // Check for overflows if (_value > allowance[_from][msg.sender]) throw;     // Check allowance balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                           // Subtract from the sender balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to], _value);                             // Add the same to the recipient allowance[_from][msg.sender] = SafeMath.safeSub(allowance[_from][msg.sender], _value); Transfer(_from, _to, _value); return true; } function burn(address _from, uint256 _value) returns (bool success) { if(msg.sender != owner)throw; if (balanceOf[_from] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[_from] = SafeMath.safeSub(balanceOf[_from], _value);                      // Subtract from the sender totalSupply = SafeMath.safeSub(totalSupply,_value);                                // Updates totalSupply Burn(_from, _value); return true; } function freeze(uint256 _value) returns (bool success) { if (balanceOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; balanceOf[msg.sender] = SafeMath.safeSub(balanceOf[msg.sender], _value);                      // Subtract from the sender freezeOf[msg.sender] = SafeMath.safeAdd(freezeOf[msg.sender], _value);                                // Updates totalSupply Freeze(msg.sender, _value); return true; } function unfreeze(uint256 _value) returns (bool success) { if (freezeOf[msg.sender] < _value) throw;            // Check if the sender has enough if (_value <= 0) throw; freezeOf[msg.sender] = SafeMath.safeSub(freezeOf[msg.sender], _value);                      // Subtract from the sender balanceOf[msg.sender] = SafeMath.safeAdd(balanceOf[msg.sender], _value); Unfreeze(msg.sender, _value); return true; } // transfer balance to owner function withdrawEther(uint256 amount) { if(msg.sender != owner)throw; owner.transfer(amount); } // can accept ether function() payable { } } "}
{"sol name": "1689.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract BeeAppToken { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply = 1500000000000000000000000000; // This creates an array with all balances mapping (address => uint256) public balanceOf; //mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients //event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt //event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( // uint256 initialSupply, // string tokenName, // string tokenSymbol ) public { //totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = \"Bee App Token\";                                   // Set the name for display purposes symbol = \"BTO\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { //   require(_value <= allowance[_from][msg.sender]);     // Check allowance require(_value <= balanceOf[_from]); // balanceOf[_from] -= _value; //allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } } "}
{"sol name": "580.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'Virgin' token contract // // Deployed to : 0xdbad5408df192eb20ff36d6143dd3ac71a10725d // Symbol      : Paytk // Name        : Paytoken // Total supply: 1000000000000000 // Decimals    : 18 // // Enjoy. // Coding by Jarmo van de Seijp // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract PayToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function PayToken() public { symbol = \"PAYTK\"; name = \"PayToken\"; decimals = 18; _totalSupply = 1000000000000000000000000000; balances[0xdbad5408df192eb20ff36d6143dd3ac71a10725d] = _totalSupply; Transfer(address(0), 0xdbad5408df192eb20ff36d6143dd3ac71a10725d, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "843.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: openzeppelin-solidity/contracts/ownership/rbac/Roles.sol /** * @title Roles * @author Francisco Giordano (@frangio) * @dev Library for managing addresses assigned to a Role. *      See RBAC.sol for example usage. */ library Roles { struct Role { mapping (address => bool) bearer; } /** * @dev give an address access to this role */ function add(Role storage role, address addr) internal { role.bearer[addr] = true; } /** * @dev remove an address' access to this role */ function remove(Role storage role, address addr) internal { role.bearer[addr] = false; } /** * @dev check if an address has this role * // reverts */ function check(Role storage role, address addr) view internal { require(has(role, addr)); } /** * @dev check if an address has this role * @return bool */ function has(Role storage role, address addr) view internal returns (bool) { return role.bearer[addr]; } } // File: openzeppelin-solidity/contracts/ownership/rbac/RBAC.sol /** * @title RBAC (Role-Based Access Control) * @author Matt Condon (@Shrugs) * @dev Stores and provides setters and getters for roles and addresses. * @dev Supports unlimited numbers of roles and addresses. * @dev See //contracts/mocks/RBACMock.sol for an example of usage. * This RBAC method uses strings to key roles. It may be beneficial *  for you to write your own implementation of this interface using Enums or similar. * It's also recommended that you define constants in the contract, like ROLE_ADMIN below, *  to avoid typos. */ contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address addr, string roleName); event RoleRemoved(address addr, string roleName); /** * @dev reverts if addr does not have role * @param addr address * @param roleName the name of the role * // reverts */ function checkRole(address addr, string roleName) view public { roles[roleName].check(addr); } /** * @dev determine if addr has role * @param addr address * @param roleName the name of the role * @return bool */ function hasRole(address addr, string roleName) view public returns (bool) { return roles[roleName].has(addr); } /** * @dev add a role to an address * @param addr address * @param roleName the name of the role */ function addRole(address addr, string roleName) internal { roles[roleName].add(addr); emit RoleAdded(addr, roleName); } /** * @dev remove a role from an address * @param addr address * @param roleName the name of the role */ function removeRole(address addr, string roleName) internal { roles[roleName].remove(addr); emit RoleRemoved(addr, roleName); } /** * @dev modifier to scope access to a single role (uses msg.sender as addr) * @param roleName the name of the role * // reverts */ modifier onlyRole(string roleName) { checkRole(msg.sender, roleName); _; } /** * @dev modifier to scope access to a set of roles (uses msg.sender as addr) * @param roleNames the names of the roles to scope access to * // reverts * * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this *  see: https://github.com/ethereum/solidity/issues/2467 */ // modifier onlyRoles(string[] roleNames) { //     bool hasAnyRole = false; //     for (uint8 i = 0; i < roleNames.length; i++) { //         if (hasRole(msg.sender, roleNames[i])) { //             hasAnyRole = true; //             break; //         } //     } //     require(hasAnyRole); //     _; // } } // File: contracts/RBACMintableToken.sol // This contract is adapted from RBACMintableToken by OpenZeppelin pragma solidity ^0.4.19; /** * @title RBACMintableToken * @author Vittorio Minacori (@vittominacori) * @dev Mintable Token, with RBAC minter permissions */ contract RBACMintableToken is MintableToken, RBAC { /** * A constant role name for indicating minters. */ string public constant ROLE_MINTER = \"minter\"; address[] internal minters; /** * @dev override the Mintable token modifier to add role based logic */ modifier hasMintPermission() { checkRole(msg.sender, ROLE_MINTER); _; } /** * @dev add a minter role to an address * @param minter address */ function addMinter(address minter) onlyOwner public { if (!hasRole(minter, ROLE_MINTER)) minters.push(minter); addRole(minter, ROLE_MINTER); } /** * @dev remove a minter role from an address * @param minter address */ function removeMinter(address minter) onlyOwner public { removeRole(minter, ROLE_MINTER); removeMinterByValue(minter); } function getNumberOfMinters() onlyOwner public view returns (uint) { return minters.length; } function getMinter(uint _index) onlyOwner public view returns (address) { require(_index < minters.length); return minters[_index]; } function removeMinterByIndex(uint index) internal { require(minters.length > 0); if (minters.length > 1) { minters[index] = minters[minters.length - 1]; // recover gas delete (minters[minters.length - 1]); } minters.length--; } function removeMinterByValue(address _client) internal { for (uint i = 0; i < minters.length; i++) { if (minters[i] == _client) { removeMinterByIndex(i); break; } } } } // File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: contracts/CappedToken.sol // This contract is adapted from CappedToken by OpenZeppelin pragma solidity ^0.4.19; /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } // File: contracts/DeviseToken.sol contract DeviseToken is CappedToken, BurnableToken, RBACMintableToken { string public name = \"DEVISE\"; string public symbol = \"DVZ\"; // The pricision is set to micro DVZ uint8 public decimals = 6; function DeviseToken(uint256 _cap) public CappedToken(_cap) { addMinter(owner); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { removeMinter(owner); addMinter(newOwner); super.transferOwnership(newOwner); } } "}
{"sol name": "668.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT238736' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT238736 // Name        : ADZbuzz Allstate.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT238736\"; name = \"ADZbuzz Allstate.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "210.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'AquaToken' token contract // // Deployed to : 0x8436702c9251c4dD378A52c917bf40895c5C9872 // Symbol      : AQT // Name        : AquaToken // Total supply: 10000000000000000 // Decimals    : 8 // // Enjoy. // // AquaToken contract created by AquaToken Team // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract AquaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function AquaToken() public { symbol = \"AQT\"; name = \"AquaToken\"; decimals = 8; _totalSupply = 10000000000000000; balances[0x8436702c9251c4dD378A52c917bf40895c5C9872] = _totalSupply; Transfer(address(0), 0x8436702c9251c4dD378A52c917bf40895c5C9872, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1807.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Welcome To ZeroChain Network Airdrop // // send at least 0.0001 ETH to Smart Contract 0x7589e58B2197CA56BcD186c871D3c9aBdE35B737 // NOTE: do not forget to set the gas price 100,000 for the transaction to run smoothly // Symbol      : OxCN // Name        : ZeroChainNetwork // Total supply: 1,000,000,000 // Decimals    : 18 //EXCHANGE: //while for the exchange, we have contacted some exchanges and we will probably be scheduled in the stock 4 days after the first stage 1 airdrop is done, this is the list of exchanges we managed to contact //1. Mercatox (negotiation) //2. idax (negotiation) //3. forkdelta (no response yet) //4. crex24 (negotiation) //5. bitebtc (negotiation) //6. idex (no response) //7. coinex (negotiation) //8. hitbtc (unconfirmed) //YOUR SUPPORT: //we appreciate your support, we are very excited and excited for all your support, // //supportive wallet: //-myetherwallet (online) //-metamask (extension) //-imtoken (Android) //-coinomi (Android) // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract OxChainNetwork is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; uint public startDate; uint public bonusEnds; uint public endDate; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function OxChainNetwork() public { symbol = \"OxCN\"; name = \"OxChain Network\"; decimals = 18; bonusEnds = now + 1500 weeks; endDate = now + 7500 weeks; } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // 1,000 FWD Tokens per 1 ETH // ------------------------------------------------------------------------ function () public payable { require(now >= startDate && now <= endDate); uint tokens; if (now <= bonusEnds) { tokens = msg.value * 50000001; } else { tokens = msg.value * 14000000000000000000000; } balances[msg.sender] = safeAdd(balances[msg.sender], tokens); _totalSupply = safeAdd(_totalSupply, tokens); Transfer(address(0), msg.sender, tokens); owner.transfer(msg.value); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "306.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "607.sol", "label": 1, "sol content": "pragma solidity ^0.4.21; // File: contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } // File: contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract DubaiGreenBlockChain is StandardToken, Ownable { // Constants string  public constant name = \"Dubai Green BlockChain\"; string  public constant symbol = \"DGBC\"; uint8   public constant decimals = 4; uint256 public constant INITIAL_SUPPLY      = 1000000000 * (10 ** uint256(decimals)); mapping(address => bool) touched; function DubaiGreenBlockChain() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } function _transfer(address _from, address _to, uint _value) internal { require (balances[_from] >= _value);               // Check if the sender has enough require (balances[_to] + _value > balances[_to]); // Check for overflows balances[_from] = balances[_from].sub(_value);                         // Subtract from the sender balances[_to] = balances[_to].add(_value);                            // Add the same to the recipient emit Transfer(_from, _to, _value); } function safeWithdrawal(uint _value ) onlyOwner public { if (_value == 0) owner.transfer(address(this).balance); else owner.transfer(_value); } } "}
{"sol name": "1735.sol", "label": 1, "sol content": "pragma solidity ^0.4.16; contract moduleTokenInterface{ uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed a_owner, address indexed _spender, uint256 _value); event OwnerChang(address indexed _old,address indexed _new,uint256 _coin_change); event adminUsrChange(address usrAddr,address changeBy,bool isAdded); event onAdminTransfer(address to,uint256 value); } contract moduleToken is moduleTokenInterface { struct transferPlanInfo{ uint256 transferValidValue; bool isInfoValid; } struct ethPlanInfo{ uint256 ethNum; uint256 coinNum; bool isValid; } //\u7ba1\u7406\u5458\u4e4b\u4e00\u53d1\u8d77\u4e00\u4e2a\u8f6c\u8d26\u64cd\u4f5c\uff0c\u9700\u8981\u591a\u4eba\u6279\u51c6\u65f6\u91c7\u7528\u8fd9\u4e2a\u6570\u636e\u7ed3\u6784 struct transferEthAgreement{ //\u8981\u54ea\u4e9b\u4eba\u7b7e\u7f72 mapping(address=>bool) signUsrList; //\u5df2\u7ecf\u7b7e\u7f72\u7684\u4eba\u6570 uint32 signedUsrCount; //\u8981\u6c42\u8f6c\u51fa\u7684eth\u6570\u91cf uint256 transferEthInWei; //\u8f6c\u5f80\u54ea\u91cc address to; //\u5f53\u524d\u8f6c\u8d26\u8981\u6c42\u7684\u53d1\u8d77\u4eba address infoOwner; //\u5f53\u524d\u8bb0\u5f55\u662f\u5426\u6709\u6548(\u5fc5\u987b123456789) uint32 magic; //\u662f\u5426\u751f\u6548\u4e86 bool isValid; } string public name;                   //\u540d\u79f0\uff0c\u4f8b\u5982\"My test token\" uint8 public decimals;               //\u8fd4\u56detoken\u4f7f\u7528\u7684\u5c0f\u6570\u70b9\u540e\u51e0\u4f4d\u3002\u6bd4\u5982\u5982\u679c\u8bbe\u7f6e\u4e3a3\uff0c\u5c31\u662f\u652f\u63010.001\u8868\u793a. string public symbol;               //token\u7b80\u79f0,like MTT address public owner; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; //\u662f\u5426\u5141\u8bb8\u76f4\u63a5\u63a5\u53d7eth\u800c\u4e0d\u8fd4\u56decot bool public canRecvEthDirect=false; //\u4ee5\u4e0b\u4e3a\u672c\u4ee3\u5e01\u534f\u8bae\u7279\u6b8a\u903b\u8f91\u6240\u9700\u7684\u76f8\u5173\u53d8 // //\u5e01\u7684\u4ef7\u683c\uff0c\u4e3a0\u65f6\u5219\u82b1\u94b1\u6309\u4ef7\u683c\u8d2d\u4e70\u7684\u903b\u8f91\u4e0d\u751f\u6548 uint256 public coinPriceInWei; //\u5728\u5217\u8868\u91cc\u7684\u4eba\u8f6c\u51fa\u4ee3\u5e01\u5fc5\u987b\u9075\u5b88\u89c4\u5b9a\u7684\u65f6\u95f4\u3001\u6570\u91cf\u9650\u5236(\u6bd4\u5982\u5b9e\u73b0\u4ee3\u5e01\u5b9a\u65f6\u89e3\u51bb) mapping(address=>transferPlanInfo) public transferPlanList; //\u6307\u5b9a\u7684\u4eba\u6309\u6307\u5b9a\u7684\u4ee5\u592a\u5e01\u6570\u91cf\u3001\u4ee3\u5e01\u6570\u91cf\u8d2d\u4e70\u4ee3\u5e01\uff0c\u4e0d\u6309\u4ef7\u683c\u903b\u8f91\u8d2d\u4e70\uff08\u6bd4\u5982\u5929\u4f7f\u8f6e\u52df\u8d44\uff09 //\u5426\u5219\u6309\u4ef7\u683c\u76f8\u5173\u903b\u8f91\u5904\u7406\u8d2d\u4e70\u4ee3\u5e01\u7684\u8bf7\u6c42 mapping(address => ethPlanInfo) public ethPlanList; uint public blockTime=block.timestamp; bool public isTransPaused=true;//\u4e3atrue\u65f6\u7981\u6b62\u8f6c\u8d26 //\u5b9e\u73b0\u591a\u7ba1\u7406\u5458\u76f8\u5173\u7684\u53d8\u91cf struct adminUsrInfo{ bool isValid; string userName; string descInfo; } mapping(address=>adminUsrInfo) public adminOwners; //\u7ba1\u7406\u5458\u7ec4 bool public isAdminOwnersValid; uint32 public adminUsrCount;//\u6709\u6548\u7684\u7ba1\u7406\u5458\u7528\u6237\u6570 mapping(uint256=>transferEthAgreement) public transferEthAgreementList; function moduleToken( uint256 _initialAmount, uint8 _decimalUnits) public { owner=msg.sender;//\u8bb0\u5f55\u5408\u7ea6\u7684owner if(_initialAmount<=0){ totalSupply = 100000000000;   // \u8bbe\u7f6e\u521d\u59cb\u603b\u91cf balances[owner]=100000000000; }else{ totalSupply = _initialAmount;   // \u8bbe\u7f6e\u521d\u59cb\u603b\u91cf balances[owner]=_initialAmount; } if(_decimalUnits<=0){ decimals=2; }else{ decimals = _decimalUnits; } name = \"CareerOn Token\"; symbol = \"COT\"; } function changeContractName(string _newName,string _newSymbol) public { require(msg.sender==owner || adminOwners[msg.sender].isValid); name=_newName; symbol=_newSymbol; } function transfer( address _to, uint256 _value) public returns (bool success) { if(isTransPaused){ emit Transfer(msg.sender, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } //\u9ed8\u8ba4totalSupply \u4e0d\u4f1a\u8d85\u8fc7\u6700\u5927\u503c (2^256 - 1). //\u5982\u679c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u5c06\u4f1a\u6709\u65b0\u7684token\u751f\u6210\uff0c\u5219\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u53e5\u907f\u514d\u6ea2\u51fa\u7684\u5f02\u5e38 if(_to==address(this)){ emit Transfer(msg.sender, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } if(balances[msg.sender] < _value || balances[_to] + _value <= balances[_to]) { emit Transfer(msg.sender, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } if(transferPlanList[msg.sender].isInfoValid && transferPlanList[msg.sender].transferValidValue<_value) { emit Transfer(msg.sender, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } balances[msg.sender] -= _value;//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[_to] += _value;//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value if(transferPlanList[msg.sender].isInfoValid){ transferPlanList[msg.sender].transferValidValue -=_value; } emit Transfer(msg.sender, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function transferFrom( address _from, address _to, uint256 _value) public returns (bool success) { if(isTransPaused){ emit Transfer(_from, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } if(_to==address(this)){ emit Transfer(_from, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } if(balances[_from] < _value || allowed[_from][msg.sender] < _value) { emit Transfer(_from, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } if(transferPlanList[_from].isInfoValid && transferPlanList[_from].transferValidValue<_value) { emit Transfer(_from, _to, 0);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 revert(); return; } balances[_to] += _value;//\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value balances[_from] -= _value; //\u652f\u51fa\u8d26\u6237_from\u51cf\u53bbtoken\u6570\u91cf_value allowed[_from][msg.sender] -= _value;//\u6d88\u606f\u53d1\u9001\u8005\u53ef\u4ee5\u4ece\u8d26\u6237_from\u4e2d\u8f6c\u51fa\u7684\u6570\u91cf\u51cf\u5c11_value if(transferPlanList[_from].isInfoValid){ transferPlanList[_from].transferValidValue -=_value; } emit Transfer(_from, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function balanceOf(address accountAddr) public constant returns (uint256 balance) { return balances[accountAddr]; } function approve(address _spender, uint256 _value) public returns (bool success) { require(msg.sender!=_spender && _value>0); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance( address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender];//\u5141\u8bb8_spender\u4ece_owner\u4e2d\u8f6c\u51fa\u7684token\u6570 } //\u4ee5\u4e0b\u4e3a\u672c\u4ee3\u5e01\u534f\u8bae\u7684\u7279\u6b8a\u903b\u8f91 //\u8f6c\u79fb\u534f\u8bae\u6240\u6709\u6743\u5e76\u5c06\u9644\u5e26\u7684\u4ee3\u5e01\u4e00\u5e76\u8f6c\u79fb\u8fc7\u53bb function changeOwner(address newOwner) public{ require(msg.sender==owner && msg.sender!=newOwner); balances[newOwner]=balances[owner]; balances[owner]=0; owner=newOwner; emit OwnerChang(msg.sender,newOwner,balances[owner]);//\u89e6\u53d1\u5408\u7ea6\u6240\u6709\u6743\u7684\u8f6c\u79fb\u4e8b\u4ef6 } function setPauseStatus(bool isPaused)public{ if(msg.sender!=owner && !adminOwners[msg.sender].isValid){ revert(); return; } isTransPaused=isPaused; } //\u8bbe\u7f6e\u8f6c\u8d26\u9650\u5236\uff0c\u6bd4\u5982\u51bb\u7ed3\u4ec0\u4e48\u7684 function setTransferPlan(address addr, uint256 allowedMaxValue, bool isValid) public { if(msg.sender!=owner && !adminOwners[msg.sender].isValid){ revert(); return ; } transferPlanList[addr].isInfoValid=isValid; if(transferPlanList[addr].isInfoValid){ transferPlanList[addr].transferValidValue=allowedMaxValue; } } //\u628a\u672c\u4ee3\u5e01\u534f\u8bae\u8d26\u6237\u4e0b\u7684eth\u8f6c\u5230\u6307\u5b9a\u8d26\u6237 function TransferEthToAddr(address _to,uint256 _value)public payable{ require(msg.sender==owner && !isAdminOwnersValid); _to.transfer(_value); } function createTransferAgreement(uint256 agreeMentId, uint256 transferEthInWei, address to) public { require(adminOwners[msg.sender].isValid && transferEthAgreementList[agreeMentId].magic!=123456789 && transferEthAgreementList[agreeMentId].magic!=987654321); transferEthAgreementList[agreeMentId].magic=123456789; transferEthAgreementList[agreeMentId].infoOwner=msg.sender; transferEthAgreementList[agreeMentId].transferEthInWei=transferEthInWei; transferEthAgreementList[agreeMentId].to=to; transferEthAgreementList[agreeMentId].isValid=true; transferEthAgreementList[agreeMentId].signUsrList[msg.sender]=true; transferEthAgreementList[agreeMentId].signedUsrCount=1; } function disableTransferAgreement(uint256 agreeMentId) public { require(transferEthAgreementList[agreeMentId].infoOwner==msg.sender && transferEthAgreementList[agreeMentId].magic==123456789); transferEthAgreementList[agreeMentId].isValid=false; transferEthAgreementList[agreeMentId].magic=987654321; } function sign(uint256 agreeMentId,address to,uint256 transferEthInWei) public payable{ require(transferEthAgreementList[agreeMentId].magic==123456789 && transferEthAgreementList[agreeMentId].isValid && transferEthAgreementList[agreeMentId].transferEthInWei==transferEthInWei && transferEthAgreementList[agreeMentId].to==to && adminOwners[msg.sender].isValid && !transferEthAgreementList[agreeMentId].signUsrList[msg.sender]&& adminUsrCount>=2 ); transferEthAgreementList[agreeMentId].signUsrList[msg.sender]=true; transferEthAgreementList[agreeMentId].signedUsrCount++; if(transferEthAgreementList[agreeMentId].signedUsrCount<=adminUsrCount/2) { return; } to.transfer(transferEthInWei); transferEthAgreementList[agreeMentId].isValid=false; transferEthAgreementList[agreeMentId].magic=987654321; emit onAdminTransfer(to,transferEthInWei); return; } struct needToAddAdminInfo{ uint256 magic; mapping(address=>uint256) postedPeople; uint32 postedCount; } mapping(address=>needToAddAdminInfo) public needToAddAdminInfoList; function addAdminOwners(address usrAddr, string userName, string descInfo)public { needToAddAdminInfo memory info; //\u4e0d\u662f\u7ba1\u7406\u5458\u4e5f\u4e0d\u662fowner\uff0c\u5219\u7981\u6b62\u4efb\u4f55\u64cd\u4f5c if(!adminOwners[msg.sender].isValid && owner!=msg.sender){ revert(); return; } //\u4efb\u4f55\u60c5\u51b5,owner\u5730\u5740\u4e0d\u53ef\u4ee5\u88ab\u6dfb\u52a0\u5230\u7ba1\u7406\u5458\u7ec4 if(usrAddr==owner){ revert(); return; } //\u5df2\u7ecf\u5728\u7ba1\u7406\u5458\u7ec4\u7684\u4e0d\u53ef\u4ee5\u88ab\u6dfb\u52a0 if(adminOwners[usrAddr].isValid){ revert(); return; } //\u4e0d\u5141\u8bb8\u6dfb\u52a0\u81ea\u5df1\u5230\u7ba1\u7406\u5458\u7ec4 if(usrAddr==msg.sender){ revert(); return; } //\u7ba1\u7406\u5458\u4e0d\u52302\u4eba\u65f6\uff0cowner\u53ef\u4ee5\u81f3\u591a\u6dfb\u52a02\u4eba\u5230\u7ba1\u7406\u5458 if(adminUsrCount<2){ if(msg.sender!=owner){ revert(); return; } adminOwners[usrAddr].isValid=true; adminOwners[usrAddr].userName=userName; adminOwners[usrAddr].descInfo=descInfo; adminUsrCount++; if(adminUsrCount>=2) isAdminOwnersValid=true; emit adminUsrChange(usrAddr,msg.sender,true); return; } //\u7ba1\u7406\u5458\u5927\u4e8e\u7b49\u4e8e2\u4eba\u65f6\uff0cowner\u6dfb\u52a0\u7ba1\u7406\u5458\u9700\u8981\u5f97\u5230\u8fc7\u534a\u6570\u7ba1\u7406\u5458\u7684\u540c\u610f\uff0c\u800c\u4e14\u81f3\u5c11\u5fc5\u987b\u662f2 if(msg.sender==owner){ //\u67d0\u4e2a\u7528\u6237\u5df2\u7ecf\u88ab\u8981\u6c42\u6dfb\u52a0\u5230\u7ba1\u7406\u5458\u7ec4\uff0cowner\u6b64\u65f6\u662f\u6ca1\u6709\u6295\u7968\u6743\u7684 if(needToAddAdminInfoList[usrAddr].magic==123456789){ revert(); return; } //\u5141\u8bb8owner\u628a\u67d0\u4e2a\u4eba\u6dfb\u52a0\u5230\u8981\u6c42\u8fdb\u5165\u7ba1\u7406\u5458\u7ec4\u7684\u5217\u8868\u91cc\uff0c\u540e\u7eed\u7531\u5176\u5b83\u7ba1\u7406\u5458\u6295\u7968 info.magic=123456789; info.postedCount=0; needToAddAdminInfoList[usrAddr]=info; return; }//\u7ba1\u7406\u5458\u5927\u4e8e\u7b49\u4e8e2\u4eba\u65f6\uff0cowner\u6dfb\u52a0\u65b0\u7684\u7ba1\u7406\u5458\uff0c\u5fc5\u987b\u8fc7\u534a\u6570\u7ba1\u7406\u5458\u540c\u610f\u4e14\u81f3\u5c11\u662f2 else if(adminOwners[msg.sender].isValid) { //\u7ba1\u7406\u5458\u53ea\u80fd\u6295\u7968\u786e\u8ba4\u6dfb\u52a0\u7ba1\u7406\u5458\uff0c\u4e0d\u80fd\u76f4\u63a5\u6dfb\u52a0\u7ba1\u7406\u5458 if(needToAddAdminInfoList[usrAddr].magic!=123456789){ revert(); return; } //\u5df2\u7ecf\u6295\u8fc7\u7968\u7684\u7ba1\u7406\u5458\u4e0d\u5141\u8bb8\u518d\u6295 if(needToAddAdminInfoList[usrAddr].postedPeople[msg.sender]==123456789){ revert(); return; } needToAddAdminInfoList[usrAddr].postedCount++; needToAddAdminInfoList[usrAddr].postedPeople[msg.sender]=123456789; if(adminUsrCount>=2 && needToAddAdminInfoList[usrAddr].postedCount>adminUsrCount/2){ adminOwners[usrAddr].userName=userName; adminOwners[usrAddr].descInfo=descInfo; adminOwners[usrAddr].isValid=true; needToAddAdminInfoList[usrAddr]=info; adminUsrCount++; emit adminUsrChange(usrAddr,msg.sender,true); return; } }else{ return revert();//\u5176\u5b83\u60c5\u51b5\u4e00\u5f8b\u4e0d\u53ef\u4ee5\u6dfb\u52a0\u7ba1\u7406\u5458 } } struct needDelFromAdminInfo{ uint256 magic; mapping(address=>uint256) postedPeople; uint32 postedCount; } mapping(address=>needDelFromAdminInfo) public needDelFromAdminInfoList; function delAdminUsrs(address usrAddr) public { needDelFromAdminInfo memory info; //\u5c1a\u4e0d\u662f\u7ba1\u7406\u5458\uff0c\u65e0\u9700\u5220\u9664 if(!adminOwners[usrAddr].isValid){ revert(); return; } //\u5f53\u524d\u7ba1\u7406\u5458\u6570\u5c0f\u4e8e4\u7684\u8bdd\u4e0d\u8ba9\u518d\u5220\u7528\u6237 if(adminUsrCount<4){ revert(); return; } //\u5f53\u524d\u7ba1\u7406\u5458\u6570\u662f\u5947\u6570\u65f6\u4e0d\u8ba9\u5220\u7528\u6237 if(adminUsrCount%2!=0){ revert(); return; } //\u4e0d\u5141\u8bb8\u628a\u81ea\u5df1\u9000\u51fa\u7ba1\u7406\u5458 if(usrAddr==msg.sender){ revert(); return; } if(msg.sender==owner){ //owner\u6ca1\u6709\u6743\u9650\u786e\u8ba4\u5220\u9664\u7ba1\u7406\u5458 if(needDelFromAdminInfoList[usrAddr].magic==123456789){ revert(); return; } //owner\u53ef\u4ee5\u63d0\u8bae\u5220\u9664\u7ba1\u7406\u5458\uff0c\u4f46\u662f\u9700\u8981\u7ba1\u7406\u5458\u8fc7\u534a\u6570\u540c\u610f info.magic=123456789; info.postedCount=0; needDelFromAdminInfoList[usrAddr]=info; return; } //\u7ba1\u7406\u5458\u786e\u8ba4\u5220\u9664\u7528\u6237 //\u7ba1\u7406\u5458\u53ea\u6709\u6743\u9650\u786e\u8ba4\u5220\u9664 if(needDelFromAdminInfoList[usrAddr].magic!=123456789){ revert(); return; } //\u5df2\u7ecf\u6295\u8fc7\u7968\u7684\u4e0d\u5141\u8bb8\u518d\u6295 if(needDelFromAdminInfoList[usrAddr].postedPeople[msg.sender]==123456789){ revert(); return; } needDelFromAdminInfoList[usrAddr].postedCount++; needDelFromAdminInfoList[usrAddr].postedPeople[msg.sender]=123456789; //\u540c\u610f\u7684\u4eba\u6570\u5c1a\u672a\u8d85\u8fc7\u4e00\u534a\u5219\u76f4\u63a5\u8fd4\u56de if(needDelFromAdminInfoList[usrAddr].postedCount<=adminUsrCount/2){ return; } //\u540c\u610f\u7684\u4eba\u6570\u8d85\u8fc7\u4e00\u534a adminOwners[usrAddr].isValid=false; if(adminUsrCount>=1) adminUsrCount--; if(adminUsrCount<=1) isAdminOwnersValid=false; needDelFromAdminInfoList[usrAddr]=info; emit adminUsrChange(usrAddr,msg.sender,false); } //\u8bbe\u7f6e\u6307\u5b9a\u4eba\u6309\u56fa\u5b9aeth\u6570\u3001\u56fa\u5b9a\u4ee3\u5e01\u6570\u8d2d\u4e70\u4ee3\u5e01\uff0c\u6bd4\u5982\u5929\u4f7f\u8f6e\u52df\u8d44 function setEthPlan(address addr,uint256 _ethNum,uint256 _coinNum,bool _isValid) public { require(msg.sender==owner && _ethNum>=0 && _coinNum>=0 && (_ethNum + _coinNum)>0 && _coinNum<=balances[owner]); ethPlanList[addr].isValid=_isValid; if(ethPlanList[addr].isValid){ ethPlanList[addr].ethNum=_ethNum; ethPlanList[addr].coinNum=_coinNum; } } //\u8bbe\u7f6e\u4ee3\u5e01\u4ef7\u683c(Wei) function setCoinPrice(uint256 newPriceInWei) public returns(uint256 oldPriceInWei){ require(msg.sender==owner); uint256 _old=coinPriceInWei; coinPriceInWei=newPriceInWei; return _old; } function balanceInWei() public constant returns(uint256 nowBalanceInWei){ return address(this).balance; } function changeRecvEthStatus(bool _canRecvEthDirect) public{ if(msg.sender!=owner){ revert(); return; } canRecvEthDirect=_canRecvEthDirect; } //\u56de\u9000\u51fd\u6570 //\u5408\u7ea6\u8d26\u6237\u6536\u5230eth\u65f6\u4f1a\u88ab\u8c03\u7528 //\u4efb\u4f55\u5f02\u5e38\u65f6\uff0c\u8fd9\u4e2a\u51fd\u6570\u4e5f\u4f1a\u88ab\u8c03\u7528 //\u82e5\u6709\u96f6\u5934\u4e0d\u627e\u96f6\uff0c\u907f\u514d\u88abDDOS\u653b\u51fb function () public payable { if(canRecvEthDirect){ return; } if(ethPlanList[msg.sender].isValid==true && msg.value>=ethPlanList[msg.sender].ethNum && ethPlanList[msg.sender].coinNum>=0 && ethPlanList[msg.sender].coinNum<=balances[owner]){ ethPlanList[msg.sender].isValid=false; balances[owner] -= ethPlanList[msg.sender].coinNum;//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[msg.sender] += ethPlanList[msg.sender].coinNum;//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value emit Transfer(this, msg.sender, ethPlanList[msg.sender].coinNum);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 }else if(!ethPlanList[msg.sender].isValid && coinPriceInWei>0 && msg.value/coinPriceInWei<=balances[owner] && msg.value/coinPriceInWei+balances[msg.sender]>balances[msg.sender]){ uint256 buyCount=msg.value/coinPriceInWei; balances[owner] -=buyCount; balances[msg.sender] +=buyCount; emit Transfer(this, msg.sender, buyCount);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 }else{ revert(); } } } "}
{"sol name": "35.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; contract BEECASHBACKHOME { uint public constant _totalSupply = 50000000000000000000000000; string public constant symbol = \"BCH\"; string public constant name = \"BEE CASHBACK HOME\"; uint8 public constant decimals = 18; mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; function BEECASHBACKHOME() { balances[msg.sender] = _totalSupply; } function totalSupply() constant returns (uint256 totalSupply) { return _totalSupply; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function transfer (address _to, uint256 _value) returns (bool success) { require( balances[msg.sender] >= _value && _value > 0 ); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require( allowed[_from][msg.sender] >= _value && balances[_from] >= _value && _value > 0 ); balances[_from] -= _value; balances[_to] += _value; allowed [_from][msg.sender] -= _value; Transfer (_from, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } "}
{"sol name": "34.sol", "label": 1, "sol content": "/** Global Gold Cash */ pragma solidity ^0.4.18; contract owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } function destruct() public onlyOwner { selfdestruct(owner); } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor() public { totalSupply = 10000000 * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = 'Global Gold Cash';                          // Set the name for display purposes symbol = \"GGC\";                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0);                        // Prevent transfer to 0x0 address. Use burn() instead require(balanceOf[_from] >= _value);        // Check if the sender has enough require(balanceOf[_to] + _value > balanceOf[_to]);  // Check for overflows uint previousBalances = balanceOf[_from] + balanceOf[_to];  // Save this for an assertion in the future balanceOf[_from] -= _value;                     // Subtract from the sender balanceOf[_to] += _value;                       // Add the same to the recipient emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances);      // Asserts are used to use static analysis to find bugs in your code. They should never fail } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } contract GlobalGoldCashToken is owned, TokenERC20 { uint256 public decimals = 18; string  public tokenName; string  public tokenSymbol; uint minBalanceForAccounts ;                                         //threshold amount mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ constructor() public { owner = msg.sender; totalSupply = 1000000000000000000; balanceOf[owner]=totalSupply; tokenName=\"Global Gold Cash\"; tokenSymbol=\"GGC\"; } /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value > balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); } /// @notice Create `mintedAmount` tokens and send it to `target` /// @param target Address to receive the tokens /// @param mintedAmount the amount of tokens it will receive function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens /// @param target Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } } "}
{"sol name": "372.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; library SafeMath { function mul(uint a, uint b) internal pure returns (uint) { uint c = a * b; require(a == 0 || c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { uint c = a / b; return c; } function sub(uint a, uint b) internal pure returns (uint) { require(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint) { uint c = a + b; require(c >= a); return c; } function max(uint a, uint b) internal pure returns (uint) { return a >= b ? a : b; } function min(uint a, uint b) internal pure returns (uint) { return a < b ? a : b; } } // @title The Contract is Mongolian National MDEX Token Issue. // // @Author: Tim Wars // @Date: 2018.8.1 // @Seealso: ERC20 // contract MntToken { // === Event === event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed owner, address indexed spender, uint value); event Burn(address indexed from, uint value); event TransferLocked(address indexed from, address indexed to, uint value, uint8 locktype); event Purchased(address indexed recipient, uint purchase, uint amount); // === Defined === using SafeMath for uint; // --- Owner Section --- address public owner; bool public frozen = false; // // --- ERC20 Token Section --- uint8 constant public decimals = 6; uint public totalSupply = 100*10**(8+uint256(decimals));  // ***** 100 * 100 Million string constant public name = \"MDEX Platform Token | Mongolia National Blockchain Digital Assets Exchange Token\"; string constant public symbol = \"MNT\"; mapping(address => uint) ownerance; // Owner Balance mapping(address => mapping(address => uint)) public allowance; // Allower Balance // --- Locked Section --- uint8 LOCKED_TYPE_MAX = 2; // ***** Max locked type uint private constant RELEASE_BASE_TIME = 1533686888; // ***** (2018-08-08 08:08:08) Private Lock phase start datetime (UTC seconds) address[] private lockedOwner; mapping(address => uint) public lockedance; // Lockeder Balance mapping(address => uint8) public lockedtype; // Locked Type mapping(address => uint8) public unlockedstep; // Unlocked Step uint public totalCirculating; // Total circulating token amount // === Modifier === // --- Owner Section --- modifier isOwner() { require(msg.sender == owner); _; } modifier isNotFrozen() { require(!frozen); _; } // --- ERC20 Section --- modifier hasEnoughBalance(uint _amount) { require(ownerance[msg.sender] >= _amount); _; } modifier overflowDetected(address _owner, uint _amount) { require(ownerance[_owner] + _amount >= ownerance[_owner]); _; } modifier hasAllowBalance(address _owner, address _allower, uint _amount) { require(allowance[_owner][_allower] >= _amount); _; } modifier isNotEmpty(address _addr, uint _value) { require(_addr != address(0)); require(_value != 0); _; } modifier isValidAddress { assert(0x0 != msg.sender); _; } // --- Locked Section --- modifier hasntLockedBalance(address _checker) { require(lockedtype[_checker] == 0); _; } modifier checkLockedType(uint8 _locktype) { require(_locktype > 0 && _locktype <= LOCKED_TYPE_MAX); _; } // === Constructor === constructor() public { owner = msg.sender; ownerance[msg.sender] = totalSupply; totalCirculating = totalSupply; emit Transfer(address(0), msg.sender, totalSupply); } // --- ERC20 Token Section --- function approve(address _spender, uint _value) isNotFrozen isValidAddress public returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); // must spend to 0 where pre approve balance. allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint _value) isNotFrozen isValidAddress overflowDetected(_to, _value) public returns (bool success) { require(ownerance[_from] >= _value); require(allowance[_from][msg.sender] >= _value); ownerance[_to] = ownerance[_to].add(_value); ownerance[_from] = ownerance[_from].sub(_value); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint balance) { balance = ownerance[_owner] + lockedance[_owner]; return balance; } function available(address _owner) public constant returns (uint) { return ownerance[_owner]; } function transfer(address _to, uint _value) public isNotFrozen isValidAddress isNotEmpty(_to, _value) hasEnoughBalance(_value) overflowDetected(_to, _value) returns (bool success) { ownerance[msg.sender] = ownerance[msg.sender].sub(_value); ownerance[_to] = ownerance[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } // --- Owner Section --- function transferOwner(address _newOwner) isOwner public returns (bool success) { if (_newOwner != address(0)) { owner = _newOwner; } return true; } function freeze() isOwner public returns (bool success) { frozen = true; return true; } function unfreeze() isOwner public returns (bool success) { frozen = false; return true; } function burn(uint _value) isNotFrozen isValidAddress hasEnoughBalance(_value) public returns (bool success) { ownerance[msg.sender] = ownerance[msg.sender].sub(_value); ownerance[0x0] = ownerance[0x0].add(_value); totalSupply = totalSupply.sub(_value); totalCirculating = totalCirculating.sub(_value); emit Burn(msg.sender, _value); return true; } // --- Locked Section --- function transferLocked(address _to, uint _value, uint8 _locktype) public isNotFrozen isOwner isValidAddress isNotEmpty(_to, _value) hasEnoughBalance(_value) hasntLockedBalance(_to) checkLockedType(_locktype) returns (bool success) { require(msg.sender != _to); ownerance[msg.sender] = ownerance[msg.sender].sub(_value); if (_locktype == 1) { lockedance[_to] = _value; lockedtype[_to] = _locktype; lockedOwner.push(_to); totalCirculating = totalCirculating.sub(_value); emit TransferLocked(msg.sender, _to, _value, _locktype); } else if (_locktype == 2) { uint _first = _value / 100 * 8; // prevent overflow ownerance[_to] = ownerance[_to].add(_first); lockedance[_to] = _value.sub(_first); lockedtype[_to] = _locktype; lockedOwner.push(_to); totalCirculating = totalCirculating.sub(_value.sub(_first)); emit Transfer(msg.sender, _to, _first); emit TransferLocked(msg.sender, _to, _value.sub(_first), _locktype); } return true; } // ***** // Because too many unlocking steps * accounts, it will burn lots of GAS !!!!!!!!!!!!!!!!!!!!!!!!!!! // Because too many unlocking steps * accounts, it will burn lots of GAS !!!!!!!!!!!!!!!!!!!!!!!!!!! // // LockedType 1 : after 6 monthes / release 10 % per month; 10 steps // LockedType 2 :  before 0 monthes / release 8 % per month; 11 steps / 1 step has release real balance init. function unlock(address _locker, uint _delta, uint8 _locktype) private returns (bool success) { if (_locktype == 1) { if (_delta < 6 * 30 days) { return false; } uint _more1 = _delta.sub(6 * 30 days); uint _step1 = _more1 / 30 days; for(uint8 i = 0; i < 10; i++) { if (unlockedstep[_locker] == i && i < 9 && i <= _step1 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (10 - i)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (10 - i)); unlockedstep[_locker] = i + 1; } else if (i == 9 && unlockedstep[_locker] == 9 && _step1 == 9){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } else if (_locktype == 2) { if (_delta < 30 days) { return false; } uint _more2 = _delta - 30 days; uint _step2 = _more2 / 30 days; for(uint8 j = 0; j < 11; j++) { if (unlockedstep[_locker] == j && j < 10 && j <= _step2 ) { ownerance[_locker] = ownerance[_locker].add(lockedance[_locker] / (11 - j)); lockedance[_locker] = lockedance[_locker].sub(lockedance[_locker] / (11 - j)); unlockedstep[_locker] = j + 1; } else if (j == 10 && unlockedstep[_locker] == 10 && _step2 == 10){ ownerance[_locker] = ownerance[_locker].add(lockedance[_locker]); lockedance[_locker] = 0; unlockedstep[_locker] = 0; lockedtype[_locker] = 0; } } } return true; } function lockedCounts() public view returns (uint counts) { return lockedOwner.length; } function releaseLocked() public isNotFrozen returns (bool success) { require(now > RELEASE_BASE_TIME); uint delta = now - RELEASE_BASE_TIME; uint lockedAmount; for (uint i = 0; i < lockedOwner.length; i++) { if ( lockedance[lockedOwner[i]] > 0) { lockedAmount = lockedance[lockedOwner[i]]; unlock(lockedOwner[i], delta, lockedtype[lockedOwner[i]]); totalCirculating = totalCirculating.add(lockedAmount - lockedance[lockedOwner[i]]); } } return true; } } "}
{"sol name": "143.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ function Crowdsale(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens(address _beneficiary, uint256 _tokenAmount) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState(address _beneficiary, uint256 _weiAmount) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title PenCrowdsale * @dev Crowdsale that locks tokens from withdrawal until it ends. */ contract PenCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; // Map of all purchaiser's balances (doesn't include bounty amounts) mapping(address => uint256) public balances; // Amount of issued tokens uint256 public tokensIssued; // Bonus tokens rate multiplier x1000 (i.e. 1200 is 1.2 x 1000 = 120% x1000 = +20% bonus) uint256 public bonusMultiplier; // Is a crowdsale closed? bool public closed; /** * Event for token withdrawal logging * @param receiver who receive the tokens * @param amount amount of tokens sent */ event TokenDelivered(address indexed receiver, uint256 amount); /** * Event for token adding by referral program * @param beneficiary who got the tokens * @param amount amount of tokens added */ event TokenAdded(address indexed beneficiary, uint256 amount); /** * Init crowdsale by setting its params * * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold * @param _bonusMultiplier bonus tokens rate multiplier x1000 */ function PenCrowdsale( uint256 _rate, address _wallet, ERC20 _token, uint256 _bonusMultiplier ) Crowdsale( _rate, _wallet, _token ) { bonusMultiplier = _bonusMultiplier; } /** * @dev Withdraw tokens only after crowdsale ends. */ function withdrawTokens() public { _withdrawTokensFor(msg.sender); } /** * @dev Overrides parent by storing balances instead of issuing tokens right away. * @param _beneficiary Token purchaser * @param _tokenAmount Amount of tokens purchased */ function _processPurchase(address _beneficiary, uint256 _tokenAmount) internal { require(!hasClosed()); balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount); tokensIssued = tokensIssued.add(_tokenAmount); } /** * @dev Overrides the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate).mul(bonusMultiplier).div(1000); } /** * @dev Deliver tokens to receiver_ after crowdsale ends. */ function withdrawTokensFor(address receiver_) public onlyOwner { _withdrawTokensFor(receiver_); } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { return closed; } /** * @dev Closes the period in which the crowdsale is open. */ function closeCrowdsale(bool closed_) public onlyOwner { closed = closed_; } /** * @dev set the bonus multiplier. */ function setBonusMultiplier(uint256 bonusMultiplier_) public onlyOwner { bonusMultiplier = bonusMultiplier_; } /** * @dev Withdraw tokens excess on the contract after crowdsale. */ function postCrowdsaleWithdraw(uint256 _tokenAmount) public onlyOwner { token.transfer(wallet, _tokenAmount); } /** * @dev Add tokens for specified beneficiary (referral system tokens, for example). * @param _beneficiary Token purchaser * @param _tokenAmount Amount of tokens added */ function addTokens(address _beneficiary, uint256 _tokenAmount) public onlyOwner { balances[_beneficiary] = balances[_beneficiary].add(_tokenAmount); tokensIssued = tokensIssued.add(_tokenAmount); emit TokenAdded(_beneficiary, _tokenAmount); } /** * @dev Withdraw tokens for receiver_ after crowdsale ends. */ function _withdrawTokensFor(address receiver_) internal { require(hasClosed()); uint256 amount = balances[receiver_]; require(amount > 0); balances[receiver_] = 0; emit TokenDelivered(receiver_, amount); _deliverTokens(receiver_, amount); } } "}
{"sol name": "688.sol", "label": 1, "sol content": "pragma solidity 0.4.18; library SafeMath { /** * Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract QPay { string public symbol=\"QPY\"; string public name=\"QPay\" ; uint8 public constant decimals = 18; uint256 _totalSupply = 0; uint256 _FreeQPY = 1230; uint256 _ML1 = 2; uint256 _ML2 = 3; uint256 _ML3 = 4; uint256 _LimitML1 = 3e15; uint256 _LimitML2 = 6e15; uint256 _LimitML3 = 9e15; uint256 _MaxDistribPublicSupply = 950000000; uint256 _OwnerDistribSupply = 0; uint256 _CurrentDistribPublicSupply = 0; uint256 _ExtraTokensPerETHSended = 150000; address _DistribFundsReceiverAddress = 0; address _remainingTokensReceiverAddress = 0; address owner = 0; bool setupDone = false; bool IsDistribRunning = false; bool DistribStarted = false; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed _owner, uint256 _value); mapping(address => uint256) balances; mapping(address => mapping(address => uint256)) allowed; mapping(address => bool) public Claimed; modifier onlyOwner() { require(msg.sender == owner); _; } function QPay() public { owner = msg.sender; } function() public payable { if (IsDistribRunning) { uint256 _amount; if (((_CurrentDistribPublicSupply + _amount) > _MaxDistribPublicSupply) && _MaxDistribPublicSupply > 0) revert(); if (!_DistribFundsReceiverAddress.send(msg.value)) revert(); if (Claimed[msg.sender] == false) { _amount = _FreeQPY * 1e18; _CurrentDistribPublicSupply += _amount; balances[msg.sender] += _amount; _totalSupply += _amount; Transfer(this, msg.sender, _amount); Claimed[msg.sender] = true; } if (msg.value >= 9e15) { _amount = msg.value * _ExtraTokensPerETHSended * 4; } else { if (msg.value >= 6e15) { _amount = msg.value * _ExtraTokensPerETHSended * 3; } else { if (msg.value >= 3e15) { _amount = msg.value * _ExtraTokensPerETHSended * 2; } else { _amount = msg.value * _ExtraTokensPerETHSended; } } } _CurrentDistribPublicSupply += _amount; balances[msg.sender] += _amount; _totalSupply += _amount; Transfer(this, msg.sender, _amount); } else { revert(); } } function SetupQPY(string tokenName, string tokenSymbol, uint256 ExtraTokensPerETHSended, uint256 MaxDistribPublicSupply, uint256 OwnerDistribSupply, address remainingTokensReceiverAddress, address DistribFundsReceiverAddress, uint256 FreeQPY) public { if (msg.sender == owner && !setupDone) { symbol = tokenSymbol; name = tokenName; _FreeQPY = FreeQPY; _ExtraTokensPerETHSended = ExtraTokensPerETHSended; _MaxDistribPublicSupply = MaxDistribPublicSupply * 1e18; if (OwnerDistribSupply > 0) { _OwnerDistribSupply = OwnerDistribSupply * 1e18; _totalSupply = _OwnerDistribSupply; balances[owner] = _totalSupply; _CurrentDistribPublicSupply += _totalSupply; Transfer(this, owner, _totalSupply); } _DistribFundsReceiverAddress = DistribFundsReceiverAddress; if (_DistribFundsReceiverAddress == 0) _DistribFundsReceiverAddress = owner; _remainingTokensReceiverAddress = remainingTokensReceiverAddress; setupDone = true; } } function SetupML(uint256 ML1inX, uint256 ML2inX, uint256 LimitML1inWei, uint256 LimitML2inWei) onlyOwner public { _ML1 = ML1inX; _ML2 = ML2inX; _LimitML1 = LimitML1inWei; _LimitML2 = LimitML2inWei; } function SetExtra(uint256 ExtraTokensPerETHSended) onlyOwner public { _ExtraTokensPerETHSended = ExtraTokensPerETHSended; } function SetFreeQPY(uint256 FreeQPY) onlyOwner public { _FreeQPY = FreeQPY; } function StartDistrib() public returns(bool success) { if (msg.sender == owner && !DistribStarted && setupDone) { DistribStarted = true; IsDistribRunning = true; } else { revert(); } return true; } function StopDistrib() public returns(bool success) { if (msg.sender == owner && IsDistribRunning) { if (_remainingTokensReceiverAddress != 0 && _MaxDistribPublicSupply > 0) { uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply; if (_remainingAmount > 0) { balances[_remainingTokensReceiverAddress] += _remainingAmount; _totalSupply += _remainingAmount; Transfer(this, _remainingTokensReceiverAddress, _remainingAmount); } } DistribStarted = false; IsDistribRunning = false; } else { revert(); } return true; } function distribution(address[] addresses, uint256 _amount) onlyOwner public { uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply; require(addresses.length <= 255); require(_amount <= _remainingAmount); _amount = _amount * 1e18; for (uint i = 0; i < addresses.length; i++) { require(_amount <= _remainingAmount); _CurrentDistribPublicSupply += _amount; balances[addresses[i]] += _amount; _totalSupply += _amount; Transfer(this, addresses[i], _amount); } if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) { DistribStarted = false; IsDistribRunning = false; } } function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner public { uint256 _remainingAmount = _MaxDistribPublicSupply - _CurrentDistribPublicSupply; uint256 _amount; require(addresses.length <= 255); require(addresses.length == amounts.length); for (uint8 i = 0; i < addresses.length; i++) { _amount = amounts[i] * 1e18; require(_amount <= _remainingAmount); _CurrentDistribPublicSupply += _amount; balances[addresses[i]] += _amount; _totalSupply += _amount; Transfer(this, addresses[i], _amount); if (_CurrentDistribPublicSupply >= _MaxDistribPublicSupply) { DistribStarted = false; IsDistribRunning = false; } } } function BurnTokens(uint256 amount) public returns(bool success) { uint256 _amount = amount * 1e18; if (balances[msg.sender] >= _amount) { balances[msg.sender] -= _amount; _totalSupply -= _amount; Burn(msg.sender, _amount); Transfer(msg.sender, 0, _amount); } else { revert(); } return true; } function totalSupply() public constant returns(uint256 totalSupplyValue) { return _totalSupply; } function MaxDistribPublicSupply_() public constant returns(uint256 MaxDistribPublicSupply) { return _MaxDistribPublicSupply; } function OwnerDistribSupply_() public constant returns(uint256 OwnerDistribSupply) { return _OwnerDistribSupply; } function CurrentDistribPublicSupply_() public constant returns(uint256 CurrentDistribPublicSupply) { return _CurrentDistribPublicSupply; } function RemainingTokensReceiverAddress() public constant returns(address remainingTokensReceiverAddress) { return _remainingTokensReceiverAddress; } function DistribFundsReceiverAddress() public constant returns(address DistribfundsReceiver) { return _DistribFundsReceiverAddress; } function Owner() public constant returns(address ownerAddress) { return owner; } function SetupDone() public constant returns(bool setupDoneFlag) { return setupDone; } function IsDistribRunningFalg_() public constant returns(bool IsDistribRunningFalg) { return IsDistribRunning; } function IsDistribStarted() public constant returns(bool IsDistribStartedFlag) { return DistribStarted; } function balanceOf(address _owner) public constant returns(uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _amount) public returns(bool success) { if (balances[msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[msg.sender] -= _amount; balances[_to] += _amount; Transfer(msg.sender, _to, _amount); return true; } else { return false; } } function transferFrom( address _from, address _to, uint256 _amount ) public returns(bool success) { if (balances[_from] >= _amount && allowed[_from][msg.sender] >= _amount && _amount > 0 && balances[_to] + _amount > balances[_to]) { balances[_from] -= _amount; allowed[_from][msg.sender] -= _amount; balances[_to] += _amount; Transfer(_from, _to, _amount); return true; } else { return false; } } function approve(address _spender, uint256 _amount) public returns(bool success) { allowed[msg.sender][_spender] = _amount; Approval(msg.sender, _spender, _amount); return true; } function allowance(address _owner, address _spender) public constant returns(uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "339.sol", "label": 1, "sol content": "/* * This program is free software: you can redistribute it and/or modify * it under the terms of the GNU Lesser General Public License as published by * the Free Software Foundation, either version 3 of the License, or * (at your option) any later version. * * This program is distributed in the hope that it will be useful, * but WITHOUT ANY WARRANTY; without even the implied warranty of * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the * GNU Lesser General Public License for more details. * * You should have received a copy of the GNU Lesser General Public License * along with this program. If not, see <http://www.gnu.org/licenses/>. */ pragma solidity ^0.4.23; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei. // The rate is the conversion between wei and the smallest and indivisible token unit. // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK // 1 wei will give you 1 unit, or 0.001 TOK. uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.transfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title TimedCrowdsale * @dev Crowdsale accepting contributions only within a time frame. */ contract TimedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public openingTime; uint256 public closingTime; /** * @dev Reverts if not in crowdsale time range. */ modifier onlyWhileOpen { // solium-disable-next-line security/no-block-members require(block.timestamp >= openingTime && block.timestamp <= closingTime); _; } /** * @dev Constructor, takes crowdsale opening and closing times. * @param _openingTime Crowdsale opening time * @param _closingTime Crowdsale closing time */ constructor(uint256 _openingTime, uint256 _closingTime) public { // solium-disable-next-line security/no-block-members require(_openingTime >= block.timestamp); require(_closingTime >= _openingTime); openingTime = _openingTime; closingTime = _closingTime; } /** * @dev Checks whether the period in which the crowdsale is open has already elapsed. * @return Whether crowdsale period has elapsed */ function hasClosed() public view returns (bool) { // solium-disable-next-line security/no-block-members return block.timestamp > closingTime; } /** * @dev Extend parent behavior requiring to be within contributing period * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal onlyWhileOpen { super._preValidatePurchase(_beneficiary, _weiAmount); } } /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is TimedCrowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasClosed()); finalization(); emit Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal { } } /** * @title RefundVault * @dev This contract is used for storing funds while a crowdsale * is in progress. Supports refunding the money if crowdsale fails, * and forwarding it if crowdsale is successful. */ contract RefundVault is Ownable { using SafeMath for uint256; enum State { Active, Refunding, Closed } mapping (address => uint256) public deposited; address public wallet; State public state; event Closed(); event RefundsEnabled(); event Refunded(address indexed beneficiary, uint256 weiAmount); /** * @param _wallet Vault address */ constructor(address _wallet) public { require(_wallet != address(0)); wallet = _wallet; state = State.Active; } /** * @param investor Investor address */ function deposit(address investor) onlyOwner public payable { require(state == State.Active); deposited[investor] = deposited[investor].add(msg.value); } function close() onlyOwner public { require(state == State.Active); state = State.Closed; emit Closed(); wallet.transfer(address(this).balance); } function enableRefunds() onlyOwner public { require(state == State.Active); state = State.Refunding; emit RefundsEnabled(); } /** * @param investor Investor address */ function refund(address investor) public { require(state == State.Refunding); uint256 depositedValue = deposited[investor]; deposited[investor] = 0; investor.transfer(depositedValue); emit Refunded(investor, depositedValue); } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract FreezableToken is StandardToken { // freezing chains mapping (bytes32 => uint64) internal chains; // freezing amounts for each chain mapping (bytes32 => uint) internal freezings; // total freezing balance per address mapping (address => uint) internal freezingBalance; event Freezed(address indexed to, uint64 release, uint amount); event Released(address indexed owner, uint amount); /** * @dev Gets the balance of the specified address include freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner) + freezingBalance[_owner]; } /** * @dev Gets the balance of the specified address without freezing tokens. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function actualBalanceOf(address _owner) public view returns (uint256 balance) { return super.balanceOf(_owner); } function freezingBalanceOf(address _owner) public view returns (uint256 balance) { return freezingBalance[_owner]; } /** * @dev gets freezing count * @param _addr Address of freeze tokens owner. */ function freezingCount(address _addr) public view returns (uint count) { uint64 release = chains[toKey(_addr, 0)]; while (release != 0) { count++; release = chains[toKey(_addr, release)]; } } /** * @dev gets freezing end date and freezing balance for the freezing portion specified by index. * @param _addr Address of freeze tokens owner. * @param _index Freezing portion index. It ordered by release date descending. */ function getFreezing(address _addr, uint _index) public view returns (uint64 _release, uint _balance) { for (uint i = 0; i < _index + 1; i++) { _release = chains[toKey(_addr, _release)]; if (_release == 0) { return; } } _balance = freezings[toKey(_addr, _release)]; } /** * @dev freeze your tokens to the specified address. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to freeze. * @param _until Release date, must be in future. */ function freezeTo(address _to, uint _amount, uint64 _until) public { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Transfer(msg.sender, _to, _amount); emit Freezed(_to, _until, _amount); } /** * @dev release first available freezing tokens. */ function releaseOnce() public { bytes32 headKey = toKey(msg.sender, 0); uint64 head = chains[headKey]; require(head != 0); require(uint64(block.timestamp) > head); bytes32 currentKey = toKey(msg.sender, head); uint64 next = chains[currentKey]; uint amount = freezings[currentKey]; delete freezings[currentKey]; balances[msg.sender] = balances[msg.sender].add(amount); freezingBalance[msg.sender] = freezingBalance[msg.sender].sub(amount); if (next == 0) { delete chains[headKey]; } else { chains[headKey] = next; delete chains[currentKey]; } emit Released(msg.sender, amount); } /** * @dev release all available for release freezing tokens. Gas usage is not deterministic! * @return how many tokens was released */ function releaseAll() public returns (uint tokens) { uint release; uint balance; (release, balance) = getFreezing(msg.sender, 0); while (release != 0 && block.timestamp > release) { releaseOnce(); tokens += balance; (release, balance) = getFreezing(msg.sender, 0); } } function toKey(address _addr, uint _release) internal pure returns (bytes32 result) { // WISH masc to increase entropy result = 0x5749534800000000000000000000000000000000000000000000000000000000; assembly { result := or(result, mul(_addr, 0x10000000000000000)) result := or(result, _release) } } function freeze(address _to, uint64 _until) internal { require(_until > block.timestamp); bytes32 key = toKey(_to, _until); bytes32 parentKey = toKey(_to, uint64(0)); uint64 next = chains[parentKey]; if (next == 0) { chains[parentKey] = _until; return; } bytes32 nextKey = toKey(_to, next); uint parent; while (next != 0 && _until > next) { parent = next; parentKey = nextKey; next = chains[nextKey]; nextKey = toKey(_to, next); } if (_until == next) { return; } if (next != 0) { chains[key] = next; } chains[parentKey] = _until; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract FreezableMintableToken is FreezableToken, MintableToken { /** * @dev Mint the specified amount of token to the specified address and freeze it until the specified date. *      Be careful, gas usage is not deterministic, *      and depends on how many freezes _to address already has. * @param _to Address to which token will be freeze. * @param _amount Amount of token to mint and freeze. * @param _until Release date, must be in future. * @return A boolean that indicates if the operation was successful. */ function mintAndFreeze(address _to, uint _amount, uint64 _until) public onlyOwner canMint returns (bool) { totalSupply_ = totalSupply_.add(_amount); bytes32 currentKey = toKey(_to, _until); freezings[currentKey] = freezings[currentKey].add(_amount); freezingBalance[_to] = freezingBalance[_to].add(_amount); freeze(_to, _until); emit Mint(_to, _amount); emit Freezed(_to, _until, _amount); emit Transfer(msg.sender, _to, _amount); return true; } } contract Consts { uint public constant TOKEN_DECIMALS = 18; uint8 public constant TOKEN_DECIMALS_UINT8 = 18; uint public constant TOKEN_DECIMAL_MULTIPLIER = 10 ** TOKEN_DECIMALS; string public constant TOKEN_NAME = \"Cpollo\"; string public constant TOKEN_SYMBOL = \"CPLO\"; bool public constant PAUSED = false; address public constant TARGET_USER = 0x1415241a0025290E03B97Ab3922DF216D0d77d15; uint public constant START_TIME = 1534737600; bool public constant CONTINUE_MINTING = false; } /** * @title CappedCrowdsale * @dev Crowdsale with a limit for total contributions. */ contract CappedCrowdsale is Crowdsale { using SafeMath for uint256; uint256 public cap; /** * @dev Constructor, takes maximum amount of wei accepted in the crowdsale. * @param _cap Max amount of wei to be contributed */ constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Checks whether the cap has been reached. * @return Whether the cap was reached */ function capReached() public view returns (bool) { return weiRaised >= cap; } /** * @dev Extend parent behavior requiring purchase to respect the funding cap. * @param _beneficiary Token purchaser * @param _weiAmount Amount of wei contributed */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { super._preValidatePurchase(_beneficiary, _weiAmount); require(weiRaised.add(_weiAmount) <= cap); } } /** * @title MintedCrowdsale * @dev Extension of Crowdsale contract whose tokens are minted in each purchase. * Token ownership should be transferred to MintedCrowdsale for minting. */ contract MintedCrowdsale is Crowdsale { /** * @dev Overrides delivery by minting tokens upon purchase. * @param _beneficiary Token purchaser * @param _tokenAmount Number of tokens to be minted */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { require(MintableToken(token).mint(_beneficiary, _tokenAmount)); } } contract MainToken is Consts, FreezableMintableToken, BurnableToken, Pausable { function name() public pure returns (string _name) { return TOKEN_NAME; } function symbol() public pure returns (string _symbol) { return TOKEN_SYMBOL; } function decimals() public pure returns (uint8 _decimals) { return TOKEN_DECIMALS_UINT8; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transferFrom(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool _success) { require(!paused); return super.transfer(_to, _value); } } /** * @title RefundableCrowdsale * @dev Extension of Crowdsale contract that adds a funding goal, and * the possibility of users getting a refund if goal is not met. * Uses a RefundVault as the crowdsale's vault. */ contract RefundableCrowdsale is FinalizableCrowdsale { using SafeMath for uint256; // minimum amount of funds to be raised in weis uint256 public goal; // refund vault used to hold funds while crowdsale is running RefundVault public vault; /** * @dev Constructor, creates RefundVault. * @param _goal Funding goal */ constructor(uint256 _goal) public { require(_goal > 0); vault = new RefundVault(wallet); goal = _goal; } /** * @dev Investors can claim refunds here if crowdsale is unsuccessful */ function claimRefund() public { require(isFinalized); require(!goalReached()); vault.refund(msg.sender); } /** * @dev Checks whether funding goal was reached. * @return Whether funding goal was reached */ function goalReached() public view returns (bool) { return weiRaised >= goal; } /** * @dev vault finalization task, called when owner calls finalize() */ function finalization() internal { if (goalReached()) { vault.close(); } else { vault.enableRefunds(); } super.finalization(); } /** * @dev Overrides Crowdsale fund forwarding, sending funds to vault. */ function _forwardFunds() internal { vault.deposit.value(msg.value)(msg.sender); } } contract MainCrowdsale is Consts, FinalizableCrowdsale, MintedCrowdsale, CappedCrowdsale { function hasStarted() public view returns (bool) { return now >= openingTime; } function startTime() public view returns (uint256) { return openingTime; } function endTime() public view returns (uint256) { return closingTime; } function hasClosed() public view returns (bool) { return super.hasClosed() || capReached(); } function hasEnded() public view returns (bool) { return hasClosed(); } function finalization() internal { super.finalization(); if (PAUSED) { MainToken(token).unpause(); } if (!CONTINUE_MINTING) { require(MintableToken(token).finishMinting()); } Ownable(token).transferOwnership(TARGET_USER); } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate).div(1 ether); } } contract TemplateCrowdsale is Consts, MainCrowdsale , RefundableCrowdsale { event Initialized(); event TimesChanged(uint startTime, uint endTime, uint oldStartTime, uint oldEndTime); bool public initialized = false; constructor(MintableToken _token) public Crowdsale(200000 * TOKEN_DECIMAL_MULTIPLIER, 0x1415241a0025290E03B97Ab3922DF216D0d77d15, _token) TimedCrowdsale(START_TIME > now ? START_TIME : now, 1538366400) CappedCrowdsale(50000000000000000000000) RefundableCrowdsale(300000000000000000000) { } function init() public onlyOwner { require(!initialized); initialized = true; if (PAUSED) { MainToken(token).pause(); } address[4] memory addresses = [address(0x1415241a0025290e03b97ab3922df216d0d77d15),address(0x1415241a0025290e03b97ab3922df216d0d77d15),address(0x1415241a0025290e03b97ab3922df216d0d77d15),address(0xf0cc0bd6f0b597d8d9e1f4e11785764c0d171499)]; uint[4] memory amounts = [uint(1500000000000000000000000000),uint(1500000000000000000000000000),uint(2000000000000000000000000000),uint(5000000000000000000000000000)]; uint64[4] memory freezes = [uint64(0),uint64(0),uint64(0),uint64(1538366461)]; for (uint i = 0; i < addresses.length; i++) { if (freezes[i] == 0) { MainToken(token).mint(addresses[i], amounts[i]); } else { MainToken(token).mintAndFreeze(addresses[i], amounts[i], freezes[i]); } } transferOwnership(TARGET_USER); emit Initialized(); } function setStartTime(uint _startTime) public onlyOwner { // only if CS was not started require(now < openingTime); // only move time to future require(_startTime > openingTime); require(_startTime < closingTime); emit TimesChanged(_startTime, closingTime, openingTime, closingTime); openingTime = _startTime; } function setEndTime(uint _endTime) public onlyOwner { // only if CS was not ended require(now < closingTime); // only if new end time in future require(now < _endTime); require(_endTime > openingTime); emit TimesChanged(openingTime, _endTime, openingTime, closingTime); closingTime = _endTime; } function setTimes(uint _startTime, uint _endTime) public onlyOwner { require(_endTime > _startTime); uint oldStartTime = openingTime; uint oldEndTime = closingTime; bool changed = false; if (_startTime != oldStartTime) { require(_startTime > now); // only if CS was not started require(now < oldStartTime); // only move time to future require(_startTime > oldStartTime); openingTime = _startTime; changed = true; } if (_endTime != oldEndTime) { // only if CS was not ended require(now < oldEndTime); // end time in future require(now < _endTime); closingTime = _endTime; changed = true; } if (changed) { emit TimesChanged(openingTime, _endTime, openingTime, closingTime); } } } "}
{"sol name": "1896.sol", "label": 1, "sol content": "pragma solidity 0.4.21; // Abstract contract for the full ERC 20 Token standard pragma solidity 0.4.21; contract EIP20Interface { /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public constant returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender)  public constant returns (uint256 remaining); // solhint-disable-next-line no-simple-event-func-name event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract SAFCOIN is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name;                   //fancy name: s uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: function SAFCOIN( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "655.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: ..\\openzeppelin-solidity\\contracts\\math\\SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: ..\\openzeppelin-solidity\\contracts\\ownership\\Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } // File: ..\\openzeppelin-solidity\\contracts\\lifecycle\\Pausable.sol /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } // File: contracts\\HorseyExchange.sol /** * @title ERC721 Non-Fungible Token Standard basic interface * @dev see https://github.com/ethereum/EIPs/blob/master/EIPS/eip-721.md */ contract ERC721Basic { function balanceOf(address _owner) public view returns (uint256 _balance); function ownerOf(uint256 _tokenId) public view returns (address _owner); function exists(uint256 _tokenId) public view returns (bool _exists); function approve(address _to, uint256 _tokenId) public; function getApproved(uint256 _tokenId) public view returns (address _operator); function transferFrom(address _from, address _to, uint256 _tokenId) public; } /** @dev HorseyExchange contract - handles horsey market exchange which includes the following set of functions: 1. Deposit to Exchange 2. Cancel sale 3. Purchase token **/ contract HorseyExchange is Pausable { //also Ownable using SafeMath for uint256; event HorseyDeposit(uint256 tokenId, uint256 price); event SaleCanceled(uint256 tokenId); event HorseyPurchased(uint256 tokenId, address newOwner, uint256 totalToPay); /// @dev Fee applied to market maker - measured as percentage uint256 public marketMakerFee = 3; /// @dev Amount collected in fees uint256 collectedFees = 0; /// @dev  RoyalStables TOKEN ERC721Basic public token; /** @dev used to store the price and the owner address of a token on sale */ struct SaleData { uint256 price; address owner; } /// @dev Market spec to lookup price and original owner based on token id mapping (uint256 => SaleData) market; /// @dev mapping of current tokens on market by owner mapping (address => uint256[]) userBarn; /// @dev initialize constructor() Pausable() public { } /** @dev Since the exchange requires the horsey contract and horsey contract requires exchange address, we cant initialize both of them in constructors @param _token Address of the stables contract */ function setStables(address _token) external onlyOwner() { require(address(_token) != 0,\"Address of token is zero\"); token = ERC721Basic(_token); } /** @dev Allows the owner to change market fees @param fees The new fees to apply (can be zero) */ function setMarketFees(uint256 fees) external onlyOwner() { marketMakerFee = fees; } /// @return the tokens on sale based on the user address function getTokensOnSale(address user) external view returns(uint256[]) { return userBarn[user]; } /// @return the token price with the fees function getTokenPrice(uint256 tokenId) public view isOnMarket(tokenId) returns (uint256) { return market[tokenId].price + (market[tokenId].price.div(100).mul(marketMakerFee)); } /** @dev User sends token to sell to exchange - at this point the exchange contract takes ownership, but will map token ownership back to owner for auotmated withdraw on cancel - requires that user is the rightful owner and is not asking for a null price */ function depositToExchange(uint256 tokenId, uint256 price) external whenNotPaused() isTokenOwner(tokenId) nonZeroPrice(price) tokenAvailable() { require(token.getApproved(tokenId) == address(this),\"Exchange is not allowed to transfer\"); //Transfers token from depositee to exchange (contract address) token.transferFrom(msg.sender, address(this), tokenId); //add the token to the market market[tokenId] = SaleData(price,msg.sender); //Add token to exchange map - tracking by owner of all tokens userBarn[msg.sender].push(tokenId); emit HorseyDeposit(tokenId, price); } /** @dev Allows true owner of token to cancel sale at anytime @param tokenId ID of the token to remove from the market @return true if user still has tokens for sale */ function cancelSale(uint256 tokenId) external whenNotPaused() originalOwnerOf(tokenId) tokenAvailable() returns (bool) { //throws on fail - transfers token from exchange back to original owner token.transferFrom(address(this),msg.sender,tokenId); //Reset token on market - remove delete market[tokenId]; //Reset barn tracker for user _removeTokenFromBarn(tokenId, msg.sender); emit SaleCanceled(tokenId); //Return true if this user is still 'active' within the exchange //This will help with client side actions return userBarn[msg.sender].length > 0; } /** @dev Performs the purchase of a token that is present on the market - this includes checking that the proper amount is sent + appliced fee, updating seller's balance, updated collected fees and transfering token to buyer Only market tokens can be purchased @param tokenId ID of the token we wish to purchase */ function purchaseToken(uint256 tokenId) external payable whenNotPaused() isOnMarket(tokenId) tokenAvailable() notOriginalOwnerOf(tokenId) { //Did the sender accidently pay over? - if so track the amount over uint256 totalToPay = getTokenPrice(tokenId); require(msg.value >= totalToPay, \"Not paying enough\"); //fetch this tokens sale data SaleData memory sale = market[tokenId]; //Add to collected fee amount payable to DEVS collectedFees += totalToPay - sale.price; //pay the seller sale.owner.transfer(sale.price); //Reset barn tracker for user _removeTokenFromBarn(tokenId,  sale.owner); //Reset token on market - remove delete market[tokenId]; //Transfer the ERC721 to the buyer - we leave the sale amount //to be withdrawn by the user (transferred from exchange) token.transferFrom(address(this), msg.sender, tokenId); //Return over paid amount to sender if necessary if(msg.value > totalToPay) //overpaid { msg.sender.transfer(msg.value.sub(totalToPay)); } emit HorseyPurchased(tokenId, msg.sender, totalToPay); } /// @dev Transfers the collected fees to the owner function withdraw() external onlyOwner() { assert(collectedFees <= address(this).balance); owner.transfer(collectedFees); collectedFees = 0; } /** @dev Internal function to remove a token from the users barn array @param tokenId ID of the token to remove @param barnAddress Address of the user selling tokens */ function _removeTokenFromBarn(uint tokenId, address barnAddress)  internal { uint256[] storage barnArray = userBarn[barnAddress]; require(barnArray.length > 0,\"No tokens to remove\"); int index = _indexOf(tokenId, barnArray); require(index >= 0, \"Token not found in barn\"); // Shift entire array :( for (uint256 i = uint256(index); i<barnArray.length-1; i++){ barnArray[i] = barnArray[i+1]; } // Remove element, update length, return array // this should be enough since https://ethereum.stackexchange.com/questions/1527/how-to-delete-an-element-at-a-certain-index-in-an-array barnArray.length--; } /** @dev Helper function which stores in memory an array which is passed in, and @param item element we are looking for @param array the array to look into @return the index of the item of interest */ function _indexOf(uint item, uint256[] memory array) internal pure returns (int256){ //Iterate over array to find indexOf(token) for(uint256 i = 0; i < array.length; i++){ if(array[i] == item){ return int256(i); } } //Item not found return -1; } /// @dev requires token to be on the market = current owner is exchange modifier isOnMarket(uint256 tokenId) { require(token.ownerOf(tokenId) == address(this),\"Token not on market\"); _; } /// @dev Is the user the owner of this token? modifier isTokenOwner(uint256 tokenId) { require(token.ownerOf(tokenId) == msg.sender,\"Not tokens owner\"); _; } /// @dev Is this the original owner of the token - at exchange level modifier originalOwnerOf(uint256 tokenId) { require(market[tokenId].owner == msg.sender,\"Not the original owner of\"); _; } /// @dev Is this the original owner of the token - at exchange level modifier notOriginalOwnerOf(uint256 tokenId) { require(market[tokenId].owner != msg.sender,\"Is the original owner\"); _; } /// @dev Is a nonzero price being sent? modifier nonZeroPrice(uint256 price){ require(price > 0,\"Price is zero\"); _; } /// @dev Do we have a token address modifier tokenAvailable(){ require(address(token) != 0,\"Token address not set\"); _; } } // File: contracts\\EthorseHelpers.sol contract BettingControllerInterface { address public owner; } /** @title Race contract - used for linking ethorse Race struct @dev This interface is losely based on ethorse race contract */ contract EthorseRace { //Encapsulation of racing information struct chronus_info { bool  betting_open; // boolean: check if betting is open bool  race_start; //boolean: check if race has started bool  race_end; //boolean: check if race has ended bool  voided_bet; //boolean: check if race has been voided uint32  starting_time; // timestamp of when the race starts uint32  betting_duration; uint32  race_duration; // duration of the race uint32 voided_timestamp; } address public owner; //Point to racing information chronus_info public chronus; //Coin index mapping to flag - true if index is winner mapping (bytes32 => bool) public winner_horse; /* // exposing the coin pool details for DApp function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint) { return (coinIndex[index].total, coinIndex[index].pre, coinIndex[index].post, coinIndex[index].price_check, voterIndex[candidate].bets[index]); } */ // exposing the coin pool details for DApp function getCoinIndex(bytes32 index, address candidate) external constant returns (uint, uint, uint, bool, uint); } /** @title API contract - used to connect with Race contract and encapsulate race information for token inidices and winner checking. */ contract EthorseHelpers { /// @dev Convert all symbols to bytes array bytes32[] public all_horses = [bytes32(\"BTC\"),bytes32(\"ETH\"),bytes32(\"LTC\")]; mapping(address => bool) private _legitOwners; /// @dev Used to add new symbol to the bytes array function _addHorse(bytes32 newHorse) internal { all_horses.push(newHorse); } function _addLegitOwner(address newOwner) internal { _legitOwners[newOwner] = true; } function getall_horsesCount() public view returns(uint) { return all_horses.length; } /** @param raceAddress - address of this race @param eth_address - user's ethereum wallet address @return true if user is winner + name of the winning horse (LTC,BTC,ETH,...) */ function _isWinnerOf(address raceAddress, address eth_address) internal view returns (bool,bytes32) { //acquire race, fails if doesnt exist EthorseRace race = EthorseRace(raceAddress); //acquire races betting controller BettingControllerInterface bc = BettingControllerInterface(race.owner()); //make sure the betting controllers owner is in the legit list given by devs require(_legitOwners[bc.owner()]); //acquire chronus bool  voided_bet; //boolean: check if race has been voided bool  race_end; //boolean: check if race has ended (,,race_end,voided_bet,,,,) = race.chronus(); //cant be winner if race was refunded or didnt end yet if(voided_bet || !race_end) return (false,bytes32(0)); //aquire winner race index bytes32 horse; bool found = false; uint256 arrayLength = all_horses.length; //Iterate over coin symbols to find winner - tie could be possible? for(uint256 i = 0; i < arrayLength; i++) { if(race.winner_horse(all_horses[i])) { horse = all_horses[i]; found = true; break; } } //no winner horse? shouldnt happen unless this horse isnt registered if(!found) return (false,bytes32(0)); //check the bet amount of the eth_address on the winner horse uint256 bet_amount = 0; if(eth_address != address(0)) { (,,,, bet_amount) = race.getCoinIndex(horse, eth_address); } //winner if the eth_address had a bet > 0 on the winner horse return (bet_amount > 0, horse); } } // File: contracts\\HorseyToken.sol contract RoyalStablesInterface { struct Horsey { address race; bytes32 dna; uint8 feedingCounter; uint8 tier; } mapping(uint256 => Horsey) public horseys; mapping(address => uint32) public carrot_credits; mapping(uint256 => string) public names; address public master; function getOwnedTokens(address eth_address) public view returns (uint256[]); function storeName(uint256 tokenId, string newName) public; function storeCarrotsCredit(address client, uint32 amount) public; function storeHorsey(address client, uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public; function modifyHorsey(uint256 tokenId, address race, bytes32 dna, uint8 feedingCounter, uint8 tier) public; function modifyHorseyDna(uint256 tokenId, bytes32 dna) public; function modifyHorseyFeedingCounter(uint256 tokenId, uint8 feedingCounter) public; function modifyHorseyTier(uint256 tokenId, uint8 tier) public; function unstoreHorsey(uint256 tokenId) public; function ownerOf(uint256 tokenId) public returns (address); } /** @title HorseyToken ERC721 Token @dev Horse contract - horse derives fro AccessManager built on top of ERC721 token and uses @dev EthorseHelpers and AccessManager */ contract HorseyToken is EthorseHelpers,Pausable { using SafeMath for uint256; /// @dev called when someone claims a token event Claimed(address raceAddress, address eth_address, uint256 tokenId); /// @dev called when someone starts a feeding process event Feeding(uint256 tokenId); /// @dev called when someone ends a feeding process event ReceivedCarrot(uint256 tokenId, bytes32 newDna); /// @dev called when someone fails to end a feeding on the 255 blocks timer event FeedingFailed(uint256 tokenId); /// @dev called when a horsey is renamed event HorseyRenamed(uint256 tokenId, string newName); /// @dev called when a horsey is freed for carrots event HorseyFreed(uint256 tokenId); /// @dev address of the RoyalStables RoyalStablesInterface public stables; ///@dev multiplier applied to carrots received from burning a horsey uint8 public carrotsMultiplier = 1; ///@dev multiplier applied to rarity bounds when feeding horsey uint8 public rarityMultiplier = 1; ///@dev fee to pay when claiming a token uint256 public claimingFee = 0.008 ether; /** @dev Holds the necessary data to feed a horsey The user has to create begin feeding and wait for the block with the feeding transaction to be hashed Only then he can stop the feeding */ struct FeedingData { uint256 blockNumber;    ///@dev Holds the block number where the feeding began uint256 horsey;         ///@dev Holds the horsey id } /// @dev Maps a user to his pending feeding mapping(address => FeedingData) public pendingFeedings; /// @dev Stores the renaming fees per character a user has to pay upon renaming a horsey uint256 public renamingCostsPerChar = 0.001 ether; /** @dev Contracts constructor Initializes token data is pausable,ownable @param stablesAddress Address of the official RoyalStables contract */ constructor(address stablesAddress) EthorseHelpers() Pausable() public { stables = RoyalStablesInterface(stablesAddress); } /** @dev Changes multiplier for rarity on feed @param newRarityMultiplier The cost to charge in wei for each character of the name */ function setRarityMultiplier(uint8 newRarityMultiplier) external onlyOwner()  { rarityMultiplier = newRarityMultiplier; } /** @dev Sets a new muliplier for freeing a horse @param newCarrotsMultiplier the new multiplier for feeding */ function setCarrotsMultiplier(uint8 newCarrotsMultiplier) external onlyOwner()  { carrotsMultiplier = newCarrotsMultiplier; } /** @dev Sets a new renaming per character cost in wei Any CLevel can call this function @param newRenamingCost The cost to charge in wei for each character of the name */ function setRenamingCosts(uint256 newRenamingCost) external onlyOwner()  { renamingCostsPerChar = newRenamingCost; } /** @dev Sets a new claiming fee in wei Any CLevel can call this function @param newClaimingFee The cost to charge in wei for each claimed HRSY */ function setClaimingCosts(uint256 newClaimingFee) external onlyOwner()  { claimingFee = newClaimingFee; } /** @dev Allows to add a legit owner address for races validation @param newAddress the dev address deploying BettingController to add */ function addLegitDevAddress(address newAddress) external onlyOwner() { _addLegitOwner(newAddress); } /** @dev Owner can withdraw the current balance */ function withdraw() external onlyOwner()  { owner.transfer(address(this).balance); //throws on fail } //allows owner to add a horse name to the possible horses list (BTC,ETH,LTC,...) /** @dev Adds a new horse index to the possible horses list (BTC,ETH,LTC,...) This is in case ethorse adds a new coin Any CLevel can call this function @param newHorse Index of the horse to add (same data type as the original ethorse erc20 contract code) */ function addHorseIndex(bytes32 newHorse) external onlyOwner() { _addHorse(newHorse); } /** @dev Gets the complete list of token ids which belongs to an address @param eth_address The address you want to lookup owned tokens from @return List of all owned by eth_address tokenIds */ function getOwnedTokens(address eth_address) public view returns (uint256[]) { return stables.getOwnedTokens(eth_address); } /** @dev Allows to check if an eth_address can claim a horsey from this contract should we also check if already claimed here? @param raceAddress The ethorse race you want to claim from @param eth_address The users address you want to claim the token for @return True only if eth_address is a winner of the race contract at raceAddress */ function can_claim(address raceAddress, address eth_address) public view returns (bool) { bool res; (res,) = _isWinnerOf(raceAddress, eth_address); return res; } /** @dev Allows a user to claim a special horsey with the same dna as the race one Cant be used on paused The sender has to be a winner of the race and must never have claimed a special horsey from this race @param raceAddress The race's address */ function claim(address raceAddress) external payable costs(claimingFee) whenNotPaused() { //call _isWinnerOf with a 0 address to simply get the winner horse bytes32 winner; (,winner) = _isWinnerOf(raceAddress, address(0)); require(winner != bytes32(0),\"Winner is zero\"); require(can_claim(raceAddress, msg.sender),\"can_claim return false\"); //require(!exists(id)); should already be checked by mining function uint256 id = _generate_special_horsey(raceAddress, msg.sender, winner); emit Claimed(raceAddress, msg.sender, id); } /** @dev Allows a user to give a horsey a name or rename it This function is payable and its cost is renamingCostsPerChar * length(newname) Cant be called while paused If called with too low balance, the modifier will throw If called with too much balance, we try to return the remaining funds back Upon completion we update all ceos balances, maybe not very efficient? @param tokenId ID of the horsey to rename @param newName The name to give to the horsey */ function renameHorsey(uint256 tokenId, string newName) external whenNotPaused() onlyOwnerOf(tokenId) costs(renamingCostsPerChar * bytes(newName).length) payable { uint256 renamingFee = renamingCostsPerChar * bytes(newName).length; //Return over paid amount to sender if necessary if(msg.value > renamingFee) //overpaid { msg.sender.transfer(msg.value.sub(renamingFee)); } //store the new name stables.storeName(tokenId,newName); emit HorseyRenamed(tokenId,newName); } /** @dev Allows a user to burn a token he owns to get carrots The mount of carrots given is equal to the horsey's feedingCounter upon burning Cant be called on a horsey with a pending feeding Cant be called while paused @param tokenId ID of the token to burn */ function freeForCarrots(uint256 tokenId) external whenNotPaused() onlyOwnerOf(tokenId) { require(pendingFeedings[msg.sender].horsey != tokenId,\"\"); //credit carrots uint8 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) + uint32(feedingCounter * carrotsMultiplier)); stables.unstoreHorsey(tokenId); emit HorseyFreed(tokenId); } /** @dev Returns the amount of carrots the user owns We have a getter to hide the carrots amount from public view @return The current amount of carrot credits the sender owns */ function getCarrotCredits() external view returns (uint32) { return stables.carrot_credits(msg.sender); } /** @dev Returns horsey data of a given token @param tokenId ID of the horsey to fetch @return (race address, dna, feedingCounter, name) */ function getHorsey(uint256 tokenId) public view returns (address, bytes32, uint8, string) { RoyalStablesInterface.Horsey memory temp; (temp.race,temp.dna,temp.feedingCounter,temp.tier) = stables.horseys(tokenId); return (temp.race,temp.dna,temp.feedingCounter,stables.names(tokenId)); } /** @dev Allows to feed a horsey to increase its feedingCounter value Gives a chance to get a rare trait The amount of carrots required is the value of current feedingCounter The carrots the user owns will be reduced accordingly upon success Cant be called while paused @param tokenId ID of the horsey to feed */ function feed(uint256 tokenId) external whenNotPaused() onlyOwnerOf(tokenId) carrotsMeetLevel(tokenId) noFeedingInProgress() { pendingFeedings[msg.sender] = FeedingData(block.number,tokenId); uint8 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); stables.storeCarrotsCredit(msg.sender,stables.carrot_credits(msg.sender) - uint32(feedingCounter)); emit Feeding(tokenId); } /** @dev Allows user to stop feeding a horsey This will trigger a random rarity chance */ function stopFeeding() external feedingInProgress() returns (bool) { uint256 blockNumber = pendingFeedings[msg.sender].blockNumber; uint256 tokenId = pendingFeedings[msg.sender].horsey; //you cant feed and stop feeding from the same block! require(block.number - blockNumber >= 1,\"feeding and stop feeding are in same block\"); delete pendingFeedings[msg.sender]; //solidity only gives you access to the previous 256 blocks //deny and remove this obsolete feeding if we cant fetch its blocks hash if(block.number - blockNumber > 255) { //the feeding is outdated = failed //the user can feed again but he lost his carrots emit FeedingFailed(tokenId); return false; } //token could have been transfered in the meantime to someone else if(stables.ownerOf(tokenId) != msg.sender) { //the feeding is failed because the token no longer belongs to this user = failed //the user has lost his carrots emit FeedingFailed(tokenId); return false; } //call horsey generation with the claim block hash _feed(tokenId, blockhash(blockNumber)); bytes32 dna; (,dna,,) = stables.horseys(tokenId); emit ReceivedCarrot(tokenId, dna); return true; } /// @dev Only ether sent explicitly through the donation() function is accepted function() external payable { revert(\"Not accepting donations\"); } /** @dev Internal function to increase a horsey's rarity Uses a random value to assess if the feeding process increases rarity The chances of having a rarity increase are based on the current feedingCounter @param tokenId ID of the token to \"feed\" @param blockHash Hash of the block where the feeding began */ function _feed(uint256 tokenId, bytes32 blockHash) internal { //Grab the upperbound for probability 100,100 uint8 tier; uint8 feedingCounter; (,,feedingCounter,tier) = stables.horseys(tokenId); uint256 probabilityByRarity = 10 ** (uint256(tier).add(1)); uint256 randNum = uint256(keccak256(abi.encodePacked(tokenId, blockHash))) % probabilityByRarity; //Scale probability based on horsey's level if(randNum <= (feedingCounter * rarityMultiplier)){ _increaseRarity(tokenId, blockHash); } //Increment feedingCounter //Maximum allowed is 255, which requires 32385 carrots, so we should never reach that if(feedingCounter < 255) { stables.modifyHorseyFeedingCounter(tokenId,feedingCounter+1); } } /// @dev creates a special token id based on the race and the coin index function _makeSpecialId(address race, address sender, bytes32 coinIndex) internal pure returns (uint256) { return uint256(keccak256(abi.encodePacked(race, sender, coinIndex))); } /** @dev Internal function to generate a SPECIAL horsey token we then use the ERC721 inherited minting process the dna is a bytes32 target for a keccak256. Not using blockhash finaly, a bitmask zeros the first 2 bytes for rarity traits @param race Address of the associated race @param eth_address Address of the user to receive the token @param coinIndex The index of the winning coin @return ID of the token */ function _generate_special_horsey(address race, address eth_address, bytes32 coinIndex) internal returns (uint256) { uint256 id = _makeSpecialId(race, eth_address, coinIndex); //generate dna bytes32 dna = _shiftRight(keccak256(abi.encodePacked(race, coinIndex)),16); //storeHorsey checks if the token exists before minting already, so we dont have to here stables.storeHorsey(eth_address,id,race,dna,1,0); return id; } /** @dev Internal function called to increase a horsey rarity We generate a random zeros mask with a single 1 in the leading 16 bits @param tokenId Id of the token to increase rarity of @param blockHash hash of the block where the feeding began */ function _increaseRarity(uint256 tokenId, bytes32 blockHash) private { uint8 tier; bytes32 dna; (,dna,,tier) = stables.horseys(tokenId); if(tier < 255) stables.modifyHorseyTier(tokenId,tier+1); uint256 random = uint256(keccak256(abi.encodePacked(tokenId, blockHash))); //this creates a mask of 256 bits such as one of the first 16 bits will be 1 bytes32 rarityMask = _shiftLeft(bytes32(1), (random % 16 + 240)); bytes32 newdna = dna | rarityMask; //apply mask to add the random flag stables.modifyHorseyDna(tokenId,newdna); } /// @dev shifts a bytes32 left by n positions function _shiftLeft(bytes32 data, uint n) internal pure returns (bytes32) { return bytes32(uint256(data)*(2 ** n)); } /// @dev shifts a bytes32 right by n positions function _shiftRight(bytes32 data, uint n) internal pure returns (bytes32) { return bytes32(uint256(data)/(2 ** n)); } /// @dev Modifier to ensure user can afford a rehorse modifier carrotsMeetLevel(uint256 tokenId){ uint256 feedingCounter; (,,feedingCounter,) = stables.horseys(tokenId); require(feedingCounter <= stables.carrot_credits(msg.sender),\"Not enough carrots\"); _; } /// @dev insures the caller payed the required amount modifier costs(uint256 amount) { require(msg.value >= amount,\"Not enough funds\"); _; } /// @dev requires the address to be non null modifier validAddress(address addr) { require(addr != address(0),\"Address is zero\"); _; } /// @dev requires that the user isnt feeding a horsey already modifier noFeedingInProgress() { //if the key does not exit, then the default struct data is used where blockNumber is 0 require(pendingFeedings[msg.sender].blockNumber == 0,\"Already feeding\"); _; } /// @dev requires that the user isnt feeding a horsey already modifier feedingInProgress() { //if the key does not exit, then the default struct data is used where blockNumber is 0 require(pendingFeedings[msg.sender].blockNumber != 0,\"No pending feeding\"); _; } /// @dev requires that the user isnt feeding a horsey already modifier onlyOwnerOf(uint256 tokenId) { require(stables.ownerOf(tokenId) == msg.sender, \"Caller is not owner of this token\"); _; } } // File: contracts\\HorseyPilot.sol /** @title Adds rank management utilities and voting behavior @dev Handles equities distribution and levels of access EXCHANGE FUNCTIONS IT CAN CALL setClaimingFee OK 5 setMarketFees OK 1 withdraw TOKEN FUNCTIONS IT CAN CALL setRenamingCosts OK 0 addHorseIndex OK 3 setCarrotsMultiplier 8 setRarityMultiplier 9 addLegitDevAddress 2 withdraw PAUSING OK 4 */ contract HorseyPilot { using SafeMath for uint256; /// @dev event that is fired when a new proposal is made event NewProposal(uint8 methodId, uint parameter, address proposer); /// @dev event that is fired when a proposal is accepted event ProposalPassed(uint8 methodId, uint parameter, address proposer); /// @dev minimum threshold that must be met in order to confirm /// a contract update uint8 constant votingThreshold = 2; /// @dev minimum amount of time a proposal can live /// after this time it can be forcefully invoked or killed by anyone uint256 constant proposalLife = 7 days; /// @dev amount of time until another proposal can be made /// we use this to eliminate proposal spamming uint256 constant proposalCooldown = 1 days; /// @dev used to reference the exact time the last proposal vetoed uint256 cooldownStart; /// @dev The addresses of the accounts (or contracts) that can execute actions within each roles. address public jokerAddress; address public knightAddress; address public paladinAddress; /// @dev List of all addresses allowed to vote address[3] public voters; /// @dev joker is the pool and gets the rest uint8 constant public knightEquity = 40; uint8 constant public paladinEquity = 10; /// @dev deployed exchange and token addresses address public exchangeAddress; address public tokenAddress; /// @dev Mapping to keep track of pending balance of contract owners mapping(address => uint) internal _cBalance; /// @dev Encapsulates information about a proposed update struct Proposal{ address proposer;           /// @dev address of the CEO at the origin of this proposal uint256 timestamp;          /// @dev the time at which this propsal was made uint256 parameter;          /// @dev parameters associated with proposed method invocation uint8   methodId;           /// @dev id maps to function 0:rename horse, 1:change fees, 2:? address[] yay;              /// @dev list of all addresses who voted address[] nay;              /// @dev list of all addresses who voted against } /// @dev the pending proposal Proposal public currentProposal; /// @dev true if the proposal is waiting for votes bool public proposalInProgress = false; /// @dev Value to keep track of avaible balance uint256 public toBeDistributed; /// @dev used to deploy contracts only once bool deployed = false; /** @param _jokerAddress joker @param _knightAddress knight @param _paladinAddress paladin @param _voters list of all allowed voting addresses */ constructor( address _jokerAddress, address _knightAddress, address _paladinAddress, address[3] _voters ) public { jokerAddress = _jokerAddress; knightAddress = _knightAddress; paladinAddress = _paladinAddress; for(uint i = 0; i < 3; i++) { voters[i] = _voters[i]; } //Set cooldown start to 1 day ago so that cooldown is irrelevant cooldownStart = block.timestamp - proposalCooldown; } /** @dev Used to deploy children contracts as a one shot call */ function deployChildren(address stablesAddress) external { require(!deployed,\"already deployed\"); // deploy token and exchange contracts exchangeAddress = new HorseyExchange(); tokenAddress = new HorseyToken(stablesAddress); // the exchange requires horsey token address HorseyExchange(exchangeAddress).setStables(stablesAddress); deployed = true; } /** @dev Transfers joker ownership to a new address @param newJoker the new address */ function transferJokerOwnership(address newJoker) external validAddress(newJoker) { require(jokerAddress == msg.sender,\"Not right role\"); _moveBalance(newJoker); jokerAddress = newJoker; } /** @dev Transfers knight ownership to a new address @param newKnight the new address */ function transferKnightOwnership(address newKnight) external validAddress(newKnight) { require(knightAddress == msg.sender,\"Not right role\"); _moveBalance(newKnight); knightAddress = newKnight; } /** @dev Transfers paladin ownership to a new address @param newPaladin the new address */ function transferPaladinOwnership(address newPaladin) external validAddress(newPaladin) { require(paladinAddress == msg.sender,\"Not right role\"); _moveBalance(newPaladin); paladinAddress = newPaladin; } /** @dev Allow CEO to withdraw from pending value always checks to update redist We ONLY redist when a user tries to withdraw so we are not redistributing on every payment @param destination The address to send the ether to */ function withdrawCeo(address destination) external onlyCLevelAccess() validAddress(destination) { //Check that pending balance can be redistributed - if so perform //this procedure if(toBeDistributed > 0){ _updateDistribution(); } //Grab the balance of this CEO uint256 balance = _cBalance[msg.sender]; //If we have non-zero balance, CEO may withdraw from pending amount if(balance > 0 && (address(this).balance >= balance)) { destination.transfer(balance); //throws on fail _cBalance[msg.sender] = 0; } } /// @dev acquire funds from owned contracts function syncFunds() external { uint256 prevBalance = address(this).balance; HorseyToken(tokenAddress).withdraw(); HorseyExchange(exchangeAddress).withdraw(); uint256 newBalance = address(this).balance; //add to toBeDistributed = toBeDistributed.add(newBalance - prevBalance); } /// @dev allows a noble to access his holdings function getNobleBalance() external view onlyCLevelAccess() returns (uint256) { return _cBalance[msg.sender]; } /** @dev Make a proposal and add to pending proposals @param methodId a string representing the function ie. 'renameHorsey()' @param parameter parameter to be used if invocation is approved */ function makeProposal( uint8 methodId, uint256 parameter ) external onlyCLevelAccess() proposalAvailable() cooledDown() { currentProposal.timestamp = block.timestamp; currentProposal.parameter = parameter; currentProposal.methodId = methodId; currentProposal.proposer = msg.sender; delete currentProposal.yay; delete currentProposal.nay; proposalInProgress = true; emit NewProposal(methodId,parameter,msg.sender); } /** @dev Call to vote on a pending proposal */ function voteOnProposal(bool voteFor) external proposalPending() onlyVoters() notVoted() { //cant vote on expired! require((block.timestamp - currentProposal.timestamp) <= proposalLife); if(voteFor) { currentProposal.yay.push(msg.sender); //Proposal went through? invoke it if( currentProposal.yay.length >= votingThreshold ) { _doProposal(); proposalInProgress = false; //no need to reset cooldown on successful proposal return; } } else { currentProposal.nay.push(msg.sender); //Proposal failed? if( currentProposal.nay.length >= votingThreshold ) { proposalInProgress = false; cooldownStart = block.timestamp; return; } } } /** @dev Helps moving pending balance from one role to another @param newAddress the address to transfer the pending balance from the msg.sender account */ function _moveBalance(address newAddress) internal validAddress(newAddress) { require(newAddress != msg.sender); /// @dev IMPORTANT or else the account balance gets reset here! _cBalance[newAddress] = _cBalance[msg.sender]; _cBalance[msg.sender] = 0; } /** @dev Called at the start of withdraw to distribute any pending balances that live in the contract will only ever be called if balance is non-zero (funds should be distributed) */ function _updateDistribution() internal { require(toBeDistributed != 0,\"nothing to distribute\"); uint256 knightPayday = toBeDistributed.div(100).mul(knightEquity); uint256 paladinPayday = toBeDistributed.div(100).mul(paladinEquity); /// @dev due to the equities distribution, queen gets the remaining value uint256 jokerPayday = toBeDistributed.sub(knightPayday).sub(paladinPayday); _cBalance[jokerAddress] = _cBalance[jokerAddress].add(jokerPayday); _cBalance[knightAddress] = _cBalance[knightAddress].add(knightPayday); _cBalance[paladinAddress] = _cBalance[paladinAddress].add(paladinPayday); //Reset balance to 0 toBeDistributed = 0; } /** @dev Execute the proposal */ function _doProposal() internal { /// UPDATE the renaming cost if( currentProposal.methodId == 0 ) HorseyToken(tokenAddress).setRenamingCosts(currentProposal.parameter); /// UPDATE the market fees if( currentProposal.methodId == 1 ) HorseyExchange(exchangeAddress).setMarketFees(currentProposal.parameter); /// UPDATE the legit dev addresses list if( currentProposal.methodId == 2 ) HorseyToken(tokenAddress).addLegitDevAddress(address(currentProposal.parameter)); /// ADD a horse index to exchange if( currentProposal.methodId == 3 ) HorseyToken(tokenAddress).addHorseIndex(bytes32(currentProposal.parameter)); /// PAUSE/UNPAUSE the dApp if( currentProposal.methodId == 4 ) { if(currentProposal.parameter == 0) { HorseyExchange(exchangeAddress).unpause(); HorseyToken(tokenAddress).unpause(); } else { HorseyExchange(exchangeAddress).pause(); HorseyToken(tokenAddress).pause(); } } /// UPDATE the claiming fees if( currentProposal.methodId == 5 ) HorseyToken(tokenAddress).setClaimingCosts(currentProposal.parameter); /// UPDATE carrots multiplier if( currentProposal.methodId == 8 ){ HorseyToken(tokenAddress).setCarrotsMultiplier(uint8(currentProposal.parameter)); } /// UPDATE rarity multiplier if( currentProposal.methodId == 9 ){ HorseyToken(tokenAddress).setRarityMultiplier(uint8(currentProposal.parameter)); } emit ProposalPassed(currentProposal.methodId,currentProposal.parameter,currentProposal.proposer); } /// @dev requires the address to be non null modifier validAddress(address addr) { require(addr != address(0),\"Address is zero\"); _; } /// @dev requires the sender to be on the contract owners list modifier onlyCLevelAccess() { require((jokerAddress == msg.sender) || (knightAddress == msg.sender) || (paladinAddress == msg.sender),\"not c level\"); _; } /// @dev requires that a proposal is not in process or has exceeded its lifetime, and has cooled down /// after being vetoed modifier proposalAvailable(){ require(((!proposalInProgress) || ((block.timestamp - currentProposal.timestamp) > proposalLife)),\"proposal already pending\"); _; } // @dev requries that if this proposer was the last proposer, that he or she has reached the // cooldown limit modifier cooledDown( ){ if(msg.sender == currentProposal.proposer && (block.timestamp - cooldownStart < 1 days)){ revert(\"Cool down period not passed yet\"); } _; } /// @dev requires a proposal to be active modifier proposalPending() { require(proposalInProgress,\"no proposal pending\"); _; } /// @dev requires the voter to not have voted already modifier notVoted() { uint256 length = currentProposal.yay.length; for(uint i = 0; i < length; i++) { if(currentProposal.yay[i] == msg.sender) { revert(\"Already voted\"); } } length = currentProposal.nay.length; for(i = 0; i < length; i++) { if(currentProposal.nay[i] == msg.sender) { revert(\"Already voted\"); } } _; } /// @dev requires the voter to not have voted already modifier onlyVoters() { bool found = false; uint256 length = voters.length; for(uint i = 0; i < length; i++) { if(voters[i] == msg.sender) { found = true; break; } } if(!found) { revert(\"not a voter\"); } _; } } "}
{"sol name": "1808.sol", "label": 1, "sol content": "pragma solidity ^0.4.21; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns  (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /*Token  Contract*/ contract ZXCToken is StandardToken, Ownable { using SafeMath for uint256; // Token Information string  public constant NAME = \"0XCoin\"; string  public constant SYMBOL = \"0XC\"; uint8   public constant DECIMALS = 18; // Sale period1. uint256 public startDate1; uint256 public endDate1; // Sale period2. uint256 public startDate2; uint256 public endDate2; //SaleCap uint256 public saleCap; // Address Where Token are keep address public tokenWallet; // Address where funds are collected. address public fundWallet; // Amount of raised money in wei. uint256 public weiRaised; // Event event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); // Modifiers modifier uninitialized() { require(tokenWallet == 0x0); require(fundWallet == 0x0); _; } constructor() public {} // Trigger with Transfer event // Fallback function can be used to buy tokens function () public payable { buyTokens(msg.sender, msg.value); } function getDate() public view returns(uint256 _date) { _date = getCurrentTimestamp(); } //Initial Contract function initialize(address _tokenWallet, address _fundWallet, uint256 _start1, uint256 _end1, uint256 _saleCap, uint256 _totalSupply) public onlyOwner uninitialized { //require(_start >= getCurrentTimestamp()); require(_start1 < _end1); require(_tokenWallet != 0x0); require(_fundWallet != 0x0); require(_totalSupply >= _saleCap); startDate1 = _start1; endDate1 = _end1; saleCap = _saleCap; tokenWallet = _tokenWallet; fundWallet = _fundWallet; totalSupply = _totalSupply; balances[tokenWallet] = saleCap; balances[0xb1] = _totalSupply.sub(saleCap); } //Set PreSale Time function setPeriod(uint period, uint256 _start, uint256 _end) public onlyOwner { require(_end > _start); if (period == 1) { startDate1 = _start; endDate1 = _end; }else if (period == 2) { require(_start > endDate1); startDate2 = _start; endDate2 = _end; } } // For pushing pre-ICO records function sendForPreICO(address buyer, uint256 amount) public onlyOwner { require(saleCap >= amount); saleCap = saleCap - amount; // Transfer balances[tokenWallet] = balances[tokenWallet].sub(amount); balances[buyer] = balances[buyer].add(amount); } //Set SaleCap function setSaleCap(uint256 _saleCap) public onlyOwner { require(balances[0xb1].add(balances[tokenWallet]).sub(_saleCap) > 0); uint256 amount=0; //Check SaleCap if (balances[tokenWallet] > _saleCap) { amount = balances[tokenWallet].sub(_saleCap); balances[0xb1] = balances[0xb1].add(amount); } else { amount = _saleCap.sub(balances[tokenWallet]); balances[0xb1] = balances[0xb1].sub(amount); } balances[tokenWallet] = _saleCap; saleCap = _saleCap; } //Calcute Bouns function getBonusByTime(uint256 atTime) public constant returns (uint256) { if (atTime < startDate1) { return 0; } else if (endDate1 > atTime && atTime > startDate1) { return 5000; } else if (endDate2 > atTime && atTime > startDate2) { return 2500; } else { return 0; } } function getBounsByAmount(uint256 etherAmount, uint256 tokenAmount) public pure returns (uint256) { //Max 40% uint256 bonusRatio = etherAmount.div(500 ether); if (bonusRatio > 4) { bonusRatio = 4; } uint256 bonusCount = SafeMath.mul(bonusRatio, 10); uint256 bouns = SafeMath.mul(tokenAmount, bonusCount); uint256 realBouns = SafeMath.div(bouns, 100); return realBouns; } //Stop Contract function finalize() public onlyOwner { require(!saleActive()); // Transfer the rest of token to tokenWallet balances[tokenWallet] = balances[tokenWallet].add(balances[0xb1]); balances[0xb1] = 0; } //Check SaleActive function saleActive() public constant returns (bool) { return ( (getCurrentTimestamp() >= startDate1 && getCurrentTimestamp() < endDate1 && saleCap > 0) || (getCurrentTimestamp() >= startDate2 && getCurrentTimestamp() < endDate2 && saleCap > 0) ); } //Get CurrentTS function getCurrentTimestamp() internal view returns (uint256) { return now; } //Buy Token function buyTokens(address sender, uint256 value) internal { //Check Sale Status require(saleActive()); //Minum buying limit require(value >= 0.5 ether); // Calculate token amount to be purchased uint256 bonus = getBonusByTime(getCurrentTimestamp()); uint256 amount = value.mul(bonus); // If ETH > 500 the add 10% if (getCurrentTimestamp() >= startDate1 && getCurrentTimestamp() < endDate1) { uint256 p1Bouns = getBounsByAmount(value, amount); amount = amount + p1Bouns; } // We have enough token to sale require(saleCap >= amount); // Transfer balances[tokenWallet] = balances[tokenWallet].sub(amount); balances[sender] = balances[sender].add(amount); saleCap = saleCap - amount; // Update state. weiRaised = weiRaised + value; // Forward the fund to fund collection wallet. //tokenWallet.transfer(msg.value); fundWallet.transfer(msg.value); } } "}
{"sol name": "980.sol", "label": 1, "sol content": "pragma solidity ^0.4.12; contract IMigrationContract { function migrate(address addr, uint256 nas) returns (bool success); } /* \u7075\u611f\u6765\u81ea\u4e8eNAS  coin*/ contract SafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x >= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /*  ERC 20 token */ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract HKHCToken is StandardToken, SafeMath { // metadata string  public constant name = \"Happily keep health\"; string  public constant symbol = \"HKHC\"; uint256 public constant decimals = 18; string  public version = \"1.0\"; // contracts address public ethFundDeposit;          // ETH\u5b58\u653e\u5730\u5740 address public newContractAddr;         // token\u66f4\u65b0\u5730\u5740 // crowdsale parameters bool    public isFunding;                // \u72b6\u6001\u5207\u6362\u5230true uint256 public fundingStartBlock; uint256 public fundingStopBlock; uint256 public currentSupply;           // \u6b63\u5728\u552e\u5356\u4e2d\u7684tokens\u6570\u91cf uint256 public tokenRaised = 0;         // \u603b\u7684\u552e\u5356\u6570\u91cftoken uint256 public tokenMigrated = 0;     // \u603b\u7684\u5df2\u7ecf\u4ea4\u6613\u7684 token uint256 public tokenExchangeRate = 625;             // 625 BILIBILI \u5151\u6362 1 ETH // events event AllocateToken(address indexed _to, uint256 _value);   // \u5206\u914d\u7684\u79c1\u6709\u4ea4\u6613token; event IssueToken(address indexed _to, uint256 _value);      // \u516c\u5f00\u53d1\u884c\u552e\u5356\u7684token; event IncreaseSupply(uint256 _value); event DecreaseSupply(uint256 _value); event Migrate(address indexed _to, uint256 _value); // \u8f6c\u6362 function formatDecimals(uint256 _value) internal returns (uint256 ) { return _value * 10 ** decimals; } // constructor function HKHCToken( address _ethFundDeposit, uint256 _currentSupply) { ethFundDeposit = _ethFundDeposit; isFunding = false;                           //\u901a\u8fc7\u63a7\u5236\u9884CrowdS ale\u72b6\u6001 fundingStartBlock = 0; fundingStopBlock = 0; currentSupply = formatDecimals(_currentSupply); totalSupply = formatDecimals(1000000000); balances[msg.sender] = totalSupply; if(currentSupply > totalSupply) throw; } modifier isOwner()  { require(msg.sender == ethFundDeposit); _; } ///  \u8bbe\u7f6etoken\u6c47\u7387 function setTokenExchangeRate(uint256 _tokenExchangeRate) isOwner external { if (_tokenExchangeRate == 0) throw; if (_tokenExchangeRate == tokenExchangeRate) throw; tokenExchangeRate = _tokenExchangeRate; } /// @dev \u8d85\u53d1token\u5904\u7406 function increaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + currentSupply > totalSupply) throw; currentSupply = safeAdd(currentSupply, value); IncreaseSupply(value); } /// @dev \u88ab\u76d7token\u5904\u7406 function decreaseSupply (uint256 _value) isOwner external { uint256 value = formatDecimals(_value); if (value + tokenRaised > currentSupply) throw; currentSupply = safeSubtract(currentSupply, value); DecreaseSupply(value); } ///  \u542f\u52a8\u533a\u5757\u68c0\u6d4b \u5f02\u5e38\u7684\u5904\u7406 function startFunding (uint256 _fundingStartBlock, uint256 _fundingStopBlock) isOwner external { if (isFunding) throw; if (_fundingStartBlock >= _fundingStopBlock) throw; if (block.number >= _fundingStartBlock) throw; fundingStartBlock = _fundingStartBlock; fundingStopBlock = _fundingStopBlock; isFunding = true; } ///  \u5173\u95ed\u533a\u5757\u5f02\u5e38\u5904\u7406 function stopFunding() isOwner external { if (!isFunding) throw; isFunding = false; } /// \u5f00\u53d1\u4e86\u4e00\u4e2a\u65b0\u7684\u5408\u540c\u6765\u63a5\u6536token\uff08\u6216\u8005\u66f4\u65b0token\uff09 function setMigrateContract(address _newContractAddr) isOwner external { if (_newContractAddr == newContractAddr) throw; newContractAddr = _newContractAddr; } /// \u8bbe\u7f6e\u65b0\u7684\u6240\u6709\u8005\u5730\u5740 function changeOwner(address _newFundDeposit) isOwner() external { if (_newFundDeposit == address(0x0)) throw; ethFundDeposit = _newFundDeposit; } ///\u8f6c\u79fbtoken\u5230\u65b0\u7684\u5408\u7ea6 function migrate() external { if(isFunding) throw; if(newContractAddr == address(0x0)) throw; uint256 tokens = balances[msg.sender]; if (tokens == 0) throw; balances[msg.sender] = 0; tokenMigrated = safeAdd(tokenMigrated, tokens); IMigrationContract newContract = IMigrationContract(newContractAddr); if (!newContract.migrate(msg.sender, tokens)) throw; Migrate(msg.sender, tokens);               // log it } /// \u8f6c\u8d26ETH \u5230  HKHCToken \u56e2\u961f function transferETH() isOwner external { if (this.balance == 0) throw; if (!ethFundDeposit.send(this.balance)) throw; } ///  \u5c06BILIBILI token\u5206\u914d\u5230\u9884\u5904\u7406\u5730\u5740\u3002 function allocateToken (address _addr, uint256 _eth) isOwner external { if (_eth == 0) throw; if (_addr == address(0x0)) throw; uint256 tokens = safeMult(formatDecimals(_eth), tokenExchangeRate); if (tokens + tokenRaised > currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[_addr] += tokens; AllocateToken(_addr, tokens);  // \u8bb0\u5f55token\u65e5\u5fd7 } /// \u8d2d\u4e70token function () payable { if (!isFunding) throw; if (msg.value == 0) throw; if (block.number < fundingStartBlock) throw; if (block.number > fundingStopBlock) throw; uint256 tokens = safeMult(msg.value, tokenExchangeRate); if (tokens + tokenRaised > currentSupply) throw; tokenRaised = safeAdd(tokenRaised, tokens); balances[msg.sender] += tokens; IssueToken(msg.sender, tokens);  //\u8bb0\u5f55\u65e5\u5fd7 } } "}
{"sol name": "126.sol", "label": 1, "sol content": "// Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md pragma solidity ^0.4.21; contract EIP20Interface { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public view returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public view returns (uint256 remaining); // solhint-disable-next-line no-simple-event-func-name event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract TestCoin is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX function TestCoin( ) public { balances[msg.sender] = 10*10**26;               // Give the creator all initial tokens totalSupply = 10*10**26;                        // Update total supply name = \"LHJT\";                                   // Set the name for display purposes decimals = 18;                                 // Amount of decimals for display purposes symbol = \"LHJT\";                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "258.sol", "label": 1, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract CRYPTOHEDGECoin { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function CRYPTOHEDGECoin( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1822.sol", "label": 1, "sol content": "pragma solidity ^0.4.2; contract CoinByInsomnia { string  public name = \"CoinByInsomnia\"; string  public symbol = \"CBI\"; string  public standard = \"CoinByInsomnia v1.0\"; uint256 public totalSupply; event Transfer( address indexed _from, address indexed _to, uint256 _value ); event Approval( address indexed _owner, address indexed _spender, uint256 _value ); mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; constructor (uint256 _initialSupply) public { balanceOf[msg.sender] = _initialSupply; totalSupply = _initialSupply; } function transfer(address _to, uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= balanceOf[_from]); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; balanceOf[_to] += _value; allowance[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; } } "}
{"sol name": "944.sol", "label": 1, "sol content": "pragma solidity 0.4.22; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event FrozenFunds(address target, uint tokens); event Buy(address indexed sender, uint eth, uint token); } // Owned contract contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } //Transfer owner rights, can use only owner (the best practice of secure for the contracts) function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } //Accept tranfer owner rights function acceptOwnership() public onlyOwner { emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // Pausable Contract contract Pausable is Owned { event Pause(); event Unpause(); bool public paused = false; //Modifier to make a function callable only when the contract is not paused. modifier whenNotPaused() { require(!paused); _; } //Modifier to make a function callable only when the contract is paused. modifier whenPaused() { require(paused); _; } //called by the owner to pause, triggers stopped state function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } //called by the owner to unpause, returns to normal state function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract VXR is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) public balances; mapping(address => uint) public lockInfo; mapping(address => mapping(address => uint)) internal allowed; mapping (address => bool) public admins; modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; } function setAdmin(address _admin, bool isAdmin) public onlyOwner { admins[_admin] = isAdmin; } constructor() public{ symbol = 'VXR'; name = 'Versara Trade'; decimals = 18; _totalSupply = 1000000000*10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public view returns (uint) { return _totalSupply; } function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0);                                    // Prevent transfer to 0x0 address. Use burn() instead require(_value != 0);                                   // Prevent transfer 0 require(balances[_from] >= _value);                     // Check if the sender has enough require(balances[_from] - _value >= lockInfo[_from]);   // Check after transaction, balance is still more than locked value balances[_from] = balances[_from].sub(_value);          // Substract value from sender balances[_to] = balances[_to].add(_value);              // Add value to recipient emit Transfer(_from, _to, _value); } function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { _transfer(msg.sender, to, tokens); return true; } function approve(address _spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = tokens; emit Approval(msg.sender, _spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { require(allowed[from][msg.sender] >= tokens); _transfer(from, to, tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); return true; } function allowance(address tokenOwner, address spender) public whenNotPaused view returns (uint remaining) { return allowed[tokenOwner][spender]; } //Admin Tool function lockOf(address tokenOwner) public view returns (uint lockedToken) { return lockInfo[tokenOwner]; } //lock tokens or lock 0 to release all function lock(address target, uint lockedToken) public whenNotPaused onlyAdmin { lockInfo[target] = lockedToken; emit FrozenFunds(target, lockedToken); } //Batch lock or lock 0 to release all function batchLock(address[] accounts, uint lockedToken) public whenNotPaused onlyAdmin { for (uint i = 0; i < accounts.length; i++) { lock(accounts[i], lockedToken); } } //Batch lock amount with array function batchLockArray(address[] accounts, uint[] lockedToken) public whenNotPaused onlyAdmin { for (uint i = 0; i < accounts.length; i++) { lock(accounts[i], lockedToken[i]); } } //Airdrop Batch with lock function batchAirdropWithLock(address[] receivers, uint tokens, bool freeze) public whenNotPaused onlyAdmin { for (uint i = 0; i < receivers.length; i++) { sendTokensWithLock(receivers[i], tokens, freeze); } } //VIP Batch with lock function batchVipWithLock(address[] receivers, uint[] tokens, bool freeze) public whenNotPaused onlyAdmin { for (uint i = 0; i < receivers.length; i++) { sendTokensWithLock(receivers[i], tokens[i], freeze); } } //Send token with lock function sendTokensWithLock (address receiver, uint tokens, bool freeze) public whenNotPaused onlyAdmin { _transfer(msg.sender, receiver, tokens); if(freeze) { uint lockedAmount = lockInfo[receiver] + tokens; lock(receiver, lockedAmount); } } //Send initial tokens function sendInitialTokens (address user) public onlyOwner { _transfer(msg.sender, user, balanceOf(owner)); } } "}
{"sol name": "544.sol", "label": 1, "sol content": "pragma solidity ^0.4.16; contract Token{ uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Burn(address indexed from, uint256 value); event Inflat(address indexed from, uint256 value); } contract HNContract is Token { // string public name;                   //\u540d\u79f0\uff0c\u4f8b\u5982\"My test token\" // uint8 public decimals;               //\u8fd4\u56detoken\u4f7f\u7528\u7684\u5c0f\u6570\u70b9\u540e\u51e0\u4f4d\u3002\u6bd4\u5982\u5982\u679c\u8bbe\u7f6e\u4e3a3\uff0c\u5c31\u662f\u652f\u63010.001\u8868\u793a. // string public symbol;               //token\u7b80\u79f0,like MTT uint8 constant public decimals = 18; string constant public name = \"HNContract\"; string constant public symbol = \"NN\"; uint public totalSupply = 1000000000 * 10 ** uint256(decimals); address contract_creator; // function TokenDemo(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) public { function HNContract() public { // totalSupply = _initialAmount * 10 ** uint256(_decimalUnits);         // \u8bbe\u7f6e\u521d\u59cb\u603b\u91cf balances[msg.sender] = totalSupply; // \u521d\u59cbtoken\u6570\u91cf\u7ed9\u4e88\u6d88\u606f\u53d1\u9001\u8005\uff0c\u56e0\u4e3a\u662f\u6784\u9020\u51fd\u6570\uff0c\u6240\u4ee5\u8fd9\u91cc\u4e5f\u662f\u5408\u7ea6\u7684\u521b\u5efa\u8005 // record contract_creator contract_creator=msg.sender; // name = _tokenName; // decimals = _decimalUnits; // symbol = _tokenSymbol; } function inflat(uint256 _value) public returns(bool success){ require(msg.sender == contract_creator); require(_value > 0); totalSupply += _value; balances[contract_creator] +=_value; Inflat(contract_creator, _value); return true; } function transfer(address _to, uint256 _value) public returns (bool success) { //\u9ed8\u8ba4totalSupply \u4e0d\u4f1a\u8d85\u8fc7\u6700\u5927\u503c (2^256 - 1). //\u5982\u679c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u5c06\u4f1a\u6709\u65b0\u7684token\u751f\u6210\uff0c\u5219\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u53e5\u907f\u514d\u6ea2\u51fa\u7684\u5f02\u5e38 require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(_to != 0x0); balances[msg.sender] -= _value;//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[_to] += _value;//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value Transfer(msg.sender, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value;//\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value balances[_from] -= _value; //\u652f\u51fa\u8d26\u6237_from\u51cf\u53bbtoken\u6570\u91cf_value allowed[_from][msg.sender] -= _value;//\u6d88\u606f\u53d1\u9001\u8005\u53ef\u4ee5\u4ece\u8d26\u6237_from\u4e2d\u8f6c\u51fa\u7684\u6570\u91cf\u51cf\u5c11_value Transfer(_from, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender];//\u5141\u8bb8_spender\u4ece_owner\u4e2d\u8f6c\u51fa\u7684token\u6570 } function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] -= _value; totalSupply -=_value; Burn(burner, _value); } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } "}
{"sol name": "370.sol", "label": 1, "sol content": "// Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md pragma solidity ^0.4.18; contract EIP20Interface { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public view returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public view returns (uint256 remaining); // solhint-disable-next-line no-simple-event-func-name event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /* Implements EIP20 token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md .*/ contract Purox is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX function Purox( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "847.sol", "label": 1, "sol content": "// $Lira Token pragma solidity ^0.4.4; contract Token { function totalSupply() constant returns (uint256 supply) {} function balanceOf(address _owner) constant returns (uint256 balance) {} function transfer(address _to, uint256 _value) returns (bool success) {} function transferFrom(address _from, address _to, uint256 _value) returns (bool success) {} function approve(address _spender, uint256 _value) returns (bool success) {} function allowance(address _owner, address _spender) constant returns (uint256 remaining) {} event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else {return false;} } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value > balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else {return false;} } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; uint256 public totalSupply; } contract Lira is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = \"1.0\"; uint256 public unitsOneEthCanBuy; uint256 public totalEthInWei; address public fundsWallet; function Lira() { balances[msg.sender] = 1000000000000000000000000000000; totalSupply = 1000000000000000000000000000000; name = \"Lira Token\"; decimals = 18; symbol = \"LIRA\"; fundsWallet = msg.sender; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); if (!_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)) {throw;} return true; } } "}
{"sol name": "241.sol", "label": 1, "sol content": "pragma solidity ^0.4.19; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ForeignToken { function balanceOf(address _owner) constant public returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } interface Token { function distr(address _to, uint256 _value) public returns (bool); function totalSupply() constant public returns (uint256 supply); function balanceOf(address _owner) constant public returns (uint256 balance); } contract BEN is ERC20 { using SafeMath for uint256; address owner = msg.sender; mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; mapping (address => bool) public blacklist; string public constant name = \"BENetwork\"; string public constant symbol = \"BEN\"; uint public constant decimals = 8; uint256 public totalSupply = 100000000e8; uint256 public totalDistributed = 10000000e8; uint256 public totalRemaining = totalSupply.sub(totalDistributed); uint256 public value; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); event Distr(address indexed to, uint256 amount); event DistrFinished(); event Burn(address indexed burner, uint256 value); bool public distributionFinished = false; modifier canDistr() { require(!distributionFinished); _; } modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyWhitelist() { require(blacklist[msg.sender] == false); _; } function BEN () public { owner = msg.sender; value = 400e8; distr(owner, totalDistributed); } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function enableWhitelist(address[] addresses) onlyOwner public { for (uint i = 0; i < addresses.length; i++) { blacklist[addresses[i]] = false; } } function disableWhitelist(address[] addresses) onlyOwner public { for (uint i = 0; i < addresses.length; i++) { blacklist[addresses[i]] = true; } } function finishDistribution() onlyOwner canDistr public returns (bool) { distributionFinished = true; DistrFinished(); return true; } function distr(address _to, uint256 _amount) canDistr private returns (bool) { totalDistributed = totalDistributed.add(_amount); totalRemaining = totalRemaining.sub(_amount); balances[_to] = balances[_to].add(_amount); Distr(_to, _amount); Transfer(address(0), _to, _amount); return true; if (totalDistributed >= totalSupply) { distributionFinished = true; } } function airdrop(address[] addresses) onlyOwner canDistr public { require(addresses.length <= 255); require(value <= totalRemaining); for (uint i = 0; i < addresses.length; i++) { require(value <= totalRemaining); distr(addresses[i], value); } if (totalDistributed >= totalSupply) { distributionFinished = true; } } function distribution(address[] addresses, uint256 amount) onlyOwner canDistr public { require(addresses.length <= 255); require(amount <= totalRemaining); for (uint i = 0; i < addresses.length; i++) { require(amount <= totalRemaining); distr(addresses[i], amount); } if (totalDistributed >= totalSupply) { distributionFinished = true; } } function distributeAmounts(address[] addresses, uint256[] amounts) onlyOwner canDistr public { require(addresses.length <= 255); require(addresses.length == amounts.length); for (uint8 i = 0; i < addresses.length; i++) { require(amounts[i] <= totalRemaining); distr(addresses[i], amounts[i]); if (totalDistributed >= totalSupply) { distributionFinished = true; } } } function () external payable { getTokens(); } function getTokens() payable canDistr onlyWhitelist public { if (value > totalRemaining) { value = totalRemaining; } require(value <= totalRemaining); address investor = msg.sender; uint256 toGive = value; distr(investor, toGive); if (toGive > 0) { blacklist[investor] = true; } if (totalDistributed >= totalSupply) { distributionFinished = true; } value = value.div(100000).mul(99999); } function balanceOf(address _owner) constant public returns (uint256) { return balances[_owner]; } // mitigates the ERC20 short address attack modifier onlyPayloadSize(uint size) { assert(msg.data.length >= size + 4); _; } function transfer(address _to, uint256 _amount) onlyPayloadSize(2 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(msg.sender, _to, _amount); return true; } function transferFrom(address _from, address _to, uint256 _amount) onlyPayloadSize(3 * 32) public returns (bool success) { require(_to != address(0)); require(_amount <= balances[_from]); require(_amount <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_amount); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_amount); balances[_to] = balances[_to].add(_amount); Transfer(_from, _to, _amount); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { // mitigates the ERC20 spend/approval race condition if (_value != 0 && allowed[msg.sender][_spender] != 0) { return false; } allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant public returns (uint256) { return allowed[_owner][_spender]; } function getTokenBalance(address tokenAddress, address who) constant public returns (uint){ ForeignToken t = ForeignToken(tokenAddress); uint bal = t.balanceOf(who); return bal; } function withdraw() onlyOwner public { uint256 etherBalance = this.balance; owner.transfer(etherBalance); } function burn(uint256 _value) onlyOwner public { require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); totalDistributed = totalDistributed.sub(_value); Burn(burner, _value); } function withdrawForeignTokens(address _tokenContract) onlyOwner public returns (bool) { ForeignToken token = ForeignToken(_tokenContract); uint256 amount = token.balanceOf(address(this)); return token.transfer(owner, amount); } } "}
{"sol name": "9.sol", "label": 1, "sol content": "pragma solidity ^0.4.16; contract WWW  { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; uint256 public totalSupply; string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function WWW() public { balances[msg.sender] = 100000000000000;               // Give the creator all initial tokens totalSupply = 100000000000000;                        // Update total supply name = \"WWW Chain\";                                   // Set the name for display purposes decimals =4;                            // Amount of decimals for display purposes symbol = \"WWW\";                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function test() public view returns (uint256 balance) { return 2+3; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "130.sol", "label": 1, "sol content": "/* ==================================================================== */ /* Copyright (c) 2018 The TokenTycoon Project.  All rights reserved. /* /* https://tokentycoon.io /* /* authors [email\u00a0protected] /*         [email\u00a0protected] /* ==================================================================== */ pragma solidity ^0.4.23; contract AccessAdmin { bool public isPaused = false; address public addrAdmin; event AdminTransferred(address indexed preAdmin, address indexed newAdmin); constructor() public { addrAdmin = msg.sender; } modifier onlyAdmin() { require(msg.sender == addrAdmin); _; } modifier whenNotPaused() { require(!isPaused); _; } modifier whenPaused { require(isPaused); _; } function setAdmin(address _newAdmin) external onlyAdmin { require(_newAdmin != address(0)); emit AdminTransferred(addrAdmin, _newAdmin); addrAdmin = _newAdmin; } function doPause() external onlyAdmin whenNotPaused { isPaused = true; } function doUnpause() external onlyAdmin whenPaused { isPaused = false; } } interface TokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TalentCard is AccessAdmin { uint8 public decimals = 0; uint256 public totalSupply = 1000000000; string public name = \"Token Tycoon Talent Card\"; string public symbol = \"TTTC\"; mapping (address => uint256) balances; mapping (address => mapping(address => uint256)) allowed; /// @dev Trust contract mapping (address => bool) safeContracts; event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); constructor() public { addrAdmin = msg.sender; balances[this] = totalSupply; } function balanceOf(address _owner) external view returns (uint256) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) external view returns (uint256) { return allowed[_owner][_spender]; } function transferFrom(address _from, address _to, uint256 _value) external returns (bool) { require(_value <= allowed[_from][msg.sender]); allowed[_from][msg.sender] -= _value; return _transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) external returns (bool) { return _transfer(msg.sender, _to, _value); } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); uint256 oldFromVal = balances[_from]; require(_value > 0 && oldFromVal >= _value); uint256 oldToVal = balances[_to]; uint256 newToVal = oldToVal + _value; require(newToVal > oldToVal); uint256 newFromVal = oldFromVal - _value; balances[_from] = newFromVal; balances[_to] = newToVal; assert((oldFromVal + oldToVal) == (newFromVal + newToVal)); emit Transfer(_from, _to, _value); return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) external returns (bool success) { TokenRecipient spender = TokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function setSafeContract(address _actionAddr, bool _useful) external onlyAdmin { safeContracts[_actionAddr] = _useful; } function getSafeContract(address _actionAddr) external view onlyAdmin returns(bool) { return safeContracts[_actionAddr]; } function safeSendCard(uint256 _amount, address _to) external { require(safeContracts[msg.sender]); require(balances[address(this)] >= _amount); require(_to != address(0)); _transfer(address(this), _to, _amount); } } "}
{"sol name": "566.sol", "label": 1, "sol content": "pragma solidity ^0.4.21; contract Token{ uint256 public totalSupply; function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract CYFToken is Token { string public name = \"\u4e5e\u529b\u9a6c\u624e\u7f57\u7684\u96eaCYF\";                   //\u540d\u79f0 uint8 public decimals = 18;               //\u8fd4\u56detoken\u4f7f\u7528\u7684\u5c0f\u6570\u70b9\u540e\u51e0\u4f4d\u3002\u6bd4\u5982\u5982\u679c\u8bbe\u7f6e\u4e3a3\uff0c\u5c31\u662f\u652f\u63010.001\u8868\u793a. string public symbol = \"CYF\";               //token\u7b80\u79f0 mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; function CYFToken() public { totalSupply = 7000000000 * (10 ** (uint256(decimals)));         // \u8bbe\u7f6e\u521d\u59cb\u603b\u91cf balances[msg.sender] = totalSupply; // \u521d\u59cbtoken\u6570\u91cf\u7ed9\u4e88\u6d88\u606f\u53d1\u9001\u8005\uff0c\u56e0\u4e3a\u662f\u6784\u9020\u51fd\u6570\uff0c\u6240\u4ee5\u8fd9\u91cc\u4e5f\u662f\u5408\u7ea6\u7684\u521b\u5efa\u8005 } function transfer(address _to, uint256 _value) public returns (bool success) { //\u9ed8\u8ba4totalSupply \u4e0d\u4f1a\u8d85\u8fc7\u6700\u5927\u503c (2^256 - 1). //\u5982\u679c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u5c06\u4f1a\u6709\u65b0\u7684token\u751f\u6210\uff0c\u5219\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u53e5\u907f\u514d\u6ea2\u51fa\u7684\u5f02\u5e38 require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(_to != 0x0); balances[msg.sender] -= _value;//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[_to] += _value;//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value emit Transfer(msg.sender, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value;//\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value balances[_from] -= _value; //\u652f\u51fa\u8d26\u6237_from\u51cf\u53bbtoken\u6570\u91cf_value allowed[_from][msg.sender] -= _value;//\u6d88\u606f\u53d1\u9001\u8005\u53ef\u4ee5\u4ece\u8d26\u6237_from\u4e2d\u8f6c\u51fa\u7684\u6570\u91cf\u51cf\u5c11_value emit Transfer(_from, _to, _value);//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender];//\u5141\u8bb8_spender\u4ece_owner\u4e2d\u8f6c\u51fa\u7684token\u6570 } } "}
{"sol name": "1690.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; // File: contracts/zeppelin/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** *  @title ERC223 interface **/ contract ERC223Interface { function transfer(address to, uint value, bytes data) public returns (bool); event Transfer(address indexed from, address indexed to, uint value, bytes data); } /** * @title ERC223 token handler **/ contract ERC223Receiver { function tokenFallback(address _fromm, uint256 _value, bytes _data) public pure; } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; address public newOwner; /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } event OwnershipTransferred(address oldOwner, address newOwner); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. * @dev Modified by function 'finalUnpause' */ contract Pausable is Ownable { event Pause(); event Unpause(); event FinalUnpause(); bool public paused = false; // finalUnpaused always false, not sure its purpose bool public finalUnpaused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { require (!finalUnpaused); paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } /** * func unpause and finalUnpause are doing same stuff except from event. * didn't see any effect. */ function finalUnpause() onlyOwner public { paused = false; emit FinalUnpause(); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { // not required, sub method will take care of this. // require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } /** * @title Tipcoin contract **/ contract TipcoinToken is StandardToken, Pausable, BurnableToken, ERC223Interface { using SafeMath for uint256; string public constant name = \"Tipcoin\"; string public constant symbol = \"TIPC\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 1000000000; constructor() public { // owner is already initiated in ownable constructor. // owner = msg.sender; totalSupply_ = INITIAL_SUPPLY * 10 ** 18; balances[owner] = totalSupply_; emit Transfer(address(0), owner, INITIAL_SUPPLY); } /** * @dev transfer token for a specified address with call custom function external data * @param _to The address to transfer to. * @param _value The amount to be transferred. * @param _data The data to call tokenFallback function. * @param _fallback The function name and params to call external function */ function transfer(address _to, uint256 _value, bytes _data, string _fallback) public whenNotPaused returns (bool) { require( _to != address(0)); if (isContract(_to)) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); assert(_to.call.value(0)(bytes4(keccak256(abi.encodePacked(_fallback))), msg.sender, _value, _data)); if (_data.length == 0) { emit Transfer(msg.sender, _to, _value); } else { emit Transfer(msg.sender, _to, _value); emit Transfer(msg.sender, _to, _value, _data); } return true; } else { return transferToAddress(msg.sender, _to, _value, _data); } } /** * @dev transfer token for a specified address with external data * @param _to The address to transfer to. * @param _value The amount to be transferred. * @param _data The data to call tokenFallback function */ function transfer(address _to, uint256 _value, bytes _data) public whenNotPaused returns (bool) { if (isContract(_to)) { return transferToContract(msg.sender, _to, _value, _data); } else { return transferToAddress(msg.sender, _to, _value, _data); } } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { bytes memory empty; if (isContract(_to)) { return transferToContract(msg.sender, _to, _value, empty); } else { return transferToAddress(msg.sender, _to, _value, empty); } } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool){ require( _to != address(0)); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); bytes memory empty; if (isContract(_to)) { return transferToContract(_from, _to, _value, empty); } else { return transferToAddress(_from, _to, _value, empty); } } //@dev internal part function isContract(address _addr) internal view returns (bool) { uint length; assembly { length := extcodesize(_addr) } return (length >0); } function transferToAddress(address _from, address _to, uint256 _value, bytes _data) private returns (bool) { balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); if (_data.length == 0) { emit Transfer(_from, _to, _value); } else { emit Transfer(_from, _to, _value); emit Transfer(_from, _to, _value, _data); } return true; } function transferToContract(address _from, address _to, uint256 _value, bytes _data) private returns (bool) { balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); ERC223Receiver receiver = ERC223Receiver(_to); receiver.tokenFallback(_from, _value, _data); if (_data.length == 0) { emit Transfer(_from, _to, _value); } else { emit Transfer(_from, _to, _value); emit Transfer(_from, _to, _value, _data); } return true; } } "}
{"sol name": "33.sol", "label": 1, "sol content": "pragma solidity 0.4.24; contract AbcdEfg { mapping (uint256 => Mark) public marks; string public constant name = \"abcdEfg\"; string public constant symbol = \"a2g\"; uint8 public constant decimals = 0; string public constant memo = \"Fit in the words here!Fit in the words here!Fit in the words here!Fit in the words here!\"; mapping (address => uint256) private balances; mapping (address => uint256) private marked; uint256 private totalSupply_ = 1000; uint256 private markId = 0; event Transfer( address indexed from, address indexed to, uint256 value ); struct Mark { address author; bytes content; } constructor() public { balances[msg.sender] = totalSupply_; } function () public { mark(); } function mark() internal { require(1 + marked[msg.sender] <= balances[msg.sender]); markId ++; marked[msg.sender] ++; Mark memory temp; temp.author = msg.sender; temp.content = msg.data; marks[markId] = temp; } function totalSupply() public view returns (uint256) { return totalSupply_; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool) { require(_value + marked[msg.sender] <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender] - _value; balances[_to] = balances[_to] + _value; emit Transfer(msg.sender, _to, _value); return true; } } "}
{"sol name": "977.sol", "label": 1, "sol content": "pragma solidity ^0.4.16; contract WBET{ uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ uint256 public totalSupply; string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;                //How many decimals to show. string public symbol;                 //An identifier: eg SBX event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); function WBET() public { balances[msg.sender] = 3600000000000;               // Give the creator all initial tokens totalSupply = 3600000000000;                        // Update total supply name = \"\u4e16\u884c\u4ee5\u592a\u94fe\";                                   // Set the name for display purposes decimals =4;                            // Amount of decimals for display purposes symbol = \"WBET\";                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "364.sol", "label": 1, "sol content": "/* Implements EIP20 token standard: https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20.md .*/ pragma solidity ^0.4.21; contract EIP20Interface { /* This is a slight change to the ERC20 base standard. function totalSupply() constant returns (uint256 supply); is replaced with: uint256 public totalSupply; This automatically creates a getter function for the totalSupply. This is moved to the base contract since public getter functions are not currently recognised as an implementation of the matching abstract function by the compiler. */ /// total amount of tokens uint256 public totalSupply; /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) public view returns (uint256 balance); /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint256 _value) public returns (bool success); /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); /// @notice `msg.sender` approves `_spender` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of tokens to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint256 _value) public returns (bool success); /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) public view returns (uint256 remaining); // solhint-disable-next-line no-simple-event-func-name event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ATM is EIP20Interface { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; /* NOTE: The following variables are OPTIONAL vanities. One does not have to include them. They allow one to customise the token contract & in no way influences the core functionality. Some wallets/interfaces might not even bother to look at this information. */ string public name;                   //fancy name: eg Simon Bucks uint8 public decimals;               //How many decimals to show. string public symbol;                 //An identifier: eg SBX function ATM( uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol ) public { balances[msg.sender] = _initialAmount;               // Give the creator all initial tokens totalSupply = _initialAmount;                        // Update total supply name = _tokenName;                                   // Set the name for display purposes decimals = _decimalUnits;                            // Amount of decimals for display purposes symbol = _tokenSymbol;                               // Set the symbol for display purposes } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); //solhint-disable-line indent, no-unused-vars return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { uint256 allowance = allowed[_from][msg.sender]; require(balances[_from] >= _value && allowance >= _value); balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT256) { allowed[_from][msg.sender] -= _value; } emit Transfer(_from, _to, _value); //solhint-disable-line indent, no-unused-vars return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); //solhint-disable-line indent, no-unused-vars return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } "}
{"sol name": "633.sol", "label": 1, "sol content": "pragma solidity ^0.4.18; contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } /*  ERC 20 token */ contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract NABC is StandardToken { // metadata string public constant name = \"NABC\"; string public constant symbol = \"NABC\"; uint256 public constant decimals = 18; string public version = \"1.0\"; address private creator; mapping (address => uint256) private blackmap; mapping (address => uint256) private releaseamount; modifier onlyCreator() { require(msg.sender == creator); _; } function _addressNotNull(address _to) private pure returns (bool) { return _to != address(0); } function addBlackAccount(address _b) public onlyCreator { require(_addressNotNull(_b)); blackmap[_b] = 1; } function clearBlackAccount(address _b) public onlyCreator { require(_addressNotNull(_b)); blackmap[_b] = 0; } function checkBlackAccount(address _b) public returns (uint256) { require(_addressNotNull(_b)); return blackmap[_b]; } function setReleaseAmount(address _b, uint256 _a) public onlyCreator { require(_addressNotNull(_b)); require(balances[_b] >= _a); releaseamount[_b] = _a; } function checkReleaseAmount(address _b) public returns (uint256) { require(_addressNotNull(_b)); return releaseamount[_b]; } address account1 = 0xA1eA1e293839e2005a8E47f772B758DaBC0515FB;  //70% address account2 = 0xD285bB3f0d0A6271d535Bd37798A452892466De0;  //30% uint256 public amount1 = 34* 10000 * 10000 * 10**decimals; uint256 public amount2 = 14* 10000 * 10000 * 10**decimals; // constructor function NABC() { creator = msg.sender; totalSupply = amount1 + amount2; balances[account1] = amount1; balances[account2] = amount2; balances[msg.sender] = 2 * 10000 * 10000 * 10**decimals; } function transfer(address _to, uint256 _value) returns (bool success) { if (balances[msg.sender] >= _value && _value > 0) { if(blackmap[msg.sender] != 0){ if(releaseamount[msg.sender] < _value){ return false; } else{ releaseamount[msg.sender] -= _value; balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } } else{ balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } } else { return false; } } } "}
{"sol name": "1720.sol", "label": 1, "sol content": "/************************************************************************* * This contract has been merged with solidify * https://github.com/tiesnetwork/solidify *************************************************************************/ pragma solidity ^0.4.18; /************************************************************************* * import \"zeppelin-solidity/contracts/math/SafeMath.sol\" : start *************************************************************************/ /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /************************************************************************* * import \"zeppelin-solidity/contracts/math/SafeMath.sol\" : end *************************************************************************/ /************************************************************************* * import \"zeppelin-solidity/contracts/token/MintableToken.sol\" : start *************************************************************************/ /************************************************************************* * import \"./StandardToken.sol\" : start *************************************************************************/ /************************************************************************* * import \"./BasicToken.sol\" : start *************************************************************************/ /************************************************************************* * import \"./ERC20Basic.sol\" : start *************************************************************************/ /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /************************************************************************* * import \"./ERC20Basic.sol\" : end *************************************************************************/ /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /************************************************************************* * import \"./BasicToken.sol\" : end *************************************************************************/ /************************************************************************* * import \"./ERC20.sol\" : start *************************************************************************/ /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /************************************************************************* * import \"./ERC20.sol\" : end *************************************************************************/ /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /************************************************************************* * import \"./StandardToken.sol\" : end *************************************************************************/ /************************************************************************* * import \"../ownership/Ownable.sol\" : start *************************************************************************/ /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /************************************************************************* * import \"../ownership/Ownable.sol\" : end *************************************************************************/ /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } /************************************************************************* * import \"zeppelin-solidity/contracts/token/MintableToken.sol\" : end *************************************************************************/ contract HC8 is MintableToken { /* Token constants */ string public name = \"Hydrocarbon8\"; string public symbol = \"HC8\"; uint public decimals = 6; /* Blocks token transfers until ICO is finished.*/ bool public tokensBlocked = true; // list of addresses with time-freezend tokens mapping (address => uint) public teamTokensFreeze; event debugLog(string key, uint value); /* Allow token transfer.*/ function unblock() external onlyOwner { tokensBlocked = false; } /* Override some function to add support of blocking .*/ function transfer(address _to, uint256 _value) public returns (bool) { require(!tokensBlocked); require(allowTokenOperations(_to)); require(allowTokenOperations(msg.sender)); super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(!tokensBlocked); require(allowTokenOperations(_from)); require(allowTokenOperations(_to)); super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public returns (bool) { require(!tokensBlocked); require(allowTokenOperations(_spender)); super.approve(_spender, _value); } // Hold team/founders tokens for defined time function freezeTokens(address _holder, uint time) public onlyOwner { require(_holder != 0x0); teamTokensFreeze[_holder] = time; } function allowTokenOperations(address _holder) public constant returns (bool) { return teamTokensFreeze[_holder] == 0 || now >= teamTokensFreeze[_holder]; } } contract HC8ICO { using SafeMath for uint; //========== // Variables //========== //States enum IcoState {Running, Paused, Failed, Finished} // ico successed bool public isSuccess = false; // contract hardcoded owner address public owner = 0x07c88CC4316F47131d5D3AD84B3151397E858120; address public wallet = 0x81c9Ad6B14F6cBd71155B504e6E88963420f1829; address public unsold = 0x7Cb4C67d020042537476Bc13033461ce154bD3e0; // Start time uint public constant startTime = 1533715688; // End time uint public endTime = startTime + 60 days; // decimals multiplier for calculation & debug uint public constant multiplier = 1000000; // minimal amount of tokens for sale uint private constant minTokens = 50  * multiplier; // one million uint public constant mln = 1000000; // ICO max tokens for sale uint public constant tokensCap = 99 * mln * multiplier; //ICO success uint public constant minSuccess = 2 * mln * multiplier; // Amount of sold tokens uint public totalSupply = 0; // Amount of tokens w/o bonus uint public tokensSoldTotal = 0; // State of ICO - default Running IcoState public icoState = IcoState.Running; // @dev for debug uint private constant rateDivider = 1; // initial price in wei uint public priceInWei = 2481641572 / rateDivider; // robot address address public _robot = 0x63b247db491D3d3E32A9629509Fb459386Aff921; // if ICO not finished - we must send all old contract eth to new bool public tokensAreFrozen = true; // The token being sold HC8 public token; // Structure for holding bonuses and tokens for btc investors // We can now deprecate rate/bonus_tokens/value without bitcoin holding mechanism - we don't need it struct TokensHolder { uint value; //amount of wei uint tokens; //amount of tokens uint bonus; //amount of bonus tokens uint total; //total tokens uint rate; //conversion rate for hold moment uint change; //unused wei amount if tx reaches cap } //wei amount mapping (address => uint) public investors; struct teamTokens { address holder; uint freezePeriod; uint percent; uint divider; uint maxTokens; } teamTokens[] public listTeamTokens; // Bonus params uint[] public bonusPatterns = [80, 60, 40, 20]; uint[] public bonusLimit = [5 * mln * multiplier, 10 * mln * multiplier, 15 * mln * multiplier, 20 * mln * multiplier]; // flag to prevent team tokens regen with external call bool public teamTokensGenerated = false; //========= //Modifiers //========= // Active ICO modifier ICOActive { require(icoState == IcoState.Running); require(now >= (startTime)); require(now <= (endTime)); _; } // Finished ICO modifier ICOFinished { require(icoState == IcoState.Finished); _; } // Failed ICO - time is over modifier ICOFailed { require(now >= (endTime)); require(icoState == IcoState.Failed || !isSuccess); _; } // Allows some methods to be used by team or robot modifier onlyOwner() { require(msg.sender == owner); _; } modifier onlyTeam() { require(msg.sender == owner || msg.sender == _robot); _; } modifier successICOState() { require(isSuccess); _; } //======= // Events //======= event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint value, uint amount); event RunIco(); event PauseIco(); event SuccessIco(); event ICOFails(); event updateRate(uint time, uint rate); event debugLog(string key, uint value); event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); //======== // Methods //======== // Constructor function HC8ICO() public { token = new HC8(); //if (owner == 0x0) {//owner not set in contract //    owner = msg.sender; //} //uint freezePeriod; //uint percent; //uint divider; // // Company tokens 10%, blocked for 182 days listTeamTokens.push(teamTokens(0x1b83619057f2230060ea672E7C03C5DAe8A1eEE6, 182 days, 10, 1, 0)); // Company tokens 10%, blocked for 1 year listTeamTokens.push(teamTokens(0xB7F2BD192baAe546F5a48570b5d5990be2C31433, 1 years, 10, 1, 0)); // Team tokens 6.667% listTeamTokens.push(teamTokens(0xB6e2E9019AC0282Bc20b6874dea8488Db4E41512, 0, 32, 10, 0)); listTeamTokens.push(teamTokens(0x0adC0CC5E9625E893Ec5C56Ee9D189644FF3744F, 0, 16, 10, 0)); listTeamTokens.push(teamTokens(0xB5c5C8C3615A48c03BF0F2a30fD1EC3Aea8C5A20, 0, 16, 10, 0)); listTeamTokens.push(teamTokens(0x79C3659236c51C82b7c0A5CD02932551470fA8cF, 0, 200, 1000, 0)); listTeamTokens.push(teamTokens(0x644dEd1858174fc9b91d614846d1545Ad510074B, 0, 6670, 100000, 0)); // Team tokens 6.667%, blocked for 1 year listTeamTokens.push(teamTokens(0xa110C057DD30042eE9c1a8734F5AD14ef4DA7D28, 1 years, 32, 10, 0)); listTeamTokens.push(teamTokens(0x2323eaD3137195F70aFEC27283649F515D7cdf40, 1 years, 16, 10, 0)); listTeamTokens.push(teamTokens(0x4A536E9F10c19112C33DEA04BFC62216792a197D, 1 years, 16, 10, 0)); listTeamTokens.push(teamTokens(0x93c7338D6D23Ed36c6eD5d05C80Dc54BDB2ebCcd, 1 years, 200, 1000, 0)); listTeamTokens.push(teamTokens(0x3bFF85649F76bf0B6719657D1a7Ea7de4C6F77F5, 1 years, 6670, 100000, 0)); // Team tokes 6.667%, blocked for 2 years listTeamTokens.push(teamTokens(0x1543E108cDA983eA3e4DF7fa599096EBa2BDC26b, 2 years, 32, 10, 0)); listTeamTokens.push(teamTokens(0x0d05195af835F64cf42bC01276196E7D313Ca572, 2 years, 16, 10, 0)); listTeamTokens.push(teamTokens(0x5a9447368cF7D1Ae134444263c51E07e8d8091eA, 2 years, 16, 10, 0)); listTeamTokens.push(teamTokens(0x9293824d3A66Af4fdE6f29Aa016b784408B5cA5F, 2 years, 200, 1000, 0)); listTeamTokens.push(teamTokens(0x8bbBd613EA5a840FDE29DFa6F6E53E93FE998c7F, 2 years, 6660, 100000, 0)); } // fallback function can be used to buy tokens function() public payable ICOActive { require(!isReachedLimit()); TokensHolder memory tokens = calculateTokens(msg.value); require(tokens.total > 0); token.mint(msg.sender, tokens.total); TokenPurchase(msg.sender, msg.sender, tokens.value, tokens.total); if (tokens.change > 0 && tokens.change <= msg.value) { msg.sender.transfer(tokens.change); } investors[msg.sender] = investors[msg.sender].add(tokens.value); addToStat(tokens.tokens, tokens.bonus); debugLog(\"rate \", priceInWei); manageStatus(); } function hasStarted() public constant returns (bool) { return now >= startTime; } function hasFinished() public constant returns (bool) { return now >= endTime || isReachedLimit(); } // Calculates amount of bonus tokens function getBonus(uint _value, uint _sold) internal constant returns (TokensHolder) { TokensHolder memory result; uint _bonus = 0; result.tokens = _value; for (uint8 i = 0; _value > 0 && i < bonusLimit.length; ++i) { uint current_bonus_part = 0; if (_value > 0 && _sold < bonusLimit[i]) { uint bonus_left = bonusLimit[i] - _sold; uint _bonusedPart = min(_value, bonus_left); current_bonus_part = current_bonus_part.add(percent(_bonusedPart, bonusPatterns[i])); _value = _value.sub(_bonusedPart); _sold = _sold.add(_bonusedPart); } if (current_bonus_part > 0) { _bonus = _bonus.add(current_bonus_part); } } result.bonus = _bonus; return result; } // Are we reached tokens limit? function isReachedLimit() internal constant returns (bool) { return tokensCap.sub(totalSupply) == 0; } function manageStatus() internal { if (totalSupply >= minSuccess && !isSuccess) { successICO(); } bool capIsReached = (totalSupply == tokensCap); if (capIsReached || (now >= endTime)) { if (!isSuccess) { failICO(); } else { finishICO(false); } } } function calculateForValue(uint value) public constant returns (uint, uint, uint) { TokensHolder memory tokens = calculateTokens(value); return (tokens.total, tokens.tokens, tokens.bonus); } function calculateTokens(uint value) internal constant returns (TokensHolder) { require(value > 0); require(priceInWei * minTokens <= value); uint tokens = value.div(priceInWei); require(tokens > 0); uint remain = tokensCap.sub(totalSupply); uint change = 0; uint value_clear = 0; if (remain <= tokens) { tokens = remain; change = value.sub(tokens.mul(priceInWei)); value_clear = value.sub(change); } else { value_clear = value; } TokensHolder memory bonus = getBonus(tokens, tokensSoldTotal); uint total = tokens + bonus.bonus; bonus.tokens = tokens; bonus.total = total; bonus.change = change; bonus.rate = priceInWei; bonus.value = value_clear; return bonus; } // Add tokens&bonus amount to counters function addToStat(uint tokens, uint bonus) internal { uint total = tokens + bonus; totalSupply = totalSupply.add(total); //tokensBought = tokensBought.add(tokens.div(multiplier)); //tokensBonus = tokensBonus.add(bonus.div(multiplier)); tokensSoldTotal = tokensSoldTotal.add(tokens); } // manual start ico after pause function startIco() external onlyOwner { require(icoState == IcoState.Paused); icoState = IcoState.Running; RunIco(); } // manual pause ico function pauseIco() external onlyOwner { require(icoState == IcoState.Running); icoState = IcoState.Paused; PauseIco(); } // auto success ico - cat withdraw ether now function successICO() internal { isSuccess = true; SuccessIco(); } function finishICO(bool manualFinish) internal successICOState { if(!manualFinish) { bool capIsReached = (totalSupply == tokensCap); if (capIsReached && now < endTime) { endTime = now; } } else { endTime = now; } icoState = IcoState.Finished; tokensAreFrozen = false; // maybe this must be called as external one-time call token.unblock(); } function failICO() internal { icoState = IcoState.Failed; ICOFails(); } function refund() public ICOFailed { require(msg.sender != 0x0); require(investors[msg.sender] > 0); uint refundVal = investors[msg.sender]; investors[msg.sender] = 0; uint balance = token.balanceOf(msg.sender); totalSupply = totalSupply.sub(balance); msg.sender.transfer(refundVal); } // Withdraw allowed only on success function withdraw(uint value) external onlyOwner successICOState { wallet.transfer(value); } // Generates team tokens after ICO finished function generateTeamTokens() internal ICOFinished { require(!teamTokensGenerated); teamTokensGenerated = true; if(tokensCap > totalSupply) { uint unsoldAmount = tokensCap.sub(totalSupply); token.mint(unsold, unsoldAmount); //debugLog('unsold ', unsoldAmount); totalSupply = totalSupply.add(unsoldAmount); } uint totalSupplyTokens = totalSupply; totalSupplyTokens = totalSupplyTokens.mul(100); totalSupplyTokens = totalSupplyTokens.div(60); for (uint8 i = 0; i < listTeamTokens.length; ++i) { uint teamTokensPart = percent(totalSupplyTokens, listTeamTokens[i].percent); if (listTeamTokens[i].divider != 0) { teamTokensPart = teamTokensPart.div(listTeamTokens[i].divider); } if (listTeamTokens[i].maxTokens != 0 && listTeamTokens[i].maxTokens < teamTokensPart) { teamTokensPart = listTeamTokens[i].maxTokens; } token.mint(listTeamTokens[i].holder, teamTokensPart); if(listTeamTokens[i].freezePeriod != 0) { token.freezeTokens(listTeamTokens[i].holder, endTime + listTeamTokens[i].freezePeriod); } addToStat(teamTokensPart, 0); } } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } //========================== // Methods for bots requests //========================== // set/update robot address function setRobot(address robot) public onlyOwner { require(robot != 0x0); _robot = robot; } // update token price in wei function setRate(uint newRate) public onlyTeam { require(newRate > 0); //todo min rate check! 0 - for debug priceInWei = newRate; updateRate(now, newRate); } // mb deprecated function robotRefund(address investor) public onlyTeam ICOFailed { require(investor != 0x0); require(investors[investor] > 0); uint refundVal = investors[investor]; investors[investor] = 0; uint balance = token.balanceOf(investor); totalSupply = totalSupply.sub(balance); investor.transfer(refundVal); } function manualFinish() public onlyTeam successICOState { require(!hasFinished()); finishICO(true); generateTeamTokens(); } function autoFinishTime() public onlyTeam { require(hasFinished()); manageStatus(); generateTeamTokens(); } //======== // Helpers //======== // calculation of min value function min(uint a, uint b) internal pure returns (uint) { return a < b ? a : b; } function percent(uint value, uint bonus) internal pure returns (uint) { return (value * bonus).div(100); } } "}
{"sol name": "117.sol", "label": 1, "sol content": "pragma solidity ^0.4.10; contract SafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x >= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns  (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token , SafeMath { bool public status = true; modifier on() { require(status == true); _; } function transfer(address _to, uint256 _value) on returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && _to != 0X0) { balances[msg.sender] -= _value; balances[_to] = safeAdd(balances[_to],_value); Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) on returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] = safeAdd(balances[_to],_value); balances[_from] = safeSubtract(balances[_from],_value); allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender],_value); Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) on constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) on returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) on constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract ExShellToken is StandardToken { string public name = \"ExShellToken\"; uint8 public decimals = 8; string public symbol = \"ET\"; bool private init =true; function turnon() controller { status = true; } function turnoff() controller { status = false; } function ExShellToken() { require(init==true); totalSupply = 2000000000; balances[0xa089a405b1df71a6155705fb2bce87df2a86a9e4] = totalSupply; init = false; } address public controller1 =0xa089a405b1df71a6155705fb2bce87df2a86a9e4; address public controller2 =0x5aa64423529e43a53c7ea037a07f94abc0c3a111; modifier controller () { require(msg.sender == controller1||msg.sender == controller2); _; } } "}
{"sol name": "465.sol", "label": 1, "sol content": "pragma solidity ^0.4.8; contract Token{ uint256 public totalSupply; function balanceOf(address _owner) constant returns (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token { function transfer(address _to, uint256 _value) returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract EightStandardToken is StandardToken { string public name; uint8 public decimals; string public symbol; string public version = '0.1'; function EightStandardToken(uint256 _initialAmount, string _tokenName, uint8 _decimalUnits, string _tokenSymbol) { balances[msg.sender] = _initialAmount; totalSupply = _initialAmount; name = _tokenName; decimals = _decimalUnits; symbol = _tokenSymbol; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); require(_spender.call(bytes4(bytes32(sha3(\"receiveApproval(address,uint256,address,bytes)\"))), msg.sender, _value, this, _extraData)); return true; } } "}
{"sol name": "394.sol", "label": 1, "sol content": "pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public {owner = msg.sender; } modifier onlyOwner() {require(msg.sender == owner); _; } } contract REALIDVerification is Ownable { event AddVerifiedInfo(address useraddress,address orgaddress,uint8 certificateNo,string orgsign,string infoHash,string resultHash); event UpdateVerifiedSign(address orgaddress,address useraddress,string infoHash,uint8 certificateNo,string orgsign); event AddOrgInfo(address orgaddress,string certificate); event UpdateValidOrgInfo(address orgaddress,bool isvalid); event UpdateWebsiteOrg(address orgaddress,string website); struct verifiedInfo{ address validOrg; uint8 certificateNo; string orgSign; string resultHash; uint256 createTime; } struct orgInfo{ string orgName; string[] certificateAds; string website; bool isvalid; uint256 createTime; string country; uint8 level; } mapping (address => mapping (string => verifiedInfo)) internal verifiedDatas; mapping (address => orgInfo) internal orgData; function addOrg(address orgaddress,string orgName,string certificate,string website,string country, uint8 level) public onlyOwner { require(orgData[orgaddress].createTime == 0); if(bytes(certificate).length != 0){ orgData[orgaddress].certificateAds.push(certificate); } orgData[orgaddress].orgName = orgName; orgData[orgaddress].website = website; orgData[orgaddress].isvalid = true; orgData[orgaddress].createTime = now; orgData[orgaddress].country = country; orgData[orgaddress].level = level; emit AddOrgInfo(orgaddress, certificate); } function updateValidOrg(address orgaddress,bool isvalid) public onlyOwner { require(orgData[orgaddress].createTime != 0); orgData[orgaddress].isvalid = isvalid; emit UpdateValidOrgInfo(orgaddress, isvalid); } function updateWebsite(address orgaddress,string website) public onlyOwner { require(orgData[orgaddress].createTime != 0); orgData[orgaddress].website = website; emit UpdateWebsiteOrg(orgaddress,website); } modifier onlyValidOrg{ require(orgData[msg.sender].isvalid);_; } function addOrgCertificate(string certificate) public onlyValidOrg returns(uint){ uint certificateNo = orgData[msg.sender].certificateAds.length; orgData[msg.sender].certificateAds.push(certificate); return certificateNo; } function addVerifiedInfo(address useraddress,string infoHash,uint8 certificateNo,string orgSign,string resultHash) public onlyValidOrg { require(verifiedDatas[useraddress][infoHash].validOrg == address(0)); verifiedDatas[useraddress][infoHash].validOrg = msg.sender; verifiedDatas[useraddress][infoHash].certificateNo = certificateNo; verifiedDatas[useraddress][infoHash].orgSign = orgSign; verifiedDatas[useraddress][infoHash].resultHash = resultHash; verifiedDatas[useraddress][infoHash].createTime = now; emit AddVerifiedInfo(useraddress,msg.sender,certificateNo,orgSign,infoHash,resultHash); } function updateVerifiedSign(address useraddress,string infoHash,uint8 certificateNo,string orgSign) public onlyValidOrg { require(verifiedDatas[useraddress][infoHash].validOrg == msg.sender); verifiedDatas[useraddress][infoHash].certificateNo = certificateNo; verifiedDatas[useraddress][infoHash].orgSign = orgSign; emit UpdateVerifiedSign(msg.sender,useraddress,infoHash,certificateNo,orgSign); } function getVerifiedInfo(address useraddress,string infoHash) view public returns(address,uint8, string, string,uint256){ return (verifiedDatas[useraddress][infoHash].validOrg, verifiedDatas[useraddress][infoHash].certificateNo, verifiedDatas[useraddress][infoHash].orgSign, verifiedDatas[useraddress][infoHash].resultHash, verifiedDatas[useraddress][infoHash].createTime); } function getOrgInfo(address org) view public returns(string,string,string,uint256,string,uint8){ if(orgData[org].certificateAds.length == 0){ return (orgData[org].orgName,orgData[org].website,\"\",orgData[org].createTime,orgData[org].country,orgData[org].level); }else{ return (orgData[org].orgName,orgData[org].website,orgData[org].certificateAds[0],orgData[org].createTime,orgData[org].country,orgData[org].level); } } function getCertificateInfoByNo(address org,uint8 certificateNo) view public returns(string){ return (orgData[org].certificateAds[certificateNo]); } function isvalidOrg(address orgaddress) view public onlyOwner returns(bool){ return orgData[orgaddress].isvalid; } } "}
