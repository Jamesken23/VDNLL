{"sol name": "1623.sol", "label": 0, "sol content": "pragma solidity 0.4.24; contract Token { /// @return total amount of tokens function totalSupply() constant returns (uint supply) {} /// @param _owner The address from which the balance will be retrieved /// @return The balance function balanceOf(address _owner) constant returns (uint balance) {} /// @notice send `_value` token to `_to` from `msg.sender` /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transfer(address _to, uint _value) returns (bool success) {} /// @notice send `_value` token to `_to` from `_from` on the condition it is approved by `_from` /// @param _from The address of the sender /// @param _to The address of the recipient /// @param _value The amount of token to be transferred /// @return Whether the transfer was successful or not function transferFrom(address _from, address _to, uint _value) returns (bool success) {} /// @notice `msg.sender` approves `_addr` to spend `_value` tokens /// @param _spender The address of the account able to transfer the tokens /// @param _value The amount of wei to be approved for transfer /// @return Whether the approval was successful or not function approve(address _spender, uint _value) returns (bool success) {} /// @param _owner The address of the account owning tokens /// @param _spender The address of the account able to transfer the tokens /// @return Amount of remaining tokens allowed to spent function allowance(address _owner, address _spender) constant returns (uint remaining) {} event Transfer(address indexed _from, address indexed _to, uint _value); event Approval(address indexed _owner, address indexed _spender, uint _value); } contract RegularToken is Token { function transfer(address _to, uint _value) returns (bool) { //Default assumes totalSupply can't be over max (2^256 - 1). if (balances[msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[msg.sender] -= _value; balances[_to] += _value; Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint _value) returns (bool) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && balances[_to] + _value >= balances[_to]) { balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) constant returns (uint) { return balances[_owner]; } function approve(address _spender, uint _value) returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) constant returns (uint) { return allowed[_owner][_spender]; } mapping (address => uint) balances; mapping (address => mapping (address => uint)) allowed; uint public totalSupply; } contract UnboundedRegularToken is RegularToken { uint constant MAX_UINT = 2**256 - 1; /// @dev ERC20 transferFrom, modified such that an allowance of MAX_UINT represents an unlimited amount. /// @param _from Address to transfer from. /// @param _to Address to transfer to. /// @param _value Amount to transfer. /// @return Success of transfer. function transferFrom(address _from, address _to, uint _value) public returns (bool) { uint allowance = allowed[_from][msg.sender]; if (balances[_from] >= _value && allowance >= _value && balances[_to] + _value >= balances[_to] ) { balances[_to] += _value; balances[_from] -= _value; if (allowance < MAX_UINT) { allowed[_from][msg.sender] -= _value; } Transfer(_from, _to, _value); return true; } else { return false; } } } contract GongPanToken is UnboundedRegularToken { uint public totalSupply = 100000000000000000000000000; uint8 constant public decimals = 18; string constant public name = \"GongPanToken\"; string constant public symbol = \"GPT\"; function GongPanToken() { balances[msg.sender] = totalSupply; Transfer(address(0), msg.sender, totalSupply); } } "}
{"sol name": "359.sol", "label": 0, "sol content": "contract Bitnova { /* Public variables of the token */ string public standard = 'Token 0.1'; string public name; string public symbol; uint8 public decimals; uint256 public initialSupply; uint256 public totalSupply; /* This creates an array with all balances */ mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; /* Initializes contract with initial supply tokens to the creator of the contract */ function Bitnova() { initialSupply = 10000000; name =\"bitnova\"; decimals = 0; symbol = \"BTN\"; balanceOf[msg.sender] = initialSupply;              // Give the creator all initial tokens totalSupply = initialSupply;                        // Update total supply } /* Send coins */ function transfer(address _to, uint256 _value) { if (balanceOf[msg.sender] < _value) throw;           // Check if the sender has enough if (balanceOf[_to] + _value < balanceOf[_to]) throw; // Check for overflows balanceOf[msg.sender] -= _value;                     // Subtract from the sender balanceOf[_to] += _value;                            // Add the same to the recipient } /* This unnamed function is called whenever someone tries to send ether to it */ function () { throw;     // Prevents accidental sending of ether } } "}
{"sol name": "830.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'BAGS' token contract // // Deployed to : 0xc5C2f1d0D344150cEEFA9A31217620632C5d38B4 // Symbol      : BAGS // Name        : BAGS // Total supply: 374000000000 // Decimals    : 3 // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Bags is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function Bags() public { symbol = \"BAGS\"; name = \"BAGS\"; decimals = 3; _totalSupply = 374000000000000; balances[0xc5C2f1d0D344150cEEFA9A31217620632C5d38B4] = _totalSupply; Transfer(address(0), 0xc5C2f1d0D344150cEEFA9A31217620632C5d38B4, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "573.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract EnjoyGameToken { function transfer(address _to, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); function transferAndLock(address _to, uint256 _value, uint256 _releaseTimeS) public returns (bool); } contract TransferEGTMulti { address public tokenAddr = 0xc5faadd1206ca91d9f8dd015b3498affad9a58bc; EnjoyGameToken egt = EnjoyGameToken(tokenAddr); modifier isAdmin() { if(0xe7266A1eFb21069E257Ec8Fc3e103f1FcF2C3e5D != msg.sender || 0xc1180dd8a1270c7aafc76d957dbb1c4c09720370 != msg.sender || 0x7C2A9bEA4177606B97bd333836F916ED475bb638 != msg.sender || 0x22B8EAeA7F027c37a968Ac95c7Fa009Aa52fF754 != msg.sender || 0xC24878A818Da47A1f39f2F926620E547B0d41831 != msg.sender){ revert(\"not admin\"); } _; } function transferMulti(address[] tos, uint256[] values) public isAdmin() { if(tos.length != values.length){ revert(\"params error\"); } for(uint256 i=0; i<tos.length; i++){ egt.transfer(tos[i], values[i]); } } function transferFromMulti(address[] froms, address[] tos, uint256[] values) public isAdmin() { if(tos.length != froms.length || tos.length != values.length){ revert(\"params error\"); } for(uint256 i=0; i<tos.length; i++){ egt.transferFrom(froms[i], tos[i], values[i]); } } function transferAndLockMulti(address[] tos, uint256[] values, uint256[] _releaseTimeSs) public isAdmin() { if(tos.length != values.length || tos.length != _releaseTimeSs.length){ revert(\"params error\"); } for(uint256 i=0; i<tos.length; i++){ egt.transferAndLock(tos[i], values[i], _releaseTimeSs[i]); } } } "}
{"sol name": "908.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; function totalSupply() public view returns (uint256) { return totalSupply_; } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract CappedToken is MintableToken { uint256 public cap; constructor(uint256 _cap) public { require(_cap > 0); cap = _cap; } function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; modifier whenNotPaused() { require(!paused); _; } modifier whenPaused() { require(paused); _; } function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract XPUBToken is CappedToken, PausableToken { string public constant name = \"X PUBLIC FUND\"; string public constant symbol = \"XPUB\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 0; uint256 public constant MAX_SUPPLY = 30 * 10000 * 10000 * (10 ** uint256(decimals)); constructor() CappedToken(MAX_SUPPLY) public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } function mint(address _to, uint256 _amount) onlyOwner canMint whenNotPaused public returns (bool) { return super.mint(_to, _amount); } function finishMinting() onlyOwner canMint whenNotPaused public returns (bool) { return super.finishMinting(); } function transferOwnership(address newOwner) onlyOwner whenNotPaused public { super.transferOwnership(newOwner); } function() payable public { revert(); } } "}
{"sol name": "203.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract RMBToken is StandardToken { string  public name = \"RMB Token\"; string  public symbol = \"RMB\"; uint8   public decimals = 18; uint    public totalSupply = 1*100000000; function () payable public { revert(); } function RMBToken() public { balances[msg.sender] = totalSupply; } } "}
{"sol name": "590.sol", "label": 0, "sol content": "pragma solidity ^ 0.4.18; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TRCERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TRCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1823.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title DeliveryTokenBasic ERC20 token */ contract DeliveryTokenBasic is ERC20 { using SafeMath for uint256; mapping (address => mapping (address => uint256)) internal allowed; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title DeliveryToken */ contract DeliveryToken is DeliveryTokenBasic { string public constant name = \"DeliveryToken\";\t// solium-disable-line uppercase string public constant symbol = \"DLV\";\t\t    // solium-disable-line uppercase uint8 public constant decimals = 18;\t\t\t    // solium-disable-line uppercase uint256 public constant INITIAL_SUPPLY = 2200000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(address(0), msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "759.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // File: openzeppelin-solidity/contracts/token/ERC20/MintableToken.sol /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/openzeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } // File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: contracts/robonomics/XRT.sol contract XRT is MintableToken, BurnableToken { string public constant name     = \"Robonomics Beta\"; string public constant symbol   = \"XRT\"; uint   public constant decimals = 9; uint256 public constant INITIAL_SUPPLY = 10000 * (10 ** uint256(decimals)); constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; emit Transfer(0x0, msg.sender, INITIAL_SUPPLY); } } "}
{"sol name": "684.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 _a, uint256 _b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (_a == 0) { return 0; } c = _a * _b; assert(c / _a == _b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 _a, uint256 _b) internal pure returns (uint256) { // assert(_b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = _a / _b; // assert(_a == _b * c + _a % _b); // There is no case in which this doesn't hold return _a / _b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_b <= _a); return _a - _b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 _a, uint256 _b) internal pure returns (uint256 c) { c = _a + _b; assert(c >= _a); return c; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { function totalSupply() public view returns (uint256); function balanceOf(address _who) public view returns (uint256); function allowance(address _owner, address _spender) public view returns (uint256); function transfer(address _to, uint256 _value) public returns (bool); function approve(address _spender, uint256 _value) public returns (bool); function transferFrom(address _from, address _to, uint256 _value) public returns (bool); event Transfer( address indexed from, address indexed to, uint256 value ); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_value <= balances[msg.sender]); require(_to != address(0)); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); require(_to != address(0)); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue >= oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer( ERC20 _token, address _to, uint256 _value ) internal { require(_token.transfer(_to, _value)); } function safeTransferFrom( ERC20 _token, address _from, address _to, uint256 _value ) internal { require(_token.transferFrom(_from, _to, _value)); } function safeApprove( ERC20 _token, address _spender, uint256 _value ) internal { require(_token.approve(_spender, _value)); } } /// @title Multisignature wallet - Allows multiple parties to agree on transactions before execution. /// @author Stefan George - <[email\u00a0protected]> /// modified by Juwita Winadwiastuti - <juwita.winadwiastuti[at]hara.ag> ///             Arkan Gilang - <arkan.gilang[at]hara.ag> contract MultiSigWallet { /* *  Events */ event Confirmation(address indexed sender, uint indexed transactionId); event Revocation(address indexed sender, uint indexed transactionId); event Submission(uint indexed transactionId); event Execution(uint indexed transactionId); event ExecutionFailure(uint indexed transactionId); event Deposit(address indexed sender, uint value); event OwnerAddition(address indexed owner); event OwnerRemoval(address indexed owner); event RequirementChange(uint required); using SafeERC20 for ERC20; /* *  Constants */ uint constant public MAX_OWNER_COUNT = 50; /* *  Storage */ mapping (uint => Transaction) public transactions; mapping (uint => mapping (address => bool)) public confirmations; mapping (address => bool) public isOwner; mapping (uint => address) public tokens; mapping (uint => bool) public tokenset; address[] public owners; uint public required; uint public transactionCount; struct Transaction { address destination; uint txType; // 0 = etherWithdraw 1 = addOwner 2 = removeOwner 10-19 = tokenWithdraw uint value; bool executed; } /* *  Modifiers */ modifier ownerDoesNotExist(address owner) { require(!isOwner[owner]); _; } modifier ownerExists(address owner) { require(isOwner[owner]); _; } modifier transactionExists(uint transactionId) { require(transactions[transactionId].destination != 0); _; } modifier confirmed(uint transactionId, address owner) { require(confirmations[transactionId][owner]); _; } modifier notConfirmed(uint transactionId, address owner) { require(!confirmations[transactionId][owner]); _; } modifier notExecuted(uint transactionId) { require(!transactions[transactionId].executed); _; } modifier notNull(address _address) { require(_address != 0); _; } modifier validRequirement(uint ownerCount, uint _required) { require(ownerCount <= MAX_OWNER_COUNT && _required <= ownerCount && _required != 0 && ownerCount != 0); _; } modifier tokenIsSet(uint tokenId) { require(tokenset[tokenId]); _; } modifier tokenNotSet(uint tokenId) { require(!tokenset[tokenId]); _; } /// @dev Fallback function allows to deposit wei. function() public payable { if (msg.value > 0) emit Deposit(msg.sender, msg.value); } /* * Public functions */ /// @dev Contract constructor sets initial owners and required number of confirmations. constructor() public { owners = [msg.sender]; isOwner[msg.sender] = true; required = 1; } function setToken(uint tokenId, address tokenContract) public tokenNotSet(tokenId) { tokens[tokenId]=tokenContract; tokenset[tokenId]=true; } /// @dev Allows to add a new owner. Transaction has to be sent by owner. /// @param owner Address of new owner. function addOwner(address owner) private ownerExists(msg.sender) ownerDoesNotExist(owner) notNull(owner) validRequirement(owners.length + 1, required) returns (bool) { isOwner[owner] = true; owners.push(owner); emit OwnerAddition(owner); uint halfOwner = uint(owners.length)/2; changeRequirement(halfOwner + 1); return true; } /// @dev Allows to remove an owner. Transaction has to be sent by owner. /// @param owner Address of owner. function removeOwner(address owner) private ownerExists(owner) ownerExists(msg.sender) returns (bool) { uint halfOwner = uint(owners.length - 1)/2; changeRequirement(halfOwner + 1); isOwner[owner] = false; for (uint i=0; i<owners.length - 1; i++) if (owners[i] == owner) { owners[i] = owners[owners.length - 1]; break; } owners.length -= 1; emit OwnerRemoval(owner); return true; } /// @dev Allows to replace an owner with a new owner. Transaction has to be sent by owner. /// @param owner Address of owner to be replaced. /// @param newOwner Address of new owner. function replaceOwner(address owner, address newOwner) public ownerExists(msg.sender) ownerExists(owner) ownerDoesNotExist(newOwner) { for (uint i=0; i<owners.length; i++) if (owners[i] == owner) { owners[i] = newOwner; break; } isOwner[owner] = false; isOwner[newOwner] = true; emit OwnerRemoval(owner); emit OwnerAddition(newOwner); } /// @dev Allows to change the number of required confirmations. Transaction has to be sent by owner. /// @param _required Number of required confirmations. function changeRequirement(uint _required) private ownerExists(msg.sender) validRequirement(owners.length, _required) { required = _required; emit RequirementChange(_required); } /// @dev Allows an owner to submit and confirm a withdraw transaction. /// @param destination Withdraw destination address. /// @param value Number of wei to withdraw. /// @return Returns transaction ID. function submitWithdrawTransaction(address destination, uint value) public ownerExists(msg.sender) returns (uint transactionId) { transactionId = addTransaction(destination, value, 0); confirmTransaction(transactionId); } /// @dev Allows an owner to submit and confirm a withdraw token transaction. /// @param tokenId token id. /// @param destination Withdraw destination address. /// @param value Number of token to withdraw. /// @return Returns transaction ID. function submitWithdrawTokenTransaction(uint tokenId, address destination, uint value) public ownerExists(msg.sender) tokenIsSet(tokenId) returns (uint transactionId) { transactionId = addTransaction(destination, value, tokenId+10); confirmTransaction(transactionId); } /// @dev Allows an owner to submit and confirm a withdraw token transaction. /// @param owner new owner. /// @return Returns transaction ID. function submitAddOwnerTransaction(address owner) public ownerExists(msg.sender) returns (uint transactionId) { transactionId = addTransaction(owner, 0, 1); confirmTransaction(transactionId); } /// @dev Allows an owner to submit and confirm a withdraw token transaction. /// @param owner old owner. /// @return Returns transaction ID. function submitRemoveOwnerTransaction(address owner) public ownerExists(msg.sender) returns (uint transactionId) { transactionId = addTransaction(owner, 0, 2); confirmTransaction(transactionId); } /// @dev Allows an owner to confirm a transaction. /// @param transactionId Transaction ID. function confirmTransaction(uint transactionId) public ownerExists(msg.sender) transactionExists(transactionId) notConfirmed(transactionId, msg.sender) { confirmations[transactionId][msg.sender] = true; emit Confirmation(msg.sender, transactionId); executeTransaction(transactionId); } /// @dev Allows an owner to revoke a confirmation for a transaction. /// @param transactionId Transaction ID. function revokeConfirmation(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { confirmations[transactionId][msg.sender] = false; emit Revocation(msg.sender, transactionId); } /// @dev Allows anyone to execute a confirmed transaction. /// @param transactionId Transaction ID. function executeTransaction(uint transactionId) public ownerExists(msg.sender) confirmed(transactionId, msg.sender) notExecuted(transactionId) { if (isConfirmed(transactionId)) { Transaction storage txn = transactions[transactionId]; txn.executed = true; if (txn.txType == 0 && withdraw(txn.destination, txn.value)) emit Execution(transactionId); else if (txn.txType == 1 && addOwner(txn.destination)) emit Execution(transactionId); else if (txn.txType == 2 && removeOwner(txn.destination)) emit Execution(transactionId); else if (txn.txType > 3 && tokenWithdraw(txn.txType-10,txn.destination,txn.value)) emit Execution(transactionId); else { emit ExecutionFailure(transactionId); txn.executed = false; } } } function tokenWithdraw(uint tokenId, address destination, uint value) ownerExists(msg.sender) tokenIsSet(tokenId) private returns (bool) { ERC20 _token = ERC20(tokens[tokenId]); _token.safeTransfer(destination, value); return true; } /// @dev Function to send wei to address. /// @param destination Address destination to send wei. /// @param value Amount of wei to send. /// @return Confirmation status. function withdraw(address destination, uint value) ownerExists(msg.sender) private returns (bool) { destination.transfer(value); return true; } /// @dev Returns the confirmation status of a transaction. /// @param transactionId Transaction ID. /// @return Confirmation status. function isConfirmed(uint transactionId) public constant returns (bool) { uint count = 0; for (uint i=0; i<owners.length; i++) { if (confirmations[transactionId][owners[i]]) count += 1; if (count == required) return true; } } /* * Internal functions */ /// @dev Adds a new transaction to the transaction mapping, if transaction does not exist yet. /// @param destination Transaction target address. /// @param value Transaction wei value. /// @return Returns transaction ID. function addTransaction(address destination, uint value, uint txType) internal notNull(destination) returns (uint transactionId) { transactionId = transactionCount; transactions[transactionId] = Transaction({ destination: destination, txType: txType, value: value, executed: false }); transactionCount += 1; emit Submission(transactionId); } /* * Web3 call functions */ /// @dev Returns number of confirmations of a transaction. /// @param transactionId Transaction ID. /// @return Number of confirmations. function getConfirmationCount(uint transactionId) public constant returns (uint count) { for (uint i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) count += 1; } /// @dev Returns total number of transactions after filers are applied. /// @param pending Include pending transactions. /// @param executed Include executed transactions. /// @return Total number of transactions after filters are applied. function getTransactionCount(bool pending, bool executed) public constant returns (uint count) { for (uint i=0; i<transactionCount; i++) if (   pending && !transactions[i].executed || executed && transactions[i].executed) count += 1; } /// @dev Returns list of owners. /// @return List of owner addresses. function getOwners() public constant returns (address[]) { return owners; } /// @dev Returns array with owner addresses, which confirmed transaction. /// @param transactionId Transaction ID. /// @return Returns array of owner addresses. function getConfirmations(uint transactionId) public constant returns (address[] _confirmations) { address[] memory confirmationsTemp = new address[](owners.length); uint count = 0; uint i; for (i=0; i<owners.length; i++) if (confirmations[transactionId][owners[i]]) { confirmationsTemp[count] = owners[i]; count += 1; } _confirmations = new address[](count); for (i=0; i<count; i++) _confirmations[i] = confirmationsTemp[i]; } } "}
{"sol name": "622.sol", "label": 0, "sol content": "pragma solidity ^0.4.19; contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender;  } modifier onlyOwner() { address sender =  msg.sender; address _owner = owner; require(msg.sender == _owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract SelfDestroy is Ownable { using SafeMath for uint256; uint256 public weiAmount = 0; constructor() public {} // fallback function to receive ether function () public payable { weiAmount = weiAmount + msg.value; } function destroy(address _address) public onlyOwner { selfdestruct(_address); } } "}
{"sol name": "854.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract Loyalty is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"GIFT\"; // v8 name = \"Loyalty\"; decimals = 8; _totalSupply = 200000000000000000; balances[msg.sender] = _totalSupply; emit Transfer(address(0), msg.sender, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } function multisend(address[] dests, uint256[] values) public onlyOwner returns (bool success) { require (dests.length == values.length); uint256 bal = balances[msg.sender]; for (uint i = 0; i < values.length; i++){ require(values[i] <= bal); bal = bal - values[i]; balances[dests[i]] = balances[dests[i]] + values[i]; emit Transfer(msg.sender, dests[i], values[i]); } balances[msg.sender] = bal; return true; } } "}
{"sol name": "696.sol", "label": 0, "sol content": "// Created using Token Wizard https://github.com/poanetwork/token-wizard by POA Network pragma solidity ^0.4.11; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Interface for defining crowdsale pricing. */ contract PricingStrategy { address public tier; /** Interface declaration. */ function isPricingStrategy() public constant returns (bool) { return true; } /** Self check if all references are correctly set. * * Checks that pricing strategy matches crowdsale parameters. */ function isSane(address crowdsale) public constant returns (bool) { return true; } /** * @dev Pricing tells if this is a presale purchase or not. @param purchaser Address of the purchaser @return False by default, true if a presale purchaser */ function isPresalePurchase(address purchaser) public constant returns (bool) { return false; } /* How many weis one token costs */ function updateRate(uint newOneTokenInWei) public; /** * When somebody tries to buy tokens for X eth, calculate how many tokens they get. * * * @param value - What is the value of the transaction send in as wei * @param tokensSold - how much tokens have been sold this far * @param weiRaised - how much money has been raised this far in the main token sale - this number excludes presale * @param msgSender - who is the investor of this transaction * @param decimals - how many decimal units the token has * @return Amount of tokens the investor receives */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint tokenAmount); } /** * This smart contract code is Copyright 2017 TokenMarket Ltd. For more information see https://tokenmarket.net * * Licensed under the Apache License, version 2.0: https://github.com/TokenMarketNet/ico/blob/master/LICENSE.txt */ /** * Safe unsigned safe math. * * https://blog.aragon.one/library-driven-development-in-solidity-2bebcaf88736#.750gwtwli * * Originally from https://raw.githubusercontent.com/AragonOne/zeppelin-solidity/master/contracts/SafeMathLib.sol * * Maintained here until merged to mainline zeppelin-solidity. * */ library SafeMathLibExt { function times(uint a, uint b) returns (uint) { uint c = a * b; assert(a == 0 || c / a == b); return c; } function divides(uint a, uint b) returns (uint) { assert(b > 0); uint c = a / b; assert(a == b * c + a % b); return c; } function minus(uint a, uint b) returns (uint) { assert(b <= a); return a - b; } function plus(uint a, uint b) returns (uint) { uint c = a + b; assert(c>=a); return c; } } /** * Fixed crowdsale pricing - everybody gets the same price. */ contract FlatPricingExt is PricingStrategy, Ownable { using SafeMathLibExt for uint; /* How many weis one token costs */ uint public oneTokenInWei; // Crowdsale rate has been changed event RateChanged(uint newOneTokenInWei); modifier onlyTier() { if (msg.sender != address(tier)) throw; _; } function setTier(address _tier) onlyOwner { assert(_tier != address(0)); assert(tier == address(0)); tier = _tier; } function FlatPricingExt(uint _oneTokenInWei) onlyOwner { require(_oneTokenInWei > 0); oneTokenInWei = _oneTokenInWei; } function updateRate(uint newOneTokenInWei) onlyTier { oneTokenInWei = newOneTokenInWei; RateChanged(newOneTokenInWei); } /** * Calculate the current price for buy in amount. * */ function calculatePrice(uint value, uint weiRaised, uint tokensSold, address msgSender, uint decimals) public constant returns (uint) { uint multiplier = 10 ** decimals; return value.times(multiplier) / oneTokenInWei; } } "}
{"sol name": "772.sol", "label": 0, "sol content": "pragma solidity ^0.4.23; // File: openzeppelin-solidity/contracts/ownership/Ownable.sol /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } // File: openzeppelin-solidity/contracts/math/SafeMath.sol /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20Basic.sol /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } // File: openzeppelin-solidity/contracts/token/ERC20/BasicToken.sol /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } // File: openzeppelin-solidity/contracts/token/ERC20/BurnableToken.sol /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } // File: openzeppelin-solidity/contracts/token/ERC20/ERC20.sol /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } // File: openzeppelin-solidity/contracts/token/ERC20/DetailedERC20.sol /** * @title DetailedERC20 token * @dev The decimals are only for visualization purposes. * All the operations are done using the smallest and indivisible token unit, * just as on Ethereum all the operations are done in wei. */ contract DetailedERC20 is ERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } // File: openzeppelin-solidity/contracts/token/ERC20/StandardToken.sol /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint _subtractedValue ) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } // File: contracts/grapevine/token/GrapevineToken.sol /** * @title Grapevine Token * @dev Grapevine Token **/ contract GrapevineToken is DetailedERC20, BurnableToken, StandardToken, Ownable { constructor() DetailedERC20(\"GVINE\", \"GVINE\", 18) public { totalSupply_ = 825000000 * (10 ** uint256(decimals)); // Update total supply with the decimal amount balances[msg.sender] = totalSupply_; emit Transfer(address(0), msg.sender, totalSupply_); } /** * @dev burns the provided the _value, can be used only by the owner of the contract. * @param _value The value of the tokens to be burnt. */ function burn(uint256 _value) public onlyOwner { super.burn(_value); } } "}
{"sol name": "666.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); Mint(_to, _amount); Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; MintFinished(); return true; } } /** * @title Capped token * @dev Mintable token with a token cap. */ contract CappedToken is MintableToken { uint256 public cap; function CappedToken(uint256 _cap) public { require(_cap > 0); cap = _cap; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { require(totalSupply_.add(_amount) <= cap); return super.mint(_to, _amount); } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply_ = totalSupply_.sub(_value); Burn(burner, _value); } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title Pausable token * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract Token is StandardToken , MintableToken, CappedToken { string public constant name = 'Bitcoin Empowerment Coin'; string public constant symbol = 'BEC'; uint8 public constant decimals = 18; function Token() public payable CappedToken(30000000000*10**uint(decimals)) { uint premintAmount = 5000000000*10**uint(decimals); totalSupply_ = totalSupply_.add(premintAmount); balances[msg.sender] = balances[msg.sender].add(premintAmount); Transfer(address(0), msg.sender, premintAmount); } } "}
{"sol name": "1961.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract Token{ function balanceOf(address _owner) public constant returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract HongmenToken is Token { uint256 public totalSupply; string  public name; uint8   public decimals; string  public symbol; function HongmenToken(uint256 initialAmount, string tokenName, uint8 decimalUnits, string tokenSymbol) public { totalSupply = initialAmount * 10 ** uint256(decimalUnits); balances[msg.sender] = totalSupply; name = tokenName; decimals = decimalUnits; symbol = tokenSymbol; } function transfer(address _to, uint256 _value) public returns (bool success) { //\u9ed8\u8ba4totalSupply \u4e0d\u4f1a\u8d85\u8fc7\u6700\u5927\u503c (2^256 - 1). //\u5982\u679c\u968f\u7740\u65f6\u95f4\u7684\u63a8\u79fb\u5c06\u4f1a\u6709\u65b0\u7684token\u751f\u6210\uff0c\u5219\u53ef\u4ee5\u7528\u4e0b\u9762\u8fd9\u53e5\u907f\u514d\u6ea2\u51fa\u7684\u5f02\u5e38 require(balances[msg.sender] >= _value && balances[_to] + _value > balances[_to]); require(_to != 0x0); balances[msg.sender] -= _value;\t\t\t//\u4ece\u6d88\u606f\u53d1\u9001\u8005\u8d26\u6237\u4e2d\u51cf\u53bbtoken\u6570\u91cf_value balances[_to] += _value;\t\t\t\t//\u5f80\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value Transfer(msg.sender, _to, _value);\t\t//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0); balances[_to] += _value;\t\t\t\t//\u63a5\u6536\u8d26\u6237\u589e\u52a0token\u6570\u91cf_value balances[_from] -= _value; \t\t\t\t//\u652f\u51fa\u8d26\u6237_from\u51cf\u53bbtoken\u6570\u91cf_value allowed[_from][msg.sender] -= _value;\t//\u6d88\u606f\u53d1\u9001\u8005\u53ef\u4ee5\u4ece\u8d26\u6237_from\u4e2d\u8f6c\u51fa\u7684\u6570\u91cf\u51cf\u5c11_value Transfer(_from, _to, _value);\t\t\t//\u89e6\u53d1\u8f6c\u5e01\u4ea4\u6613\u4e8b\u4ef6 return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender];\t\t//\u5141\u8bb8_spender\u4ece_owner\u4e2d\u8f6c\u51fa\u7684token\u6570\uff0c\u4e5f\u5c31\u662f\u6388\u6743 } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } "}
{"sol name": "940.sol", "label": 0, "sol content": "pragma solidity ^0.4.20; contract SafeMath { function safeMul(uint256 a, uint256 b) public pure  returns (uint256)  { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function safeDiv(uint256 a, uint256 b)public pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b)public pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b)public pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } function _assert(bool assertion)public pure { assert(!assertion); } } contract ERC20Interface { string public name; string public symbol; uint8 public  decimals; uint public totalSupply; function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract ERC20 is ERC20Interface,SafeMath { // ?????????????balanceOf???? mapping(address => uint256) public balanceOf; // allowed?????????????????address?? ????????????(?????address)?????uint256?? mapping(address => mapping(address => uint256)) allowed; constructor(string _name) public { name = _name;  // \"UpChain\"; symbol = \"ETPP\"; decimals = 4; totalSupply = 1038628770000; balanceOf[msg.sender] = totalSupply; } // ??? function transfer(address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(balanceOf[msg.sender] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]);   // ?????? balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to] ,_value); // ??????? emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) returns (bool success) { require(_to != address(0)); require(allowed[_from][msg.sender] >= _value); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] = SafeMath.safeAdd(balanceOf[_to],_value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender], _value); emit Transfer(msg.sender, _to, _value); return true; } function approve(address _spender, uint256 _value) returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract owned { address public owner; constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnerShip(address newOwer) public onlyOwner { owner = newOwer; } } contract SelfDesctructionContract is owned { string  public someValue; modifier ownerRestricted { require(owner == msg.sender); _; } // constructor function SelfDesctructionContract() { owner = msg.sender; } // a simple setter function function setSomeValue(string value){ someValue = value; } // you can call it anything you want function destroyContract() ownerRestricted { selfdestruct(owner); } } contract AdvanceToken is ERC20, owned,SelfDesctructionContract{ mapping (address => bool) public frozenAccount; event AddSupply(uint amount); event FrozenFunds(address target, bool frozen); event Burn(address target, uint amount); constructor (string _name) ERC20(_name) public { } function mine(address target, uint amount) public onlyOwner { totalSupply =SafeMath.safeAdd(totalSupply,amount) ; balanceOf[target] = SafeMath.safeAdd(balanceOf[target],amount); emit AddSupply(amount); emit Transfer(0, target, amount); } function freezeAccount(address target, bool freeze) public onlyOwner { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transfer(address _to, uint256 _value) public returns (bool success) { success = _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(allowed[_from][msg.sender] >= _value); success =  _transfer(_from, _to, _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value) ; } function _transfer(address _from, address _to, uint256 _value) internal returns (bool) { require(_to != address(0)); require(!frozenAccount[_from]); require(balanceOf[_from] >= _value); require(balanceOf[ _to] + _value >= balanceOf[ _to]); balanceOf[_from] =SafeMath.safeSub(balanceOf[_from],_value) ; balanceOf[_to] =SafeMath.safeAdd(balanceOf[_to],_value) ; emit Transfer(_from, _to, _value); return true; } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender],_value) ; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value)  public returns (bool success) { require(balanceOf[_from] >= _value); require(allowed[_from][msg.sender] >= _value); totalSupply =SafeMath.safeSub(totalSupply,_value) ; balanceOf[msg.sender] =SafeMath.safeSub(balanceOf[msg.sender], _value); allowed[_from][msg.sender] =SafeMath.safeSub(allowed[_from][msg.sender],_value); emit Burn(msg.sender, _value); return true; } } "}
{"sol name": "951.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) public balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } /** * @title CABoxToken * @dev Very simple ERC20 Token example, where all tokens are pre-assigned to the creator. * Note they can later distribute these tokens as they wish using `transfer` and other * `StandardToken` functions. */ contract CABoxToken is BurnableToken, Ownable { string public constant name = \"CABox\"; string public constant symbol = \"CAB\"; uint8 public constant decimals = 18; uint256 public constant INITIAL_SUPPLY = 500 * 1000000 * (10 ** uint256(decimals)); /** * @dev Constructor that gives msg.sender all of existing tokens. */ function CABoxToken() public { totalSupply = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "1716.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract RedBlue is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function RedBlue() public { symbol = \"RB\"; name = \"RedBlue\"; decimals = 18; _totalSupply = 78000000000000000000000000000; balances[msg.sender] = _totalSupply; Transfer(address(0), msg.sender, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "1685.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; // ---------------------------------------------------------------------------- // 'TessrnetToken' token contract // // Deployed to : 0xDE012Fee8754BA1DF8077E1B6216a945Ec4285D7 // Symbol      : TSRN // Name        : TESSRNET // Total supply: 1000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract TessrnetToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"TSRN\"; name = \"TESSRNET\"; decimals = 8; _totalSupply = 100000000000000; balances[0xDE012Fee8754BA1DF8077E1B6216a945Ec4285D7] = _totalSupply; emit Transfer(address(0), 0xDE012Fee8754BA1DF8077E1B6216a945Ec4285D7, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "959.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor(address _owner) public { owner = _owner; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract Whitelist is Ownable { mapping(address => bool) internal investorMap; /** * event for investor approval logging * @param investor approved investor */ event Approved(address indexed investor); /** * event for investor disapproval logging * @param investor disapproved investor */ event Disapproved(address indexed investor); constructor(address _owner) public Ownable(_owner) { } /** @param _investor the address of investor to be checked * @return true if investor is approved */ function isInvestorApproved(address _investor) external view returns (bool) { require(_investor != address(0)); return investorMap[_investor]; } /** @dev approve an investor * @param toApprove investor to be approved */ function approveInvestor(address toApprove) external onlyOwner { investorMap[toApprove] = true; emit Approved(toApprove); } /** @dev approve investors in bulk * @param toApprove array of investors to be approved */ function approveInvestorsInBulk(address[] toApprove) external onlyOwner { for (uint i = 0; i < toApprove.length; i++) { investorMap[toApprove[i]] = true; emit Approved(toApprove[i]); } } /** @dev disapprove an investor * @param toDisapprove investor to be disapproved */ function disapproveInvestor(address toDisapprove) external onlyOwner { delete investorMap[toDisapprove]; emit Disapproved(toDisapprove); } /** @dev disapprove investors in bulk * @param toDisapprove array of investors to be disapproved */ function disapproveInvestorsInBulk(address[] toDisapprove) external onlyOwner { for (uint i = 0; i < toDisapprove.length; i++) { delete investorMap[toDisapprove[i]]; emit Disapproved(toDisapprove[i]); } } } /** * @title Validator * @dev The Validator contract has a validator address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Validator { address public validator; event NewValidatorSet(address indexed previousOwner, address indexed newValidator); /** * @dev The Validator constructor sets the original `validator` of the contract to the sender * account. */ constructor() public { validator = msg.sender; } /** * @dev Throws if called by any account other than the validator. */ modifier onlyValidator() { require(msg.sender == validator); _; } /** * @dev Allows the current validator to transfer control of the contract to a newValidator. * @param newValidator The address to become next validator. */ function setNewValidator(address newValidator) public onlyValidator { require(newValidator != address(0)); emit NewValidatorSet(validator, newValidator); validator = newValidator; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } constructor(address _owner) public Ownable(_owner) { } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract DetailedERC20 { string public name; string public symbol; uint8 public decimals; constructor(string _name, string _symbol, uint8 _decimals) public { name = _name; symbol = _symbol; decimals = _decimals; } } /** @title Compliant Token */ contract CompliantToken is Validator, DetailedERC20, MintableToken { Whitelist public whiteListingContract; struct TransactionStruct { address from; address to; uint256 value; uint256 fee; address spender; } mapping (uint => TransactionStruct) public pendingTransactions; mapping (address => mapping (address => uint256)) public pendingApprovalAmount; uint256 public currentNonce = 0; uint256 public transferFee; address public feeRecipient; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } modifier checkIsValueValid(uint256 _value) { require(_value > 0); _; } /** * event for rejected transfer logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ event TransferRejected( address indexed from, address indexed to, uint256 value, uint256 indexed nonce, uint256 reason ); /** * event for transfer tokens logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens */ event TransferWithFee( address indexed from, address indexed to, uint256 value, uint256 fee ); /** * event for transfer/transferFrom request logging * @param from address from which tokens have to be transferred * @param to address to tokens have to be transferred * @param value number of tokens * @param fee fee in tokens * @param spender The address which will spend the tokens */ event RecordedPendingTransaction( address indexed from, address indexed to, uint256 value, uint256 fee, address indexed spender ); /** * event for whitelist contract update logging * @param _whiteListingContract address of the new whitelist contract */ event WhiteListingContractSet(address indexed _whiteListingContract); /** * event for fee update logging * @param previousFee previous fee * @param newFee new fee */ event FeeSet(uint256 indexed previousFee, uint256 indexed newFee); /** * event for fee recipient update logging * @param previousRecipient address of the old fee recipient * @param newRecipient address of the new fee recipient */ event FeeRecipientSet(address indexed previousRecipient, address indexed newRecipient); /** @dev Constructor * @param _owner Token contract owner * @param _name Token name * @param _symbol Token symbol * @param _decimals number of decimals in the token(usually 18) * @param whitelistAddress Ethereum address of the whitelist contract * @param recipient Ethereum address of the fee recipient * @param fee token fee for approving a transfer */ constructor( address _owner, string _name, string _symbol, uint8 _decimals, address whitelistAddress, address recipient, uint256 fee ) public MintableToken(_owner) DetailedERC20(_name, _symbol, _decimals) Validator() { setWhitelistContract(whitelistAddress); setFeeRecipient(recipient); setFee(fee); } /** @dev Updates whitelist contract address * @param whitelistAddress New whitelist contract address */ function setWhitelistContract(address whitelistAddress) public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } /** @dev Updates token fee for approving a transfer * @param fee New token fee */ function setFee(uint256 fee) public onlyValidator { emit FeeSet(transferFee, fee); transferFee = fee; } /** @dev Updates fee recipient address * @param recipient New whitelist contract address */ function setFeeRecipient(address recipient) public onlyValidator checkIsAddressValid(recipient) { emit FeeRecipientSet(feeRecipient, recipient); feeRecipient = recipient; } /** @dev Updates token name * @param _name New token name */ function updateName(string _name) public onlyOwner { require(bytes(_name).length != 0); name = _name; } /** @dev Updates token symbol * @param _symbol New token name */ function updateSymbol(string _symbol) public onlyOwner { require(bytes(_symbol).length != 0); symbol = _symbol; } /** @dev transfer request * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transfer(address _to, uint256 _value) public checkIsInvestorApproved(msg.sender) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 pendingAmount = pendingApprovalAmount[msg.sender][address(0)]; if (msg.sender == feeRecipient) { require(_value.add(pendingAmount) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[msg.sender]); pendingApprovalAmount[msg.sender][address(0)] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( msg.sender, _to, _value, transferFee, address(0) ); emit RecordedPendingTransaction(msg.sender, _to, _value, transferFee, address(0)); currentNonce++; return true; } /** @dev transferFrom request * @param _from address from which the tokens have to be transferred * @param _to address to which the tokens have to be transferred * @param _value amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public checkIsInvestorApproved(_from) checkIsInvestorApproved(_to) checkIsValueValid(_value) returns (bool) { uint256 allowedTransferAmount = allowed[_from][msg.sender]; uint256 pendingAmount = pendingApprovalAmount[_from][msg.sender]; if (_from == feeRecipient) { require(_value.add(pendingAmount) <= balances[_from]); require(_value.add(pendingAmount) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value); } else { require(_value.add(pendingAmount).add(transferFee) <= balances[_from]); require(_value.add(pendingAmount).add(transferFee) <= allowedTransferAmount); pendingApprovalAmount[_from][msg.sender] = pendingAmount.add(_value).add(transferFee); } pendingTransactions[currentNonce] = TransactionStruct( _from, _to, _value, transferFee, msg.sender ); emit RecordedPendingTransaction(_from, _to, _value, transferFee, msg.sender); currentNonce++; return true; } /** @dev approve transfer/transferFrom request * @param nonce request recorded at this particular nonce */ function approveTransfer(uint256 nonce) external onlyValidator checkIsInvestorApproved(pendingTransactions[nonce].from) checkIsInvestorApproved(pendingTransactions[nonce].to) checkIsValueValid(pendingTransactions[nonce].value) returns (bool) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; address to = pendingTransactions[nonce].to; uint256 value = pendingTransactions[nonce].value; uint256 allowedTransferAmount = allowed[from][spender]; uint256 pendingAmount = pendingApprovalAmount[from][spender]; uint256 fee = pendingTransactions[nonce].fee; uint256 balanceFrom = balances[from]; uint256 balanceTo = balances[to]; delete pendingTransactions[nonce]; if (from == feeRecipient) { fee = 0; balanceFrom = balanceFrom.sub(value); balanceTo = balanceTo.add(value); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value); } pendingAmount = pendingAmount.sub(value); } else { balanceFrom = balanceFrom.sub(value.add(fee)); balanceTo = balanceTo.add(value); balances[feeRecipient] = balances[feeRecipient].add(fee); if (spender != address(0)) { allowedTransferAmount = allowedTransferAmount.sub(value).sub(fee); } pendingAmount = pendingAmount.sub(value).sub(fee); } emit TransferWithFee( from, to, value, fee ); emit Transfer( from, to, value ); balances[from] = balanceFrom; balances[to] = balanceTo; allowed[from][spender] = allowedTransferAmount; pendingApprovalAmount[from][spender] = pendingAmount; return true; } /** @dev reject transfer/transferFrom request * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ function rejectTransfer(uint256 nonce, uint256 reason) external onlyValidator checkIsAddressValid(pendingTransactions[nonce].from) { address from = pendingTransactions[nonce].from; address spender = pendingTransactions[nonce].spender; if (from == feeRecipient) { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value); } else { pendingApprovalAmount[from][spender] = pendingApprovalAmount[from][spender] .sub(pendingTransactions[nonce].value).sub(pendingTransactions[nonce].fee); } emit TransferRejected( from, pendingTransactions[nonce].to, pendingTransactions[nonce].value, nonce, reason ); delete pendingTransactions[nonce]; } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale. * Crowdsales have a start and end timestamps, where investors can make * token purchases and the crowdsale will assign them tokens based * on a token per ETH rate. Funds collected are forwarded to a wallet * as they arrive. The contract requires a MintableToken that will be * minted as contributions arrive, note that the crowdsale contract * must be owner of the token in order to be able to mint it. */ contract Crowdsale { using SafeMath for uint256; // The token being sold MintableToken public token; // start and end timestamps where investments are allowed (both inclusive) uint256 public startTime; uint256 public endTime; // address where funds are collected address public wallet; // how many token units a buyer gets per wei uint256 public rate; // amount of raised money in wei uint256 public weiRaised; // amount of tokens sold uint256 public totalSupply; // maximum amount of tokens that can be sold uint256 public tokenCap; /** * event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase(address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount); constructor(uint256 _startTime, uint256 _endTime, uint256 _tokenCap, uint256 _rate, address _wallet, MintableToken _token) public { require(_startTime >= now); require(_endTime >= _startTime); require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); startTime = _startTime; endTime = _endTime; tokenCap = _tokenCap; rate = _rate; wallet = _wallet; token = _token; } // fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender); } // low level token purchase function function buyTokens(address beneficiary) public payable { require(beneficiary != address(0)); require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); totalSupply = totalSupply.add(tokens); token.mint(beneficiary, tokens); emit TokenPurchase(msg.sender, beneficiary, weiAmount, tokens); forwardFunds(); } // @return true if crowdsale event has ended function hasEnded() public view returns (bool) { return now > endTime; } // Override this method to have a way to add business logic to your crowdsale when buying function getTokenAmount(uint256 weiAmount) internal view returns(uint256) { return weiAmount.mul(rate); } // send ether to the fund collection wallet // override to create custom fund forwarding mechanisms function forwardFunds() internal { wallet.transfer(msg.value); } // @return true if the transaction can buy tokens function validPurchase() internal view returns (bool) { uint256 tokens = msg.value.mul(rate); require(totalSupply.add(tokens) <= tokenCap); bool withinPeriod = now >= startTime && now <= endTime; bool nonZeroPurchase = msg.value != 0; return withinPeriod && nonZeroPurchase; } } /** * @title FinalizableCrowdsale * @dev Extension of Crowdsale where an owner can do extra work * after finishing. */ contract FinalizableCrowdsale is Crowdsale, Ownable { using SafeMath for uint256; bool public isFinalized = false; event Finalized(); constructor(address _owner) public Ownable(_owner) {} /** * @dev Must be called after crowdsale ends, to do some extra finalization * work. Calls the contract's finalization function. */ function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); emit Finalized(); isFinalized = true; } /** * @dev Can be overridden to add finalization logic. The overriding function * should call super.finalization() to ensure the chain of finalization is * executed entirely. */ function finalization() internal {} } /** @title Compliant Crowdsale */ contract CompliantCrowdsale is Validator, FinalizableCrowdsale { Whitelist public whiteListingContract; struct MintStruct { address to; uint256 tokens; uint256 weiAmount; } mapping (uint => MintStruct) public pendingMints; uint256 public currentMintNonce; mapping (address => uint) public rejectedMintBalance; modifier checkIsInvestorApproved(address _account) { require(whiteListingContract.isInvestorApproved(_account)); _; } modifier checkIsAddressValid(address _account) { require(_account != address(0)); _; } /** * event for rejected mint logging * @param to address for which buy tokens got rejected * @param value number of tokens * @param amount number of ethers invested * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ event MintRejected( address indexed to, uint256 value, uint256 amount, uint256 indexed nonce, uint256 reason ); /** * event for buy tokens request logging * @param beneficiary address for which buy tokens is requested * @param tokens number of tokens * @param weiAmount number of ethers invested * @param nonce request recorded at this particular nonce */ event ContributionRegistered( address beneficiary, uint256 tokens, uint256 weiAmount, uint256 nonce ); /** * event for whitelist contract update logging * @param _whiteListingContract address of the new whitelist contract */ event WhiteListingContractSet(address indexed _whiteListingContract); /** * event for claimed ether logging * @param account user claiming the ether * @param amount ether claimed */ event Claimed(address indexed account, uint256 amount); /** @dev Constructor * @param whitelistAddress Ethereum address of the whitelist contract * @param _startTime crowdsale start time * @param _endTime crowdsale end time * @param _tokenCap maximum number of tokens to be sold in the crowdsale * @param _rate number of tokens to be sold per ether * @param _wallet Ethereum address of the wallet * @param _token Ethereum address of the token contract * @param _owner Ethereum address of the owner */ constructor( address whitelistAddress, uint256 _startTime, uint256 _endTime, uint256 _tokenCap, uint256 _rate, address _wallet, MintableToken _token, address _owner ) public FinalizableCrowdsale(_owner) Crowdsale(_startTime, _endTime, _tokenCap, _rate, _wallet, _token) { setWhitelistContract(whitelistAddress); } /** @dev Updates whitelist contract address * @param whitelistAddress address of the new whitelist contract */ function setWhitelistContract(address whitelistAddress) public onlyValidator checkIsAddressValid(whitelistAddress) { whiteListingContract = Whitelist(whitelistAddress); emit WhiteListingContractSet(whiteListingContract); } /** @dev buy tokens request * @param beneficiary the address to which the tokens have to be minted */ function buyTokens(address beneficiary) public payable checkIsInvestorApproved(beneficiary) { require(validPurchase()); uint256 weiAmount = msg.value; // calculate token amount to be created uint256 tokens = weiAmount.mul(rate); pendingMints[currentMintNonce] = MintStruct(beneficiary, tokens, weiAmount); emit ContributionRegistered(beneficiary, tokens, weiAmount, currentMintNonce); currentMintNonce++; } /** @dev approve buy tokens request * @param nonce request recorded at this particular nonce */ function approveMint(uint256 nonce) external onlyValidator checkIsInvestorApproved(pendingMints[nonce].to) returns (bool) { // update state weiRaised = weiRaised.add(pendingMints[nonce].weiAmount); totalSupply = totalSupply.add(pendingMints[nonce].tokens); //No need to use mint-approval on token side, since the minting is already approved in the crowdsale side token.mint(pendingMints[nonce].to, pendingMints[nonce].tokens); emit TokenPurchase( msg.sender, pendingMints[nonce].to, pendingMints[nonce].weiAmount, pendingMints[nonce].tokens ); forwardFunds(pendingMints[nonce].weiAmount); delete pendingMints[nonce]; return true; } /** @dev reject buy tokens request * @param nonce request recorded at this particular nonce * @param reason reason for rejection */ function rejectMint(uint256 nonce, uint256 reason) external onlyValidator checkIsAddressValid(pendingMints[nonce].to) { rejectedMintBalance[pendingMints[nonce].to] = rejectedMintBalance[pendingMints[nonce].to].add(pendingMints[nonce].weiAmount); emit MintRejected( pendingMints[nonce].to, pendingMints[nonce].tokens, pendingMints[nonce].weiAmount, nonce, reason ); delete pendingMints[nonce]; } /** @dev claim back ether if buy tokens request is rejected */ function claim() external { require(rejectedMintBalance[msg.sender] > 0); uint256 value = rejectedMintBalance[msg.sender]; rejectedMintBalance[msg.sender] = 0; msg.sender.transfer(value); emit Claimed(msg.sender, value); } function finalization() internal { token.finishMinting(); transferTokenOwnership(owner); super.finalization(); } /** @dev Updates token contract address * @param newToken New token contract address */ function setTokenContract(address newToken) external onlyOwner checkIsAddressValid(newToken) { token = CompliantToken(newToken); } /** @dev transfers ownership of the token contract * @param newOwner New owner of the token contract */ function transferTokenOwnership(address newOwner) public onlyOwner checkIsAddressValid(newOwner) { token.transferOwnership(newOwner); } function forwardFunds(uint256 amount) internal { wallet.transfer(amount); } } "}
{"sol name": "1865.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ constructor( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "836.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** * @title ERC721 token receiver interface * @dev Interface for any contract that wants to support safeTransfers * from ERC721 asset contracts. */ interface ERC721Receiver { /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ ///bytes4 internal constant ERC721_RECEIVED = 0x150b7a02; /** * @notice Handle the receipt of an NFT * @dev The ERC721 smart contract calls this function on the recipient * after a `safetransfer`. This function MAY throw to revert and reject the * transfer. Return of other than the magic value MUST result in the * transaction being reverted. * Note: the contract address is always the message sender. * @param _operator The address which called `safeTransferFrom` function * @param _from The address which previously owned the token * @param _tokenId The NFT identifier which is being transfered * @param _data Additional data with no specified format * @return `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))` */ function onERC721Received( address _operator, address _from, uint _tokenId, bytes _data ) public returns(bytes4); } /** * @title ERC165 * @dev https://github.com/ethereum/EIPs/blob/master/EIPS/eip-165.md */ interface ERC165 { /** * @notice Query if a contract implements an interface * @param _interfaceId The interface identifier, as specified in ERC-165 * @dev Interface identification is specified in ERC-165. This function * uses less than 30,000 gas. */ function supportsInterface(bytes4 _interfaceId) external view returns (bool); } /** * @title SupportsInterfaceWithLookup * @author Matt Condon (@shrugs) * @dev Implements ERC165 using a lookup table. */ contract SupportsInterfaceWithLookup is ERC165 { bytes4 public constant InterfaceId_ERC165 = 0x01ffc9a7; /** * 0x01ffc9a7 === *   bytes4(keccak256('supportsInterface(bytes4)')) */ /** * @dev a mapping of interface id to whether or not it's supported */ mapping(bytes4 => bool) internal supportedInterfaces; /** * @dev A contract implementing SupportsInterfaceWithLookup * implement ERC165 itself */ constructor() public { _registerInterface(InterfaceId_ERC165); } /** * @dev implement supportsInterface(bytes4) using a lookup table */ function supportsInterface(bytes4 _interfaceId) external view returns (bool) { return supportedInterfaces[_interfaceId]; } /** * @dev private method for registering an interface */ function _registerInterface(bytes4 _interfaceId) internal { require(_interfaceId != 0xffffffff); supportedInterfaces[_interfaceId] = true; } } contract MyCryptoChampCore{ struct Champ { uint id; uint attackPower; uint defencePower; uint cooldownTime; uint readyTime; uint winCount; uint lossCount; uint position; uint price; uint withdrawCooldown; uint eq_sword; uint eq_shield; uint eq_helmet; bool forSale; } struct AddressInfo { uint withdrawal; uint champsCount; uint itemsCount; string name; } struct Item { uint id; uint8 itemType; uint8 itemRarity; uint attackPower; uint defencePower; uint cooldownReduction; uint price; uint onChampId; bool onChamp; bool forSale; } Champ[] public champs; Item[] public items; mapping (uint => uint) public leaderboard; mapping (address => AddressInfo) public addressInfo; mapping (bool => mapping(address => mapping (address => bool))) public tokenOperatorApprovals; mapping (bool => mapping(uint => address)) public tokenApprovals; mapping (bool => mapping(uint => address)) public tokenToOwner; mapping (uint => string) public champToName; mapping (bool => uint) public tokensForSaleCount; uint public pendingWithdrawal = 0; function addWithdrawal(address _address, uint _amount) public; function clearTokenApproval(address _from, uint _tokenId, bool _isTokenChamp) public; function setChampsName(uint _champId, string _name) public; function setLeaderboard(uint _x, uint _value) public; function setTokenApproval(uint _id, address _to, bool _isTokenChamp) public; function setTokenOperatorApprovals(address _from, address _to, bool _approved, bool _isTokenChamp) public; function setTokenToOwner(uint _id, address _owner, bool _isTokenChamp) public; function setTokensForSaleCount(uint _value, bool _isTokenChamp) public; function transferToken(address _from, address _to, uint _id, bool _isTokenChamp) public; function newChamp(uint _attackPower,uint _defencePower,uint _cooldownTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale,address _owner) public returns (uint); function newItem(uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale,address _owner) public returns (uint); function updateAddressInfo(address _address, uint _withdrawal, bool _updatePendingWithdrawal, uint _champsCount, bool _updateChampsCount, uint _itemsCount, bool _updateItemsCount, string _name, bool _updateName) public; function updateChamp(uint _champId, uint _attackPower,uint _defencePower,uint _cooldownTime,uint _readyTime,uint _winCount,uint _lossCount,uint _position,uint _price,uint _withdrawCooldown,uint _eq_sword, uint _eq_shield, uint _eq_helmet, bool _forSale) public; function updateItem(uint _id,uint8 _itemType,uint8 _itemRarity,uint _attackPower,uint _defencePower,uint _cooldownReduction,uint _price,uint _onChampId,bool _onChamp,bool _forSale) public; function getChampStats(uint256 _champId) public view returns(uint256,uint256,uint256); function getChampsByOwner(address _owner) external view returns(uint256[]); function getTokensForSale(bool _isTokenChamp) view external returns(uint256[]); function getItemsByOwner(address _owner) external view returns(uint256[]); function getTokenCount(bool _isTokenChamp) external view returns(uint); function getTokenURIs(uint _tokenId, bool _isTokenChamp) public view returns(string); function onlyApprovedOrOwnerOfToken(uint _id, address _msgsender, bool _isTokenChamp) external view returns(bool); } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address internal contractOwner; constructor () internal { if(contractOwner == address(0)){ contractOwner = msg.sender; } } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == contractOwner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); contractOwner = newOwner; } } /** * Utility library of inline functions on addresses */ library AddressUtils { /** * Returns whether the target address is a contract * @dev This function will return false if invoked during the constructor of a contract, * as the code is not actually created until after the constructor finishes. * @param addr address to check * @return whether the target address is a contract */ function isContract(address addr) internal view returns (bool) { uint256 size; // XXX Currently there is no better way to check if there is a contract in an address // than to check the size of the code at that address. // See https://ethereum.stackexchange.com/a/14016/36603 // for more details about how this works. // TODO Check this again before the Serenity release, because all addresses will be // contracts then. // solium-disable-next-line security/no-inline-assembly assembly { size := extcodesize(addr) } return size > 0; } } contract ERC721 is Ownable, SupportsInterfaceWithLookup { using AddressUtils for address; string private _ERC721name = \"Champ\"; string private _ERC721symbol = \"MXC\"; bool private tokenIsChamp = true; address private controllerAddress; MyCryptoChampCore core; function setCore(address newCoreAddress) public onlyOwner { core = MyCryptoChampCore(newCoreAddress); } function setController(address _address) external onlyOwner { controllerAddress = _address; } function emitTransfer(address _from, address _to, uint _tokenId) external { require(msg.sender == controllerAddress); emit Transfer(_from, _to, _tokenId); } //ERC721 START event Transfer(address indexed _from, address indexed _to, uint indexed _tokenId); event Approval(address indexed _owner, address indexed _approved, uint indexed _tokenId); event ApprovalForAll(address indexed _owner, address indexed _operator, bool _approved); bytes4 private constant InterfaceId_ERC721 = 0x80ac58cd; /** * 0x80ac58cd === *   bytes4(keccak256('balanceOf(address)')) ^ *   bytes4(keccak256('ownerOf(uint256)')) ^ *   bytes4(keccak256('approve(address,uint256)')) ^ *   bytes4(keccak256('getApproved(uint256)')) ^ *   bytes4(keccak256('setApprovalForAll(address,bool)')) ^ *   bytes4(keccak256('isApprovedForAll(address,address)')) ^ *   bytes4(keccak256('transferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256)')) ^ *   bytes4(keccak256('safeTransferFrom(address,address,uint256,bytes)')) */ bytes4 private constant InterfaceId_ERC721Exists = 0x4f558e79; /** * 0x4f558e79 === *   bytes4(keccak256('exists(uint256)')) */ /** * @dev Magic value to be returned upon successful reception of an NFT *  Equals to `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`, *  which can be also obtained as `ERC721Receiver(0).onERC721Received.selector` */ bytes4 private constant ERC721_RECEIVED = 0x150b7a02; bytes4 constant InterfaceId_ERC721Enumerable = 0x780e9d63; /** bytes4(keccak256('totalSupply()')) ^ bytes4(keccak256('tokenOfOwnerByIndex(address,uint256)')) ^ bytes4(keccak256('tokenByIndex(uint256)')); */ bytes4 private constant InterfaceId_ERC721Metadata = 0x5b5e139f; /** * 0x5b5e139f === *   bytes4(keccak256('name()')) ^ *   bytes4(keccak256('symbol()')) ^ *   bytes4(keccak256('tokenURI(uint256)')) */ constructor() public { // register the supported interfaces to conform to ERC721 via ERC165 _registerInterface(InterfaceId_ERC721); _registerInterface(InterfaceId_ERC721Exists); _registerInterface(InterfaceId_ERC721Enumerable); _registerInterface(InterfaceId_ERC721Metadata); } /** * @dev Guarantees msg.sender is owner of the given token * @param _tokenId uint ID of the token to validate its ownership belongs to msg.sender */ modifier onlyOwnerOf(uint _tokenId) { require(ownerOf(_tokenId) == msg.sender); _; } /** * @dev Checks msg.sender can transfer a token, by being owner, approved, or operator * @param _tokenId uint ID of the token to validate */ modifier canTransfer(uint _tokenId) { require(isApprovedOrOwner(msg.sender, _tokenId)); _; } /** * @dev Gets the balance of the specified address * @param _owner address to query the balance of * @return uint representing the amount owned by the passed address */ function balanceOf(address _owner) public view returns (uint) { require(_owner != address(0)); uint balance; if(tokenIsChamp){ (,balance,,) = core.addressInfo(_owner); }else{ (,,balance,) = core.addressInfo(_owner); } return balance; } /** * @dev Gets the owner of the specified token ID * @param _tokenId uint ID of the token to query the owner of * @return owner address currently marked as the owner of the given token ID */ function ownerOf(uint _tokenId) public view returns (address) { address owner = core.tokenToOwner(tokenIsChamp,_tokenId); require(owner != address(0)); return owner; } /** * @dev Returns whether the specified token exists * @param _tokenId uint ID of the token to query the existence of * @return whether the token exists */ function exists(uint _tokenId) public view returns (bool) { address owner = core.tokenToOwner(tokenIsChamp,_tokenId); return owner != address(0); } /** * @dev Approves another address to transfer the given token ID * The zero address indicates there is no approved address. * There can only be one approved address per token at a given time. * Can only be called by the token owner or an approved operator. * @param _to address to be approved for the given token ID * @param _tokenId uint ID of the token to be approved */ function approve(address _to, uint _tokenId) public { address owner = ownerOf(_tokenId); require(_to != owner); require(msg.sender == owner || isApprovedForAll(owner, msg.sender)); core.setTokenApproval(_tokenId, _to,tokenIsChamp); emit Approval(owner, _to, _tokenId); } /** * @dev Gets the approved address for a token ID, or zero if no address set * @param _tokenId uint ID of the token to query the approval of * @return address currently approved for the given token ID */ function getApproved(uint _tokenId) public view returns (address) { return core.tokenApprovals(tokenIsChamp,_tokenId); } /** * @dev Sets or unsets the approval of a given operator * An operator is allowed to transfer all tokens of the sender on their behalf * @param _to operator address to set the approval * @param _approved representing the status of the approval to be set */ function setApprovalForAll(address _to, bool _approved) public { require(_to != msg.sender); core.setTokenOperatorApprovals(msg.sender,_to,_approved,tokenIsChamp); emit ApprovalForAll(msg.sender, _to, _approved); } /** * @dev Tells whether an operator is approved by a given owner * @param _owner owner address which you want to query the approval of * @param _operator operator address which you want to query the approval of * @return bool whether the given operator is approved by the given owner */ function isApprovedForAll( address _owner, address _operator ) public view returns (bool) { return core.tokenOperatorApprovals(tokenIsChamp, _owner,_operator); } /** * @dev Returns whether the given spender can transfer a given token ID * @param _spender address of the spender to query * @param _tokenId uint ID of the token to be transferred * @return bool whether the msg.sender is approved for the given token ID, *  is an operator of the owner, or is the owner of the token */ function isApprovedOrOwner( address _spender, uint _tokenId ) internal view returns (bool) { address owner = ownerOf(_tokenId); // Disable solium check because of // https://github.com/duaraghav8/Solium/issues/175 // solium-disable-next-line operator-whitespace return ( _spender == owner || getApproved(_tokenId) == _spender || isApprovedForAll(owner, _spender) ); } /** * @dev Transfers the ownership of a given token ID to another address * Usage of this method is discouraged, use `safeTransferFrom` whenever possible * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint ID of the token to be transferred */ function transferFrom( address _from, address _to, uint _tokenId ) public canTransfer(_tokenId) { require(_from != address(0)); require(_to != address(0)); core.clearTokenApproval(_from, _tokenId, tokenIsChamp); core.transferToken(_from, _to, _tokenId, tokenIsChamp); emit Transfer(_from, _to, _tokenId); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`; otherwise, * the transfer is reverted. * * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint ID of the token to be transferred */ function safeTransferFrom( address _from, address _to, uint _tokenId ) public canTransfer(_tokenId) { // solium-disable-next-line arg-overflow safeTransferFrom(_from, _to, _tokenId, \"\"); } /** * @dev Safely transfers the ownership of a given token ID to another address * If the target address is a contract, it must implement `onERC721Received`, * which is called upon a safe transfer, and return the magic value * `bytes4(keccak256(\"onERC721Received(address,address,uint,bytes)\"))`; otherwise, * the transfer is reverted. * Requires the msg sender to be the owner, approved, or operator * @param _from current owner of the token * @param _to address to receive the ownership of the given token ID * @param _tokenId uint ID of the token to be transferred * @param _data bytes data to send along with a safe transfer check */ function safeTransferFrom( address _from, address _to, uint _tokenId, bytes _data ) public canTransfer(_tokenId) { transferFrom(_from, _to, _tokenId); // solium-disable-next-line arg-overflow require(checkAndCallSafeTransfer(_from, _to, _tokenId, _data)); } /** * @dev Internal function to invoke `onERC721Received` on a target address * The call is not executed if the target address is not a contract * @param _from address representing the previous owner of the given token ID * @param _to target address that will receive the tokens * @param _tokenId uint ID of the token to be transferred * @param _data bytes optional data to send along with the call * @return whether the call correctly returned the expected magic value */ function checkAndCallSafeTransfer( address _from, address _to, uint _tokenId, bytes _data ) internal returns (bool) { if (!_to.isContract()) { return true; } bytes4 retval = ERC721Receiver(_to).onERC721Received( msg.sender, _from, _tokenId, _data); return (retval == ERC721_RECEIVED); } /// /// ERC721Enumerable /// /// @notice Count NFTs tracked by this contract /// @return A count of valid NFTs tracked by this contract, where each one of ///  them has an assigned and queryable owner not equal to the zero address function totalSupply() external view returns (uint){ return core.getTokenCount(tokenIsChamp); } /// @notice Enumerate valid NFTs /// @dev Throws if `_index` >= `totalSupply()`. /// @param _index A counter less than `totalSupply()` /// @return The token identifier for the `_index`th NFT, ///  (sort order not specified) function tokenByIndex(uint _index) external view returns (uint){ uint tokenIndexesLength = this.totalSupply(); require(_index < tokenIndexesLength); return _index; } /// @notice Enumerate NFTs assigned to an owner /// @dev Throws if `_index` >= `balanceOf(_owner)` or if ///  `_owner` is the zero address, representing invalid NFTs. /// @param _owner An address where we are interested in NFTs owned by them /// @param _index A counter less than `balanceOf(_owner)` /// @return The token identifier for the `_index`th NFT assigned to `_owner`, ///   (sort order not specified) function tokenOfOwnerByIndex(address _owner, uint _index) external view returns (uint){ require(_index >= balanceOf(_owner)); require(_owner!=address(0)); uint[] memory tokens; uint tokenId; if(tokenIsChamp){ tokens = core.getChampsByOwner(_owner); }else{ tokens = core.getItemsByOwner(_owner); } for(uint i = 0; i < tokens.length; i++){ if(i + 1 == _index){ tokenId = tokens[i]; break; } } return tokenId; } /// /// ERC721Metadata /// /// @notice A descriptive name for a collection of NFTs in this contract function name() external view returns (string _name){ return _ERC721name; } /// @notice An abbreviated name for NFTs in this contract function symbol() external view returns (string _symbol){ return _ERC721symbol; } /// @notice A distinct Uniform Resource Identifier (URI) for a given asset. /// @dev Throws if `_tokenId` is not a valid NFT. URIs are defined in RFC ///  3986. The URI may point to a JSON file that conforms to the \"ERC721 ///  Metadata JSON Schema\". function tokenURI(uint _tokenId) external view returns (string){ require(exists(_tokenId)); return core.getTokenURIs(_tokenId,tokenIsChamp); } } "}
{"sol name": "1989.sol", "label": 0, "sol content": "pragma solidity ^ 0.4.18; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract GCCERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 8; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function GCCERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "934.sol", "label": 0, "sol content": "pragma solidity 0.4.24; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } // Abstract contract for the full ERC 20 Token standard // https://github.com/ethereum/EIPs/issues/20 contract ERC20 { uint256 public _totalSupply; string public name; string public symbol; uint8 public decimals; function totalSupply() public constant returns (uint256 supply); function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } //Implements ERC 20 Token standard: https://github.com/ethereum/EIPs/issues/20 contract ERC20Token is ERC20 { using SafeMath for uint256; function totalSupply() public constant returns (uint) { return _totalSupply.sub(balances[address(0)]); } function balanceOf(address _owner) view public returns (uint256 balance) { return balances[_owner]; } function transfer(address _to, uint256 _value) public returns (bool success) { //require(balances[msg.sender] >= _value); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) view public returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } /** * @title ERC677 transferAndCall token interface * @dev See https://github.com/ethereum/EIPs/issues/677 for specification and *      discussion. */ contract ERC677 { event Transfer(address indexed _from, address indexed _to, uint256 _amount, bytes _data); function transferAndCall(address _receiver, uint _amount, bytes _data) public; } /** * @title Receiver interface for ERC677 transferAndCall * @dev See https://github.com/ethereum/EIPs/issues/677 for specification and *      discussion. */ contract ERC677Receiver { function tokenFallback(address _from, uint _amount, bytes _data) public; } contract ERC677Token is ERC677, ERC20Token { function transferAndCall(address _receiver, uint _amount, bytes _data) public { require(super.transfer(_receiver, _amount)); emit Transfer(msg.sender, _receiver, _amount, _data); // call receiver if (isContract(_receiver)) { ERC677Receiver to = ERC677Receiver(_receiver); to.tokenFallback(msg.sender, _amount, _data); } } function isContract(address _addr) internal view returns (bool) { uint len; assembly { len := extcodesize(_addr) } return len > 0; } } contract Splitable is ERC677Token, Ownable { uint32 public split; mapping (address => uint32) public splits; event Split(address indexed addr, uint32 multiplyer); constructor() public { split = 0; } function splitShare() onlyOwner public { require(split * 2 >= split); if (split == 0) split = 2; else split *= 2; claimShare(); } function isSplitable() public view returns (bool) { return splits[msg.sender] != split; } function claimShare() public { uint32 s = splits[msg.sender]; if (s == split) return; if (s == 0) s = 1; splits[msg.sender] = split; uint b = balances[msg.sender]; uint nb = b * split / s; balances[msg.sender] = nb; _totalSupply += nb - b; } function claimShare(address _u1, address _u2) public { uint32 s = splits[_u1]; if (s != split) { if (s == 0) s = 1; splits[_u1] = split; uint b = balances[_u1]; uint nb = b.mul(split / s); balances[_u1] = nb; _totalSupply += nb - b; } s = splits[_u2]; if (s != split) { if (s == 0) s = 1; splits[_u2] = split; b = balances[_u2]; nb = b.mul(split / s); balances[_u2] = nb; _totalSupply += nb - b; } } function transfer(address _to, uint256 _value) public returns (bool success) { if (splits[msg.sender] != splits[_to]) claimShare(msg.sender, _to); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { if (splits[_from] != splits[_to]) claimShare(msg.sender, _to); return super.transferFrom(_from, _to, _value); } function transferAndCall(address _receiver, uint _amount, bytes _data) public { if (splits[_receiver] != splits[_receiver]) claimShare(msg.sender, _receiver); return super.transferAndCall(_receiver, _amount, _data); } } contract Lockable is ERC20Token, Ownable { using SafeMath for uint256; mapping (address => uint256) public lockAmounts; // function lock(address to, uint amount) public onlyOwner { //     lockAmounts[to] = lockAmounts[to].add(amount); // } function unlock(address to, uint amount) public onlyOwner { lockAmounts[to] = lockAmounts[to].sub(amount); } function issueCoin(address to, uint amount) public onlyOwner { lockAmounts[to] = lockAmounts[to].add(amount); transfer(to, amount); //  balances[to] = balances[to].add(amount); //  balances[owner] = balances[owner].sub(amount); //  emit Transfer(owner, to, amount); } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value + lockAmounts[msg.sender]); return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(balances[_from] >= _value + lockAmounts[_from]); return super.transferFrom(_from, _to, _value); } } contract VCoin is ERC677Token, Ownable, Splitable, Lockable { uint32 public purchaseNo; event Purchase(uint32 indexed purchaseNo, address from, uint value, bytes data); constructor() public { symbol = \"VICT\"; name = \"Victory Token\"; decimals = 18; _totalSupply = 1000000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); purchaseNo = 1; } function () public payable { require(!isContract(msg.sender)); owner.transfer(msg.value); emit Purchase(purchaseNo++, msg.sender, msg.value, msg.data); //emit Transfer(owner, msg.sender, msg.value); } } "}
{"sol name": "575.sol", "label": 0, "sol content": "pragma solidity 0.4.21; contract Ownable { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Ownable() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev modifier to allow actions only when the contract IS paused */ modifier whenNotPaused() { require(!paused); _; } /** * @dev modifier to allow actions only when the contract IS NOT paused */ modifier whenPaused { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public returns (bool) { paused = true; emit Pause(); return true; } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public returns (bool) { paused = false; emit Unpause(); return true; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and an // initial fixed supply // ---------------------------------------------------------------------------- contract ROB is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ROB() public { symbol = \"ROB\"; name = \"NeoWorld Rare Ore B\"; decimals = 18; _totalSupply = 10000000 * 10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account `tokenOwner` // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to `to` account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { balances[msg.sender] = balances[msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } function increaseApproval (address _spender, uint _addedValue) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public whenNotPaused returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } // ------------------------------------------------------------------------ // Transfer `tokens` from the `from` account to the `to` account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the `from` account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { balances[from] = balances[from].sub(tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); balances[to] = balances[to].add(tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for `spender` to transferFrom(...) `tokens` // from the token owner's account. The `spender` contract function // `receiveApproval(...)` is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public whenNotPaused returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "735.sol", "label": 0, "sol content": "pragma solidity ^0.4.12; library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); uint256 _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } function increaseApproval (address _spender, uint _addedValue) returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract BurnableToken is StandardToken { event Burn(address indexed burner, uint256 value); function burn(uint256 _value) public { require(_value > 0); require(_value <= balances[msg.sender]); address burner = msg.sender; balances[burner] = balances[burner].sub(_value); totalSupply = totalSupply.sub(_value); Burn(burner, _value); } } contract Cygnus is BurnableToken, Ownable { string public constant name = \"Cygnus\"; string public constant symbol = \"Cyg\"; uint public constant decimals = 18; uint256 public constant initialSupply = 16000000000 * (10 ** uint256(decimals)); function Cygnus() { totalSupply = initialSupply; balances[msg.sender] = initialSupply; // Send all tokens to owner } } "}
{"sol name": "1897.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; contract OmnesToken { string public name = \"Omnes Coin\";      //  token name string public symbol = \"OMNES\";        //  token symbol uint256 public decimals = 18;          //  token digit mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; uint256 public totalSupply = 0; bool public stopped = false; uint256 constant valueFounder = 1000000000000000000000000000; address owner = 0x0; modifier isOwner { assert(owner == msg.sender); _; } modifier isRunning { assert (!stopped); _; } modifier validAddress { assert(0x0 != msg.sender); _; } function OmnesToken(address _addressFounder) { owner = msg.sender; totalSupply = valueFounder; balanceOf[_addressFounder] = valueFounder; Transfer(0x0, _addressFounder, valueFounder); } function transfer(address _to, uint256 _value) isRunning validAddress returns (bool success) { require(balanceOf[msg.sender] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); balanceOf[msg.sender] -= _value; balanceOf[_to] += _value; Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) isRunning validAddress returns (bool success) { require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value >= balanceOf[_to]); require(allowance[_from][msg.sender] >= _value); balanceOf[_to] += _value; balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) isRunning validAddress returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); allowance[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function stop() isOwner { stopped = true; } function start() isOwner { stopped = false; } function setName(string _name) isOwner { name = _name; } function burn(uint256 _value) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; balanceOf[0x0] += _value; Transfer(msg.sender, 0x0, _value); } event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } "}
{"sol name": "949.sol", "label": 0, "sol content": "pragma solidity 0.4.22; library SafeMath { function add(uint a, uint b) internal pure returns (uint c) { c = a + b; require(c >= a); } function sub(uint a, uint b) internal pure returns (uint c) { require(b <= a); c = a - b; } function mul(uint a, uint b) internal pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function div(uint a, uint b) internal pure returns (uint c) { require(b > 0); c = a / b; } } contract ERC20Interface { function totalSupply() public view returns (uint); function balanceOf(address tokenOwner) public view returns (uint balance); function allowance(address tokenOwner, address spender) public view returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); event FrozenFunds(address target, uint tokens); event Buy(address indexed sender, uint eth, uint token); } // Owned contract contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } //Transfer owner rights, can use only owner (the best practice of secure for the contracts) function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } //Accept tranfer owner rights function acceptOwnership() public onlyOwner { emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // Pausable Contract contract Pausable is Owned { event Pause(); event Unpause(); bool public paused = false; //Modifier to make a function callable only when the contract is not paused. modifier whenNotPaused() { require(!paused); _; } //Modifier to make a function callable only when the contract is paused. modifier whenPaused() { require(paused); _; } //called by the owner to pause, triggers stopped state function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } //called by the owner to unpause, returns to normal state function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract GB is ERC20Interface, Pausable { using SafeMath for uint; string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) public balances; mapping(address => uint) public lockInfo; mapping(address => mapping(address => uint)) internal allowed; mapping (address => bool) public admins; modifier onlyAdmin { require(msg.sender == owner || admins[msg.sender]); _; } function setAdmin(address _admin, bool isAdmin) public onlyOwner { admins[_admin] = isAdmin; } constructor() public{ symbol = 'GalaxyBlock'; name = 'Galaxy Block '; decimals = 18; _totalSupply = 100000000*10**uint(decimals); balances[owner] = _totalSupply; emit Transfer(address(0), owner, _totalSupply); } function totalSupply() public view returns (uint) { return _totalSupply; } function balanceOf(address tokenOwner) public view returns (uint balance) { return balances[tokenOwner]; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0);                                    // Prevent transfer to 0x0 address. Use burn() instead require(_value != 0);                                   // Prevent transfer 0 require(balances[_from] >= _value);                     // Check if the sender has enough require(balances[_from] - _value >= lockInfo[_from]);   // Check after transaction, balance is still more than locked value balances[_from] = balances[_from].sub(_value);          // Substract value from sender balances[_to] = balances[_to].add(_value);              // Add value to recipient emit Transfer(_from, _to, _value); } function transfer(address to, uint tokens) public whenNotPaused returns (bool success) { _transfer(msg.sender, to, tokens); return true; } function approve(address _spender, uint tokens) public whenNotPaused returns (bool success) { allowed[msg.sender][_spender] = tokens; emit Approval(msg.sender, _spender, tokens); return true; } function transferFrom(address from, address to, uint tokens) public whenNotPaused returns (bool success) { require(allowed[from][msg.sender] >= tokens); _transfer(from, to, tokens); allowed[from][msg.sender] = allowed[from][msg.sender].sub(tokens); return true; } function allowance(address tokenOwner, address spender) public whenNotPaused view returns (uint remaining) { return allowed[tokenOwner][spender]; } //Admin Tool function lockOf(address tokenOwner) public view returns (uint lockedToken) { return lockInfo[tokenOwner]; } //lock tokens or lock 0 to release all function lock(address target, uint lockedToken) public whenNotPaused onlyAdmin { lockInfo[target] = lockedToken; emit FrozenFunds(target, lockedToken); } //Batch lock amount with array function batchLockArray(address[] accounts, uint[] lockedToken) public whenNotPaused onlyAdmin { for (uint i = 0; i < accounts.length; i++) { lock(accounts[i], lockedToken[i]); } } function batchVipWtihLock(address[] receivers, uint[] tokens, bool freeze) public whenNotPaused onlyAdmin { for (uint i = 0; i < receivers.length; i++) { sendTokensWithLock(receivers[i], tokens[i], freeze); } } //Send token with lock function sendTokensWithLock (address receiver, uint tokens, bool freeze) public whenNotPaused onlyAdmin { _transfer(msg.sender, receiver, tokens); if(freeze) { uint lockedAmount = lockInfo[receiver] + tokens; lock(receiver, lockedAmount); } } //Send initial tokens function sendInitialTokens (address user) public onlyOwner { _transfer(msg.sender, user, balanceOf(owner)); } } "}
{"sol name": "783.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "1921.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'EMJAC' token contract // // Deployed to : 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF // Symbol      : EMJAC // Name        : EMJAC // Total supply: 2500000000000 // Decimals    : 4 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract EMJAC is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function EMJAC() public { symbol = \"EMJAC\"; name = \"EMJAC\"; decimals = 4; _totalSupply = 2500000000000; balances[0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF] = _totalSupply; Transfer(address(0), 0xf7d58Ed54556B8b4522BeCC4EA161D4A3DC9f6EF, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "829.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal constant returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal constant returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal constant returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value > 0 && _value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; Unpause(); } } /** * @title Pausable token * * @dev StandardToken modified with pausable transfers. **/ contract PausableToken is StandardToken, Pausable { function transfer(address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } } /** * @title TAXChain * * @dev Implementation of TAXChain based on the basic standard token. */ contract TAXChain is PausableToken { /** * Public variables of the token * The following variables are OPTIONAL vanities. One does not have to include them. * They allow one to customise the token contract & in no way influences the core functionality. * Some wallets/interfaces might not even bother to look at this information. */ string public name = \"TAXChain\"; string public symbol = \"TAX\"; string public version = '1.0.0'; uint8 public decimals = 18; /** * @dev Function to check the amount of tokens that an owner allowed to a spender. */ function TAXChain() { totalSupply = 10000000000 * (10**(uint256(decimals))); balances[0xAAA50586b0aB10dcb4Ce664A475Fb506419dF2E4] = totalSupply;    // Give the creator all initial tokens Transfer(address(0),0xAAA50586b0aB10dcb4Ce664A475Fb506419dF2E4, totalSupply); } function () { //if ether is sent to this address, send it back. revert(); } } "}
{"sol name": "443.sol", "label": 0, "sol content": "/* Its part of ethereum public blockchain. Developed by AsaCoin Development Team 2018. */ pragma solidity ^0.4.21; contract ERC20Interface { uint256 public totalSupply; function balanceOf(address _owner) public view returns (uint256 balance); function transfer(address _to, uint256 _value) public returns (bool success); function transferFrom(address _from, address _to, uint256 _value) public returns (bool success); function approve(address _spender, uint256 _value) public returns (bool success); function allowance(address _owner, address _spender) public view returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract AsaCoin is ERC20Interface, Ownable { uint256 constant private MAX_UINT256 = 2**256 - 1; mapping (address => uint256) public balances; mapping (address => mapping (address => uint256)) public allowed; string public name; uint8 public decimals; string public symbol; uint256 public totalSupply; uint256 public tokenDecimal = 1000000000000000000; constructor() public { totalSupply = 450000000 * tokenDecimal; balances[msg.sender] = totalSupply; name = \"AsaCoin\"; decimals = 18; symbol = \"ASA\"; } function transfer(address _to, uint256 _value) public returns (bool success) { require(balances[msg.sender] >= _value); balances[msg.sender] -= _value; balances[_to] += _value; emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) onlyOwner public returns (bool success) { require(balances[_from] >= _value); balances[_to] += _value; balances[_from] -= _value; allowed[_from][msg.sender] -= _value; emit Transfer(_from, _to, _value); return true; } function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) public returns (bool success) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } function () payable public { balances[msg.sender] += msg.value; } } "}
{"sol name": "519.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract EAI_TokenERC { // Public variables of the token string public name; string public symbol; uint8 public decimals = 8; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function EAI_TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "737.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public constant returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) constant public returns (uint256 remaining) { return allowed[_owner][_spender]; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ function Ownable() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); owner = newOwner; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * @dev Issue: * https://github.com/OpenZeppelin/zeppelin-solidity/issues/120 */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } /** * @dev Function to mint tokens * @param _to The address that will recieve the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint(address _to, uint256 _amount) onlyOwner canMint public returns (bool) { totalSupply = totalSupply.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } contract Veradium is MintableToken { string public constant name = \"Veradium\"; string public constant symbol = \"VRDM\"; uint32 public constant decimals = 18; } "}
{"sol name": "1655.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor () public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } interface tokenRecipient {function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external;} contract TokenERC20 { using SafeMath for uint256; string public name; string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping(address => uint256) public balanceOf; mapping(address => mapping(address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value && _value > 0); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] = balanceOf[_from].sub(_value); balanceOf[_to] = balanceOf[_to].add(_value); emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function batchTransfer(address[] _to, uint _value) public returns (bool success) { require(_to.length > 0 && _to.length <= 20); for (uint i = 0; i < _to.length; i++) { _transfer(msg.sender, _to[i], _value); } return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } } contract JTCToken is Ownable, TokenERC20 { constructor ( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} } "}
{"sol name": "346.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Pausable * @dev Base contract which allows children to implement an emergency stop mechanism. */ contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract IOGToken is StandardToken, Ownable, Pausable { // events event Burn(address indexed burner, uint256 amount); event AddressLocked(address indexed _owner, uint256 _expiry); // erc20 constants string public constant name = \"IOGToken\"; string public constant symbol = \"IOG\"; uint8 public constant decimals = 18; uint256 public constant TOTAL_SUPPLY = 2200000000 * (10 ** uint256(decimals)); // lock mapping (address => uint256) public addressLocks; // constructor constructor(address[] addressList, uint256[] tokenAmountList, uint256[] lockedPeriodList) public { totalSupply_ = TOTAL_SUPPLY; balances[msg.sender] = TOTAL_SUPPLY; emit Transfer(0x0, msg.sender, TOTAL_SUPPLY); // distribution distribution(addressList, tokenAmountList, lockedPeriodList); } // distribution function distribution(address[] addressList, uint256[] tokenAmountList, uint256[] lockedPeriodList) onlyOwner internal { // Token allocation // - foundation: 25% (16% locked) // - platform ecosystem: 35% (30% locked) // - early investor: 15% (12.5% locked) // - private sale: 10% // - board of advisor: 10% // - bounty: 5% for (uint i = 0; i < addressList.length; i++) { uint256 lockedPeriod = lockedPeriodList[i]; // lock if (0 < lockedPeriod) { timeLock(addressList[i], tokenAmountList[i] * (10 ** uint256(decimals)), now + (lockedPeriod * 60 * 60 * 24)); } // unlock else { transfer(addressList[i], tokenAmountList[i] * (10 ** uint256(decimals))); } } } // lock modifier canTransfer(address _sender) { require(_sender != address(0)); require(canTransferIfLocked(_sender)); _; } function canTransferIfLocked(address _sender) internal view returns(bool) { if (0 == addressLocks[_sender]) return true; return (now >= addressLocks[_sender]); } function timeLock(address _to, uint256 _value, uint256 releaseDate) onlyOwner public { addressLocks[_to] = releaseDate; transfer(_to, _value); emit AddressLocked(_to, _value); } // erc20 methods function transfer(address _to, uint256 _value) canTransfer(msg.sender) whenNotPaused public returns (bool success) { return super.transfer(_to, _value); } function transferFrom(address _from, address _to, uint256 _value) canTransfer(_from) whenNotPaused public returns (bool success) { return super.transferFrom(_from, _to, _value); } function approve(address _spender, uint256 _value) whenNotPaused public returns (bool) { return super.approve(_spender, _value); } function increaseApproval(address _spender, uint _addedValue) whenNotPaused public returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval(address _spender, uint _subtractedValue) whenNotPaused public returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } // burn function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } // token drain function emergencyERC20Drain(ERC20 token, uint256 amount) external onlyOwner { // owner can drain tokens that are sent here by mistake token.transfer(owner, amount); } } "}
{"sol name": "833.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * See https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { require(token.transfer(to, value)); } function safeTransferFrom( ERC20 token, address from, address to, uint256 value ) internal { require(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { require(token.approve(spender, value)); } } /** * @title Crowdsale * @dev Crowdsale is a base contract for managing a token crowdsale, * allowing investors to purchase tokens with ether. This contract implements * such functionality in its most fundamental form and can be extended to provide additional * functionality and/or custom behavior. * The external interface represents the basic interface for purchasing tokens, and conform * the base architecture for crowdsales. They are *not* intended to be modified / overriden. * The internal interface conforms the extensible and modifiable surface of crowdsales. Override * the methods to add functionality. Consider using 'super' where appropiate to concatenate * behavior. */ contract Crowdsale { using SafeMath for uint256; using SafeERC20 for ERC20; // The token being sold ERC20 public token; // Address where funds are collected address public wallet; // How many token units a buyer gets per wei. // The rate is the conversion between wei and the smallest and indivisible token unit. // So, if you are using a rate of 1 with a DetailedERC20 token with 3 decimals called TOK // 1 wei will give you 1 unit, or 0.001 TOK. uint256 public rate; // Amount of wei raised uint256 public weiRaised; /** * Event for token purchase logging * @param purchaser who paid for the tokens * @param beneficiary who got the tokens * @param value weis paid for purchase * @param amount amount of tokens purchased */ event TokenPurchase( address indexed purchaser, address indexed beneficiary, uint256 value, uint256 amount ); /** * @param _rate Number of token units a buyer gets per wei * @param _wallet Address where collected funds will be forwarded to * @param _token Address of the token being sold */ constructor(uint256 _rate, address _wallet, ERC20 _token) public { require(_rate > 0); require(_wallet != address(0)); require(_token != address(0)); rate = _rate; wallet = _wallet; token = _token; } // ----------------------------------------- // Crowdsale external interface // ----------------------------------------- /** * @dev fallback function ***DO NOT OVERRIDE*** */ function () external payable { buyTokens(msg.sender); } /** * @dev low level token purchase ***DO NOT OVERRIDE*** * @param _beneficiary Address performing the token purchase */ function buyTokens(address _beneficiary) public payable { uint256 weiAmount = msg.value; _preValidatePurchase(_beneficiary, weiAmount); // calculate token amount to be created uint256 tokens = _getTokenAmount(weiAmount); // update state weiRaised = weiRaised.add(weiAmount); _processPurchase(_beneficiary, tokens); emit TokenPurchase( msg.sender, _beneficiary, weiAmount, tokens ); _updatePurchasingState(_beneficiary, weiAmount); _forwardFunds(); _postValidatePurchase(_beneficiary, weiAmount); } // ----------------------------------------- // Internal interface (extensible) // ----------------------------------------- /** * @dev Validation of an incoming purchase. Use require statements to revert state when conditions are not met. Use super to concatenate validations. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _preValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { require(_beneficiary != address(0)); require(_weiAmount != 0); } /** * @dev Validation of an executed purchase. Observe state and use revert statements to undo rollback when valid conditions are not met. * @param _beneficiary Address performing the token purchase * @param _weiAmount Value in wei involved in the purchase */ function _postValidatePurchase( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Source of tokens. Override this method to modify the way in which the crowdsale ultimately gets and sends its tokens. * @param _beneficiary Address performing the token purchase * @param _tokenAmount Number of tokens to be emitted */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { token.safeTransfer(_beneficiary, _tokenAmount); } /** * @dev Executed when a purchase has been validated and is ready to be executed. Not necessarily emits/sends tokens. * @param _beneficiary Address receiving the tokens * @param _tokenAmount Number of tokens to be purchased */ function _processPurchase( address _beneficiary, uint256 _tokenAmount ) internal { _deliverTokens(_beneficiary, _tokenAmount); } /** * @dev Override for extensions that require an internal state to check for validity (current user contributions, etc.) * @param _beneficiary Address receiving the tokens * @param _weiAmount Value in wei involved in the purchase */ function _updatePurchasingState( address _beneficiary, uint256 _weiAmount ) internal { // optional override } /** * @dev Override to extend the way in which ether is converted to tokens. * @param _weiAmount Value in wei to be converted into tokens * @return Number of tokens that can be purchased with the specified _weiAmount */ function _getTokenAmount(uint256 _weiAmount) internal view returns (uint256) { return _weiAmount.mul(rate); } /** * @dev Determines how ETH is stored/forwarded on purchases. */ function _forwardFunds() internal { wallet.transfer(msg.value); } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } /** * @title Roles * @author Francisco Giordano (@frangio) * @dev Library for managing addresses assigned to a Role. * See RBAC.sol for example usage. */ library Roles { struct Role { mapping (address => bool) bearer; } /** * @dev give an address access to this role */ function add(Role storage role, address addr) internal { role.bearer[addr] = true; } /** * @dev remove an address' access to this role */ function remove(Role storage role, address addr) internal { role.bearer[addr] = false; } /** * @dev check if an address has this role * // reverts */ function check(Role storage role, address addr) view internal { require(has(role, addr)); } /** * @dev check if an address has this role * @return bool */ function has(Role storage role, address addr) view internal returns (bool) { return role.bearer[addr]; } } /** * @title RBAC (Role-Based Access Control) * @author Matt Condon (@Shrugs) * @dev Stores and provides setters and getters for roles and addresses. * Supports unlimited numbers of roles and addresses. * See //contracts/mocks/RBACMock.sol for an example of usage. * This RBAC method uses strings to key roles. It may be beneficial * for you to write your own implementation of this interface using Enums or similar. * It's also recommended that you define constants in the contract, like ROLE_ADMIN below, * to avoid typos. */ contract RBAC { using Roles for Roles.Role; mapping (string => Roles.Role) private roles; event RoleAdded(address indexed operator, string role); event RoleRemoved(address indexed operator, string role); /** * @dev reverts if addr does not have role * @param _operator address * @param _role the name of the role * // reverts */ function checkRole(address _operator, string _role) view public { roles[_role].check(_operator); } /** * @dev determine if addr has role * @param _operator address * @param _role the name of the role * @return bool */ function hasRole(address _operator, string _role) view public returns (bool) { return roles[_role].has(_operator); } /** * @dev add a role to an address * @param _operator address * @param _role the name of the role */ function addRole(address _operator, string _role) internal { roles[_role].add(_operator); emit RoleAdded(_operator, _role); } /** * @dev remove a role from an address * @param _operator address * @param _role the name of the role */ function removeRole(address _operator, string _role) internal { roles[_role].remove(_operator); emit RoleRemoved(_operator, _role); } /** * @dev modifier to scope access to a single role (uses msg.sender as addr) * @param _role the name of the role * // reverts */ modifier onlyRole(string _role) { checkRole(msg.sender, _role); _; } /** * @dev modifier to scope access to a set of roles (uses msg.sender as addr) * @param _roles the names of the roles to scope access to * // reverts * * @TODO - when solidity supports dynamic arrays as arguments to modifiers, provide this *  see: https://github.com/ethereum/solidity/issues/2467 */ // modifier onlyRoles(string[] _roles) { //     bool hasAnyRole = false; //     for (uint8 i = 0; i < _roles.length; i++) { //         if (hasRole(msg.sender, _roles[i])) { //             hasAnyRole = true; //             break; //         } //     } //     require(hasAnyRole); //     _; // } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * https://github.com/ethereum/EIPs/issues/20 * Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title Mintable token * @dev Simple ERC20 Token example, with mintable token creation * Based on code by TokenMarketNet: https://github.com/TokenMarketNet/ico/blob/master/contracts/MintableToken.sol */ contract MintableToken is StandardToken, Ownable { event Mint(address indexed to, uint256 amount); event MintFinished(); bool public mintingFinished = false; modifier canMint() { require(!mintingFinished); _; } modifier hasMintPermission() { require(msg.sender == owner); _; } /** * @dev Function to mint tokens * @param _to The address that will receive the minted tokens. * @param _amount The amount of tokens to mint. * @return A boolean that indicates if the operation was successful. */ function mint( address _to, uint256 _amount ) hasMintPermission canMint public returns (bool) { totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Mint(_to, _amount); emit Transfer(address(0), _to, _amount); return true; } /** * @dev Function to stop minting new tokens. * @return True if the operation was successful. */ function finishMinting() onlyOwner canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } } /** * @title MintedCrowdsale * @dev Extension of Crowdsale contract whose tokens are minted in each purchase. * Token ownership should be transferred to MintedCrowdsale for minting. */ contract MintedCrowdsale is Crowdsale { /** * @dev Overrides delivery by minting tokens upon purchase. * @param _beneficiary Token purchaser * @param _tokenAmount Number of tokens to be minted */ function _deliverTokens( address _beneficiary, uint256 _tokenAmount ) internal { require(MintableToken(token).mint(_beneficiary, _tokenAmount)); } } contract CoinSmarttICO is MintedCrowdsale { constructor(uint256 _rate, address _wallet, ERC20 _token) Crowdsale(_rate, _wallet, _token) { } } "}
{"sol name": "1775.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* Wo Men Yi Qi Lai Nian Fo: \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d \u0905\u092e\u093f\u0924\u093e\u092d. \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d \u0f60\u0f7c\u0f51\u0f0b\u0f51\u0f54\u0f42\u0f0b\u0f58\u0f7a\u0f51\u0f0d. \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88 \uc544\ubbf8\ud0c0\ubd88. \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b \u963f\u5f25\u9640\u4f5b. \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b \u963f\u5f4c\u9640\u4f5b. Amitabha Amitabha Amitabha Amitabha Amitabha Amitabha Amitabha Amitabha Amitabha Amitabha. \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30 \u0e1e\u0e23\u0e30\u0e2d\u0e21\u0e34\u0e15\u0e32\u0e20\u0e1e\u0e38\u0e17\u0e18\u0e30. Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt Adi\u0111\u00e0ph\u1eadt. \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826 \u1834\u1820\u182d\u182f\u1820\u1830\u1822 \u1826\u182d\u1821\u1822 \u182d\u1821\u1837\u1821\u182f\u1832\u1826. Jiang Wo Suo Xiu De Yi Qie Gong De,Hui Xiang Gei Fa Jie Yi Qie Zhong Sheng. */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); constructor() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); emit OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract TEST008 is Ownable{ using SafeMath for uint256; string public constant name       = \"TEST008\"; string public constant symbol     = \"\u6d4b\u8bd5\u516b\"; uint32 public constant decimals   = 18; uint256 public totalSupply        = 999999 ether; uint256 public currentTotalSupply = 0; uint256 startBalance              = 999 ether; mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); if( !touched[msg.sender] && currentTotalSupply < totalSupply ){ balances[msg.sender] = balances[msg.sender].add( startBalance ); touched[msg.sender] = true; currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= allowed[_from][msg.sender]); if( !touched[_from] && currentTotalSupply < totalSupply ){ touched[_from] = true; balances[_from] = balances[_from].add( startBalance ); currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function getBalance(address _a) internal constant returns(uint256) { if( currentTotalSupply < totalSupply ){ if( touched[_a] ) return balances[_a]; else return balances[_a].add( startBalance ); } else { return balances[_a]; } } function balanceOf(address _owner) public view returns (uint256 balance) { return getBalance( _owner ); } } "}
{"sol name": "404.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error * source: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/math/SafeMath.sol */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } /* \"Interfaces\" */ //  this is expected from another contracts //  if it wants to spend tokens of behalf of the token owner in our contract //  this can be used in many situations, for example to convert pre-ICO tokens to ICO tokens //  see 'approveAndCall' function contract allowanceRecipient { function receiveApproval(address _from, uint256 _value, address _inContract, bytes _extraData) public returns (bool); } // see: // https://github.com/ethereum/EIPs/issues/677 contract tokenRecipient { function tokenFallback(address _from, uint256 _value, bytes _extraData) public returns (bool); } /** * The ACCP contract * ver. 2.0 */ contract ACCP { // see: https://github.com/OpenZeppelin/openzeppelin-solidity/blob/master/contracts/token/ERC20/BasicToken.sol using SafeMath for uint256; address public owner; /* --- ERC-20 variables */ // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#name // function name() constant returns (string name) string public name = \"ACCP\"; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#symbol // function symbol() constant returns (string symbol) string public symbol = \"ACCP\"; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#decimals // function decimals() constant returns (uint8 decimals) uint8 public decimals = 0; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#totalsupply // function totalSupply() constant returns (uint256 totalSupply) // we start with zero and will create tokens as SC receives ETH uint256 public totalSupply = 10 * 1000000000; // 10B // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#balanceof // function balanceOf(address _owner) constant returns (uint256 balance) mapping(address => uint256) public balanceOf; // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#allowance // function allowance(address _owner, address _spender) constant returns (uint256 remaining) mapping(address => mapping(address => uint256)) public allowance; /* --- ERC-20 events */ // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#events // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer-1 event Transfer(address indexed from, address indexed to, uint256 value); // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approval event Approval(address indexed _owner, address indexed spender, uint256 value); /* --- Interaction with other contracts events  */ event DataSentToAnotherContract(address indexed _from, address indexed _toContract, bytes _extraData); /* --- Other variables */ bool public transfersBlocked = false; mapping(address => bool) public whiteListed; /* ---------- Constructor */ // do not forget about: // https://medium.com/@codetractio/a-look-into-paritys-multisig-wallet-bug-affecting-100-million-in-ether-and-tokens-356f5ba6e90a constructor() public { // owner = msg.sender; owner = 0xff809E4ebB5F94171881b3CA9a0EBf4405C6370a; // (!!!) all tokens initially belong to smart contract itself balanceOf[this] = totalSupply; } event TransfersBlocked(address indexed by);// function blockTransfers() public {// only owner! // require(msg.sender == owner); // require(!transfersBlocked); transfersBlocked = true; emit TransfersBlocked(msg.sender); } event TransfersAllowed(address indexed by);// function allowTransfers() public {// only owner! // require(msg.sender == owner); // require(transfersBlocked); transfersBlocked = false; emit TransfersAllowed(msg.sender); } event AddedToWhiteList(address indexed by, address indexed added);// function addToWhiteList(address acc) public {// only owner! // require(msg.sender == owner); // require(!whiteListed[acc]); whiteListed[acc] = true; emit AddedToWhiteList(msg.sender, acc); } event RemovedFromWhiteList(address indexed by, address indexed removed);// function removeFromWhiteList(address acc) public {// only owner! // require(msg.sender == owner); // require(acc != owner); // require(!whiteListed[acc]); whiteListed[acc] = false; emit RemovedFromWhiteList(msg.sender, acc); } event tokensBurnt(address indexed by, uint256 value); // function burnTokens() public {// only owner! // require(msg.sender == owner); // require(balanceOf[this] > 0); emit tokensBurnt(msg.sender, balanceOf[this]); balanceOf[this] = 0; } /* --- ERC-20 Functions */ // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#methods // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transfer function transfer(address _to, uint256 _value) public returns (bool){ return transferFrom(msg.sender, _to, _value); } // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#transferfrom function transferFrom(address _from, address _to, uint256 _value) public returns (bool){ // Transfers of 0 values MUST be treated as normal transfers and fire the Transfer event (ERC-20) require(_value >= 0); // The function SHOULD throw unless the _from account has deliberately authorized the sender of the message via some mechanism require(msg.sender == _from || _value <= allowance[_from][msg.sender] || (_from == address(this) && msg.sender == owner)); // TODO: require(!transfersBlocked || (whiteListed[_from] && whiteListed[msg.sender])); // check if _from account have required amount require(_value <= balanceOf[_from]); // Subtract from the sender // balanceOf[_from] = balanceOf[_from] - _value; balanceOf[_from] = balanceOf[_from].sub(_value); // // Add the same to the recipient // balanceOf[_to] = balanceOf[_to] + _value; balanceOf[_to] = balanceOf[_to].add(_value); // If allowance used, change allowances correspondingly if (_from != msg.sender && (!(_from == address(this) && msg.sender == owner))) { // allowance[_from][msg.sender] = allowance[_from][msg.sender] - _value; allowance[_from][msg.sender] = allowance[_from][msg.sender].sub(_value); } // event emit Transfer(_from, _to, _value); return true; } // end of transferFrom // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md#approve // there is and attack, see: // https://github.com/CORIONplatform/solidity/issues/6, // https://drive.google.com/file/d/0ByMtMw2hul0EN3NCaVFHSFdxRzA/view // but this function is required by ERC-20 function approve(address _spender, uint256 _value) public returns (bool){ require(_value >= 0); allowance[msg.sender][_spender] = _value; // event emit Approval(msg.sender, _spender, _value); return true; } /*  ---------- Interaction with other contracts  */ /* User can allow another smart contract to spend some shares in his behalf *  (this function should be called by user itself) *  @param _spender another contract's address *  @param _value number of tokens *  @param _extraData Data that can be sent from user to another contract to be processed *  bytes - dynamically-sized byte array, *  see http://solidity.readthedocs.io/en/v0.4.15/types.html#dynamically-sized-byte-array *  see possible attack information in comments to function 'approve' *  > this may be used to convert pre-ICO tokens to ICO tokens */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool) { approve(_spender, _value); // 'spender' is another contract that implements code as prescribed in 'allowanceRecipient' above allowanceRecipient spender = allowanceRecipient(_spender); // our contract calls 'receiveApproval' function of another contract ('allowanceRecipient') to send information about // allowance and data sent by user // 'this' is this (our) contract address if (spender.receiveApproval(msg.sender, _value, this, _extraData)) { emit DataSentToAnotherContract(msg.sender, _spender, _extraData); return true; } return false; } // end of approveAndCall // for convenience: function approveAllAndCall(address _spender, bytes _extraData) public returns (bool success) { return approveAndCall(_spender, balanceOf[msg.sender], _extraData); } /* https://github.com/ethereum/EIPs/issues/677 * transfer tokens with additional info to another smart contract, and calls its correspondent function * @param address _to - another smart contract address * @param uint256 _value - number of tokens * @param bytes _extraData - data to send to another contract * > this may be used to convert pre-ICO tokens to ICO tokens */ function transferAndCall(address _to, uint256 _value, bytes _extraData) public returns (bool success){ transferFrom(msg.sender, _to, _value); tokenRecipient receiver = tokenRecipient(_to); if (receiver.tokenFallback(msg.sender, _value, _extraData)) { emit DataSentToAnotherContract(msg.sender, _to, _extraData); return true; } return false; } // end of transferAndCall // for example for converting ALL tokens of user account to another tokens function transferAllAndCall(address _to, bytes _extraData) public returns (bool success){ return transferAndCall(_to, balanceOf[msg.sender], _extraData); } } "}
{"sol name": "1624.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Ownable * @dev The Ownable contract has an owner address, and provides basic authorization control * functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) public onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { uint256 public totalSupply; function balanceOf(address who) public constant returns  (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) returns (bool) { balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) constant returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public constant returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amout of tokens to be transfered */ function transferFrom(address _from, address _to, uint256 _value) returns (bool) { var _allowance = allowed[_from][msg.sender]; // Check is not needed because sub(_allowance, _value) will already throw if this condition is not met // require (_value <= _allowance); balances[_to] = balances[_to].add(_value); balances[_from] = balances[_from].sub(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Aprove the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifing the amount of tokens still avaible for the spender. */ function allowance(address _owner, address _spender) constant returns (uint256 remaining) { return allowed[_owner][_spender]; } } /*Token  Contract*/ contract ZXCToken is StandardToken, Ownable { using SafeMath for uint256; // Token \u8cc7\u8a0a string  public constant name = \"M726 Coin\"; string  public constant symbol = \"M726\"; uint8   public constant decimals = 18; // Sale period1. uint256 public startDate1; uint256 public endDate1; // Sale period2. uint256 public startDate2; uint256 public endDate2; //\u76ee\u524d\u92b7\u552e\u984d uint256 public saleCap; // Address Where Token are keep address public tokenWallet; // Address where funds are collected. address public fundWallet; // Amount of raised money in wei. uint256 public weiRaised; // Event event TokenPurchase(address indexed purchaser, uint256 value, uint256 amount); // Modifiers modifier uninitialized() { require(tokenWallet == 0x0); require(fundWallet == 0x0); _; } constructor() public {} // Trigger with Transfer event // Fallback function can be used to buy tokens function () public payable { buyTokens(msg.sender, msg.value); } //\u521d\u59cb\u5316\u5408\u7d04 function initialize(address _tokenWallet, address _fundWallet, uint256 _start1, uint256 _end1, uint256 _saleCap, uint256 _totalSupply) public onlyOwner uninitialized { //require(_start >= getCurrentTimestamp()); require(_start1 < _end1); require(_tokenWallet != 0x0); require(_fundWallet != 0x0); require(_totalSupply >= _saleCap); startDate1 = _start1; endDate1 = _end1; saleCap = _saleCap; tokenWallet = _tokenWallet; fundWallet = _fundWallet; totalSupply = _totalSupply; balances[tokenWallet] = saleCap; balances[0xb1] = _totalSupply.sub(saleCap); } //\u8a2d\u5b9a\u92b7\u552e\u671f\u9593 function setPeriod(uint period, uint256 _start, uint256 _end) public onlyOwner { require(_end > _start); if (period == 1) { startDate1 = _start; endDate1 = _end; }else if (period == 2) { require(_start > endDate1); startDate2 = _start; endDate2 = _end; } } // For pushing pre-ICO records function sendForPreICO(address buyer, uint256 amount) public onlyOwner { require(saleCap >= amount); saleCap = saleCap - amount; // Transfer balances[tokenWallet] = balances[tokenWallet].sub(amount); balances[buyer] = balances[buyer].add(amount); } //Set SaleCap function setSaleCap(uint256 _saleCap) public onlyOwner { require(balances[0xb1].add(balances[tokenWallet]).sub(_saleCap) > 0); uint256 amount=0; //\u76ee\u524d\u92b7\u552e\u984d \u5927\u65bc \u65b0\u92b7\u552e\u984d if (balances[tokenWallet] > _saleCap) { amount = balances[tokenWallet].sub(_saleCap); balances[0xb1] = balances[0xb1].add(amount); } else { amount = _saleCap.sub(balances[tokenWallet]); balances[0xb1] = balances[0xb1].sub(amount); } balances[tokenWallet] = _saleCap; saleCap = _saleCap; } //Calcute Bouns function getBonusByTime(uint256 atTime) public constant returns (uint256) { if (atTime < startDate1) { return 0; } else if (endDate1 > atTime && atTime > startDate1) { return 5000; } else if (endDate2 > atTime && atTime > startDate2) { return 2500; } else { return 0; } } function getBounsByAmount(uint256 etherAmount, uint256 tokenAmount) public pure returns (uint256) { //\u6700\u9ad840% uint256 bonusRatio = etherAmount.div(500 ether); if (bonusRatio > 4) { bonusRatio = 4; } uint256 bonusCount = SafeMath.mul(bonusRatio, 10); uint256 bouns = SafeMath.mul(tokenAmount, bonusCount); uint256 realBouns = SafeMath.div(bouns, 100); return realBouns; } //\u7d42\u6b62\u5408\u7d04 function finalize() public onlyOwner { require(!saleActive()); // Transfer the rest of token to tokenWallet balances[tokenWallet] = balances[tokenWallet].add(balances[0xb1]); balances[0xb1] = 0; } //\u78ba\u8a8d\u662f\u5426\u6b63\u5e38\u92b7\u552e function saleActive() public constant returns (bool) { return ( (getCurrentTimestamp() >= startDate1 && getCurrentTimestamp() < endDate1 && saleCap > 0) || (getCurrentTimestamp() >= startDate2 && getCurrentTimestamp() < endDate2 && saleCap > 0) ); } //Get CurrentTS function getCurrentTimestamp() internal view returns (uint256) { return now; } //\u8cfc\u8cb7Token function buyTokens(address sender, uint256 value) internal { //Check Sale Status require(saleActive()); //Minum buying limit require(value >= 0.5 ether); // Calculate token amount to be purchased uint256 bonus = getBonusByTime(getCurrentTimestamp()); uint256 amount = value.mul(bonus); // \u7b2c\u4e00\u968e\u6bb5\u92b7\u552e\u671f\uff0c\u6bcf\u6b21\u8cfc\u8cb7\u91cf\u8d85\u904e500Ether\uff0c\u591a\u589e\u52a010% if (getCurrentTimestamp() >= startDate1 && getCurrentTimestamp() < endDate1) { uint256 p1Bouns = getBounsByAmount(value, amount); amount = amount + p1Bouns; } // We have enough token to sale require(saleCap >= amount); // Transfer balances[tokenWallet] = balances[tokenWallet].sub(amount); balances[sender] = balances[sender].add(amount); TokenPurchase(sender,value, amount); saleCap = saleCap - amount; // Update state. weiRaised = weiRaised + value; // Forward the fund to fund collection wallet. //tokenWallet.transfer(msg.value); fundWallet.transfer(msg.value); } } "}
{"sol name": "619.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) public; } contract TokenERC20 { string public name;         //\u4e2d\u56fd\u4f5b\u798f\u94fe china fofu blockchain string public symbol; uint8 public decimals = 18; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); function TokenERC20(uint256 initialSupply, string tokenName, string tokenSymbol) public { totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; name = tokenName; symbol = tokenSymbol; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function transfer(address _to, uint256 _value) public { _transfer(msg.sender, _to, _value); } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; return true; } function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; Burn(_from, _value); return true; } } "}
{"sol name": "636.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; contract owned { address public owner; function owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address newOwner) onlyOwner public { owner = newOwner; } } interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constrctor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value > balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` in behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens in your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens in your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } /******************************************/ /*       ADVANCED TOKEN STARTS HERE       */ /******************************************/ contract RANDCRYPT is owned, TokenERC20 { mapping (address => bool) public frozenAccount; /* This generates a public event on the blockchain that will notify clients */ event FrozenFunds(address target, bool frozen); /* Initializes contract with initial supply tokens to the creator of the contract */ function RANDCRYPT( uint256 initialSupply, string tokenName, string tokenSymbol ) TokenERC20(initialSupply, tokenName, tokenSymbol) public {} /* Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { require (_to != 0x0);                               // Prevent transfer to 0x0 address. Use burn() instead require (balanceOf[_from] >= _value);               // Check if the sender has enough require (balanceOf[_to] + _value >= balanceOf[_to]); // Check for overflows require(!frozenAccount[_from]);                     // Check if sender is frozen require(!frozenAccount[_to]);                       // Check if recipient is frozen balanceOf[_from] -= _value;                         // Subtract from the sender balanceOf[_to] += _value;                           // Add the same to the recipient emit Transfer(_from, _to, _value); } /// @notice Create `mintedAmount` tokens and send it to `target` /// @param target Address to receive the tokens /// @param mintedAmount the amount of tokens it will receive function mintToken(address target, uint256 mintedAmount) onlyOwner public { balanceOf[target] += mintedAmount; totalSupply += mintedAmount; emit Transfer(0, this, mintedAmount); emit Transfer(this, target, mintedAmount); } /// @notice `freeze? Prevent | Allow` `target` from sending & receiving tokens /// @param target Address to be frozen /// @param freeze either to freeze it or not function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } } "}
{"sol name": "262.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // '0Fucks' token contract // // Deployed to : 0x959225d25f645b9C66498Ef99CE39911fC1DCEd9 // Symbol      : GRV // Name        : Groova Token // Total supply: 1000000 // Decimals    : 0 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract GroovaToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ constructor() public { symbol = \"GRV\"; name = \"Groova Token\"; decimals = 0; _totalSupply = 1000000; balances[0x7f0f94823D1b0fc4D251A72e9375F2AfdA2faba3] = _totalSupply; Transfer(address(0), 0x7f0f94823D1b0fc4D251A72e9375F2AfdA2faba3, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "453.sol", "label": 0, "sol content": "pragma solidity ^0.4.17; /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract DAPL is StandardToken { string public name = \"DAPL\"; string public symbol = \"DAPL\"; uint8 public decimals = 8; uint public INITIAL_SUPPLY = 1000000000e8; constructor() public { totalSupply_ = INITIAL_SUPPLY; balances[msg.sender] = INITIAL_SUPPLY; } } "}
{"sol name": "349.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint _value, address _token, bytes _extraData) external; } contract owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); constructor() owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) onlyOwner public returns (bool success) { newOwner = _newOwner; return true; } function acceptOwnership() public returns (bool success) { require(msg.sender == newOwner); owner = newOwner; emit OwnershipTransferred(owner, newOwner); newOwner = address(0); return true; } } contract TokenERC20 is owned { string public name = 'Telex'; string public symbol = 'TLX'; uint8 public decimals = 8; uint public totalSupply = 2000000000000000; mapping (address => uint) public balanceOf; mapping (address => mapping (address => uint)) public allowance; mapping (address => bool) public frozenAccount; event Transfer(address indexed from, address indexed to, uint value); event Approval(address indexed _owner, address indexed _spender, uint _value); event FrozenFunds(address indexed target, bool frozen); constructor() TokenERC20() public { balanceOf[msg.sender] = totalSupply; } function _transfer(address _from, address _to, uint _value) internal { require(_to != 0x0); require(balanceOf[_from] >= _value); require(balanceOf[_to] + _value > balanceOf[_to]); if (msg.sender != owner) { require(!frozenAccount[msg.sender]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); } uint previousBalances = balanceOf[_from] + balanceOf[_to]; balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } function _multipleTransfer(address _from, address[] addresses, uint[] amounts) internal { for (uint i=0; i<addresses.length; i++) { address _to = addresses[i]; uint _value = amounts[i]; _transfer(_from, _to, _value); } } function transfer(address _to, uint _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function multipleTransfer(address[] addresses, uint[] amounts) public returns (bool success) { _multipleTransfer(msg.sender, addresses, amounts); return true; } function transferFrom(address _from, address _to, uint _value) public returns (bool success) { if (msg.sender != owner) { require(allowance[_from][msg.sender] >= _value); allowance[_from][msg.sender] -= _value; } _transfer(_from, _to, _value); return true; } function approve(address _spender, uint _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function approveAndCall(address _spender, uint _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } function freezeAccount(address target, bool freeze) onlyOwner public returns (bool success) { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); return true; } } "}
{"sol name": "1841.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'SotkoCoin' token contract // // Deployed to : 0x7BF7D23997Df5eAcCFdf8761050Bae789F40Db0C // Symbol      : Sotko // Name        : SotkoCoin // Total supply: 100000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract SotkoCoin is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function SotkoCoin() public { symbol = \"Sotko\"; name = \"SotkoCoin\"; decimals = 8; _totalSupply = 100000000000000; balances[0xfcc75CC556025a14E599C0027447AE68aE3dB04b] = _totalSupply; Transfer(address(0), 0xfcc75CC556025a14E599C0027447AE68aE3dB04b, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "669.sol", "label": 0, "sol content": "pragma solidity ^0.4.16; interface TokenERC20{ function transfer(address _to, uint256 _value) public; } contract locksdc2{ address sdcContractAddr = 0xe85ed250e3d91fde61bf32e22c54f04754e695c5; address sdcMainAcc = 0x34e0968ee4c3447baac34bfc6f9c8445f0633245; TokenERC20 sdcCon = TokenERC20(sdcContractAddr); struct accountInputSdc { address account; uint sdc; uint locktime; uint createttime; } struct accountOutputSdc { address account; uint256 sdc; uint createttime; } struct accoutInputOutputSdcLog{ address account; uint256 sdc; uint locktime; bool isIn; uint createttime; } mapping(address=>accountInputSdc[]) public accountInputSdcs; mapping(address=>accountOutputSdc[]) public accountOutputSdcs; mapping(address=>accoutInputOutputSdcLog[]) public accoutInputOutputSdcLogs; mapping(address=>uint) public unlockSdc; event lockLogs(address indexed _controller,address indexed _user,uint256 _sdc,uint _locktime,bool _islock); function inSdcForAdmin(address _address,uint256 _sdc,uint _locktime) public returns (bool b)   { require(msg.sender == sdcMainAcc); //\u9501\u4ed3\u5408\u7ea6\u8bb0\u5f55\u6295\u8d44\u8005\u5730\u5740\uff0c\u591a\u5c11sdc\uff0c\u9501\u5b9a\u65f6\u95f4 accountInputSdcs[_address].push(accountInputSdc(_address,_sdc,_locktime,now)); lockLogs(msg.sender,_address,_sdc,_locktime,true); accoutInputOutputSdcLogs[_address].push(accoutInputOutputSdcLog(_address,_sdc,_locktime,true,now)); return true; } function outSdcForUser(uint256 _sdc) public returns(bool b){ // cha kan jie suo de jin e bing tian jia for(uint i=0;i<accountInputSdcs[msg.sender].length;i++){ if(now >= accountInputSdcs[msg.sender][i].locktime){ unlockSdc[msg.sender] = unlockSdc[msg.sender]+accountInputSdcs[msg.sender][i].sdc; accountInputSdcs[msg.sender][i] = accountInputSdc(msg.sender,0,999999999999,now); } } //kou qian require(unlockSdc[msg.sender]>=_sdc); sdcCon.transfer(msg.sender,_sdc); unlockSdc[msg.sender] = unlockSdc[msg.sender]-_sdc; lockLogs(msg.sender,msg.sender,_sdc,now,false); accountOutputSdcs[msg.sender].push(accountOutputSdc(msg.sender,_sdc,now)); accoutInputOutputSdcLogs[msg.sender].push(accoutInputOutputSdcLog(msg.sender,_sdc,999999999999,false,now)); return true; } function nowInSeconds() constant public returns (uint){ return now; } function getAccountInputSdcslength() constant public returns(uint b){ return accountInputSdcs[msg.sender].length; } function getAccountOutputSdcslength() constant public returns(uint b){ return accountOutputSdcs[msg.sender].length; } function getLockSdc() constant public returns(uint b){ uint tmpLockSdc = 0; for(uint i=0;i<accountInputSdcs[msg.sender].length;i++){ if(now < accountInputSdcs[msg.sender][i].locktime){ tmpLockSdc = tmpLockSdc + accountInputSdcs[msg.sender][i].sdc; } } return tmpLockSdc; } function getUnlockSdc() constant public returns(uint b){ uint tmpUnlockSdc = unlockSdc[msg.sender]; for(uint i=0;i<accountInputSdcs[msg.sender].length;i++){ if(now >= accountInputSdcs[msg.sender][i].locktime){ tmpUnlockSdc = tmpUnlockSdc + accountInputSdcs[msg.sender][i].sdc; } } return tmpUnlockSdc; } function insetMoney() public returns(bool b){ for(uint i=0;i<accountInputSdcs[msg.sender].length;i++){ if(now >= accountInputSdcs[msg.sender][i].locktime){ unlockSdc[msg.sender] = unlockSdc[msg.sender]+accountInputSdcs[msg.sender][i].sdc; accountInputSdcs[msg.sender][i] = accountInputSdc(msg.sender,0,999999999999,now); } } return true; } function() payable { } } "}
{"sol name": "571.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* ANCI // Antrodia Cinamomum Token (ANCI) // ERC20 Contract with Timelock capabilities // The bigger intricate timelock mechanisms out here // --- // --- //   _   _            _   _  _  ___ ___   ___ //  | |_| |_  ___    /_\\ | \\| |/ __|_ _| | _ \\_____ __ _____ _ _ //  |  _| ' \\/ -_)  / _ \\| .` | (__ | |  |  _/ _ \\ V  V / -_) '_| //   \\__|_||_\\___| /_/ \\_\\_|\\_|\\___|___| |_| \\___/\\_/\\_/\\___|_| // // --- // --- */ /* an owner is required */ contract Owned { address public owner; function Owned() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function setOwner(address _owner) onlyOwner public { owner = _owner; } } /* SafeMath implementation to guard against overflows */ contract SafeMath { function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; assert(c >= _a); // checks for overflow return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_a >= _b); // guards against overflow return _a - _b; } function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a * _b; assert(_a == 0 || c / _a == _b); // checks for overflow return c; } } /* The main contract for the timelock capable ERC20 token */ contract Token is SafeMath, Owned { uint256 constant DAY_IN_SECONDS = 86400; string public constant standard = \"0.777\"; string public name = \"\"; string public symbol = \"\"; uint8 public decimals = 0; uint256 public totalSupply = 0; mapping (address => uint256) public balanceP; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256[]) public lockTime; mapping (address => uint256[]) public lockValue; mapping (address => uint256) public lockNum; mapping (address => bool) public locker; uint256 public later = 0; uint256 public earlier = 0; /* standard ERC20 events */ event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /* custom lock-related events */ event TransferredLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value); event TokenUnlocked(address indexed _address, uint256 _value); /* ERC20 constructor */ function Token(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balanceP[msg.sender] = _totalSupply; } /* don't allow zero address */ modifier validAddress(address _address) { require(_address != 0x0); _; } /* owner may add & remove optional locker contract */ function addLocker(address _address) public validAddress(_address) onlyOwner { locker[_address] = true; } function removeLocker(address _address) public validAddress(_address) onlyOwner { locker[_address] = false; } /* owner may fast-forward or delay ALL timelocks */ function setUnlockEarlier(uint256 _earlier) public onlyOwner { earlier = add(earlier, _earlier); } function setUnlockLater(uint256 _later) public onlyOwner { later = add(later, _later); } /* shows unlocked balance */ function balanceUnlocked(address _address) public view returns (uint256 _balance) { _balance = balanceP[_address]; uint256 i = 0; while (i < lockNum[_address]) { if (add(now, earlier) > add(lockTime[_address][i], later)) _balance = add(_balance, lockValue[_address][i]); i++; } return _balance; } /* shows locked balance */ function balanceLocked(address _address) public view returns (uint256 _balance) { _balance = 0; uint256 i = 0; while (i < lockNum[_address]) { if (add(now, earlier) < add(lockTime[_address][i], later)) _balance = add(_balance, lockValue[_address][i]); i++; } return  _balance; } /* standard ERC20 compatible balance accessor */ function balanceOf(address _address) public view returns (uint256 _balance) { _balance = balanceP[_address]; uint256 i = 0; while (i < lockNum[_address]) { _balance = add(_balance, lockValue[_address][i]); i++; } return _balance; } /* show the timelock periods and locked values */ function showTime(address _address) public view validAddress(_address) returns (uint256[] _time) { uint i = 0; uint256[] memory tempLockTime = new uint256[](lockNum[_address]); while (i < lockNum[_address]) { tempLockTime[i] = sub(add(lockTime[_address][i], later), earlier); i++; } return tempLockTime; } function showValue(address _address) public view validAddress(_address) returns (uint256[] _value) { return lockValue[_address]; } /* calculates and handles the timelocks before related operations */ function calcUnlock(address _address) private { uint256 i = 0; uint256 j = 0; uint256[] memory currentLockTime; uint256[] memory currentLockValue; uint256[] memory newLockTime = new uint256[](lockNum[_address]); uint256[] memory newLockValue = new uint256[](lockNum[_address]); currentLockTime = lockTime[_address]; currentLockValue = lockValue[_address]; while (i < lockNum[_address]) { if (add(now, earlier) > add(currentLockTime[i], later)) { balanceP[_address] = add(balanceP[_address], currentLockValue[i]); /* emit custom timelock expiration event */ emit TokenUnlocked(_address, currentLockValue[i]); } else { newLockTime[j] = currentLockTime[i]; newLockValue[j] = currentLockValue[i]; j++; } i++; } uint256[] memory trimLockTime = new uint256[](j); uint256[] memory trimLockValue = new uint256[](j); i = 0; while (i < j) { trimLockTime[i] = newLockTime[i]; trimLockValue[i] = newLockValue[i]; i++; } lockTime[_address] = trimLockTime; lockValue[_address] = trimLockValue; lockNum[_address] = j; } /* ERC20 compliant transfer method */ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); if (balanceP[msg.sender] >= _value && _value > 0) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value); balanceP[_to] = add(balanceP[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } /* custom timelocked transfer method */ function transferLocked(address _to, uint256[] _time, uint256[] _value) public validAddress(_to) returns (bool success) { require(_value.length == _time.length); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[msg.sender] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; /* emit custom timelock event */ emit TransferredLocked(msg.sender, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); /* emit standard transfer event */ emit Transfer(msg.sender, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } /* custom timelocker method */ function transferLockedFrom(address _from, address _to, uint256[] _time, uint256[] _value) public validAddress(_from) validAddress(_to) returns (bool success) { require(locker[msg.sender]); require(_value.length == _time.length); if (lockNum[_from] > 0) calcUnlock(_from); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[_from] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[_from] = sub(balanceP[_from], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; /* emit custom timelock event */ emit TransferredLocked(_from, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); /* emit standard transfer event */ emit Transfer(_from, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } /* standard ERC20 compliant transferFrom method */ function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool success) { if (lockNum[_from] > 0) calcUnlock(_from); if (balanceP[_from] >= _value && _value > 0) { allowance[_from][msg.sender] = sub(allowance[_from][msg.sender], _value); balanceP[_from] = sub(balanceP[_from], _value); balanceP[_to] = add(balanceP[_to], _value); emit Transfer(_from, _to, _value); return true; } else { return false; } } /* standard ERC20 compliant approve method */ function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /* safety method against ether transfer */ function () public payable { revert(); } } "}
{"sol name": "1639.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; require(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { require(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; require(c >= a); return c; } } contract Ownable { address public owner; event OwnershipTransferred(address indexed previousOwner, address indexed newOwner); function Ownable() public { owner = msg.sender ; } modifier onlyOwner() { require(msg.sender == owner); _; } function transferOwnership(address newOwner) public onlyOwner { require(newOwner != address(0)); OwnershipTransferred(owner, newOwner); owner = newOwner; } } contract HLChain is Ownable{ using SafeMath for uint256; string public constant name       = \"HLChain\"; string public constant symbol     = \"HLCH\"; uint32 public constant decimals   = 4; uint256 public totalSupply        = 99999999802 * (10 ** uint256(decimals)); uint256 public currentTotalSupply = 0; uint256 startBalance              = 386 * (10 ** uint256(decimals)); mapping(address => bool) touched; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; function  HLChain()  public { balances[msg.sender] = startBalance * 256476684; currentTotalSupply = balances[msg.sender]; } event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); if( !touched[msg.sender] && currentTotalSupply < totalSupply ){ balances[msg.sender] = balances[msg.sender].add( startBalance ); touched[msg.sender] = true; currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= allowed[_from][msg.sender]); if( !touched[_from] && currentTotalSupply < totalSupply ){ touched[_from] = true; balances[_from] = balances[_from].add( startBalance ); currentTotalSupply = currentTotalSupply.add( startBalance ); } require(_value <= balances[_from]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function getBalance(address _a) internal constant returns(uint256) { if( currentTotalSupply < totalSupply ){ if( touched[_a] ) return balances[_a]; else return balances[_a].add( startBalance ); } else { return balances[_a]; } } function balanceOf(address _owner) public view returns (uint256 balance) { return getBalance( _owner ); } } "}
{"sol name": "47.sol", "label": 0, "sol content": "pragma solidity ^0.4.21; contract batchTransfer { address[] public myAddresses = [ 0xEd08013f164dE7b7F008364850bc63662A2fBf23, 0x94a1B74DB77eeF267EAb3541089Bdf20C8e519A1, 0x4d12e1a980436F591B23A111306CB6A6c78Dd5D1, 0x55cE473c9B262b3753dc23BF602f71D7E5d18C22, 0x55AEcae2dFAE29EB9A0ca673b9c5d566b8218805, 0x1485e03b520214Ca0E9a48E94e9b33F0Ca817E16, 0x9aae67b59fc95FEa0010704776290836D94d7cFA, 0xB2b78F6FA006bE85AD06425ceE0c87178D6aa952, 0x0211BD8eC7BDf3Baf90b8bEb6C46d7DE1d8F03d4, 0x8bb44cD72d8672b47b27399621d44262a3EF6Ea4, 0xe86ca3b24F2428A9d4D951D38839CE3B7d22ADe8, 0x2670362B6eF336dA3968bDC8A61dA4146855a7Bf, 0xe94A7689Ef1033380907eE3DA547192075466cfE, 0x097D31d05877aC409A38ee83205e5e574bef1fCB, 0xdf7a4c36623c56d806930580158b825173C3A699, 0x187feaEedD9a96603E6CDf97bcea5F4128ff65Fd, 0xcEB05D550eF408Ded280f0992a8E6BfB832F49db, 0x6AD07e1AE0baE076D33C816481d9b0B1b5E6a040, 0xB0924f74700CbDe6ccA651d09976E21bC0D29DC3, 0x7396b0A94F3976795C72715D9310Bf8C726e1ef7, 0xEEfc87152ba264804Eb96c0DfF925C396cc4E701, 0xeB84Ff451E865eb3946b492D49D38C91067e101b, 0x747E4c5745fa31470e28c55a9a5d64E795022788, 0xB0efA9d6B68F367EcdA9665DA74DB37A704ce9d5, 0xA0430c674667d6859CE01210E6E4A8Ead55B747C, 0xFEc6AfA0d2eBaB703E5920B7614b105F610e330a, 0x9a0a6b4Aa07fc4b785BF074a1d040D9fC34E731a, 0x79D907151A02592c204d69e4109F1dAe61AE9DE2, 0xC98a75195ad0ee1c518a8e2d819ca1B321FF3845, 0xDb1f214A72f80E114C3a9171e4F8F296FC3D3F92, 0x007Cf59fa7078B31dE57d0DdA9957038Fe5A816F, 0x2Ec8f3ea67b5F1f590072Eb544E4fE8A1C7D9998, 0x97a3faa97Edcaef6aC5919283B9e19d05FE9B5d0, 0x9720B0a5d366Edee5de6fD5DB8ad124fD460533B, 0x478B26eB159a23Fd70e9a6b04f447C97C0161fA2, 0x1910990502ADd9dDe6B933f9Eba0ff64802E8f3C, 0xF0376B7cB58Db3D45BE371c2Df22b747b2ba5EEa, 0x7Ba0b792e63DC26db7579102e62F208713972992, 0x916fb7641328E54614754D5c98580CE378C8FAb0, 0x44DD9c27edd39C8334730e68EFE6df95AeE30C9B, 0x4c81397D4E62DC6f357C07d6D9c8c233BaDdbB20, 0x7e74cDcad5B35ba98B9EB4fFca46fAfe6e6bb11F, 0x7E5764071881E71c9cc8BC45E7534BF66A28cF32, 0x231D5743e868BF40babd51c16eF7b58b6Fe2352e, 0xE04CD6106278ED8B37E10828DA594a6c4c0fbe0b, 0xd909659bCF62EC3406CDA3552c19B94fd732Dc9B, 0x5E97c0d8FCE18fc24D6334B552f3837654660795, 0x30b1eBF0f93DD5132Eae21b45502Ae6B2DcD4d1E, 0xcd801049A95DAA4CCeA937D95DA628721F58c005, 0x87A18c6b6433b1d2D2f0a8Fe36413a13DF06f337, 0x0a064D62B8c67268A595c81c13376100417E4B1F, 0xC77cf23bF4B03122256BC2e3987C42B1fa2cA387, 0xeeE7935276cDA74e916DD1d3CF9D065711E96FfA, 0xF10ab787daa75D5e4a0c8178a7937677a288C242, 0x7D9D555B53936A5c358924146E07383172598550, 0x937179645d90B7B1b9a0c00fe80712E85b166CDE, 0x5a2B8315268158A9D85f66afA1bC1898e23D62f8, 0x90ef731acd486Cf6C9bb51591A109538cc8A94B5, 0xb82293EF17964dB37296A4cC417d138fF4e77856, 0xa8397a554e3CADc47dB4a9e950101366d28C2d10, 0xffffcd76b24A78F0a1fBc82fE74A79a5FD6F9fe8, 0xf0d22491c3c5db9A8dEf861939C9965e7d452f0E, 0x30Fcae99F0174d18478E0450554E640E5C2Ffc3a, 0x181F3a55dd14C4CE7b0C868036C738984f027776, 0x018a398089E5C83c13377124593D846881c8c4d2, 0xC2027a38d61FB14359586D53CEFdA4dB12f32De4, 0x219dC53E7DC5c29960b87Ed7073D2c98B2265cbE, 0x25808D3004BFd7071c075ed0140fa37905F09bfC, 0xE4b26Fd14858D04a9a091EE9D372758D62FBabBb, 0xbDBA873C20c13180b7de0142b284481bdDf879bF, 0x08d9916FeCb55046ab50110b3A949a42287224BA, 0xfC571Da17A9d3c04Dd0a39DEA7E03e5D2629A7CA, 0xC81534B70B7B61aF516dB6d1ac33C2139304C37A, 0x1Db51B53F67077d5A463664aa675485384Ca089B, 0x59c69F83e0fc83200c966937DD4D93f1c288b45A, 0x28a565D50493eacdD67E9A611A62C1b748db5aFa, 0x575A736f196CA5457c92DEC7a104763B33B4A5c0, 0xa7bA2528637d8836D5Fec116E00ea72A16Afa8d0, 0x0030aAc0FB60272A5aE4f3038e729E45b69aAbAa, 0xB7bC4db261d4F8c492a42cff9cd7B4Bc973e9D49, 0x62a5C6b6643857195ABB5075944135932fc289A3, 0x45c6ba2400F2440FC892C652e1d99260b12Ec263, 0xc0408a4FB1175d4D858bfd1eC39302DdccC885E5, 0xD3791835189d7C1a34616d6aC4eE22862a4bF28d, 0x8b9dbbC2f79aC8A2d0a0230B5Fad1d8452304192, 0xdB2E3377bE2C5B34F0EB27B1bA72C9E983C3FEc5, 0x2120e52b0ab220ad74Db8ab139da5cE0994fa425, 0xdE25F401024cc0d7915a3E4Bef83d18ddf9bE5ca, 0x9A365AA5EDf519b16cf09DB968808752CB37c0D2, 0x6D715BB64B3Bd31a709F2Beea4A315E63d7fAdB5, 0xf3a2bb5deB2F30F08839C3e34c6959703106a10C, 0x5DeCF60C259C5fD02FEe56BEa42133f11f971B01, 0xDF97f6b4F917D9547FC3Df2098A024CaC2d3F5F7, 0x38b3B4Cf3362C91bb5e46aa00E734F3010968826, 0x6d97509b96D0BC26e174746E07F9033fF5409876, 0xE3D64e497cc1c8cD2Fa9983d7e224FB98333f662, 0x96a0b95Fa91578267Fc1735c39DffaAFE0aA08f3, 0x20E82D96586A9C624677cc7b751109c326275d18, 0x07ea7DA3e2683882046c275803Af0949bCa46E35, 0xe7c4Be518EA3Afe0D864615463d6Ed95c7C80C4f, 0xD3D148a048e7Fb2C2C17E7bF4626c548e9BEa6be, 0x3537925B962B61F50aE4AE1b7f3457bcC915c453, 0x60BEcE33bEC4de1e71C27B61dD5b474FE3178A16, 0xA50f2582a202C091CB9393B3dD1ED44eb7B0F905, 0x25438cd57C75Cd3118C01D6ad5CD2eD06Ba7e2B8, 0xC2ab18709d09E337600Ffb4b0E59405B1E525Ed6, 0xce6F79184A7E98557CE1Fe840Bfbb0f40C6c2562 ]; function () public payable { require(myAddresses.length>0); uint256 distr = msg.value/myAddresses.length; for(uint256 i=0;i<myAddresses.length;i++) { myAddresses[i].transfer(distr); } } } "}
{"sol name": "260.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; interface tokenRecipient { function receiveApproval(address _from, uint256 _value, address _token, bytes _extraData) external; } contract TokenERC20 { // Public variables of the token string public name; string public symbol; uint8 public decimals = 18; // 18 decimals is the strongly suggested default, avoid changing it uint256 public totalSupply; // This creates an array with all balances mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; // This generates a public event on the blockchain that will notify clients event Transfer(address indexed from, address indexed to, uint256 value); // This generates a public event on the blockchain that will notify clients event Approval(address indexed _owner, address indexed _spender, uint256 _value); // This notifies clients about the amount burnt event Burn(address indexed from, uint256 value); /** * Constructor function * * Initializes contract with initial supply tokens to the creator of the contract */ function TokenERC20( uint256 initialSupply, string tokenName, string tokenSymbol ) public { totalSupply = initialSupply * 10 ** uint256(decimals);  // Update total supply with the decimal amount balanceOf[msg.sender] = totalSupply;                // Give the creator all initial tokens name = tokenName;                                   // Set the name for display purposes symbol = tokenSymbol;                               // Set the symbol for display purposes } /** * Internal transfer, only can be called by this contract */ function _transfer(address _from, address _to, uint _value) internal { // Prevent transfer to 0x0 address. Use burn() instead require(_to != 0x0); // Check if the sender has enough require(balanceOf[_from] >= _value); // Check for overflows require(balanceOf[_to] + _value >= balanceOf[_to]); // Save this for an assertion in the future uint previousBalances = balanceOf[_from] + balanceOf[_to]; // Subtract from the sender balanceOf[_from] -= _value; // Add the same to the recipient balanceOf[_to] += _value; emit Transfer(_from, _to, _value); // Asserts are used to use static analysis to find bugs in your code. They should never fail assert(balanceOf[_from] + balanceOf[_to] == previousBalances); } /** * Transfer tokens * * Send `_value` tokens to `_to` from your account * * @param _to The address of the recipient * @param _value the amount to send */ function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } /** * Transfer tokens from other address * * Send `_value` tokens to `_to` on behalf of `_from` * * @param _from The address of the sender * @param _to The address of the recipient * @param _value the amount to send */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]);     // Check allowance allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } /** * Set allowance for other address * * Allows `_spender` to spend no more than `_value` tokens on your behalf * * @param _spender The address authorized to spend * @param _value the max amount they can spend */ function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * Set allowance for other address and notify * * Allows `_spender` to spend no more than `_value` tokens on your behalf, and then ping the contract about it * * @param _spender The address authorized to spend * @param _value the max amount they can spend * @param _extraData some extra information to send to the approved contract */ function approveAndCall(address _spender, uint256 _value, bytes _extraData) public returns (bool success) { tokenRecipient spender = tokenRecipient(_spender); if (approve(_spender, _value)) { spender.receiveApproval(msg.sender, _value, this, _extraData); return true; } } /** * Destroy tokens * * Remove `_value` tokens from the system irreversibly * * @param _value the amount of money to burn */ function burn(uint256 _value) public returns (bool success) { require(balanceOf[msg.sender] >= _value);   // Check if the sender has enough balanceOf[msg.sender] -= _value;            // Subtract from the sender totalSupply -= _value;                      // Updates totalSupply emit Burn(msg.sender, _value); return true; } /** * Destroy tokens from other account * * Remove `_value` tokens from the system irreversibly on behalf of `_from`. * * @param _from the address of the sender * @param _value the amount of money to burn */ function burnFrom(address _from, uint256 _value) public returns (bool success) { require(balanceOf[_from] >= _value);                // Check if the targeted balance is enough require(_value <= allowance[_from][msg.sender]);    // Check allowance balanceOf[_from] -= _value;                         // Subtract from the targeted balance allowance[_from][msg.sender] -= _value;             // Subtract from the sender's allowance totalSupply -= _value;                              // Update totalSupply emit Burn(_from, _value); return true; } } "}
{"sol name": "760.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Substracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval(address _spender, uint _addedValue) public returns (bool) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval(address _spender, uint _subtractedValue) public returns (bool) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract CryptSureToken is StandardToken { string public name    = \"CryptSureToken\"; string public symbol  = \"CPST\"; uint8 public decimals = 18; // one billion in initial supply uint256 public constant INITIAL_SUPPLY = 50000000; constructor() public { totalSupply_ = INITIAL_SUPPLY * (10 ** uint256(decimals)); balances[msg.sender] = totalSupply_; transfer(msg.sender, totalSupply_); } function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(this) ); super.transfer(_to, _value); } } "}
{"sol name": "1712.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'KILLAHY' token contract // // Deployed to : 0x02169578b41b8f7f5f2dd0491aa2682a13196c44 by holder 0x821ca1b7919200Ff99495466e13CA3b3135c1668 // Symbol      : KILLAHY // Name        : Killahy Token // Total supply: 100000000 // Decimals    : 18 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract KillahyToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function KillahyToken() public { symbol = \"KILLAHY\"; name = \"Killahy Token\"; decimals = 18; _totalSupply = 100000000000000000000000000; balances[0x821ca1b7919200Ff99495466e13CA3b3135c1668] = _totalSupply; Transfer(address(0), 0x821ca1b7919200Ff99495466e13CA3b3135c1668, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "659.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; // ---------------------------------------------------------------------------- // 'ACT238325' token contract // // Deployed to : 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187 // Symbol      : ACT238325 // Name        : ADZbuzz Androidguys.com Community Token // Total supply: 2000000 // Decimals    : 8 // // Enjoy. // // (c) by Moritz Neto with BokkyPooBah / Bok Consulting Pty Ltd Au 2017. The MIT Licence. // (c) by Darwin Jayme with ADZbuzz Ltd. UK (adzbuzz.com) 2018. // ---------------------------------------------------------------------------- // ---------------------------------------------------------------------------- // Safe maths // ---------------------------------------------------------------------------- contract SafeMath { function safeAdd(uint a, uint b) public pure returns (uint c) { c = a + b; require(c >= a); } function safeSub(uint a, uint b) public pure returns (uint c) { require(b <= a); c = a - b; } function safeMul(uint a, uint b) public pure returns (uint c) { c = a * b; require(a == 0 || c / a == b); } function safeDiv(uint a, uint b) public pure returns (uint c) { require(b > 0); c = a / b; } } // ---------------------------------------------------------------------------- // ERC Token Standard #20 Interface // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // ---------------------------------------------------------------------------- contract ERC20Interface { function totalSupply() public constant returns (uint); function balanceOf(address tokenOwner) public constant returns (uint balance); function allowance(address tokenOwner, address spender) public constant returns (uint remaining); function transfer(address to, uint tokens) public returns (bool success); function approve(address spender, uint tokens) public returns (bool success); function transferFrom(address from, address to, uint tokens) public returns (bool success); event Transfer(address indexed from, address indexed to, uint tokens); event Approval(address indexed tokenOwner, address indexed spender, uint tokens); } // ---------------------------------------------------------------------------- // Contract function to receive approval and execute function in one call // // Borrowed from MiniMeToken // ---------------------------------------------------------------------------- contract ApproveAndCallFallBack { function receiveApproval(address from, uint256 tokens, address token, bytes data) public; } // ---------------------------------------------------------------------------- // Owned contract // ---------------------------------------------------------------------------- contract Owned { address public owner; address public newOwner; event OwnershipTransferred(address indexed _from, address indexed _to); function Owned() public { owner = 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187; } modifier onlyOwner { require(msg.sender == owner); _; } function transferOwnership(address _newOwner) public onlyOwner { newOwner = _newOwner; } function acceptOwnership() public { require(msg.sender == newOwner); emit OwnershipTransferred(owner, newOwner); owner = newOwner; newOwner = address(0); } } // ---------------------------------------------------------------------------- // ERC20 Token, with the addition of symbol, name and decimals and assisted // token transfers // ---------------------------------------------------------------------------- contract ADZbuzzCommunityToken is ERC20Interface, Owned, SafeMath { string public symbol; string public  name; uint8 public decimals; uint public _totalSupply; mapping(address => uint) balances; mapping(address => mapping(address => uint)) allowed; // ------------------------------------------------------------------------ // Constructor // ------------------------------------------------------------------------ function ADZbuzzCommunityToken() public { symbol = \"ACT238325\"; name = \"ADZbuzz Androidguys.com Community Token\"; decimals = 8; _totalSupply = 200000000000000; balances[0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187] = _totalSupply; emit Transfer(address(0), 0x3f70c0B02879c36162C2C902ECfe9Ac0a8a8a187, _totalSupply); } // ------------------------------------------------------------------------ // Total supply // ------------------------------------------------------------------------ function totalSupply() public constant returns (uint) { return _totalSupply  - balances[address(0)]; } // ------------------------------------------------------------------------ // Get the token balance for account tokenOwner // ------------------------------------------------------------------------ function balanceOf(address tokenOwner) public constant returns (uint balance) { return balances[tokenOwner]; } // ------------------------------------------------------------------------ // Transfer the balance from token owner's account to to account // - Owner's account must have sufficient balance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transfer(address to, uint tokens) public returns (bool success) { balances[msg.sender] = safeSub(balances[msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(msg.sender, to, tokens); return true; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account // // https://github.com/ethereum/EIPs/blob/master/EIPS/eip-20-token-standard.md // recommends that there are no checks for the approval double-spend attack // as this should be implemented in user interfaces // ------------------------------------------------------------------------ function approve(address spender, uint tokens) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); return true; } // ------------------------------------------------------------------------ // Transfer tokens from the from account to the to account // // The calling account must already have sufficient tokens approve(...)-d // for spending from the from account and // - From account must have sufficient balance to transfer // - Spender must have sufficient allowance to transfer // - 0 value transfers are allowed // ------------------------------------------------------------------------ function transferFrom(address from, address to, uint tokens) public returns (bool success) { balances[from] = safeSub(balances[from], tokens); allowed[from][msg.sender] = safeSub(allowed[from][msg.sender], tokens); balances[to] = safeAdd(balances[to], tokens); emit Transfer(from, to, tokens); return true; } // ------------------------------------------------------------------------ // Returns the amount of tokens approved by the owner that can be // transferred to the spender's account // ------------------------------------------------------------------------ function allowance(address tokenOwner, address spender) public constant returns (uint remaining) { return allowed[tokenOwner][spender]; } // ------------------------------------------------------------------------ // Token owner can approve for spender to transferFrom(...) tokens // from the token owner's account. The spender contract function // receiveApproval(...) is then executed // ------------------------------------------------------------------------ function approveAndCall(address spender, uint tokens, bytes data) public returns (bool success) { allowed[msg.sender][spender] = tokens; emit Approval(msg.sender, spender, tokens); ApproveAndCallFallBack(spender).receiveApproval(msg.sender, tokens, this, data); return true; } // ------------------------------------------------------------------------ // Don't accept ETH // ------------------------------------------------------------------------ function () public payable { revert(); } // ------------------------------------------------------------------------ // Owner can transfer out any accidentally sent ERC20 tokens // ------------------------------------------------------------------------ function transferAnyERC20Token(address tokenAddress, uint tokens) public onlyOwner returns (bool success) { return ERC20Interface(tokenAddress).transfer(owner, tokens); } } "}
{"sol name": "894.sol", "label": 0, "sol content": "pragma solidity ^0.4.18; /** * @title ERC20 * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); event Transfer(address indexed from, address indexed to, uint256 value); } pragma solidity ^0.4.18; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } pragma solidity ^0.4.18; /** * @title TopPlayer token */ contract TopPlayerToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) internal allowed; string public name = \"QTC Token\"; string public symbol = \"QTCT\"; uint256 public decimals = 18; function TopPlayerToken() public { totalSupply = 2000000000 * (10 ** decimals); balances[msg.sender] = totalSupply; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256) { return allowed[_owner][_spender]; } event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } "}
{"sol name": "752.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /* CKBC // Cinnamomum Kanehirae BlockChain (CKBC) // ERC20 Contract with Timelock capabilities // The big intricate timelock mechanisms out here // --- // --- */ /* an owner is required */ contract Owned { address public owner; function Owned() public { owner = msg.sender; } modifier onlyOwner() { require(msg.sender == owner); _; } function setOwner(address _owner) onlyOwner public { owner = _owner; } } /* SafeMath implementation to guard against overflows */ contract SafeMath { function add(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a + _b; assert(c >= _a); // checks for overflow return c; } function sub(uint256 _a, uint256 _b) internal pure returns (uint256) { assert(_a >= _b); // guard against overflow return _a - _b; } function mul(uint256 _a, uint256 _b) internal pure returns (uint256) { uint256 c = _a * _b; assert(_a == 0 || c / _a == _b); // checks for overflow return c; } } /* The main contract for the timelock capable ERC20 token */ contract Token is SafeMath, Owned { uint256 constant DAY_IN_SECONDS = 86400; string public constant standard = \"0.777\"; string public name = \"\"; string public symbol = \"\"; uint8 public decimals = 0; uint256 public totalSupply = 0; mapping (address => uint256) public balanceP; mapping (address => mapping (address => uint256)) public allowance; mapping (address => uint256[]) public lockTime; mapping (address => uint256[]) public lockValue; mapping (address => uint256) public lockNum; mapping (address => bool) public locker; uint256 public later = 0; uint256 public earlier = 0; /* standard ERC20 events */ event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); /* custom lock-related events */ event TransferredLocked(address indexed _from, address indexed _to, uint256 _time, uint256 _value); event TokenUnlocked(address indexed _address, uint256 _value); /* ERC20 constructor */ function Token(string _name, string _symbol, uint8 _decimals, uint256 _totalSupply) public { require(bytes(_name).length > 0 && bytes(_symbol).length > 0); name = _name; symbol = _symbol; decimals = _decimals; totalSupply = _totalSupply; balanceP[msg.sender] = _totalSupply; } /* don't allow zero address */ modifier validAddress(address _address) { require(_address != 0x0); _; } /* owner may add & remove optional locker contract */ function addLocker(address _address) public validAddress(_address) onlyOwner { locker[_address] = true; } function removeLocker(address _address) public validAddress(_address) onlyOwner { locker[_address] = false; } /* owner may fast-forward or delay ALL timelocks */ function setUnlockEarlier(uint256 _earlier) public onlyOwner { earlier = add(earlier, _earlier); } function setUnlockLater(uint256 _later) public onlyOwner { later = add(later, _later); } /* shows unlocked balance */ function balanceUnlocked(address _address) public view returns (uint256 _balance) { _balance = balanceP[_address]; uint256 i = 0; while (i < lockNum[_address]) { if (add(now, earlier) > add(lockTime[_address][i], later)) _balance = add(_balance, lockValue[_address][i]); i++; } return _balance; } /* shows locked balance */ function balanceLocked(address _address) public view returns (uint256 _balance) { _balance = 0; uint256 i = 0; while (i < lockNum[_address]) { if (add(now, earlier) < add(lockTime[_address][i], later)) _balance = add(_balance, lockValue[_address][i]); i++; } return  _balance; } /* standard ERC20 compatible balance accessor */ function balanceOf(address _address) public view returns (uint256 _balance) { _balance = balanceP[_address]; uint256 i = 0; while (i < lockNum[_address]) { _balance = add(_balance, lockValue[_address][i]); i++; } return _balance; } /* show the timelock periods and locked values */ function showTime(address _address) public view validAddress(_address) returns (uint256[] _time) { uint i = 0; uint256[] memory tempLockTime = new uint256[](lockNum[_address]); while (i < lockNum[_address]) { tempLockTime[i] = sub(add(lockTime[_address][i], later), earlier); i++; } return tempLockTime; } function showValue(address _address) public view validAddress(_address) returns (uint256[] _value) { return lockValue[_address]; } /* calculates and handles the timelocks before related operations */ function calcUnlock(address _address) private { uint256 i = 0; uint256 j = 0; uint256[] memory currentLockTime; uint256[] memory currentLockValue; uint256[] memory newLockTime = new uint256[](lockNum[_address]); uint256[] memory newLockValue = new uint256[](lockNum[_address]); currentLockTime = lockTime[_address]; currentLockValue = lockValue[_address]; while (i < lockNum[_address]) { if (add(now, earlier) > add(currentLockTime[i], later)) { balanceP[_address] = add(balanceP[_address], currentLockValue[i]); /* emit timelock expiration event */ emit TokenUnlocked(_address, currentLockValue[i]); } else { newLockTime[j] = currentLockTime[i]; newLockValue[j] = currentLockValue[i]; j++; } i++; } uint256[] memory trimLockTime = new uint256[](j); uint256[] memory trimLockValue = new uint256[](j); i = 0; while (i < j) { trimLockTime[i] = newLockTime[i]; trimLockValue[i] = newLockValue[i]; i++; } lockTime[_address] = trimLockTime; lockValue[_address] = trimLockValue; lockNum[_address] = j; } /* ERC20 compliant transfer method */ function transfer(address _to, uint256 _value) public validAddress(_to) returns (bool success) { if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); if (balanceP[msg.sender] >= _value && _value > 0) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value); balanceP[_to] = add(balanceP[_to], _value); emit Transfer(msg.sender, _to, _value); return true; } else { return false; } } /* custom timelocked transfer method */ function transferLocked(address _to, uint256[] _time, uint256[] _value) public validAddress(_to) returns (bool success) { require(_value.length == _time.length); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[msg.sender] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[msg.sender] = sub(balanceP[msg.sender], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; /* emit custom timelock event */ emit TransferredLocked(msg.sender, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); /* emit standard transfer event */ emit Transfer(msg.sender, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } /* custom timelocked method */ function transferLockedFrom(address _from, address _to, uint256[] _time, uint256[] _value) public validAddress(_from) validAddress(_to) returns (bool success) { require(locker[msg.sender]); require(_value.length == _time.length); if (lockNum[_from] > 0) calcUnlock(_from); uint256 i = 0; uint256 totalValue = 0; while (i < _value.length) { totalValue = add(totalValue, _value[i]); i++; } if (balanceP[_from] >= totalValue && totalValue > 0) { i = 0; while (i < _time.length) { balanceP[_from] = sub(balanceP[_from], _value[i]); lockTime[_to].length = lockNum[_to]+1; lockValue[_to].length = lockNum[_to]+1; lockTime[_to][lockNum[_to]] = add(now, _time[i]); lockValue[_to][lockNum[_to]] = _value[i]; /* emit custom timelock event */ emit TransferredLocked(_from, _to, lockTime[_to][lockNum[_to]], lockValue[_to][lockNum[_to]]); /* emit standard transfer event */ emit Transfer(_from, _to, lockValue[_to][lockNum[_to]]); lockNum[_to]++; i++; } return true; } else { return false; } } /* standard ERC20 compliant transferFrom method */ function transferFrom(address _from, address _to, uint256 _value) public validAddress(_from) validAddress(_to) returns (bool success) { if (lockNum[_from] > 0) calcUnlock(_from); if (balanceP[_from] >= _value && _value > 0) { allowance[_from][msg.sender] = sub(allowance[_from][msg.sender], _value); balanceP[_from] = sub(balanceP[_from], _value); balanceP[_to] = add(balanceP[_to], _value); emit Transfer(_from, _to, _value); return true; } else { return false; } } /* standard ERC20 compliant approve method */ function approve(address _spender, uint256 _value) public validAddress(_spender) returns (bool success) { require(_value == 0 || allowance[msg.sender][_spender] == 0); if (lockNum[msg.sender] > 0) calcUnlock(msg.sender); allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /* safety method against ether transfer */ function () public payable { revert(); } } "}
{"sol name": "449.sol", "label": 0, "sol content": "pragma solidity 0.4.24; /** @title Ownable @dev The Ownable contract has an owner address, and provides basic authorization control functions, this simplifies the implementation of \"user permissions\". */ contract Ownable { address public owner; /** @dev The Ownable constructor sets the original owner of the contract to the sender account. */ function Ownable() { owner = msg.sender; } /** @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { if (msg.sender != owner) { throw; } _; } /** @dev Allows the current owner to transfer control of the contract to a newOwner. @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner { if (newOwner != address(0)) { owner = newOwner; } } } contract Token{ function transfer(address to, uint value) public returns (bool); function decimals() public returns (uint); } contract Airdrop is Ownable { function multisend(address _tokenAddr, address[] _to, uint256[] _value) public onlyOwner returns (bool _success) { assert(_to.length == _value.length); assert(_to.length <= 150); uint decimals = Token(_tokenAddr).decimals(); // loop through to addresses and send value for (uint8 i = 0; i < _to.length; i++) { assert((Token(_tokenAddr).transfer(_to[i], _value[i] * (10 ** decimals))) == true); } return true; } } "}
{"sol name": "790.sol", "label": 0, "sol content": "pragma solidity ^0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { function mul(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a * b; assert(a == 0 || c / a == b); return c; } function div(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a / b; return c; } function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20 interface */ contract ERC20 { uint256 public totalSupply; function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 */ contract StandardToken is ERC20 { using SafeMath for uint256; mapping(address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); Transfer(msg.sender, _to, _value); return true; } /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { var _allowance = allowed[_from][msg.sender]; require(_to != address(0)); require (_value <= _allowance); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = _allowance.sub(_value); Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { // To change the approve amount you first have to reduce the addresses` //  allowance to zero by calling `approve(_spender, 0)` if it is not //  already 0 to mitigate the race condition described here: //  https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 require((_value == 0) || (allowed[msg.sender][_spender] == 0)); allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public view returns (uint256 remaining) { return allowed[_owner][_spender]; } } contract boschcoin is StandardToken { string public constant name = \"boschcoin\"; string public constant symbol = \"BOSH\"; uint8 public constant decimals = 1; function boschcoin() public { totalSupply = 999000000; balances[msg.sender] = totalSupply; } } "}
{"sol name": "118.sol", "label": 1, "sol content": "pragma solidity ^0.4.10; contract SafeMath { function safeAdd(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x + y; assert((z >= x) && (z >= y)); return z; } function safeSubtract(uint256 x, uint256 y) internal returns(uint256) { assert(x >= y); uint256 z = x - y; return z; } function safeMult(uint256 x, uint256 y) internal returns(uint256) { uint256 z = x * y; assert((x == 0)||(z/x == y)); return z; } } contract Token { uint256 public totalSupply; function balanceOf(address _owner) constant returns  (uint256 balance); function transfer(address _to, uint256 _value) returns (bool success); function transferFrom(address _from, address _to, uint256 _value) returns (bool success); function approve(address _spender, uint256 _value) returns (bool success); function allowance(address _owner, address _spender) constant returns (uint256 remaining); event Transfer(address indexed _from, address indexed _to, uint256 _value); event Approval(address indexed _owner, address indexed _spender, uint256 _value); } contract StandardToken is Token , SafeMath { bool public status = true; modifier on() { require(status == true); _; } function transfer(address _to, uint256 _value) on returns (bool success) { if (balances[msg.sender] >= _value && _value > 0 && _to != 0X0) { balances[msg.sender] -= _value; balances[_to] = safeAdd(balances[_to],_value); Transfer(msg.sender, _to, _value); return true; } else { return false; } } function transferFrom(address _from, address _to, uint256 _value) on returns (bool success) { if (balances[_from] >= _value && allowed[_from][msg.sender] >= _value && _value > 0) { balances[_to] = safeAdd(balances[_to],_value); balances[_from] = safeSubtract(balances[_from],_value); allowed[_from][msg.sender] = safeSubtract(allowed[_from][msg.sender],_value); Transfer(_from, _to, _value); return true; } else { return false; } } function balanceOf(address _owner) on constant returns (uint256 balance) { return balances[_owner]; } function approve(address _spender, uint256 _value) on returns (bool success) { allowed[msg.sender][_spender] = _value; Approval(msg.sender, _spender, _value); return true; } function allowance(address _owner, address _spender) on constant returns (uint256 remaining) { return allowed[_owner][_spender]; } mapping (address => uint256) balances; mapping (address => mapping (address => uint256)) allowed; } contract ExShellStock is StandardToken { string public name = \"ExShellStock\"; uint8 public decimals = 8; string public symbol = \"ES\"; bool private init =true; function turnon() controller { status = true; } function turnoff() controller { status = false; } function ExShellStock() { require(init==true); totalSupply = 1000000000; balances[0xc7bab5f905a5fbd846a71b027aea111acc38f302] = totalSupply; init = false; } address public controller1 =0xc7bab5f905a5fbd846a71b027aea111acc38f302; address public controller2 =0x720c97c1b4941f4403fe40f38b0f9d684080e100; modifier controller () { require(msg.sender == controller1||msg.sender == controller2); _; } } "}
{"sol name": "169.sol", "label": 1, "sol content": "pragma solidity 0.4.24; /** * @title SafeMath * @dev Math operations with safety checks that throw on error */ library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return c; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c >= a); return c; } } /** * @title ERC20Basic * @dev Simpler version of ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/179 */ contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } /** * @title Basic token * @dev Basic version of StandardToken, with no allowances. */ contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); // SafeMath.sub will throw if there is not enough balance. balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256 balance) { return balances[_owner]; } } /** * @title ERC20 interface * @dev see https://github.com/ethereum/EIPs/issues/20 */ contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval(address indexed owner, address indexed spender, uint256 value); } /** * @title Standard ERC20 token * * @dev Implementation of the basic standard token. * @dev https://github.com/ethereum/EIPs/issues/20 * @dev Based on code by FirstBlood: https://github.com/Firstbloodio/token/blob/master/smart_contract/FirstBloodToken.sol */ contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance(address _owner, address _spender) public constant returns (uint256 remaining) { return allowed[_owner][_spender]; } /** * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol */ function increaseApproval (address _spender, uint _addedValue) public returns (bool success) { allowed[msg.sender][_spender] = allowed[msg.sender][_spender].add(_addedValue); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } function decreaseApproval (address _spender, uint _subtractedValue) public returns (bool success) { uint oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } /** * @title SafeERC20 * @dev Wrappers around ERC20 operations that throw on failure. * To use this library you can add a `using SafeERC20 for ERC20;` statement to your contract, * which allows you to call the safe operations as `token.safeTransfer(...)`, etc. */ library SafeERC20 { function safeTransfer(ERC20Basic token, address to, uint256 value) internal { assert(token.transfer(to, value)); } function safeTransferFrom(ERC20 token, address from, address to, uint256 value) internal { assert(token.transferFrom(from, to, value)); } function safeApprove(ERC20 token, address spender, uint256 value) internal { assert(token.approve(spender, value)); } } contract Owned { address public owner; constructor() public { owner = msg.sender; } modifier onlyOwner { require(msg.sender == owner); _; } } /** * @title TokenVesting * @dev A token holder contract that can release its token balance gradually like a * typical vesting scheme, with a cliff and vesting period. Optionally revocable by the * owner. */ contract TokenVesting is Owned { using SafeMath for uint256; using SafeERC20 for ERC20Basic; event Released(uint256 amount); event Revoked(); // beneficiary of tokens after they are released address public beneficiary; uint256 public cliff; uint256 public start; uint256 public duration; bool public revocable; mapping (address => uint256) public released; mapping (address => bool) public revoked; /** * @dev Creates a vesting contract that vests its balance of any ERC20 token to the * _beneficiary, gradually in a linear fashion until _start + _duration. By then all * of the balance will have vested. * @param _beneficiary address of the beneficiary to whom vested tokens are transferred * @param _cliff duration in seconds of the cliff in which tokens will begin to vest * @param _start the time (as Unix time) at which point vesting starts * @param _duration duration in seconds of the period in which the tokens will vest * @param _revocable whether the vesting is revocable or not */ constructor( address _beneficiary, uint256 _start, uint256 _cliff, uint256 _duration, bool _revocable ) public { require(_beneficiary != address(0)); require(_cliff <= _duration); beneficiary = _beneficiary; revocable = _revocable; duration = _duration; cliff = _start.add(_cliff); start = _start; } /** * @notice Transfers vested tokens to beneficiary. * @param token ERC20 token which is being vested */ function release(ERC20Basic token) public { uint256 unreleased = releasableAmount(token); require(unreleased > 0); released[token] = released[token].add(unreleased); token.safeTransfer(beneficiary, unreleased); emit Released(unreleased); } /** * @notice Allows the owner to revoke the vesting. Tokens already vested * remain in the contract, the rest are returned to the owner. * @param token ERC20 token which is being vested */ function revoke(ERC20Basic token) public onlyOwner { require(revocable); require(!revoked[token]); uint256 balance = token.balanceOf(this); uint256 unreleased = releasableAmount(token); uint256 refund = balance.sub(unreleased); revoked[token] = true; token.safeTransfer(owner, refund); emit Revoked(); } /** * @dev Calculates the amount that has already vested but hasn't been released yet. * @param token ERC20 token which is being vested */ function releasableAmount(ERC20Basic token) public view returns (uint256) { return vestedAmount(token).sub(released[token]); } /** * @dev Calculates the amount that has already vested. * @param token ERC20 token which is being vested */ function vestedAmount(ERC20Basic token) public view returns (uint256) { uint256 currentBalance = token.balanceOf(this); uint256 totalBalance = currentBalance.add(released[token]); if (block.timestamp < cliff) { return 0; } else if (block.timestamp >= start.add(duration) || revoked[token]) { return totalBalance; } else { return totalBalance.mul(block.timestamp.sub(start)).div(duration); } } } /** * @title Burnable Token * @dev Token that can be irreversibly burned (destroyed). */ contract BurnableToken is BasicToken { event Burn(address indexed burner, uint256 value); /** * @dev Burns a specific amount of tokens. * @param _value The amount of token to be burned. */ function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); // no need to require value <= totalSupply, since that would imply the // sender's balance is greater than the totalSupply, which *should* be an assertion failure balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } } contract AgateToken is BurnableToken, StandardToken, Owned { string public constant name = \"AGATE\"; string public constant symbol = \"AGT\"; uint8 public constant decimals = 18; /// Maximum tokens to be allocated (490 million AGT) uint256 public constant HARD_CAP = 490000000 * 10**uint256(decimals); /// This address is used to keep the tokens for sale address public saleTokensAddress; /// This address is used to keep the bounty and airdrop tokens address public bountyTokensAddress; /// This address will receive the team tokens when they are released from the vesting address public teamTokensAddress; /// This address is used to keep the vested team tokens TokenVesting public teamTokensVesting; /// This address is used to keep the advisors tokens address public advisorsTokensAddress; /// This address is used to keep the reserve tokens address public reserveTokensAddress; /// when the token sale is closed, the unsold tokens are burnt bool public saleClosed = false; /// open the trading for everyone bool public tradingOpen = false; /// the team tokens are vested for an year after the date 15 Nov 2018 uint64 public constant date15Nov2018 = 1542240000; /// Only allowed to execute before the token sale is closed modifier beforeSaleClosed { require(!saleClosed); _; } constructor(address _teamTokensAddress, address _reserveTokensAddress, address _advisorsTokensAddress, address _saleTokensAddress, address _bountyTokensAddress) public { require(_teamTokensAddress != address(0)); require(_reserveTokensAddress != address(0)); require(_advisorsTokensAddress != address(0)); require(_saleTokensAddress != address(0)); require(_bountyTokensAddress != address(0)); teamTokensAddress = _teamTokensAddress; reserveTokensAddress = _reserveTokensAddress; advisorsTokensAddress = _advisorsTokensAddress; saleTokensAddress = _saleTokensAddress; bountyTokensAddress = _bountyTokensAddress; /// Maximum tokens to be allocated on the sale /// 318.5M AGT (65% of 490M total supply) uint256 saleTokens = 318500000 * 10**uint256(decimals); totalSupply_ = saleTokens; balances[saleTokensAddress] = saleTokens; emit Transfer(address(0), saleTokensAddress, balances[saleTokensAddress]); /// Team tokens - 49M AGT (10% of total supply) - vested for an year since 15 Nov 2018 uint256 teamTokens = 49000000 * 10**uint256(decimals); totalSupply_ = totalSupply_.add(teamTokens); teamTokensVesting = new TokenVesting(teamTokensAddress, date15Nov2018, 92 days, 365 days, false); balances[address(teamTokensVesting)] = teamTokens; emit Transfer(address(0), address(teamTokensVesting), balances[address(teamTokensVesting)]); /// Bounty and airdrop tokens - 24.5M AGT (5% of total supply) uint256 bountyTokens = 24500000 * 10**uint256(decimals); totalSupply_ = totalSupply_.add(bountyTokens); balances[bountyTokensAddress] = bountyTokens; emit Transfer(address(0), bountyTokensAddress, balances[bountyTokensAddress]); /// Advisors tokens - 24.5M AGT (5% of total supply) uint256 advisorsTokens = 24500000 * 10**uint256(decimals); totalSupply_ = totalSupply_.add(advisorsTokens); balances[advisorsTokensAddress] = advisorsTokens; emit Transfer(address(0), advisorsTokensAddress, balances[advisorsTokensAddress]); /// Reserved tokens - 73.5M AGT (15% of total supply) uint256 reserveTokens = 73500000 * 10**uint256(decimals); totalSupply_ = totalSupply_.add(reserveTokens); balances[reserveTokensAddress] = reserveTokens; emit Transfer(address(0), reserveTokensAddress, balances[reserveTokensAddress]); require(totalSupply_ <= HARD_CAP); } /// @dev reallocates the unsold and leftover bounty tokens function closeSale() external onlyOwner beforeSaleClosed { /// The unsold tokens are burnt _burn(saleTokensAddress, balances[saleTokensAddress]); saleClosed = true; } /// @dev opens the trading for everyone function openTrading() external onlyOwner { tradingOpen = true; } /// @dev Trading limited function transferFrom(address _from, address _to, uint256 _value) public returns (bool) { if(tradingOpen) { return super.transferFrom(_from, _to, _value); } return false; } /// @dev Trading limited function transfer(address _to, uint256 _value) public returns (bool) { if(tradingOpen || msg.sender == saleTokensAddress || msg.sender == bountyTokensAddress || msg.sender == advisorsTokensAddress) { return super.transfer(_to, _value); } return false; } } "}
{"sol name": "520.sol", "label": 1, "sol content": "pragma solidity ^0.4.24; contract SafeMath { function safeMul(uint256 a, uint256 b) internal pure returns (uint256) { if (a == 0) { return 0; } uint256 c = a * b; assert(c / a == b); return c; } function safeDiv(uint256 a, uint256 b) internal pure returns (uint256) { assert(b > 0); uint256 c = a / b; assert(a == b * c + a % b); return c; } function safeSub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } function safeAdd(uint256 a, uint256 b) internal pure returns (uint256) { uint256 c = a + b; assert(c>=a && c>=b); return c; } } contract HeavenlyHoundCoin is SafeMath { address public owner; string public name; string public symbol; uint public decimals; uint256 public totalSupply; mapping (address => uint256) public balanceOf; mapping (address => mapping (address => uint256)) public allowance; event Transfer(address indexed from, address indexed to, uint256 value); event Burn(address indexed from, uint256 value); event Approval(address indexed owner, address indexed spender, uint256 value); mapping (address => bool) public frozenAccount; event FrozenFunds(address target, bool frozen); bool lock = false; constructor( uint256 initialSupply, string tokenName, string tokenSymbol, uint decimalUnits ) public { owner = msg.sender; name = tokenName; symbol = tokenSymbol; decimals = decimalUnits; totalSupply = initialSupply * 10 ** uint256(decimals); balanceOf[msg.sender] = totalSupply; } modifier onlyOwner { require(msg.sender == owner); _; } modifier isLock { require(!lock); _; } function setLock(bool _lock) onlyOwner public{ lock = _lock; } function transferOwnership(address newOwner) onlyOwner public { if (newOwner != address(0)) { owner = newOwner; } } function _transfer(address _from, address _to, uint _value) isLock internal { require (_to != 0x0); require (balanceOf[_from] >= _value); require (balanceOf[_to] + _value > balanceOf[_to]); require(!frozenAccount[_from]); require(!frozenAccount[_to]); balanceOf[_from] -= _value; balanceOf[_to] += _value; emit Transfer(_from, _to, _value); } function transfer(address _to, uint256 _value) public returns (bool success) { _transfer(msg.sender, _to, _value); return true; } function transferFrom(address _from, address _to, uint256 _value) public returns (bool success) { require(_value <= allowance[_from][msg.sender]); allowance[_from][msg.sender] -= _value; _transfer(_from, _to, _value); return true; } function approve(address _spender, uint256 _value) public returns (bool success) { allowance[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } function burn(uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[msg.sender] >= _value); balanceOf[msg.sender] -= _value; totalSupply -= _value; emit Burn(msg.sender, _value); return true; } function burnFrom(address _from, uint256 _value) onlyOwner public returns (bool success) { require(balanceOf[_from] >= _value); require(_value <= allowance[_from][msg.sender]); balanceOf[_from] -= _value; allowance[_from][msg.sender] -= _value; totalSupply -= _value; emit Burn(_from, _value); return true; } function mintToken(address target, uint256 mintedAmount) onlyOwner public { uint256 _amount = mintedAmount * 10 ** uint256(decimals); balanceOf[target] += _amount; totalSupply += _amount; emit Transfer(this, target, _amount); } function freezeAccount(address target, bool freeze) onlyOwner public { frozenAccount[target] = freeze; emit FrozenFunds(target, freeze); } function transferBatch(address[] _to, uint256 _value) public returns (bool success) { for (uint i=0; i<_to.length; i++) { _transfer(msg.sender, _to[i], _value); } return true; } } "}
{"sol name": "1711.sol", "label": 1, "sol content": "// solhint-disable-next-line compiler-fixed, compiler-gt-0_4 pragma solidity ^0.4.24; //                             _,,ad8888888888bba,_ //                         ,ad88888I888888888888888ba, //                       ,88888888I88888888888888888888a, //                     ,d888888888I8888888888888888888888b, //                    d88888PP\"\"\"\" \"\"YY88888888888888888888b, //                  ,d88\"'__,,--------,,,,.;ZZZY8888888888888, //                 ,8IIl'\"                ;;l\"ZZZIII8888888888, //                ,I88l;'                  ;lZZZZZ888III8888888, //              ,II88Zl;.                  ;llZZZZZ888888I888888, //             ,II888Zl;.                .;;;;;lllZZZ888888I8888b //            ,II8888Z;;                 `;;;;;''llZZ8888888I8888, //            II88888Z;'                        .;lZZZ8888888I888b //            II88888Z; _,aaa,      .,aaaaa,__.l;llZZZ88888888I888 //            II88888IZZZZZZZZZ,  .ZZZZZZZZZZZZZZ;llZZ88888888I888, //            II88888IZZ<'(@@>Z|  |ZZZ<'(@@>ZZZZ;;llZZ888888888I88I //           ,II88888;   `\"\"\" ;|  |ZZ; `\"\"\"     ;;llZ8888888888I888 //           II888888l            `;;          .;llZZ8888888888I888, //          ,II888888Z;           ;;;        .;;llZZZ8888888888I888I //          III888888Zl;    ..,   `;;       ,;;lllZZZ88888888888I888 //          II88888888Z;;...;(_    _)      ,;;;llZZZZ88888888888I888, //          II88888888Zl;;;;;' `--'Z;.   .,;;;;llZZZZ88888888888I888b //          ]I888888888Z;;;;'   \";llllll;..;;;lllZZZZ88888888888I8888, //          II888888888Zl.;;\"Y88bd888P\";;,..;lllZZZZZ88888888888I8888I //          II8888888888Zl;.; `\"PPP\";;;,..;lllZZZZZZZ88888888888I88888 //          II888888888888Zl;;. `;;;l;;;;lllZZZZZZZZW88888888888I88888 //          `II8888888888888Zl;.    ,;;lllZZZZZZZZWMZ88888888888I88888 //           II8888888888888888ZbaalllZZZZZZZZZWWMZZZ8888888888I888888, //           `II88888888888888888b\"WWZZZZZWWWMMZZZZZZI888888888I888888b //            `II88888888888888888;ZZMMMMMMZZZZZZZZllI888888888I8888888 //             `II8888888888888888 `;lZZZZZZZZZZZlllll888888888I8888888, //              II8888888888888888, `;lllZZZZllllll;;.Y88888888I8888888b, //             ,II8888888888888888b   .;;lllllll;;;.;..88888888I88888888b, //             II888888888888888PZI;.  .`;;;.;;;..; ...88888888I8888888888, //             II888888888888PZ;;';;.   ;. .;.  .;. .. Y8888888I88888888888b, //            ,II888888888PZ;;'                        `8888888I8888888888888b, //            II888888888'                              888888I8888888888888888b //           ,II888888888                              ,888888I88888888888888888 //          ,d88888888888                              d888888I8888888888ZZZZZZZ //       ,ad888888888888I                              8888888I8888ZZZZZZZZZZZZZ //     ,d888888888888888'                              888888IZZZZZZZZZZZZZZZZZZ //   ,d888888888888P'8P'                               Y888ZZZZZZZZZZZZZZZZZZZZZ //  ,8888888888888,  \"                                 ,ZZZZZZZZZZZZZZZZZZZZZZZZ // d888888888888888,                                ,ZZZZZZZZZZZZZZZZZZZZZZZZZZZ // 888888888888888888a,      _                    ,ZZZZZZZZZZZZZZZZZZZZ888888888 // 888888888888888888888ba,_d'                  ,ZZZZZZZZZZZZZZZZZ88888888888888 // 8888888888888888888888888888bbbaaa,,,______,ZZZZZZZZZZZZZZZ888888888888888888 // 88888888888888888888888888888888888888888ZZZZZZZZZZZZZZZ888888888888888888888 // 8888888888888888888888888888888888888888ZZZZZZZZZZZZZZ88888888888888888888888 // 888888888888888888888888888888888888888ZZZZZZZZZZZZZZ888888888888888888888888 // 8888888888888888888888888888888888888ZZZZZZZZZZZZZZ88888888888888888888888888 // 88888888888888888888888888888888888ZZZZZZZZZZZZZZ8888888888888888888888888888 // 8888888888888888888888888888888888ZZZZZZZZZZZZZZ88888888888888888 Da Vinci 88 // 88888888888888888888888888888888ZZZZZZZZZZZZZZ8888888888888888888  Coders  88 // 8888888888888888888888888888888ZZZZZZZZZZZZZZ88888888888888888888888888888888 library SafeMath { function mul(uint a, uint b) internal pure returns (uint c) { if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } function div(uint a, uint b) internal pure returns (uint) { return a / b; } function mod(uint a, uint b) internal pure returns (uint) { return a % b; } function sub(uint a, uint b) internal pure returns (uint) { assert(b <= a); return a - b; } function add(uint a, uint b) internal pure returns (uint c) { c = a + b; assert(c >= a); return c; } } contract Dividends { using SafeMath for *; uint private constant FIXED_POINT = 1000000000000000000; struct Scheme { uint value; uint shares; uint mask; } struct Vault { uint value; uint shares; uint mask; } mapping (uint => mapping (address => Vault)) private vaultOfAddress; mapping (uint => Scheme) private schemeOfId; function buyShares (uint _schemeId, address _owner, uint _shares, uint _value) internal { require(_owner != address(0)); require(_shares > 0 && _value > 0); uint value = _value.mul(FIXED_POINT); Scheme storage scheme = schemeOfId[_schemeId]; scheme.value = scheme.value.add(_value); scheme.shares = scheme.shares.add(_shares); require(value > scheme.shares); uint pps = value.div(scheme.shares); Vault storage vault = vaultOfAddress[_schemeId][_owner]; vault.shares = vault.shares.add(_shares); vault.mask = vault.mask.add(scheme.mask.mul(_shares)); vault.value = vault.value.add(value.sub(pps.mul(scheme.shares))); scheme.mask = scheme.mask.add(pps); } function flushVault (uint _schemeId, address _owner) internal { uint gains = gainsOfVault(_schemeId, _owner); if (gains > 0) { Vault storage vault = vaultOfAddress[_schemeId][_owner]; vault.value = vault.value.add(gains); vault.mask = vault.mask.add(gains); } } function withdrawVault (uint _schemeId, address _owner) internal returns (uint) { flushVault(_schemeId, _owner); Vault storage vault = vaultOfAddress[_schemeId][_owner]; uint payout = vault.value.div(FIXED_POINT); if (payout > 0) { vault.value = 0; } return payout; } function creditVault (uint _schemeId, address _owner, uint _value) internal { Vault storage vault = vaultOfAddress[_schemeId][_owner]; vault.value = vault.value.add(_value.mul(FIXED_POINT)); } function gainsOfVault (uint _schemeId, address _owner) internal view returns (uint) { Scheme storage scheme = schemeOfId[_schemeId]; Vault storage vault = vaultOfAddress[_schemeId][_owner]; if (vault.shares == 0) { return 0; } return scheme.mask.mul(vault.shares).sub(vault.mask); } function valueOfVault (uint _schemeId, address _owner) internal view returns (uint) { Vault storage vault = vaultOfAddress[_schemeId][_owner]; return vault.value; } function balanceOfVault (uint _schemeId, address _owner) internal view returns (uint) { Vault storage vault = vaultOfAddress[_schemeId][_owner]; uint total = vault.value.add(gainsOfVault(_schemeId, _owner)); uint balance = total.div(FIXED_POINT); return balance; } function sharesOfVault (uint _schemeId, address _owner) internal view returns (uint) { Vault storage vault = vaultOfAddress[_schemeId][_owner]; return vault.shares; } function valueOfScheme (uint _schemeId) internal view returns (uint) { return schemeOfId[_schemeId].value; } function sharesOfScheme (uint _schemeId) internal view returns (uint) { return schemeOfId[_schemeId].shares; } } library Utils { using SafeMath for uint; uint private constant LAST_COUNTRY = 195; function regularTicketPrice () internal pure returns (uint) { return 100000000000000; } function goldenTicketPrice (uint _x) internal pure returns (uint) { uint price = _x.mul(_x).div(2168819140000000000000000).add(100000000000000).add(_x.div(100000)); return price < regularTicketPrice() ? regularTicketPrice() : price; } function ticketsForWithExcess (uint _value) internal pure returns (uint, uint) { uint tickets = _value.div(regularTicketPrice()); uint excess = _value.sub(tickets.mul(regularTicketPrice())); return (tickets, excess); } function percentageOf (uint _value, uint _p) internal pure returns (uint) { return _value.mul(_p).div(100); } function validReferralCode (string _code) internal pure returns (bool) { bytes memory b = bytes(_code); if (b.length < 3) { return false; } for (uint i = 0; i < b.length; i++) { bytes1 c = b[i]; if ( !(c >= 0x30 && c <= 0x39) && // 0-9 !(c >= 0x41 && c <= 0x5A) && // A-Z !(c >= 0x61 && c <= 0x7A) && // a-z !(c == 0x2D) // - ) { return false; } } return true; } function validNick (string _nick) internal pure returns (bool) { return bytes(_nick).length > 3; } function validCountryId (uint _countryId) internal pure returns (bool) { return _countryId > 0 && _countryId <= LAST_COUNTRY; } } contract Events { event Started ( uint _time ); event Bought ( address indexed _player, address indexed _referral, uint _countryId, uint _tickets, uint _value, uint _excess ); event Promoted ( address indexed _player, uint _goldenTickets, uint _endTime ); event Withdrew ( address indexed _player, uint _amount ); event Registered ( string _code, address indexed _referral ); event Won ( address indexed _winner, uint _pot ); } contract Constants { uint internal constant MAIN_SCHEME = 1337; uint internal constant DEFAULT_COUNTRY = 1; uint internal constant SET_NICK_FEE = 0.01 ether; uint internal constant REFERRAL_REGISTRATION_FEE = 0.1 ether; uint internal constant TO_DIVIDENDS = 40; uint internal constant TO_REFERRAL = 10; uint internal constant TO_DEVELOPERS = 8; uint internal constant TO_COUNTRY = 12; } contract State is Constants { address internal addressOfOwner; uint internal maxTime = 0; uint internal addedTime = 0; uint internal totalPot = 0; uint internal startTime = 0; uint internal endTime = 0; bool internal potWithdrawn = false; address internal addressOfCaptain; struct Info { address referral; uint countryId; uint withdrawn; string nick; } mapping (address => Info) internal infoOfAddress; mapping (address => string[]) internal codesOfAddress; mapping (string => address) internal addressOfCode; modifier restricted () { require(msg.sender == addressOfOwner); _; } modifier active () { require(startTime > 0); require(block.timestamp < endTime); require(!potWithdrawn); _; } modifier player () { require(infoOfAddress[msg.sender].countryId > 0); _; } } contract Core is Events, State, Dividends {} contract ExternalView is Core { function totalInfo () external view returns (bool, bool, address, uint, uint, uint, uint, uint, uint, address) { return ( startTime > 0, block.timestamp >= endTime, addressOfCaptain, totalPot, endTime, sharesOfScheme(MAIN_SCHEME), valueOfScheme(MAIN_SCHEME), maxTime, addedTime, addressOfOwner ); } function countryInfo (uint _countryId) external view returns (uint, uint) { return ( sharesOfScheme(_countryId), valueOfScheme(_countryId) ); } function playerInfo (address _player) external view returns (uint, uint, uint, address, uint, uint, string) { Info storage info = infoOfAddress[_player]; return ( sharesOfVault(MAIN_SCHEME, _player), balanceOfVault(MAIN_SCHEME, _player), balanceOfVault(info.countryId, _player), info.referral, info.countryId, info.withdrawn, info.nick ); } function numberOfReferralCodes (address _player) external view returns (uint) { return codesOfAddress[_player].length; } function referralCodeAt (address _player, uint i) external view returns (string) { return codesOfAddress[_player][i]; } function codeToAddress (string _code) external view returns (address) { return addressOfCode[_code]; } function goldenTicketPrice (uint _x) external pure returns (uint) { return Utils.goldenTicketPrice(_x); } } contract Internal is Core { function _registerReferral (string _code, address _referral) internal { require(Utils.validReferralCode(_code)); require(addressOfCode[_code] == address(0)); addressOfCode[_code] = _referral; codesOfAddress[_referral].push(_code); emit Registered(_code, _referral); } } contract WinnerWinner is Core, Internal, ExternalView { using SafeMath for *; constructor () public { addressOfOwner = msg.sender; } function () public payable { buy(addressOfOwner, DEFAULT_COUNTRY); } function start (uint _maxTime, uint _addedTime) public restricted { require(startTime == 0); require(_maxTime > 0 && _addedTime > 0); require(_maxTime > _addedTime); maxTime = _maxTime; addedTime = _addedTime; startTime = block.timestamp; endTime = startTime + maxTime; addressOfCaptain = addressOfOwner; _registerReferral(\"owner\", addressOfOwner); emit Started(startTime); } function buy (address _referral, uint _countryId) public payable active { require(msg.value >= Utils.regularTicketPrice()); require(msg.value <= 100000 ether); require(codesOfAddress[_referral].length > 0); require(_countryId != MAIN_SCHEME); require(Utils.validCountryId(_countryId)); (uint tickets, uint excess) = Utils.ticketsForWithExcess(msg.value); uint value = msg.value.sub(excess); require(tickets > 0); require(value.add(excess) == msg.value); Info storage info = infoOfAddress[msg.sender]; if (info.countryId == 0) { info.referral = _referral; info.countryId = _countryId; } uint vdivs = Utils.percentageOf(value, TO_DIVIDENDS); uint vreferral = Utils.percentageOf(value, TO_REFERRAL); uint vdevs = Utils.percentageOf(value, TO_DEVELOPERS); uint vcountry = Utils.percentageOf(value, TO_COUNTRY); uint vpot = value.sub(vdivs).sub(vreferral).sub(vdevs).sub(vcountry); assert(vdivs.add(vreferral).add(vdevs).add(vcountry).add(vpot) == value); buyShares(MAIN_SCHEME, msg.sender, tickets, vdivs); buyShares(info.countryId, msg.sender, tickets, vcountry); creditVault(MAIN_SCHEME, info.referral, vreferral); creditVault(MAIN_SCHEME, addressOfOwner, vdevs); if (excess > 0) { creditVault(MAIN_SCHEME, msg.sender, excess); } uint goldenTickets = value.div(Utils.goldenTicketPrice(totalPot)); if (goldenTickets > 0) { endTime = endTime.add(goldenTickets.mul(addedTime)) > block.timestamp.add(maxTime) ? block.timestamp.add(maxTime) : endTime.add(goldenTickets.mul(addedTime)); addressOfCaptain = msg.sender; emit Promoted(addressOfCaptain, goldenTickets, endTime); } totalPot = totalPot.add(vpot); emit Bought(msg.sender, info.referral, info.countryId, tickets, value, excess); } function setNick (string _nick) public payable { require(msg.value == SET_NICK_FEE); require(Utils.validNick(_nick)); infoOfAddress[msg.sender].nick = _nick; creditVault(MAIN_SCHEME, addressOfOwner, msg.value); } function registerCode (string _code) public payable { require(msg.value == REFERRAL_REGISTRATION_FEE); _registerReferral(_code, msg.sender); creditVault(MAIN_SCHEME, addressOfOwner, msg.value); } function giftCode (string _code, address _referral) public restricted { _registerReferral(_code, _referral); } function withdraw () public { Info storage info = infoOfAddress[msg.sender]; uint payout = withdrawVault(MAIN_SCHEME, msg.sender); if (Utils.validCountryId(info.countryId)) { payout = payout.add(withdrawVault(info.countryId, msg.sender)); } if (payout > 0) { info.withdrawn = info.withdrawn.add(payout); msg.sender.transfer(payout); emit Withdrew(msg.sender, payout); } } function withdrawPot () public player { require(startTime > 0); require(block.timestamp > (endTime + 10 minutes)); require(!potWithdrawn); require(totalPot > 0); require(addressOfCaptain == msg.sender); uint payout = totalPot; totalPot = 0; potWithdrawn = true; addressOfCaptain.transfer(payout); emit Won(msg.sender, payout); } } "}
{"sol name": "1675.sol", "label": 1, "sol content": "pragma solidity ^0.4.23; // produced by the Solididy File Flattener (c) David Appleton 2018 // contact : [email\u00a0protected] // released under Apache 2.0 licence contract REDTTokenConfig { string public constant NAME = \"Real Estate Doc Token\"; string public constant SYMBOL = \"REDT\"; uint8 public constant DECIMALS = 18; uint public constant DECIMALSFACTOR = 10 ** uint(DECIMALS); uint public constant TOTALSUPPLY = 1000000000 * DECIMALSFACTOR; } contract Ownable { address public owner; event OwnershipRenounced(address indexed previousOwner); event OwnershipTransferred( address indexed previousOwner, address indexed newOwner ); /** * @dev The Ownable constructor sets the original `owner` of the contract to the sender * account. */ constructor() public { owner = msg.sender; } /** * @dev Throws if called by any account other than the owner. */ modifier onlyOwner() { require(msg.sender == owner); _; } /** * @dev Allows the current owner to relinquish control of the contract. * @notice Renouncing to ownership will leave the contract without an owner. * It will not be possible to call the functions with the `onlyOwner` * modifier anymore. */ function renounceOwnership() public onlyOwner { emit OwnershipRenounced(owner); owner = address(0); } /** * @dev Allows the current owner to transfer control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function transferOwnership(address _newOwner) public onlyOwner { _transferOwnership(_newOwner); } /** * @dev Transfers control of the contract to a newOwner. * @param _newOwner The address to transfer ownership to. */ function _transferOwnership(address _newOwner) internal { require(_newOwner != address(0)); emit OwnershipTransferred(owner, _newOwner); owner = _newOwner; } } library SafeMath { /** * @dev Multiplies two numbers, throws on overflow. */ function mul(uint256 a, uint256 b) internal pure returns (uint256 c) { // Gas optimization: this is cheaper than asserting 'a' not being zero, but the // benefit is lost if 'b' is also tested. // See: https://github.com/OpenZeppelin/openzeppelin-solidity/pull/522 if (a == 0) { return 0; } c = a * b; assert(c / a == b); return c; } /** * @dev Integer division of two numbers, truncating the quotient. */ function div(uint256 a, uint256 b) internal pure returns (uint256) { // assert(b > 0); // Solidity automatically throws when dividing by 0 // uint256 c = a / b; // assert(a == b * c + a % b); // There is no case in which this doesn't hold return a / b; } /** * @dev Subtracts two numbers, throws on overflow (i.e. if subtrahend is greater than minuend). */ function sub(uint256 a, uint256 b) internal pure returns (uint256) { assert(b <= a); return a - b; } /** * @dev Adds two numbers, throws on overflow. */ function add(uint256 a, uint256 b) internal pure returns (uint256 c) { c = a + b; assert(c >= a); return c; } } contract ERC20Basic { function totalSupply() public view returns (uint256); function balanceOf(address who) public view returns (uint256); function transfer(address to, uint256 value) public returns (bool); event Transfer(address indexed from, address indexed to, uint256 value); } contract Pausable is Ownable { event Pause(); event Unpause(); bool public paused = false; /** * @dev Modifier to make a function callable only when the contract is not paused. */ modifier whenNotPaused() { require(!paused); _; } /** * @dev Modifier to make a function callable only when the contract is paused. */ modifier whenPaused() { require(paused); _; } /** * @dev called by the owner to pause, triggers stopped state */ function pause() onlyOwner whenNotPaused public { paused = true; emit Pause(); } /** * @dev called by the owner to unpause, returns to normal state */ function unpause() onlyOwner whenPaused public { paused = false; emit Unpause(); } } contract Claimable is Ownable { address public pendingOwner; /** * @dev Modifier throws if called by any account other than the pendingOwner. */ modifier onlyPendingOwner() { require(msg.sender == pendingOwner); _; } /** * @dev Allows the current owner to set the pendingOwner address. * @param newOwner The address to transfer ownership to. */ function transferOwnership(address newOwner) onlyOwner public { pendingOwner = newOwner; } /** * @dev Allows the pendingOwner address to finalize the transfer. */ function claimOwnership() onlyPendingOwner public { emit OwnershipTransferred(owner, pendingOwner); owner = pendingOwner; pendingOwner = address(0); } } contract REDTTokenSaleConfig is REDTTokenConfig { uint public constant MIN_CONTRIBUTION      = 100 finney; uint public constant RESERVE_AMOUNT = 500000000 * DECIMALSFACTOR; uint public constant SALE_START = 1537189200; uint public constant SALE_END = 1540990800; uint public constant SALE0_END = 1537794000; uint public constant SALE0_RATE = 24000; uint public constant SALE0_CAP = 400000000 * DECIMALSFACTOR; uint public constant SALE1_END = 1538398800; uint public constant SALE1_RATE = 22000; uint public constant SALE1_CAP = 500000000 * DECIMALSFACTOR; uint public constant SALE2_END = 1540990800; uint public constant SALE2_RATE = 20000; uint public constant SALE2_CAP = 500000000 * DECIMALSFACTOR; uint public constant SALE_CAP = 500000000 * DECIMALSFACTOR; address public constant MULTISIG_ETH = 0x25C7A30F23a107ebF430FDFD582Afe1245B690Af; address public constant MULTISIG_TKN = 0x25C7A30F23a107ebF430FDFD582Afe1245B690Af; } contract ERC20 is ERC20Basic { function allowance(address owner, address spender) public view returns (uint256); function transferFrom(address from, address to, uint256 value) public returns (bool); function approve(address spender, uint256 value) public returns (bool); event Approval( address indexed owner, address indexed spender, uint256 value ); } contract BasicToken is ERC20Basic { using SafeMath for uint256; mapping(address => uint256) balances; uint256 totalSupply_; /** * @dev Total number of tokens in existence */ function totalSupply() public view returns (uint256) { return totalSupply_; } /** * @dev Transfer token for a specified address * @param _to The address to transfer to. * @param _value The amount to be transferred. */ function transfer(address _to, uint256 _value) public returns (bool) { require(_to != address(0)); require(_value <= balances[msg.sender]); balances[msg.sender] = balances[msg.sender].sub(_value); balances[_to] = balances[_to].add(_value); emit Transfer(msg.sender, _to, _value); return true; } /** * @dev Gets the balance of the specified address. * @param _owner The address to query the the balance of. * @return An uint256 representing the amount owned by the passed address. */ function balanceOf(address _owner) public view returns (uint256) { return balances[_owner]; } } contract StandardToken is ERC20, BasicToken { mapping (address => mapping (address => uint256)) internal allowed; /** * @dev Transfer tokens from one address to another * @param _from address The address which you want to send tokens from * @param _to address The address which you want to transfer to * @param _value uint256 the amount of tokens to be transferred */ function transferFrom( address _from, address _to, uint256 _value ) public returns (bool) { require(_to != address(0)); require(_value <= balances[_from]); require(_value <= allowed[_from][msg.sender]); balances[_from] = balances[_from].sub(_value); balances[_to] = balances[_to].add(_value); allowed[_from][msg.sender] = allowed[_from][msg.sender].sub(_value); emit Transfer(_from, _to, _value); return true; } /** * @dev Approve the passed address to spend the specified amount of tokens on behalf of msg.sender. * Beware that changing an allowance with this method brings the risk that someone may use both the old * and the new allowance by unfortunate transaction ordering. One possible solution to mitigate this * race condition is to first reduce the spender's allowance to 0 and set the desired value afterwards: * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729 * @param _spender The address which will spend the funds. * @param _value The amount of tokens to be spent. */ function approve(address _spender, uint256 _value) public returns (bool) { allowed[msg.sender][_spender] = _value; emit Approval(msg.sender, _spender, _value); return true; } /** * @dev Function to check the amount of tokens that an owner allowed to a spender. * @param _owner address The address which owns the funds. * @param _spender address The address which will spend the funds. * @return A uint256 specifying the amount of tokens still available for the spender. */ function allowance( address _owner, address _spender ) public view returns (uint256) { return allowed[_owner][_spender]; } /** * @dev Increase the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To increment * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _addedValue The amount of tokens to increase the allowance by. */ function increaseApproval( address _spender, uint256 _addedValue ) public returns (bool) { allowed[msg.sender][_spender] = ( allowed[msg.sender][_spender].add(_addedValue)); emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } /** * @dev Decrease the amount of tokens that an owner allowed to a spender. * approve should be called when allowed[_spender] == 0. To decrement * allowed value is better to use this function to avoid 2 calls (and wait until * the first transaction is mined) * From MonolithDAO Token.sol * @param _spender The address which will spend the funds. * @param _subtractedValue The amount of tokens to decrease the allowance by. */ function decreaseApproval( address _spender, uint256 _subtractedValue ) public returns (bool) { uint256 oldValue = allowed[msg.sender][_spender]; if (_subtractedValue > oldValue) { allowed[msg.sender][_spender] = 0; } else { allowed[msg.sender][_spender] = oldValue.sub(_subtractedValue); } emit Approval(msg.sender, _spender, allowed[msg.sender][_spender]); return true; } } contract Operatable is Claimable { address public minter; address public whiteLister; address public launcher; modifier canOperate() { require(msg.sender == minter || msg.sender == whiteLister || msg.sender == owner); _; } constructor() public { minter = owner; whiteLister = owner; launcher = owner; } function setMinter (address addr) public onlyOwner { minter = addr; } function setWhiteLister (address addr) public onlyOwner { whiteLister = addr; } modifier onlyMinter()  { require (msg.sender == minter); _; } modifier ownerOrMinter()  { require ((msg.sender == minter) || (msg.sender == owner)); _; } modifier onlyLauncher()  { require (msg.sender == minter); _; } modifier onlyWhiteLister()  { require (msg.sender == whiteLister); _; } } contract Salvageable is Operatable { // Salvage other tokens that are accidentally sent into this token function emergencyERC20Drain(ERC20 oddToken, uint amount) public onlyLauncher { if (address(oddToken) == address(0)) { launcher.transfer(amount); return; } oddToken.transfer(launcher, amount); } } contract PausableToken is StandardToken, Pausable { function transfer( address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transfer(_to, _value); } function transferFrom( address _from, address _to, uint256 _value ) public whenNotPaused returns (bool) { return super.transferFrom(_from, _to, _value); } function approve( address _spender, uint256 _value ) public whenNotPaused returns (bool) { return super.approve(_spender, _value); } function increaseApproval( address _spender, uint _addedValue ) public whenNotPaused returns (bool success) { return super.increaseApproval(_spender, _addedValue); } function decreaseApproval( address _spender, uint _subtractedValue ) public whenNotPaused returns (bool success) { return super.decreaseApproval(_spender, _subtractedValue); } } contract WhiteListed is Operatable { uint public count; mapping (address => bool) public whiteList; event Whitelisted(address indexed addr, uint whitelistedCount, bool isWhitelisted); function addWhiteListed(address[] addrs) external canOperate { uint c = count; for (uint i = 0; i < addrs.length; i++) { if (!whiteList[addrs[i]]) { whiteList[addrs[i]] = true; c++; emit Whitelisted(addrs[i], count, true); } } count = c; } function removeWhiteListed(address addr) external canOperate { require(whiteList[addr]); whiteList[addr] = false; count--; emit Whitelisted(addr, count, false); } } contract REDTToken is PausableToken, REDTTokenConfig, Salvageable { using SafeMath for uint; string public name = NAME; string public symbol = SYMBOL; uint8 public decimals = DECIMALS; bool public mintingFinished = false; event Mint(address indexed to, uint amount); event MintFinished(); event Burn(address indexed burner, uint256 value); modifier canMint() { require(!mintingFinished); _; } constructor(address launcher_) public { launcher = launcher_; paused = true; } function mint(address _to, uint _amount) canMint onlyMinter public returns (bool) { require(totalSupply_.add(_amount) <= TOTALSUPPLY); totalSupply_ = totalSupply_.add(_amount); balances[_to] = balances[_to].add(_amount); emit Transfer(address(0), _to, _amount); return true; } function finishMinting() canMint public returns (bool) { mintingFinished = true; emit MintFinished(); return true; } function burn(uint256 _value) public { _burn(msg.sender, _value); } function _burn(address _who, uint256 _value) internal { require(_value <= balances[_who]); balances[_who] = balances[_who].sub(_value); totalSupply_ = totalSupply_.sub(_value); emit Burn(_who, _value); emit Transfer(_who, address(0), _value); } function sendBatchCS(address[] _recipients, uint[] _values) external canOperate returns (bool) { require(_recipients.length == _values.length); uint senderBalance = balances[msg.sender]; for (uint i = 0; i < _values.length; i++) { uint value = _values[i]; address to = _recipients[i]; require(senderBalance >= value); senderBalance = senderBalance - value; balances[to] += value; emit Transfer(msg.sender, to, value); } balances[msg.sender] = senderBalance; return true; } } contract REDTTokenSale is REDTTokenSaleConfig, Claimable, Pausable, Salvageable { using SafeMath for uint; bool public isFinalized = false; REDTToken public token; uint public tokensRaised; uint public weiRaised;              // Amount of raised money in WEI WhiteListed public whiteListed; uint public numContributors;        // Discrete number of contributors mapping (address => uint) public contributions; // to allow them to have multiple spends event Finalized(); event TokenPurchase(address indexed beneficiary, uint value, uint amount); event TokenPresale(address indexed purchaser, uint amount); struct capRec  { uint time; uint amount; } capRec[] public capz; uint public capDefault; constructor( WhiteListed _whiteListed ) public { require(now < SALE_START); require(_whiteListed != address(0)); whiteListed = _whiteListed; token = new REDTToken(owner); token.mint(MULTISIG_TKN,RESERVE_AMOUNT); initCaps(); } function initCaps() public { uint[4] memory caps = [uint(10),20,30,40]; uint[4] memory times = [uint(1),4,12,24]; for (uint i = 0; i < caps.length; i++) { capRec memory cr; cr.time = times[i]; cr.amount = caps[i]; capz.push(cr); } capDefault = 100; } function setCapRec(uint[] capsInEther, uint[] timesInHours, uint defaultCapInEther) public onlyOwner { //capRec[] memory cz = new capRec[](caps.length); require(capsInEther.length == timesInHours.length); capz.length = 0; for (uint i = 0; i < capsInEther.length; i++) { capRec memory cr; cr.time = timesInHours[i]; cr.amount = capsInEther[i]; capz.push(cr); } capDefault = defaultCapInEther; } function currentCap() public view returns (uint) { for (uint i = 0; i < capz.length; i++) { if (now < SALE_START + capz[i].time * 1 hours) return (capz[i].amount * 1 ether); } return capDefault; } function getRateAndCheckCap() public view returns (uint) { require(now>SALE_START); if ((now<SALE0_END) && (tokensRaised < SALE0_CAP)) return SALE0_RATE; if ((now<SALE1_END) && (tokensRaised < SALE1_CAP)) return SALE1_RATE; if ((now<SALE2_END) && (tokensRaised < SALE2_CAP)) return SALE2_RATE; revert(); } // Only fallback function can be used to buy tokens function () external payable { buyTokens(msg.sender, msg.value); } function buyTokens(address beneficiary, uint weiAmount) internal whenNotPaused { require(contributions[beneficiary].add(weiAmount) < currentCap()); require(whiteListed.whiteList(beneficiary)); require((weiAmount > MIN_CONTRIBUTION) || (weiAmount == SALE_CAP.sub(MIN_CONTRIBUTION))); weiRaised = weiRaised.add(weiAmount); uint tokens = weiAmount.mul(getRateAndCheckCap()); if (contributions[beneficiary] == 0) { numContributors++; } tokensRaised = tokensRaised.add(tokens); contributions[beneficiary] = contributions[beneficiary].add(weiAmount); token.mint(beneficiary, tokens); emit TokenPurchase(beneficiary, weiAmount, tokens); forwardFunds(); } function placeTokens(address beneficiary, uint256 numtokens) public ownerOrMinter { require(now < SALE_START); tokensRaised = tokensRaised.add(numtokens); token.mint(beneficiary,numtokens); } function tokensUnsold() public view returns(uint) { return token.TOTALSUPPLY().sub(token.totalSupply()); } // Return true if crowdsale event has ended function hasEnded() public view returns (bool) { return ((now > SALE_END) || (tokensRaised >= SALE_CAP)); } // Send ether to the fund collection wallet function forwardFunds() internal { MULTISIG_ETH.transfer(address(this).balance); } // Must be called after crowdsale ends, to do some extra finalization function finalize() onlyOwner public { require(!isFinalized); require(hasEnded()); finalization(); emit Finalized(); isFinalized = true; } // Stops the minting and transfer token ownership to sale owner. Mints unsold tokens to owner function finalization() internal { token.finishMinting(); token.transferOwnership(owner); } } "}
